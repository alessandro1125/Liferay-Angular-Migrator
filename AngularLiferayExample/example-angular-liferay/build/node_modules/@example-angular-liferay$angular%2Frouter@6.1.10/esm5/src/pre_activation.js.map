{"version":3,"sources":["../../../../../../../../../packages/router/src/pre_activation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatMap, every, first, last, map, mergeMap, reduce} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, ResolveData, RunGuardsAndResolvers} from './config';\nimport {ActivationStart, ChildActivationStart, Event} from './events';\nimport {ChildrenOutletContexts, OutletContext} from './router_outlet_context';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, equalParamsAndUrlSegments, inheritedParamsDataResolve} from './router_state';\nimport {andObservables, forEach, shallowEqual, wrapIntoObservable} from './utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from './utils/tree';\n\nclass CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nclass CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nexport class PreActivation {\n  private canActivateChecks: CanActivate[] = [];\n  private canDeactivateChecks: CanDeactivate[] = [];\n\n  constructor(\n      private future: RouterStateSnapshot, private curr: RouterStateSnapshot,\n      private moduleInjector: Injector, private forwardEvent?: (evt: Event) => void) {}\n\n  initialize(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.future._root;\n    const currRoot = this.curr ? this.curr._root : null;\n    this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n  }\n\n  checkGuards(): Observable<boolean> {\n    if (!this.isDeactivating() && !this.isActivating()) {\n      return of (true);\n    }\n    const canDeactivate$ = this.runCanDeactivateChecks();\n    return canDeactivate$.pipe(mergeMap(\n        (canDeactivate: boolean) => canDeactivate ? this.runCanActivateChecks() : of (false)));\n  }\n\n  resolveData(paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    if (!this.isActivating()) return of (null);\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap(\n                (check: CanActivate) => this.runResolve(check.route, paramsInheritanceStrategy)),\n            reduce((_: any, __: any) => _));\n  }\n\n  isDeactivating(): boolean { return this.canDeactivateChecks.length !== 0; }\n\n  isActivating(): boolean { return this.canActivateChecks.length !== 0; }\n\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupChildRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>|null,\n      contexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const prevChildren = nodeChildrenAsMap(currNode);\n\n    // Process the children of the future route\n    futureNode.children.forEach(c => {\n      this.setupRouteGuards(\n          c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n      delete prevChildren[c.value.outlet];\n    });\n\n    // Process any children left from the current route (not active for the future route)\n    forEach(\n        prevChildren, (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n                          this.deactivateRouteAndItsChildren(v, contexts !.getContext(k)));\n  }\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n      parentContexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n    // reusing the node\n    if (curr && future.routeConfig === curr.routeConfig) {\n      const shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(\n          curr, future, future.routeConfig !.runGuardsAndResolvers);\n      if (shouldRunGuardsAndResolvers) {\n        this.canActivateChecks.push(new CanActivate(futurePath));\n      } else {\n        // we need to set the data\n        future.data = curr.data;\n        future._resolvedData = curr._resolvedData;\n      }\n\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(\n            futureNode, currNode, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n      }\n\n      if (shouldRunGuardsAndResolvers) {\n        const outlet = context !.outlet !;\n        this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, context);\n      }\n\n      this.canActivateChecks.push(new CanActivate(futurePath));\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n      }\n    }\n  }\n\n  private shouldRunGuardsAndResolvers(\n      curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n      mode: RunGuardsAndResolvers|undefined): boolean {\n    switch (mode) {\n      case 'always':\n        return true;\n\n      case 'paramsOrQueryParamsChange':\n        return !equalParamsAndUrlSegments(curr, future) ||\n            !shallowEqual(curr.queryParams, future.queryParams);\n\n      case 'paramsChange':\n      default:\n        return !equalParamsAndUrlSegments(curr, future);\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext|null): void {\n    const children = nodeChildrenAsMap(route);\n    const r = route.value;\n\n    forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n      if (!r.component) {\n        this.deactivateRouteAndItsChildren(node, context);\n      } else if (context) {\n        this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n      } else {\n        this.deactivateRouteAndItsChildren(node, null);\n      }\n    });\n\n    if (!r.component) {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    } else if (context && context.outlet && context.outlet.isActivated) {\n      this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n    } else {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n  }\n\n  private runCanDeactivateChecks(): Observable<boolean> {\n    return from(this.canDeactivateChecks)\n        .pipe(\n            mergeMap((check: CanDeactivate) => this.runCanDeactivate(check.component, check.route)),\n            every((result: boolean) => result === true));\n  }\n\n  private runCanActivateChecks(): Observable<boolean> {\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap((check: CanActivate) => andObservables(from([\n                        this.fireChildActivationStart(check.route.parent),\n                        this.fireActivationStart(check.route), this.runCanActivateChild(check.path),\n                        this.runCanActivate(check.route)\n                      ]))),\n            every((result: boolean) => result === true));\n    // this.fireChildActivationStart(check.path),\n  }\n\n  /**\n   * This should fire off `ActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  /**\n   * This should fire off `ChildActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireChildActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ChildActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  private runCanActivate(future: ActivatedRouteSnapshot): Observable<boolean> {\n    const canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n    if (!canActivate || canActivate.length === 0) return of (true);\n    const obs = from(canActivate).pipe(map((c: any) => {\n      const guard = this.getToken(c, future);\n      let observable: Observable<boolean>;\n      if (guard.canActivate) {\n        observable = wrapIntoObservable(guard.canActivate(future, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(future, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return andObservables(obs);\n  }\n\n  private runCanActivateChild(path: ActivatedRouteSnapshot[]): Observable<boolean> {\n    const future = path[path.length - 1];\n\n    const canActivateChildGuards = path.slice(0, path.length - 1)\n                                       .reverse()\n                                       .map(p => this.extractCanActivateChild(p))\n                                       .filter(_ => _ !== null);\n\n    return andObservables(from(canActivateChildGuards).pipe(map((d: any) => {\n      const obs = from(d.guards).pipe(map((c: any) => {\n        const guard = this.getToken(c, d.node);\n        let observable: Observable<boolean>;\n        if (guard.canActivateChild) {\n          observable = wrapIntoObservable(guard.canActivateChild(future, this.future));\n        } else {\n          observable = wrapIntoObservable(guard(future, this.future));\n        }\n        return observable.pipe(first());\n      }));\n      return andObservables(obs);\n    })));\n  }\n\n  private extractCanActivateChild(p: ActivatedRouteSnapshot):\n      {node: ActivatedRouteSnapshot, guards: any[]}|null {\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n    if (!canActivateChild || canActivateChild.length === 0) return null;\n    return {node: p, guards: canActivateChild};\n  }\n\n  private runCanDeactivate(component: Object|null, curr: ActivatedRouteSnapshot):\n      Observable<boolean> {\n    const canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n    if (!canDeactivate || canDeactivate.length === 0) return of (true);\n    const canDeactivate$ = from(canDeactivate).pipe(mergeMap((c: any) => {\n      const guard = this.getToken(c, curr);\n      let observable: Observable<boolean>;\n      if (guard.canDeactivate) {\n        observable =\n            wrapIntoObservable(guard.canDeactivate(component, curr, this.curr, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(component, curr, this.curr, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return canDeactivate$.pipe(every((result: any) => result === true));\n  }\n\n  private runResolve(\n      future: ActivatedRouteSnapshot,\n      paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    const resolve = future._resolve;\n    return this.resolveNode(resolve, future).pipe(map((resolvedData: any): any => {\n      future._resolvedData = resolvedData;\n      future.data = {...future.data,\n                     ...inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve};\n      return null;\n    }));\n  }\n\n  private resolveNode(resolve: ResolveData, future: ActivatedRouteSnapshot): Observable<any> {\n    const keys = Object.keys(resolve);\n    if (keys.length === 0) {\n      return of ({});\n    }\n    if (keys.length === 1) {\n      const key = keys[0];\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        return {[key]: value};\n      }));\n    }\n    const data: {[k: string]: any} = {};\n    const runningResolvers$ = from(keys).pipe(mergeMap((key: string) => {\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        data[key] = value;\n        return value;\n      }));\n    }));\n    return runningResolvers$.pipe(last(), map(() => data));\n  }\n\n  private getResolver(injectionToken: any, future: ActivatedRouteSnapshot): Observable<any> {\n    const resolver = this.getToken(injectionToken, future);\n    return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n                              wrapIntoObservable(resolver(future, this.future));\n  }\n\n  private getToken(token: any, snapshot: ActivatedRouteSnapshot): any {\n    const config = closestLoadedConfig(snapshot);\n    const injector = config ? config.module.injector : this.moduleInjector;\n    return injector.get(token);\n  }\n}\n\n\nfunction closestLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  if (!snapshot) return null;\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n"],"sourceRoot":""}