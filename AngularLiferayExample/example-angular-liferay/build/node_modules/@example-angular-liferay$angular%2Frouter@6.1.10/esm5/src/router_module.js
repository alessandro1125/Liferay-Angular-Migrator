Liferay.Loader.define('@example-angular-liferay$angular/router@6.1.10/esm5/src/router_module', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { APP_BASE_HREF, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation, ViewportScroller } from '@angular/common';
    import { ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Compiler, Inject, Injectable, InjectionToken, Injector, NgModule, NgModuleFactoryLoader, NgProbeToken, Optional, SkipSelf, SystemJsNgModuleLoader } from '@angular/core';
    import { ÉµgetDOM as getDOM } from '@angular/platform-browser';
    import { Subject, of } from 'rxjs';
    import { EmptyOutletComponent } from './components/empty_outlet';
    import { RouterLink, RouterLinkWithHref } from './directives/router_link';
    import { RouterLinkActive } from './directives/router_link_active';
    import { RouterOutlet } from './directives/router_outlet';
    import { RouteReuseStrategy } from './route_reuse_strategy';
    import { Router } from './router';
    import { ROUTES } from './router_config_loader';
    import { ChildrenOutletContexts } from './router_outlet_context';
    import { NoPreloading, PreloadAllModules, PreloadingStrategy, RouterPreloader } from './router_preloader';
    import { RouterScroller } from './router_scroller';
    import { ActivatedRoute } from './router_state';
    import { UrlHandlingStrategy } from './url_handling_strategy';
    import { DefaultUrlSerializer, UrlSerializer } from './url_tree';
    import { flatten } from './utils/collection';
    /**
     * @description
     *
     * Contains a list of directives
     *
     *
     */
    var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent];
    /**
     * @description
     *
     * Is used in DI to configure the router.
     *
     *
     */
    export var ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');
    /**
     * @docsNotRequired
     */
    export var ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');
    export var ROUTER_PROVIDERS = [Location, { provide: UrlSerializer, useClass: DefaultUrlSerializer }, {
        provide: Router,
        useFactory: setupRouter,
        deps: [ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector, NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]]
    }, ChildrenOutletContexts, { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] }, { provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader }, RouterPreloader, NoPreloading, PreloadAllModules, { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } }];
    export function routerNgProbeToken() {
        return new NgProbeToken('Router', Router);
    }
    /**
     * @usageNotes
     *
     * RouterModule can be imported multiple times: once per lazily-loaded bundle.
     * Since the router deals with a global shared resource--location, we cannot have
     * more than one router service active.
     *
     * That is why there are two ways to create the module: `RouterModule.forRoot` and
     * `RouterModule.forChild`.
     *
     * * `forRoot` creates a module that contains all the directives, the given routes, and the router
     *   service itself.
     * * `forChild` creates a module that contains all the directives and the given routes, but does not
     *   include the router service.
     *
     * When registered at the root, the module should be used as follows
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forRoot(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * For submodules and lazy loaded submodules the module should be used as follows:
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     * @description
     *
     * Adds router directives and providers.
     *
     * Managing state transitions is one of the hardest parts of building applications. This is
     * especially true on the web, where you also need to ensure that the state is reflected in the URL.
     * In addition, we often want to split applications into multiple bundles and load them on demand.
     * Doing this transparently is not trivial.
     *
     * The Angular router solves these problems. Using the router, you can declaratively specify
     * application states, manage state transitions while taking care of the URL, and load bundles on
     * demand.
     *
     * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
     * overview of how the router should be used.
     *
     *
     */
    var RouterModule = /** @class */function () {
        // Note: We are injecting the Router so it gets created eagerly...
        function RouterModule(guard, router) {}
        RouterModule_1 = RouterModule;
        /**
         * Creates a module with all the router providers and directives. It also optionally sets up an
         * application listener to perform an initial navigation.
         *
         * Options (see `ExtraOptions`):
         * * `enableTracing` makes the router log all its internal events to the console.
         * * `useHash` enables the location strategy that uses the URL fragment instead of the history
         * API.
         * * `initialNavigation` disables the initial navigation.
         * * `errorHandler` provides a custom error handler.
         * * `preloadingStrategy` configures a preloading strategy (see `PreloadAllModules`).
         * * `onSameUrlNavigation` configures how the router handles navigation to the current URL. See
         * `ExtraOptions` for more details.
         * * `paramsInheritanceStrategy` defines how the router merges params, data and resolved data
         * from parent to child routes.
         */
        RouterModule.forRoot = function (routes, config) {
            return {
                ngModule: RouterModule_1,
                providers: [ROUTER_PROVIDERS, provideRoutes(routes), {
                    provide: ROUTER_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[Router, new Optional(), new SkipSelf()]]
                }, { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} }, {
                    provide: LocationStrategy,
                    useFactory: provideLocationStrategy,
                    deps: [PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION]
                }, {
                    provide: RouterScroller,
                    useFactory: createRouterScroller,
                    deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]
                }, {
                    provide: PreloadingStrategy,
                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy : NoPreloading
                }, { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken }, provideRouterInitializer()]
            };
        };
        /**
         * Creates a module with all the router directives and a provider registering routes.
         */
        RouterModule.forChild = function (routes) {
            return { ngModule: RouterModule_1, providers: [provideRoutes(routes)] };
        };
        var RouterModule_1;
        RouterModule = RouterModule_1 = tslib_1.__decorate([NgModule({
            declarations: ROUTER_DIRECTIVES,
            exports: ROUTER_DIRECTIVES,
            entryComponents: [EmptyOutletComponent]
        }), tslib_1.__param(0, Optional()), tslib_1.__param(0, Inject(ROUTER_FORROOT_GUARD)), tslib_1.__param(1, Optional()), tslib_1.__metadata("design:paramtypes", [Object, Router])], RouterModule);
        return RouterModule;
    }();
    export { RouterModule };
    export function createRouterScroller(router, viewportScroller, config) {
        if (config.scrollOffset) {
            viewportScroller.setOffset(config.scrollOffset);
        }
        return new RouterScroller(router, viewportScroller, config);
    }
    export function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
        if (options === void 0) {
            options = {};
        }
        return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) : new PathLocationStrategy(platformLocationStrategy, baseHref);
    }
    export function provideForRootGuard(router) {
        if (router) {
            throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
        }
        return 'guarded';
    }
    /**
     * @description
     *
     * Registers routes.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @NgModule({
     *   imports: [RouterModule.forChild(ROUTES)],
     *   providers: [provideRoutes(EXTRA_ROUTES)]
     * })
     * class MyNgModule {}
     * ```
     *
     *
     */
    export function provideRoutes(routes) {
        return [{ provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes }, { provide: ROUTES, multi: true, useValue: routes }];
    }
    export function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
        if (opts === void 0) {
            opts = {};
        }
        var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
        if (urlHandlingStrategy) {
            router.urlHandlingStrategy = urlHandlingStrategy;
        }
        if (routeReuseStrategy) {
            router.routeReuseStrategy = routeReuseStrategy;
        }
        if (opts.errorHandler) {
            router.errorHandler = opts.errorHandler;
        }
        if (opts.malformedUriErrorHandler) {
            router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
        }
        if (opts.enableTracing) {
            var dom_1 = getDOM();
            router.events.subscribe(function (e) {
                dom_1.logGroup("Router Event: " + e.constructor.name);
                dom_1.log(e.toString());
                dom_1.log(e);
                dom_1.logGroupEnd();
            });
        }
        if (opts.onSameUrlNavigation) {
            router.onSameUrlNavigation = opts.onSameUrlNavigation;
        }
        if (opts.paramsInheritanceStrategy) {
            router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
        }
        if (opts.urlUpdateStrategy) {
            router.urlUpdateStrategy = opts.urlUpdateStrategy;
        }
        if (opts.relativeLinkResolution) {
            router.relativeLinkResolution = opts.relativeLinkResolution;
        }
        return router;
    }
    export function rootRoute(router) {
        return router.routerState.root;
    }
    /**
     * To initialize the router properly we need to do in two steps:
     *
     * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
     * a resolver or a guards executes asynchronously. Second, we need to actually run
     * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
     * hook provided by the router to do that.
     *
     * The router navigation starts, reaches the point when preactivation is done, and then
     * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
     */
    var RouterInitializer = /** @class */function () {
        function RouterInitializer(injector) {
            this.injector = injector;
            this.initNavigation = false;
            this.resultOfPreactivationDone = new Subject();
        }
        RouterInitializer.prototype.appInitializer = function () {
            var _this = this;
            var p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
            return p.then(function () {
                var resolve = null;
                var res = new Promise(function (r) {
                    return resolve = r;
                });
                var router = _this.injector.get(Router);
                var opts = _this.injector.get(ROUTER_CONFIGURATION);
                if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
                    resolve(true);
                } else if (opts.initialNavigation === 'disabled') {
                    router.setUpLocationChangeListener();
                    resolve(true);
                } else if (opts.initialNavigation === 'enabled') {
                    router.hooks.afterPreactivation = function () {
                        // only the initial navigation should be delayed
                        if (!_this.initNavigation) {
                            _this.initNavigation = true;
                            resolve(true);
                            return _this.resultOfPreactivationDone;
                            // subsequent navigations should not be delayed
                        } else {
                            return of(null);
                        }
                    };
                    router.initialNavigation();
                } else {
                    throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
                }
                return res;
            });
        };
        RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
            var opts = this.injector.get(ROUTER_CONFIGURATION);
            var preloader = this.injector.get(RouterPreloader);
            var routerScroller = this.injector.get(RouterScroller);
            var router = this.injector.get(Router);
            var ref = this.injector.get(ApplicationRef);
            if (bootstrappedComponentRef !== ref.components[0]) {
                return;
            }
            if (this.isLegacyEnabled(opts)) {
                router.initialNavigation();
            } else if (this.isLegacyDisabled(opts)) {
                router.setUpLocationChangeListener();
            }
            preloader.setUpPreloading();
            routerScroller.init();
            router.resetRootComponentType(ref.componentTypes[0]);
            this.resultOfPreactivationDone.next(null);
            this.resultOfPreactivationDone.complete();
        };
        RouterInitializer.prototype.isLegacyEnabled = function (opts) {
            return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true || opts.initialNavigation === undefined;
        };
        RouterInitializer.prototype.isLegacyDisabled = function (opts) {
            return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
        };
        RouterInitializer = tslib_1.__decorate([Injectable(), tslib_1.__metadata("design:paramtypes", [Injector])], RouterInitializer);
        return RouterInitializer;
    }();
    export { RouterInitializer };
    export function getAppInitializer(r) {
        return r.appInitializer.bind(r);
    }
    export function getBootstrapListener(r) {
        return r.bootstrapListener.bind(r);
    }
    /**
     * A token for the router initializer that will be called after the app is bootstrapped.
     *
     * @experimental
     */
    export var ROUTER_INITIALIZER = new InjectionToken('Router Initializer');
    export function provideRouterInitializer() {
        return [RouterInitializer, {
            provide: APP_INITIALIZER,
            multi: true,
            useFactory: getAppInitializer,
            deps: [RouterInitializer]
        }, { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] }, { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER }];
    }
});
//# sourceMappingURL=router_module.js.map