Liferay.Loader.define('@example-angular-liferay$angular/router@6.1.10/esm5/src/router_preloader', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
    *@license
    *Copyright Google Inc. All Rights Reserved.
    *
    *Use of this source code is governed by an MIT-style license that can be
    *found in the LICENSE file at https://angular.io/license
    */
    import * as tslib_1 from "tslib";
    import { Compiler, Injectable, Injector, NgModuleFactoryLoader, NgModuleRef } from '@angular/core';
    import { from, of } from 'rxjs';
    import { catchError, concatMap, filter, map, mergeAll, mergeMap } from 'rxjs/operators';
    import { NavigationEnd, RouteConfigLoadEnd, RouteConfigLoadStart } from './events';
    import { Router } from './router';
    import { RouterConfigLoader } from './router_config_loader';
    /**
     * @description
     *
     * Provides a preloading strategy.
     *
     * @experimental
     */
    var PreloadingStrategy = /** @class */function () {
        function PreloadingStrategy() {}
        return PreloadingStrategy;
    }();
    export { PreloadingStrategy };
    /**
     * @description
     *
     * Provides a preloading strategy that preloads all modules as quickly as possible.
     *
     * ```
     * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
     * ```
     *
     * @experimental
     */
    var PreloadAllModules = /** @class */function () {
        function PreloadAllModules() {}
        PreloadAllModules.prototype.preload = function (route, fn) {
            return fn().pipe(catchError(function () {
                return of(null);
            }));
        };
        return PreloadAllModules;
    }();
    export { PreloadAllModules };
    /**
     * @description
     *
     * Provides a preloading strategy that does not preload any modules.
     *
     * This strategy is enabled by default.
     *
     * @experimental
     */
    var NoPreloading = /** @class */function () {
        function NoPreloading() {}
        NoPreloading.prototype.preload = function (route, fn) {
            return of(null);
        };
        return NoPreloading;
    }();
    export { NoPreloading };
    /**
     * The preloader optimistically loads all router configurations to
     * make navigations into lazily-loaded sections of the application faster.
     *
     * The preloader runs in the background. When the router bootstraps, the preloader
     * starts listening to all navigation events. After every such event, the preloader
     * will check if any configurations can be loaded lazily.
     *
     * If a route is protected by `canLoad` guards, the preloaded will not load it.
     *
     *
     */
    var RouterPreloader = /** @class */function () {
        function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
            this.router = router;
            this.injector = injector;
            this.preloadingStrategy = preloadingStrategy;
            var onStartLoad = function (r) {
                return router.triggerEvent(new RouteConfigLoadStart(r));
            };
            var onEndLoad = function (r) {
                return router.triggerEvent(new RouteConfigLoadEnd(r));
            };
            this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
        }
        RouterPreloader.prototype.setUpPreloading = function () {
            var _this = this;
            this.subscription = this.router.events.pipe(filter(function (e) {
                return e instanceof NavigationEnd;
            }), concatMap(function () {
                return _this.preload();
            })).subscribe(function () {});
        };
        RouterPreloader.prototype.preload = function () {
            var ngModule = this.injector.get(NgModuleRef);
            return this.processRoutes(ngModule, this.router.config);
        };
        // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If
        // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This
        // should be refactored.
        RouterPreloader.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
            var e_1, _a;
            var res = [];
            try {
                for (var routes_1 = tslib_1.__values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                    var route = routes_1_1.value;
                    // we already have the config loaded, just recurse
                    if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                        var childConfig = route._loadedConfig;
                        res.push(this.processRoutes(childConfig.module, childConfig.routes));
                        // no config loaded, fetch the config
                    } else if (route.loadChildren && !route.canLoad) {
                        res.push(this.preloadConfig(ngModule, route));
                        // recurse into children
                    } else if (route.children) {
                        res.push(this.processRoutes(ngModule, route.children));
                    }
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return from(res).pipe(mergeAll(), map(function (_) {
                return void 0;
            }));
        };
        RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
            var _this = this;
            return this.preloadingStrategy.preload(route, function () {
                var loaded$ = _this.loader.load(ngModule.injector, route);
                return loaded$.pipe(mergeMap(function (config) {
                    route._loadedConfig = config;
                    return _this.processRoutes(config.module, config.routes);
                }));
            });
        };
        RouterPreloader = tslib_1.__decorate([Injectable(), tslib_1.__metadata("design:paramtypes", [Router, NgModuleFactoryLoader, Compiler, Injector, PreloadingStrategy])], RouterPreloader);
        return RouterPreloader;
    }();
    export { RouterPreloader };
});
//# sourceMappingURL=router_preloader.js.map