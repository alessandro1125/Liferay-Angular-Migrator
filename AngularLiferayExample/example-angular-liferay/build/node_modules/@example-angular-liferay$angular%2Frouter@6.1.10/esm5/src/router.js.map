{"version":3,"sources":["../../../../../../../../../packages/router/src/router.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {Compiler, Injector, NgModuleFactoryLoader, NgModuleRef, NgZone, Optional, Type, isDevMode, ɵConsole as Console} from '@angular/core';\nimport {BehaviorSubject, Observable, Subject, Subscription, of } from 'rxjs';\nimport {concatMap, map, mergeMap} from 'rxjs/operators';\n\nimport {applyRedirects} from './apply_redirects';\nimport {LoadedRouterConfig, QueryParamsHandling, Route, Routes, standardizeConfig, validateConfig} from './config';\nimport {createRouterState} from './create_router_state';\nimport {createUrlTree} from './create_url_tree';\nimport {ActivationEnd, ChildActivationEnd, Event, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, NavigationTrigger, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized} from './events';\nimport {PreActivation} from './pre_activation';\nimport {recognize} from './recognize';\nimport {DefaultRouteReuseStrategy, DetachedRouteHandleInternal, RouteReuseStrategy} from './route_reuse_strategy';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {ChildrenOutletContexts} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot, RouterState, RouterStateSnapshot, advanceActivatedRoute, createEmptyState, inheritedParamsDataResolve} from './router_state';\nimport {Params, isNavigationCancelingError} from './shared';\nimport {DefaultUrlHandlingStrategy, UrlHandlingStrategy} from './url_handling_strategy';\nimport {UrlSerializer, UrlTree, containsTree, createEmptyUrlTree} from './url_tree';\nimport {forEach} from './utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from './utils/tree';\n\n\n/**\n * @description\n *\n * Represents the extra options used during navigation.\n *\n *\n */\nexport interface NavigationExtras {\n  /**\n   * Enables relative navigation from the current ActivatedRoute.\n   *\n   * Configuration:\n   *\n   * ```\n   * [{\n  *   path: 'parent',\n  *   component: ParentComponent,\n  *   children: [{\n  *     path: 'list',\n  *     component: ListComponent\n  *   },{\n  *     path: 'child',\n  *     component: ChildComponent\n  *   }]\n  * }]\n   * ```\n   *\n   * Navigate to list route from child route:\n   *\n   * ```\n   *  @Component({...})\n   *  class ChildComponent {\n  *    constructor(private router: Router, private route: ActivatedRoute) {}\n  *\n  *    go() {\n  *      this.router.navigate(['../list'], { relativeTo: this.route });\n  *    }\n  *  }\n   * ```\n   */\n  relativeTo?: ActivatedRoute|null;\n\n  /**\n   * Sets query parameters to the URL.\n   *\n   * ```\n   * // Navigate to /results?page=1\n   * this.router.navigate(['/results'], { queryParams: { page: 1 } });\n   * ```\n   */\n  queryParams?: Params|null;\n\n  /**\n   * Sets the hash fragment for the URL.\n   *\n   * ```\n   * // Navigate to /results#top\n   * this.router.navigate(['/results'], { fragment: 'top' });\n   * ```\n   */\n  fragment?: string;\n\n  /**\n   * Preserves the query parameters for the next navigation.\n   *\n   * deprecated, use `queryParamsHandling` instead\n   *\n   * ```\n   * // Preserve query params from /results?page=1 to /view?page=1\n   * this.router.navigate(['/view'], { preserveQueryParams: true });\n   * ```\n   *\n   * @deprecated since v4\n   */\n  preserveQueryParams?: boolean;\n\n  /**\n   *  config strategy to handle the query parameters for the next navigation.\n   *\n   * ```\n   * // from /results?page=1 to /view?page=1&page=2\n   * this.router.navigate(['/view'], { queryParams: { page: 2 },  queryParamsHandling: \"merge\" });\n   * ```\n   */\n  queryParamsHandling?: QueryParamsHandling|null;\n  /**\n   * Preserves the fragment for the next navigation\n   *\n   * ```\n   * // Preserve fragment from /results#top to /view#top\n   * this.router.navigate(['/view'], { preserveFragment: true });\n   * ```\n   */\n  preserveFragment?: boolean;\n  /**\n   * Navigates without pushing a new state into history.\n   *\n   * ```\n   * // Navigate silently to /view\n   * this.router.navigate(['/view'], { skipLocationChange: true });\n   * ```\n   */\n  skipLocationChange?: boolean;\n  /**\n   * Navigates while replacing the current state in history.\n   *\n   * ```\n   * // Navigate to /view\n   * this.router.navigate(['/view'], { replaceUrl: true });\n   * ```\n   */\n  replaceUrl?: boolean;\n}\n\n/**\n * @description\n *\n * Error handler that is invoked when a navigation errors.\n *\n * If the handler returns a value, the navigation promise will be resolved with this value.\n * If the handler throws an exception, the navigation promise will be rejected with\n * the exception.\n *\n *\n */\nexport type ErrorHandler = (error: any) => any;\n\nfunction defaultErrorHandler(error: any): any {\n  throw error;\n}\n\nfunction defaultMalformedUriErrorHandler(\n    error: URIError, urlSerializer: UrlSerializer, url: string): UrlTree {\n  return urlSerializer.parse('/');\n}\n\ntype NavStreamValue =\n    boolean | {appliedUrl: UrlTree, snapshot: RouterStateSnapshot, shouldActivate?: boolean};\n\ntype NavigationParams = {\n  id: number,\n  rawUrl: UrlTree,\n  extras: NavigationExtras,\n  resolve: any,\n  reject: any,\n  promise: Promise<boolean>,\n  source: NavigationTrigger,\n  state: {navigationId: number} | null\n};\n\n/**\n * @internal\n */\nexport type RouterHook = (snapshot: RouterStateSnapshot, runExtras: {\n  appliedUrlTree: UrlTree,\n  rawUrlTree: UrlTree,\n  skipLocationChange: boolean,\n  replaceUrl: boolean,\n  navigationId: number\n}) => Observable<void>;\n\n/**\n * @internal\n */\nfunction defaultRouterHook(snapshot: RouterStateSnapshot, runExtras: {\n  appliedUrlTree: UrlTree,\n  rawUrlTree: UrlTree,\n  skipLocationChange: boolean,\n  replaceUrl: boolean,\n  navigationId: number\n}): Observable<void> {\n  return of (null) as any;\n}\n\n/**\n * @description\n *\n * Provides the navigation and url manipulation capabilities.\n *\n * See `Routes` for more details and examples.\n *\n * @ngModule RouterModule\n *\n *\n */\nexport class Router {\n  private currentUrlTree: UrlTree;\n  private rawUrlTree: UrlTree;\n  private navigations = new BehaviorSubject<NavigationParams>(null !);\n\n  // TODO(issue/24571): remove '!'.\n  private locationSubscription !: Subscription;\n  private navigationId: number = 0;\n  private configLoader: RouterConfigLoader;\n  private ngModule: NgModuleRef<any>;\n  private console: Console;\n  private isNgZoneEnabled: boolean = false;\n\n  public readonly events: Observable<Event> = new Subject<Event>();\n  public readonly routerState: RouterState;\n\n  /**\n   * Error handler that is invoked when a navigation errors.\n   *\n   * See `ErrorHandler` for more information.\n   */\n  errorHandler: ErrorHandler = defaultErrorHandler;\n\n  /**\n   * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an\n   * error due to containing an invalid character. The most common case would be a `%` sign\n   * that's not encoded and is not part of a percent encoded sequence.\n   */\n  malformedUriErrorHandler:\n      (error: URIError, urlSerializer: UrlSerializer,\n       url: string) => UrlTree = defaultMalformedUriErrorHandler;\n\n  /**\n   * Indicates if at least one navigation happened.\n   */\n  navigated: boolean = false;\n  private lastSuccessfulId: number = -1;\n\n  /**\n   * Used by RouterModule. This allows us to\n   * pause the navigation either before preactivation or after it.\n   * @internal\n   */\n  hooks: {beforePreactivation: RouterHook, afterPreactivation: RouterHook} = {\n    beforePreactivation: defaultRouterHook,\n    afterPreactivation: defaultRouterHook\n  };\n\n  /**\n   * Extracts and merges URLs. Used for AngularJS to Angular migrations.\n   */\n  urlHandlingStrategy: UrlHandlingStrategy = new DefaultUrlHandlingStrategy();\n\n  routeReuseStrategy: RouteReuseStrategy = new DefaultRouteReuseStrategy();\n\n  /**\n   * Define what the router should do if it receives a navigation request to the current URL.\n   * By default, the router will ignore this navigation. However, this prevents features such\n   * as a \"refresh\" button. Use this option to configure the behavior when navigating to the\n   * current URL. Default is 'ignore'.\n   */\n  onSameUrlNavigation: 'reload'|'ignore' = 'ignore';\n\n  /**\n   * Defines how the router merges params, data and resolved data from parent to child\n   * routes. Available options are:\n   *\n   * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less\n   *   routes.\n   * - `'always'`, enables unconditional inheritance of parent params.\n   */\n  paramsInheritanceStrategy: 'emptyOnly'|'always' = 'emptyOnly';\n\n  /**\n   * Defines when the router updates the browser URL. The default behavior is to update after\n   * successful navigation. However, some applications may prefer a mode where the URL gets\n   * updated at the beginning of navigation. The most common use case would be updating the\n   * URL early so if navigation fails, you can show an error message with the URL that failed.\n   * Available options are:\n   *\n   * - `'deferred'`, the default, updates the browser URL after navigation has finished.\n   * - `'eager'`, updates browser URL at the beginning of navigation.\n   */\n  urlUpdateStrategy: 'deferred'|'eager' = 'deferred';\n\n  /**\n   * See {@link RouterModule} for more information.\n   */\n  relativeLinkResolution: 'legacy'|'corrected' = 'legacy';\n\n  /**\n   * Creates the router service.\n   */\n  // TODO: vsavkin make internal after the final is out.\n  constructor(\n      private rootComponentType: Type<any>|null, private urlSerializer: UrlSerializer,\n      private rootContexts: ChildrenOutletContexts, private location: Location, injector: Injector,\n      loader: NgModuleFactoryLoader, compiler: Compiler, public config: Routes) {\n    const onLoadStart = (r: Route) => this.triggerEvent(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r: Route) => this.triggerEvent(new RouteConfigLoadEnd(r));\n\n    this.ngModule = injector.get(NgModuleRef);\n    this.console = injector.get(Console);\n    const ngZone = injector.get(NgZone);\n    this.isNgZoneEnabled = ngZone instanceof NgZone;\n\n    this.resetConfig(config);\n    this.currentUrlTree = createEmptyUrlTree();\n    this.rawUrlTree = this.currentUrlTree;\n\n    this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);\n    this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);\n    this.processNavigations();\n  }\n\n  /**\n   * @internal\n   * TODO: this should be removed once the constructor of the router made internal\n   */\n  resetRootComponentType(rootComponentType: Type<any>): void {\n    this.rootComponentType = rootComponentType;\n    // TODO: vsavkin router 4.0 should make the root component set to null\n    // this will simplify the lifecycle of the router.\n    this.routerState.root.component = this.rootComponentType;\n  }\n\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation(): void {\n    this.setUpLocationChangeListener();\n    if (this.navigationId === 0) {\n      this.navigateByUrl(this.location.path(true), {replaceUrl: true});\n    }\n  }\n\n  /**\n   * Sets up the location change listener.\n   */\n  setUpLocationChangeListener(): void {\n    // Don't need to use Zone.wrap any more, because zone.js\n    // already patch onPopState, so location change callback will\n    // run into ngZone\n    if (!this.locationSubscription) {\n      this.locationSubscription = <any>this.location.subscribe((change: any) => {\n        let rawUrlTree = this.parseUrl(change['url']);\n        const source: NavigationTrigger = change['type'] === 'popstate' ? 'popstate' : 'hashchange';\n        const state = change.state && change.state.navigationId ?\n            {navigationId: change.state.navigationId} :\n            null;\n        setTimeout(\n            () => { this.scheduleNavigation(rawUrlTree, source, state, {replaceUrl: true}); }, 0);\n      });\n    }\n  }\n\n  /** The current url */\n  get url(): string { return this.serializeUrl(this.currentUrlTree); }\n\n  /** @internal */\n  triggerEvent(event: Event): void { (this.events as Subject<Event>).next(event); }\n\n  /**\n   * Resets the configuration used for navigation and generating links.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * ```\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config: Routes): void {\n    validateConfig(config);\n    this.config = config.map(standardizeConfig);\n    this.navigated = false;\n    this.lastSuccessfulId = -1;\n  }\n\n  /** @docsNotRequired */\n  ngOnDestroy(): void { this.dispose(); }\n\n  /** Disposes of the router */\n  dispose(): void {\n    if (this.locationSubscription) {\n      this.locationSubscription.unsubscribe();\n      this.locationSubscription = null !;\n    }\n  }\n\n  /**\n   * Applies an array of commands to the current url tree and creates a new url tree.\n   *\n   * When given an activate route, applies the given commands starting from the route.\n   * When not given a route, applies the given command starting from the root.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it, you\n   * // can do the following:\n   *\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   * ```\n   */\n  createUrlTree(commands: any[], navigationExtras: NavigationExtras = {}): UrlTree {\n    const {relativeTo,          queryParams,         fragment,\n           preserveQueryParams, queryParamsHandling, preserveFragment} = navigationExtras;\n    if (isDevMode() && preserveQueryParams && <any>console && <any>console.warn) {\n      console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');\n    }\n    const a = relativeTo || this.routerState.root;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q: Params|null = null;\n    if (queryParamsHandling) {\n      switch (queryParamsHandling) {\n        case 'merge':\n          q = {...this.currentUrlTree.queryParams, ...queryParams};\n          break;\n        case 'preserve':\n          q = this.currentUrlTree.queryParams;\n          break;\n        default:\n          q = queryParams || null;\n      }\n    } else {\n      q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n    return createUrlTree(a, this.currentUrlTree, commands, q !, f !);\n  }\n\n  /**\n   * Navigate based on the provided url. This navigation is always absolute.\n   *\n   * Returns a promise that:\n   * - resolves to 'true' when navigation succeeds,\n   * - resolves to 'false' when navigation fails,\n   * - is rejected when an error happens.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * ```\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * Since `navigateByUrl()` takes an absolute URL as the first parameter,\n   * it will not apply any delta to the current URL and ignores any properties\n   * in the second parameter (the `NavigationExtras`) that would change the\n   * provided URL.\n   */\n  navigateByUrl(url: string|UrlTree, extras: NavigationExtras = {skipLocationChange: false}):\n      Promise<boolean> {\n    if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {\n      this.console.warn(\n          `Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?`);\n    }\n\n    const urlTree = url instanceof UrlTree ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n\n    return this.scheduleNavigation(mergedTree, 'imperative', null, extras);\n  }\n\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * Returns a promise that:\n   * - resolves to 'true' when navigation succeeds,\n   * - resolves to 'false' when navigation fails,\n   * - is rejected when an error happens.\n   *\n   * @usageNotes\n   *\n   * ### Example\n   *\n   * ```\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * The first parameter of `navigate()` is a delta to be applied to the current URL\n   * or the one provided in the `relativeTo` property of the second parameter (the\n   * `NavigationExtras`).\n   */\n  navigate(commands: any[], extras: NavigationExtras = {skipLocationChange: false}):\n      Promise<boolean> {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url: UrlTree): string { return this.urlSerializer.serialize(url); }\n\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url: string): UrlTree {\n    let urlTree: UrlTree;\n    try {\n      urlTree = this.urlSerializer.parse(url);\n    } catch (e) {\n      urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);\n    }\n    return urlTree;\n  }\n\n  /** Returns whether the url is activated */\n  isActive(url: string|UrlTree, exact: boolean): boolean {\n    if (url instanceof UrlTree) {\n      return containsTree(this.currentUrlTree, url, exact);\n    }\n\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, exact);\n  }\n\n  private removeEmptyProps(params: Params): Params {\n    return Object.keys(params).reduce((result: Params, key: string) => {\n      const value: any = params[key];\n      if (value !== null && value !== undefined) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n\n  private processNavigations(): void {\n    this.navigations\n        .pipe(concatMap((nav: NavigationParams) => {\n          if (nav) {\n            this.executeScheduledNavigation(nav);\n            // a failed navigation should not stop the router from processing\n            // further navigations => the catch\n            return nav.promise.catch(() => {});\n          } else {\n            return <any>of (null);\n          }\n        }))\n        .subscribe(() => {});\n  }\n\n  private scheduleNavigation(\n      rawUrl: UrlTree, source: NavigationTrigger, state: {navigationId: number}|null,\n      extras: NavigationExtras): Promise<boolean> {\n    const lastNavigation = this.navigations.value;\n    // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),\n    // and that navigation results in 'replaceState' that leads to the same URL,\n    // we should skip those.\n    if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n\n    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n    // flicker. Handles the case when a popstate was emitted first.\n    if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n    // Because of a bug in IE and Edge, the location class fires two events (popstate and\n    // hashchange) every single time. The second one should be ignored. Otherwise, the URL will\n    // flicker. Handles the case when a hashchange was emitted first.\n    if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&\n        lastNavigation.rawUrl.toString() === rawUrl.toString()) {\n      return Promise.resolve(true);  // return value is not used\n    }\n\n    let resolve: any = null;\n    let reject: any = null;\n\n    const promise = new Promise<boolean>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    const id = ++this.navigationId;\n    this.navigations.next({id, source, state, rawUrl, extras, resolve, reject, promise});\n\n    // Make sure that the error is propagated even though `processNavigations` catch\n    // handler does not rethrow\n    return promise.catch((e: any) => Promise.reject(e));\n  }\n\n  private executeScheduledNavigation({id, rawUrl, extras, resolve, reject, source,\n                                      state}: NavigationParams): void {\n    const url = this.urlHandlingStrategy.extract(rawUrl);\n    const urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();\n\n    if ((this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&\n        this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {\n      if (this.urlUpdateStrategy === 'eager' && !extras.skipLocationChange) {\n        this.setBrowserUrl(rawUrl, !!extras.replaceUrl, id);\n      }\n      (this.events as Subject<Event>)\n          .next(new NavigationStart(id, this.serializeUrl(url), source, state));\n      Promise.resolve()\n          .then(\n              (_) => this.runNavigate(\n                  url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null))\n          .then(resolve, reject);\n\n      // we cannot process the current URL, but we could process the previous one =>\n      // we need to do some cleanup\n    } else if (\n        urlTransition && this.rawUrlTree &&\n        this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {\n      (this.events as Subject<Event>)\n          .next(new NavigationStart(id, this.serializeUrl(url), source, state));\n      Promise.resolve()\n          .then(\n              (_) => this.runNavigate(\n                  url, rawUrl, false, false, id,\n                  createEmptyState(url, this.rootComponentType).snapshot))\n          .then(resolve, reject);\n\n    } else {\n      this.rawUrlTree = rawUrl;\n      resolve(null);\n    }\n  }\n\n  private runNavigate(\n      url: UrlTree, rawUrl: UrlTree, skipLocationChange: boolean, replaceUrl: boolean, id: number,\n      precreatedState: RouterStateSnapshot|null): Promise<boolean> {\n    if (id !== this.navigationId) {\n      (this.events as Subject<Event>)\n          .next(new NavigationCancel(\n              id, this.serializeUrl(url),\n              `Navigation ID ${id} is not equal to the current navigation id ${this.navigationId}`));\n      return Promise.resolve(false);\n    }\n\n    return new Promise((resolvePromise, rejectPromise) => {\n      // create an observable of the url and route state snapshot\n      // this operation do not result in any side effects\n      let urlAndSnapshot$: Observable<NavStreamValue>;\n      if (!precreatedState) {\n        const moduleInjector = this.ngModule.injector;\n        const redirectsApplied$ =\n            applyRedirects(moduleInjector, this.configLoader, this.urlSerializer, url, this.config);\n\n        urlAndSnapshot$ = redirectsApplied$.pipe(mergeMap((appliedUrl: UrlTree) => {\n          return recognize(\n                     this.rootComponentType, this.config, appliedUrl, this.serializeUrl(appliedUrl),\n                     this.paramsInheritanceStrategy, this.relativeLinkResolution)\n              .pipe(map((snapshot: any) => {\n                (this.events as Subject<Event>)\n                    .next(new RoutesRecognized(\n                        id, this.serializeUrl(url), this.serializeUrl(appliedUrl), snapshot));\n\n                return {appliedUrl, snapshot};\n              }));\n        }));\n      } else {\n        urlAndSnapshot$ = of ({appliedUrl: url, snapshot: precreatedState});\n      }\n\n      const beforePreactivationDone$ =\n          urlAndSnapshot$.pipe(mergeMap((p): Observable<NavStreamValue> => {\n            if (typeof p === 'boolean') return of (p);\n            return this.hooks\n                .beforePreactivation(p.snapshot, {\n                  navigationId: id,\n                  appliedUrlTree: url,\n                  rawUrlTree: rawUrl, skipLocationChange, replaceUrl,\n                })\n                .pipe(map(() => p));\n          }));\n\n      // run preactivation: guards and data resolvers\n      let preActivation: PreActivation;\n\n      const preactivationSetup$ = beforePreactivationDone$.pipe(map((p): NavStreamValue => {\n        if (typeof p === 'boolean') return p;\n        const {appliedUrl, snapshot} = p;\n        const moduleInjector = this.ngModule.injector;\n        preActivation = new PreActivation(\n            snapshot, this.routerState.snapshot, moduleInjector,\n            (evt: Event) => this.triggerEvent(evt));\n        preActivation.initialize(this.rootContexts);\n        return {appliedUrl, snapshot};\n      }));\n\n      const preactivationCheckGuards$ =\n          preactivationSetup$.pipe(mergeMap((p): Observable<NavStreamValue> => {\n            if (typeof p === 'boolean' || this.navigationId !== id) return of (false);\n            const {appliedUrl, snapshot} = p;\n\n            this.triggerEvent(new GuardsCheckStart(\n                id, this.serializeUrl(url), this.serializeUrl(appliedUrl), snapshot));\n\n            return preActivation.checkGuards().pipe(map((shouldActivate: boolean) => {\n              this.triggerEvent(new GuardsCheckEnd(\n                  id, this.serializeUrl(url), this.serializeUrl(appliedUrl), snapshot,\n                  shouldActivate));\n              return {appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate};\n            }));\n          }));\n\n      const preactivationResolveData$ =\n          preactivationCheckGuards$.pipe(mergeMap((p): Observable<NavStreamValue> => {\n            if (typeof p === 'boolean' || this.navigationId !== id) return of (false);\n\n            if (p.shouldActivate && preActivation.isActivating()) {\n              this.triggerEvent(new ResolveStart(\n                  id, this.serializeUrl(url), this.serializeUrl(p.appliedUrl), p.snapshot));\n              return preActivation.resolveData(this.paramsInheritanceStrategy).pipe(map(() => {\n                this.triggerEvent(new ResolveEnd(\n                    id, this.serializeUrl(url), this.serializeUrl(p.appliedUrl), p.snapshot));\n                return p;\n              }));\n            } else {\n              return of (p);\n            }\n          }));\n\n      const preactivationDone$ =\n          preactivationResolveData$.pipe(mergeMap((p): Observable<NavStreamValue> => {\n            if (typeof p === 'boolean' || this.navigationId !== id) return of (false);\n            return this.hooks\n                .afterPreactivation(p.snapshot, {\n                  navigationId: id,\n                  appliedUrlTree: url,\n                  rawUrlTree: rawUrl, skipLocationChange, replaceUrl,\n                })\n                .pipe(map(() => p));\n          }));\n\n\n      // create router state\n      // this operation has side effects => route state is being affected\n      const routerState$ = preactivationDone$.pipe(map((p) => {\n        if (typeof p === 'boolean' || this.navigationId !== id) return false;\n        const {appliedUrl, snapshot, shouldActivate} = p;\n        if (shouldActivate) {\n          const state = createRouterState(this.routeReuseStrategy, snapshot, this.routerState);\n          return {appliedUrl, state, shouldActivate};\n        } else {\n          return {appliedUrl, state: null, shouldActivate};\n        }\n      }));\n\n\n      this.activateRoutes(\n          routerState$, this.routerState, this.currentUrlTree, id, url, rawUrl, skipLocationChange,\n          replaceUrl, resolvePromise, rejectPromise);\n    });\n  }\n\n  /**\n   * Performs the logic of activating routes. This is a synchronous process by default. While this\n   * is a private method, it could be overridden to make activation asynchronous.\n   */\n  private activateRoutes(\n      state: Observable<false|\n                        {appliedUrl: UrlTree, state: RouterState|null, shouldActivate?: boolean}>,\n      storedState: RouterState, storedUrl: UrlTree, id: number, url: UrlTree, rawUrl: UrlTree,\n      skipLocationChange: boolean, replaceUrl: boolean, resolvePromise: any, rejectPromise: any) {\n    // applied the new router state\n    // this operation has side effects\n    let navigationIsSuccessful: boolean;\n\n    state\n        .forEach((p) => {\n          if (typeof p === 'boolean' || !p.shouldActivate || id !== this.navigationId || !p.state) {\n            navigationIsSuccessful = false;\n            return;\n          }\n          const {appliedUrl, state} = p;\n          this.currentUrlTree = appliedUrl;\n          this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n\n          (this as{routerState: RouterState}).routerState = state;\n\n          if (this.urlUpdateStrategy === 'deferred' && !skipLocationChange) {\n            this.setBrowserUrl(this.rawUrlTree, replaceUrl, id);\n          }\n\n          new ActivateRoutes(\n              this.routeReuseStrategy, state, storedState, (evt: Event) => this.triggerEvent(evt))\n              .activate(this.rootContexts);\n\n          navigationIsSuccessful = true;\n        })\n        .then(\n            () => {\n              if (navigationIsSuccessful) {\n                this.navigated = true;\n                this.lastSuccessfulId = id;\n                (this.events as Subject<Event>)\n                    .next(new NavigationEnd(\n                        id, this.serializeUrl(url), this.serializeUrl(this.currentUrlTree)));\n                resolvePromise(true);\n              } else {\n                this.resetUrlToCurrentUrlTree();\n                (this.events as Subject<Event>)\n                    .next(new NavigationCancel(id, this.serializeUrl(url), ''));\n                resolvePromise(false);\n              }\n            },\n            (e: any) => {\n              if (isNavigationCancelingError(e)) {\n                this.navigated = true;\n                this.resetStateAndUrl(storedState, storedUrl, rawUrl);\n                (this.events as Subject<Event>)\n                    .next(new NavigationCancel(id, this.serializeUrl(url), e.message));\n\n                resolvePromise(false);\n              } else {\n                this.resetStateAndUrl(storedState, storedUrl, rawUrl);\n                (this.events as Subject<Event>)\n                    .next(new NavigationError(id, this.serializeUrl(url), e));\n                try {\n                  resolvePromise(this.errorHandler(e));\n                } catch (ee) {\n                  rejectPromise(ee);\n                }\n              }\n            });\n  }\n\n  private setBrowserUrl(url: UrlTree, replaceUrl: boolean, id: number) {\n    const path = this.urlSerializer.serialize(url);\n    if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {\n      this.location.replaceState(path, '', {navigationId: id});\n    } else {\n      this.location.go(path, '', {navigationId: id});\n    }\n  }\n\n  private resetStateAndUrl(storedState: RouterState, storedUrl: UrlTree, rawUrl: UrlTree): void {\n    (this as{routerState: RouterState}).routerState = storedState;\n    this.currentUrlTree = storedUrl;\n    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);\n    this.resetUrlToCurrentUrlTree();\n  }\n\n  private resetUrlToCurrentUrlTree(): void {\n    this.location.replaceState(\n        this.urlSerializer.serialize(this.rawUrlTree), '', {navigationId: this.lastSuccessfulId});\n  }\n}\n\nclass ActivateRoutes {\n  constructor(\n      private routeReuseStrategy: RouteReuseStrategy, private futureState: RouterState,\n      private currState: RouterState, private forwardEvent: (evt: Event) => void) {}\n\n  activate(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n\n  // De-activate the child route that are not re-used for the future state\n  private deactivateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outletName: string]: TreeNode<ActivatedRoute>} = nodeChildrenAsMap(currNode);\n\n    // Recurse on the routes active in the future state to de-activate deeper children\n    futureNode.children.forEach(futureChild => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n\n    // De-activate the routes that will not be re-used\n    forEach(children, (v: TreeNode<ActivatedRoute>, childName: string) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n\n  private deactivateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContext: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    if (future === curr) {\n      // Reusing the node, check to see if the children need to be de-activated\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContext.getContext(future.outlet);\n        if (context) {\n          this.deactivateChildRoutes(futureNode, currNode, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        // Deactivate the current route which will not be re-used\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n\n  private detachAndStoreRouteSubtree(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n    if (context && context.outlet) {\n      const componentRef = context.outlet.detach();\n      const contexts = context.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {componentRef, route, contexts});\n    }\n  }\n\n  private deactivateRouteAndOutlet(\n      route: TreeNode<ActivatedRoute>, parentContexts: ChildrenOutletContexts): void {\n    const context = parentContexts.getContext(route.value.outlet);\n\n    if (context) {\n      const children: {[outletName: string]: any} = nodeChildrenAsMap(route);\n      const contexts = route.value.component ? context.children : parentContexts;\n\n      forEach(children, (v: any, k: string) => this.deactivateRouteAndItsChildren(v, contexts));\n\n      if (context.outlet) {\n        // Destroy the component\n        context.outlet.deactivate();\n        // Destroy the contexts for all the outlets that were in the component\n        context.children.onOutletDeactivated();\n      }\n    }\n  }\n\n  private activateChildRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>|null,\n      contexts: ChildrenOutletContexts): void {\n    const children: {[outlet: string]: any} = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach(c => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n\n  private activateRoutes(\n      futureNode: TreeNode<ActivatedRoute>, currNode: TreeNode<ActivatedRoute>,\n      parentContexts: ChildrenOutletContexts): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n\n    advanceActivatedRoute(future);\n\n    // reusing the node\n    if (future === curr) {\n      if (future.component) {\n        // If we have a normal route, we need to go through an outlet.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context.children);\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        // if we have a normal route, we need to place the component into the outlet and recurse.\n        const context = parentContexts.getOrCreateContext(future.outlet);\n\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored =\n              (<DetachedRouteHandleInternal>this.routeReuseStrategy.retrieve(future.snapshot));\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context.children.onOutletReAttached(stored.contexts);\n          context.attachRef = stored.componentRef;\n          context.route = stored.route.value;\n          if (context.outlet) {\n            // Attach right away when the outlet has already been instantiated\n            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated\n            context.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRouteNodeAndItsChildren(stored.route);\n        } else {\n          const config = parentLoadedConfig(future.snapshot);\n          const cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;\n\n          context.attachRef = null;\n          context.route = future;\n          context.resolver = cmpFactoryResolver;\n          if (context.outlet) {\n            // Activate the outlet when it has already been instantiated\n            // Otherwise it will get activated from its `ngOnInit` when instantiated\n            context.outlet.activateWith(future, cmpFactoryResolver);\n          }\n\n          this.activateChildRoutes(futureNode, null, context.children);\n        }\n      } else {\n        // if we have a componentless route, we recurse but keep the same outlet map.\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n  }\n}\n\nfunction advanceActivatedRouteNodeAndItsChildren(node: TreeNode<ActivatedRoute>): void {\n  advanceActivatedRoute(node.value);\n  node.children.forEach(advanceActivatedRouteNodeAndItsChildren);\n}\n\nfunction parentLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n    if (route && route.component) return null;\n  }\n\n  return null;\n}\n\nfunction validateCommands(commands: string[]): void {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new Error(`The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\n"],"sourceRoot":""}