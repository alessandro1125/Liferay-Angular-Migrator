Liferay.Loader.define('@example-angular-liferay$angular/router@6.1.10/esm5/src/pre_activation', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { from, of } from 'rxjs';
    import { concatMap, every, first, last, map, mergeMap, reduce } from 'rxjs/operators';
    import { ActivationStart, ChildActivationStart } from './events';
    import { equalParamsAndUrlSegments, inheritedParamsDataResolve } from './router_state';
    import { andObservables, forEach, shallowEqual, wrapIntoObservable } from './utils/collection';
    import { nodeChildrenAsMap } from './utils/tree';
    var CanActivate = /** @class */function () {
        function CanActivate(path) {
            this.path = path;
            this.route = this.path[this.path.length - 1];
        }
        return CanActivate;
    }();
    var CanDeactivate = /** @class */function () {
        function CanDeactivate(component, route) {
            this.component = component;
            this.route = route;
        }
        return CanDeactivate;
    }();
    /**
     * This class bundles the actions involved in preactivation of a route.
     */
    var PreActivation = /** @class */function () {
        function PreActivation(future, curr, moduleInjector, forwardEvent) {
            this.future = future;
            this.curr = curr;
            this.moduleInjector = moduleInjector;
            this.forwardEvent = forwardEvent;
            this.canActivateChecks = [];
            this.canDeactivateChecks = [];
        }
        PreActivation.prototype.initialize = function (parentContexts) {
            var futureRoot = this.future._root;
            var currRoot = this.curr ? this.curr._root : null;
            this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
        };
        PreActivation.prototype.checkGuards = function () {
            var _this = this;
            if (!this.isDeactivating() && !this.isActivating()) {
                return of(true);
            }
            var canDeactivate$ = this.runCanDeactivateChecks();
            return canDeactivate$.pipe(mergeMap(function (canDeactivate) {
                return canDeactivate ? _this.runCanActivateChecks() : of(false);
            }));
        };
        PreActivation.prototype.resolveData = function (paramsInheritanceStrategy) {
            var _this = this;
            if (!this.isActivating()) return of(null);
            return from(this.canActivateChecks).pipe(concatMap(function (check) {
                return _this.runResolve(check.route, paramsInheritanceStrategy);
            }), reduce(function (_, __) {
                return _;
            }));
        };
        PreActivation.prototype.isDeactivating = function () {
            return this.canDeactivateChecks.length !== 0;
        };
        PreActivation.prototype.isActivating = function () {
            return this.canActivateChecks.length !== 0;
        };
        /**
         * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in
         * proper state to run `checkGuards()` method.
         */
        PreActivation.prototype.setupChildRouteGuards = function (futureNode, currNode, contexts, futurePath) {
            var _this = this;
            var prevChildren = nodeChildrenAsMap(currNode);
            // Process the children of the future route
            futureNode.children.forEach(function (c) {
                _this.setupRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));
                delete prevChildren[c.value.outlet];
            });
            // Process any children left from the current route (not active for the future route)
            forEach(prevChildren, function (v, k) {
                return _this.deactivateRouteAndItsChildren(v, contexts.getContext(k));
            });
        };
        /**
         * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in
         * proper state to run `checkGuards()` method.
         */
        PreActivation.prototype.setupRouteGuards = function (futureNode, currNode, parentContexts, futurePath) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
            // reusing the node
            if (curr && future.routeConfig === curr.routeConfig) {
                var shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
                if (shouldRunGuardsAndResolvers) {
                    this.canActivateChecks.push(new CanActivate(futurePath));
                } else {
                    // we need to set the data
                    future.data = curr.data;
                    future._resolvedData = curr._resolvedData;
                }
                // If we have a component, we need to go through an outlet.
                if (future.component) {
                    this.setupChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath);
                    // if we have a componentless route, we recurse but keep the same outlet map.
                } else {
                    this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);
                }
                if (shouldRunGuardsAndResolvers) {
                    var outlet = context.outlet;
                    this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));
                }
            } else {
                if (curr) {
                    this.deactivateRouteAndItsChildren(currNode, context);
                }
                this.canActivateChecks.push(new CanActivate(futurePath));
                // If we have a component, we need to go through an outlet.
                if (future.component) {
                    this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);
                    // if we have a componentless route, we recurse but keep the same outlet map.
                } else {
                    this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);
                }
            }
        };
        PreActivation.prototype.shouldRunGuardsAndResolvers = function (curr, future, mode) {
            switch (mode) {
                case 'always':
                    return true;
                case 'paramsOrQueryParamsChange':
                    return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);
                case 'paramsChange':
                default:
                    return !equalParamsAndUrlSegments(curr, future);
            }
        };
        PreActivation.prototype.deactivateRouteAndItsChildren = function (route, context) {
            var _this = this;
            var children = nodeChildrenAsMap(route);
            var r = route.value;
            forEach(children, function (node, childName) {
                if (!r.component) {
                    _this.deactivateRouteAndItsChildren(node, context);
                } else if (context) {
                    _this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));
                } else {
                    _this.deactivateRouteAndItsChildren(node, null);
                }
            });
            if (!r.component) {
                this.canDeactivateChecks.push(new CanDeactivate(null, r));
            } else if (context && context.outlet && context.outlet.isActivated) {
                this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
            } else {
                this.canDeactivateChecks.push(new CanDeactivate(null, r));
            }
        };
        PreActivation.prototype.runCanDeactivateChecks = function () {
            var _this = this;
            return from(this.canDeactivateChecks).pipe(mergeMap(function (check) {
                return _this.runCanDeactivate(check.component, check.route);
            }), every(function (result) {
                return result === true;
            }));
        };
        PreActivation.prototype.runCanActivateChecks = function () {
            var _this = this;
            return from(this.canActivateChecks).pipe(concatMap(function (check) {
                return andObservables(from([_this.fireChildActivationStart(check.route.parent), _this.fireActivationStart(check.route), _this.runCanActivateChild(check.path), _this.runCanActivate(check.route)]));
            }), every(function (result) {
                return result === true;
            }));
            // this.fireChildActivationStart(check.path),
        };
        /**
         * This should fire off `ActivationStart` events for each route being activated at this
         * level.
         * In other words, if you're activating `a` and `b` below, `path` will contain the
         * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always
         * return
         * `true` so checks continue to run.
         */
        PreActivation.prototype.fireActivationStart = function (snapshot) {
            if (snapshot !== null && this.forwardEvent) {
                this.forwardEvent(new ActivationStart(snapshot));
            }
            return of(true);
        };
        /**
         * This should fire off `ChildActivationStart` events for each route being activated at this
         * level.
         * In other words, if you're activating `a` and `b` below, `path` will contain the
         * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always
         * return
         * `true` so checks continue to run.
         */
        PreActivation.prototype.fireChildActivationStart = function (snapshot) {
            if (snapshot !== null && this.forwardEvent) {
                this.forwardEvent(new ChildActivationStart(snapshot));
            }
            return of(true);
        };
        PreActivation.prototype.runCanActivate = function (future) {
            var _this = this;
            var canActivate = future.routeConfig ? future.routeConfig.canActivate : null;
            if (!canActivate || canActivate.length === 0) return of(true);
            var obs = from(canActivate).pipe(map(function (c) {
                var guard = _this.getToken(c, future);
                var observable;
                if (guard.canActivate) {
                    observable = wrapIntoObservable(guard.canActivate(future, _this.future));
                } else {
                    observable = wrapIntoObservable(guard(future, _this.future));
                }
                return observable.pipe(first());
            }));
            return andObservables(obs);
        };
        PreActivation.prototype.runCanActivateChild = function (path) {
            var _this = this;
            var future = path[path.length - 1];
            var canActivateChildGuards = path.slice(0, path.length - 1).reverse().map(function (p) {
                return _this.extractCanActivateChild(p);
            }).filter(function (_) {
                return _ !== null;
            });
            return andObservables(from(canActivateChildGuards).pipe(map(function (d) {
                var obs = from(d.guards).pipe(map(function (c) {
                    var guard = _this.getToken(c, d.node);
                    var observable;
                    if (guard.canActivateChild) {
                        observable = wrapIntoObservable(guard.canActivateChild(future, _this.future));
                    } else {
                        observable = wrapIntoObservable(guard(future, _this.future));
                    }
                    return observable.pipe(first());
                }));
                return andObservables(obs);
            })));
        };
        PreActivation.prototype.extractCanActivateChild = function (p) {
            var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
            if (!canActivateChild || canActivateChild.length === 0) return null;
            return { node: p, guards: canActivateChild };
        };
        PreActivation.prototype.runCanDeactivate = function (component, curr) {
            var _this = this;
            var canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;
            if (!canDeactivate || canDeactivate.length === 0) return of(true);
            var canDeactivate$ = from(canDeactivate).pipe(mergeMap(function (c) {
                var guard = _this.getToken(c, curr);
                var observable;
                if (guard.canDeactivate) {
                    observable = wrapIntoObservable(guard.canDeactivate(component, curr, _this.curr, _this.future));
                } else {
                    observable = wrapIntoObservable(guard(component, curr, _this.curr, _this.future));
                }
                return observable.pipe(first());
            }));
            return canDeactivate$.pipe(every(function (result) {
                return result === true;
            }));
        };
        PreActivation.prototype.runResolve = function (future, paramsInheritanceStrategy) {
            var resolve = future._resolve;
            return this.resolveNode(resolve, future).pipe(map(function (resolvedData) {
                future._resolvedData = resolvedData;
                future.data = tslib_1.__assign({}, future.data, inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve);
                return null;
            }));
        };
        PreActivation.prototype.resolveNode = function (resolve, future) {
            var _this = this;
            var keys = Object.keys(resolve);
            if (keys.length === 0) {
                return of({});
            }
            if (keys.length === 1) {
                var key_1 = keys[0];
                return this.getResolver(resolve[key_1], future).pipe(map(function (value) {
                    var _a;
                    return _a = {}, _a[key_1] = value, _a;
                }));
            }
            var data = {};
            var runningResolvers$ = from(keys).pipe(mergeMap(function (key) {
                return _this.getResolver(resolve[key], future).pipe(map(function (value) {
                    data[key] = value;
                    return value;
                }));
            }));
            return runningResolvers$.pipe(last(), map(function () {
                return data;
            }));
        };
        PreActivation.prototype.getResolver = function (injectionToken, future) {
            var resolver = this.getToken(injectionToken, future);
            return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) : wrapIntoObservable(resolver(future, this.future));
        };
        PreActivation.prototype.getToken = function (token, snapshot) {
            var config = closestLoadedConfig(snapshot);
            var injector = config ? config.module.injector : this.moduleInjector;
            return injector.get(token);
        };
        return PreActivation;
    }();
    export { PreActivation };
    function closestLoadedConfig(snapshot) {
        if (!snapshot) return null;
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig) return route._loadedConfig;
        }
        return null;
    }
});
//# sourceMappingURL=pre_activation.js.map