Liferay.Loader.define('@example-angular-liferay$angular/router@6.1.10/esm5/src/router', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { NgModuleRef, NgZone, isDevMode, ÉµConsole as Console } from '@angular/core';
    import { BehaviorSubject, Subject, of } from 'rxjs';
    import { concatMap, map, mergeMap } from 'rxjs/operators';
    import { applyRedirects } from './apply_redirects';
    import { standardizeConfig, validateConfig } from './config';
    import { createRouterState } from './create_router_state';
    import { createUrlTree } from './create_url_tree';
    import { ActivationEnd, ChildActivationEnd, GuardsCheckEnd, GuardsCheckStart, NavigationCancel, NavigationEnd, NavigationError, NavigationStart, ResolveEnd, ResolveStart, RouteConfigLoadEnd, RouteConfigLoadStart, RoutesRecognized } from './events';
    import { PreActivation } from './pre_activation';
    import { recognize } from './recognize';
    import { DefaultRouteReuseStrategy } from './route_reuse_strategy';
    import { RouterConfigLoader } from './router_config_loader';
    import { advanceActivatedRoute, createEmptyState } from './router_state';
    import { isNavigationCancelingError } from './shared';
    import { DefaultUrlHandlingStrategy } from './url_handling_strategy';
    import { UrlTree, containsTree, createEmptyUrlTree } from './url_tree';
    import { forEach } from './utils/collection';
    import { nodeChildrenAsMap } from './utils/tree';
    function defaultErrorHandler(error) {
        throw error;
    }
    function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
        return urlSerializer.parse('/');
    }
    /**
     * @internal
     */
    function defaultRouterHook(snapshot, runExtras) {
        return of(null);
    }
    /**
     * @description
     *
     * Provides the navigation and url manipulation capabilities.
     *
     * See `Routes` for more details and examples.
     *
     * @ngModule RouterModule
     *
     *
     */
    var Router = /** @class */function () {
        /**
         * Creates the router service.
         */
        // TODO: vsavkin make internal after the final is out.
        function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
            var _this = this;
            this.rootComponentType = rootComponentType;
            this.urlSerializer = urlSerializer;
            this.rootContexts = rootContexts;
            this.location = location;
            this.config = config;
            this.navigations = new BehaviorSubject(null);
            this.navigationId = 0;
            this.isNgZoneEnabled = false;
            this.events = new Subject();
            /**
             * Error handler that is invoked when a navigation errors.
             *
             * See `ErrorHandler` for more information.
             */
            this.errorHandler = defaultErrorHandler;
            /**
             * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an
             * error due to containing an invalid character. The most common case would be a `%` sign
             * that's not encoded and is not part of a percent encoded sequence.
             */
            this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
            /**
             * Indicates if at least one navigation happened.
             */
            this.navigated = false;
            this.lastSuccessfulId = -1;
            /**
             * Used by RouterModule. This allows us to
             * pause the navigation either before preactivation or after it.
             * @internal
             */
            this.hooks = {
                beforePreactivation: defaultRouterHook,
                afterPreactivation: defaultRouterHook
            };
            /**
             * Extracts and merges URLs. Used for AngularJS to Angular migrations.
             */
            this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
            this.routeReuseStrategy = new DefaultRouteReuseStrategy();
            /**
             * Define what the router should do if it receives a navigation request to the current URL.
             * By default, the router will ignore this navigation. However, this prevents features such
             * as a "refresh" button. Use this option to configure the behavior when navigating to the
             * current URL. Default is 'ignore'.
             */
            this.onSameUrlNavigation = 'ignore';
            /**
             * Defines how the router merges params, data and resolved data from parent to child
             * routes. Available options are:
             *
             * - `'emptyOnly'`, the default, only inherits parent params for path-less or component-less
             *   routes.
             * - `'always'`, enables unconditional inheritance of parent params.
             */
            this.paramsInheritanceStrategy = 'emptyOnly';
            /**
             * Defines when the router updates the browser URL. The default behavior is to update after
             * successful navigation. However, some applications may prefer a mode where the URL gets
             * updated at the beginning of navigation. The most common use case would be updating the
             * URL early so if navigation fails, you can show an error message with the URL that failed.
             * Available options are:
             *
             * - `'deferred'`, the default, updates the browser URL after navigation has finished.
             * - `'eager'`, updates browser URL at the beginning of navigation.
             */
            this.urlUpdateStrategy = 'deferred';
            /**
             * See {@link RouterModule} for more information.
             */
            this.relativeLinkResolution = 'legacy';
            var onLoadStart = function (r) {
                return _this.triggerEvent(new RouteConfigLoadStart(r));
            };
            var onLoadEnd = function (r) {
                return _this.triggerEvent(new RouteConfigLoadEnd(r));
            };
            this.ngModule = injector.get(NgModuleRef);
            this.console = injector.get(Console);
            var ngZone = injector.get(NgZone);
            this.isNgZoneEnabled = ngZone instanceof NgZone;
            this.resetConfig(config);
            this.currentUrlTree = createEmptyUrlTree();
            this.rawUrlTree = this.currentUrlTree;
            this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
            this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
            this.processNavigations();
        }
        /**
         * @internal
         * TODO: this should be removed once the constructor of the router made internal
         */
        Router.prototype.resetRootComponentType = function (rootComponentType) {
            this.rootComponentType = rootComponentType;
            // TODO: vsavkin router 4.0 should make the root component set to null
            // this will simplify the lifecycle of the router.
            this.routerState.root.component = this.rootComponentType;
        };
        /**
         * Sets up the location change listener and performs the initial navigation.
         */
        Router.prototype.initialNavigation = function () {
            this.setUpLocationChangeListener();
            if (this.navigationId === 0) {
                this.navigateByUrl(this.location.path(true), { replaceUrl: true });
            }
        };
        /**
         * Sets up the location change listener.
         */
        Router.prototype.setUpLocationChangeListener = function () {
            var _this = this;
            // Don't need to use Zone.wrap any more, because zone.js
            // already patch onPopState, so location change callback will
            // run into ngZone
            if (!this.locationSubscription) {
                this.locationSubscription = this.location.subscribe(function (change) {
                    var rawUrlTree = _this.parseUrl(change['url']);
                    var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
                    var state = change.state && change.state.navigationId ? { navigationId: change.state.navigationId } : null;
                    setTimeout(function () {
                        _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true });
                    }, 0);
                });
            }
        };
        Object.defineProperty(Router.prototype, "url", {
            /** The current url */
            get: function () {
                return this.serializeUrl(this.currentUrlTree);
            },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        Router.prototype.triggerEvent = function (event) {
            this.events.next(event);
        };
        /**
         * Resets the configuration used for navigation and generating links.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.resetConfig([
         *  { path: 'team/:id', component: TeamCmp, children: [
         *    { path: 'simple', component: SimpleCmp },
         *    { path: 'user/:name', component: UserCmp }
         *  ]}
         * ]);
         * ```
         */
        Router.prototype.resetConfig = function (config) {
            validateConfig(config);
            this.config = config.map(standardizeConfig);
            this.navigated = false;
            this.lastSuccessfulId = -1;
        };
        /** @docsNotRequired */
        Router.prototype.ngOnDestroy = function () {
            this.dispose();
        };
        /** Disposes of the router */
        Router.prototype.dispose = function () {
            if (this.locationSubscription) {
                this.locationSubscription.unsubscribe();
                this.locationSubscription = null;
            }
        };
        /**
         * Applies an array of commands to the current url tree and creates a new url tree.
         *
         * When given an activate route, applies the given commands starting from the route.
         * When not given a route, applies the given command starting from the root.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * // create /team/33/user/11
         * router.createUrlTree(['/team', 33, 'user', 11]);
         *
         * // create /team/33;expand=true/user/11
         * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
         *
         * // you can collapse static segments like this (this works only with the first passed-in value):
         * router.createUrlTree(['/team/33/user', userId]);
         *
         * // If the first segment can contain slashes, and you do not want the router to split it, you
         * // can do the following:
         *
         * router.createUrlTree([{segmentPath: '/one/two'}]);
         *
         * // create /team/33/(user/11//right:chat)
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
         *
         * // remove the right secondary node
         * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
         *
         * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
         *
         * // navigate to /team/33/user/11/details
         * router.createUrlTree(['details'], {relativeTo: route});
         *
         * // navigate to /team/33/user/22
         * router.createUrlTree(['../22'], {relativeTo: route});
         *
         * // navigate to /team/44/user/22
         * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
         * ```
         */
        Router.prototype.createUrlTree = function (commands, navigationExtras) {
            if (navigationExtras === void 0) {
                navigationExtras = {};
            }
            var relativeTo = navigationExtras.relativeTo,
                queryParams = navigationExtras.queryParams,
                fragment = navigationExtras.fragment,
                preserveQueryParams = navigationExtras.preserveQueryParams,
                queryParamsHandling = navigationExtras.queryParamsHandling,
                preserveFragment = navigationExtras.preserveFragment;
            if (isDevMode() && preserveQueryParams && console && console.warn) {
                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
            }
            var a = relativeTo || this.routerState.root;
            var f = preserveFragment ? this.currentUrlTree.fragment : fragment;
            var q = null;
            if (queryParamsHandling) {
                switch (queryParamsHandling) {
                    case 'merge':
                        q = tslib_1.__assign({}, this.currentUrlTree.queryParams, queryParams);
                        break;
                    case 'preserve':
                        q = this.currentUrlTree.queryParams;
                        break;
                    default:
                        q = queryParams || null;
                }
            } else {
                q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
            }
            if (q !== null) {
                q = this.removeEmptyProps(q);
            }
            return createUrlTree(a, this.currentUrlTree, commands, q, f);
        };
        /**
         * Navigate based on the provided url. This navigation is always absolute.
         *
         * Returns a promise that:
         * - resolves to 'true' when navigation succeeds,
         * - resolves to 'false' when navigation fails,
         * - is rejected when an error happens.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigateByUrl("/team/33/user/11");
         *
         * // Navigate without updating the URL
         * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
         * ```
         *
         * Since `navigateByUrl()` takes an absolute URL as the first parameter,
         * it will not apply any delta to the current URL and ignores any properties
         * in the second parameter (the `NavigationExtras`) that would change the
         * provided URL.
         */
        Router.prototype.navigateByUrl = function (url, extras) {
            if (extras === void 0) {
                extras = { skipLocationChange: false };
            }
            if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {
                this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");
            }
            var urlTree = url instanceof UrlTree ? url : this.parseUrl(url);
            var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
            return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
        };
        /**
         * Navigate based on the provided array of commands and a starting point.
         * If no starting route is provided, the navigation is absolute.
         *
         * Returns a promise that:
         * - resolves to 'true' when navigation succeeds,
         * - resolves to 'false' when navigation fails,
         * - is rejected when an error happens.
         *
         * @usageNotes
         *
         * ### Example
         *
         * ```
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
         *
         * // Navigate without updating the URL
         * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
         * ```
         *
         * The first parameter of `navigate()` is a delta to be applied to the current URL
         * or the one provided in the `relativeTo` property of the second parameter (the
         * `NavigationExtras`).
         */
        Router.prototype.navigate = function (commands, extras) {
            if (extras === void 0) {
                extras = { skipLocationChange: false };
            }
            validateCommands(commands);
            return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
        };
        /** Serializes a `UrlTree` into a string */
        Router.prototype.serializeUrl = function (url) {
            return this.urlSerializer.serialize(url);
        };
        /** Parses a string into a `UrlTree` */
        Router.prototype.parseUrl = function (url) {
            var urlTree;
            try {
                urlTree = this.urlSerializer.parse(url);
            } catch (e) {
                urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
            }
            return urlTree;
        };
        /** Returns whether the url is activated */
        Router.prototype.isActive = function (url, exact) {
            if (url instanceof UrlTree) {
                return containsTree(this.currentUrlTree, url, exact);
            }
            var urlTree = this.parseUrl(url);
            return containsTree(this.currentUrlTree, urlTree, exact);
        };
        Router.prototype.removeEmptyProps = function (params) {
            return Object.keys(params).reduce(function (result, key) {
                var value = params[key];
                if (value !== null && value !== undefined) {
                    result[key] = value;
                }
                return result;
            }, {});
        };
        Router.prototype.processNavigations = function () {
            var _this = this;
            this.navigations.pipe(concatMap(function (nav) {
                if (nav) {
                    _this.executeScheduledNavigation(nav);
                    // a failed navigation should not stop the router from processing
                    // further navigations => the catch
                    return nav.promise.catch(function () {});
                } else {
                    return of(null);
                }
            })).subscribe(function () {});
        };
        Router.prototype.scheduleNavigation = function (rawUrl, source, state, extras) {
            var lastNavigation = this.navigations.value;
            // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
            // and that navigation results in 'replaceState' that leads to the same URL,
            // we should skip those.
            if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a popstate was emitted first.
            if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            // Because of a bug in IE and Edge, the location class fires two events (popstate and
            // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
            // flicker. Handles the case when a hashchange was emitted first.
            if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' && lastNavigation.rawUrl.toString() === rawUrl.toString()) {
                return Promise.resolve(true); // return value is not used
            }
            var resolve = null;
            var reject = null;
            var promise = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });
            var id = ++this.navigationId;
            this.navigations.next({ id: id, source: source, state: state, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise });
            // Make sure that the error is propagated even though `processNavigations` catch
            // handler does not rethrow
            return promise.catch(function (e) {
                return Promise.reject(e);
            });
        };
        Router.prototype.executeScheduledNavigation = function (_a) {
            var _this = this;
            var id = _a.id,
                rawUrl = _a.rawUrl,
                extras = _a.extras,
                resolve = _a.resolve,
                reject = _a.reject,
                source = _a.source,
                state = _a.state;
            var url = this.urlHandlingStrategy.extract(rawUrl);
            var urlTransition = !this.navigated || url.toString() !== this.currentUrlTree.toString();
            if ((this.onSameUrlNavigation === 'reload' ? true : urlTransition) && this.urlHandlingStrategy.shouldProcessUrl(rawUrl)) {
                if (this.urlUpdateStrategy === 'eager' && !extras.skipLocationChange) {
                    this.setBrowserUrl(rawUrl, !!extras.replaceUrl, id);
                }
                this.events.next(new NavigationStart(id, this.serializeUrl(url), source, state));
                Promise.resolve().then(function (_) {
                    return _this.runNavigate(url, rawUrl, !!extras.skipLocationChange, !!extras.replaceUrl, id, null);
                }).then(resolve, reject);
                // we cannot process the current URL, but we could process the previous one =>
                // we need to do some cleanup
            } else if (urlTransition && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) {
                this.events.next(new NavigationStart(id, this.serializeUrl(url), source, state));
                Promise.resolve().then(function (_) {
                    return _this.runNavigate(url, rawUrl, false, false, id, createEmptyState(url, _this.rootComponentType).snapshot);
                }).then(resolve, reject);
            } else {
                this.rawUrlTree = rawUrl;
                resolve(null);
            }
        };
        Router.prototype.runNavigate = function (url, rawUrl, skipLocationChange, replaceUrl, id, precreatedState) {
            var _this = this;
            if (id !== this.navigationId) {
                this.events.next(new NavigationCancel(id, this.serializeUrl(url), "Navigation ID " + id + " is not equal to the current navigation id " + this.navigationId));
                return Promise.resolve(false);
            }
            return new Promise(function (resolvePromise, rejectPromise) {
                // create an observable of the url and route state snapshot
                // this operation do not result in any side effects
                var urlAndSnapshot$;
                if (!precreatedState) {
                    var moduleInjector = _this.ngModule.injector;
                    var redirectsApplied$ = applyRedirects(moduleInjector, _this.configLoader, _this.urlSerializer, url, _this.config);
                    urlAndSnapshot$ = redirectsApplied$.pipe(mergeMap(function (appliedUrl) {
                        return recognize(_this.rootComponentType, _this.config, appliedUrl, _this.serializeUrl(appliedUrl), _this.paramsInheritanceStrategy, _this.relativeLinkResolution).pipe(map(function (snapshot) {
                            _this.events.next(new RoutesRecognized(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));
                            return { appliedUrl: appliedUrl, snapshot: snapshot };
                        }));
                    }));
                } else {
                    urlAndSnapshot$ = of({ appliedUrl: url, snapshot: precreatedState });
                }
                var beforePreactivationDone$ = urlAndSnapshot$.pipe(mergeMap(function (p) {
                    if (typeof p === 'boolean') return of(p);
                    return _this.hooks.beforePreactivation(p.snapshot, {
                        navigationId: id,
                        appliedUrlTree: url,
                        rawUrlTree: rawUrl, skipLocationChange: skipLocationChange, replaceUrl: replaceUrl
                    }).pipe(map(function () {
                        return p;
                    }));
                }));
                // run preactivation: guards and data resolvers
                var preActivation;
                var preactivationSetup$ = beforePreactivationDone$.pipe(map(function (p) {
                    if (typeof p === 'boolean') return p;
                    var appliedUrl = p.appliedUrl,
                        snapshot = p.snapshot;
                    var moduleInjector = _this.ngModule.injector;
                    preActivation = new PreActivation(snapshot, _this.routerState.snapshot, moduleInjector, function (evt) {
                        return _this.triggerEvent(evt);
                    });
                    preActivation.initialize(_this.rootContexts);
                    return { appliedUrl: appliedUrl, snapshot: snapshot };
                }));
                var preactivationCheckGuards$ = preactivationSetup$.pipe(mergeMap(function (p) {
                    if (typeof p === 'boolean' || _this.navigationId !== id) return of(false);
                    var appliedUrl = p.appliedUrl,
                        snapshot = p.snapshot;
                    _this.triggerEvent(new GuardsCheckStart(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot));
                    return preActivation.checkGuards().pipe(map(function (shouldActivate) {
                        _this.triggerEvent(new GuardsCheckEnd(id, _this.serializeUrl(url), _this.serializeUrl(appliedUrl), snapshot, shouldActivate));
                        return { appliedUrl: appliedUrl, snapshot: snapshot, shouldActivate: shouldActivate };
                    }));
                }));
                var preactivationResolveData$ = preactivationCheckGuards$.pipe(mergeMap(function (p) {
                    if (typeof p === 'boolean' || _this.navigationId !== id) return of(false);
                    if (p.shouldActivate && preActivation.isActivating()) {
                        _this.triggerEvent(new ResolveStart(id, _this.serializeUrl(url), _this.serializeUrl(p.appliedUrl), p.snapshot));
                        return preActivation.resolveData(_this.paramsInheritanceStrategy).pipe(map(function () {
                            _this.triggerEvent(new ResolveEnd(id, _this.serializeUrl(url), _this.serializeUrl(p.appliedUrl), p.snapshot));
                            return p;
                        }));
                    } else {
                        return of(p);
                    }
                }));
                var preactivationDone$ = preactivationResolveData$.pipe(mergeMap(function (p) {
                    if (typeof p === 'boolean' || _this.navigationId !== id) return of(false);
                    return _this.hooks.afterPreactivation(p.snapshot, {
                        navigationId: id,
                        appliedUrlTree: url,
                        rawUrlTree: rawUrl, skipLocationChange: skipLocationChange, replaceUrl: replaceUrl
                    }).pipe(map(function () {
                        return p;
                    }));
                }));
                // create router state
                // this operation has side effects => route state is being affected
                var routerState$ = preactivationDone$.pipe(map(function (p) {
                    if (typeof p === 'boolean' || _this.navigationId !== id) return false;
                    var appliedUrl = p.appliedUrl,
                        snapshot = p.snapshot,
                        shouldActivate = p.shouldActivate;
                    if (shouldActivate) {
                        var state = createRouterState(_this.routeReuseStrategy, snapshot, _this.routerState);
                        return { appliedUrl: appliedUrl, state: state, shouldActivate: shouldActivate };
                    } else {
                        return { appliedUrl: appliedUrl, state: null, shouldActivate: shouldActivate };
                    }
                }));
                _this.activateRoutes(routerState$, _this.routerState, _this.currentUrlTree, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise);
            });
        };
        /**
         * Performs the logic of activating routes. This is a synchronous process by default. While this
         * is a private method, it could be overridden to make activation asynchronous.
         */
        Router.prototype.activateRoutes = function (state, storedState, storedUrl, id, url, rawUrl, skipLocationChange, replaceUrl, resolvePromise, rejectPromise) {
            var _this = this;
            // applied the new router state
            // this operation has side effects
            var navigationIsSuccessful;
            state.forEach(function (p) {
                if (typeof p === 'boolean' || !p.shouldActivate || id !== _this.navigationId || !p.state) {
                    navigationIsSuccessful = false;
                    return;
                }
                var appliedUrl = p.appliedUrl,
                    state = p.state;
                _this.currentUrlTree = appliedUrl;
                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, rawUrl);
                _this.routerState = state;
                if (_this.urlUpdateStrategy === 'deferred' && !skipLocationChange) {
                    _this.setBrowserUrl(_this.rawUrlTree, replaceUrl, id);
                }
                new ActivateRoutes(_this.routeReuseStrategy, state, storedState, function (evt) {
                    return _this.triggerEvent(evt);
                }).activate(_this.rootContexts);
                navigationIsSuccessful = true;
            }).then(function () {
                if (navigationIsSuccessful) {
                    _this.navigated = true;
                    _this.lastSuccessfulId = id;
                    _this.events.next(new NavigationEnd(id, _this.serializeUrl(url), _this.serializeUrl(_this.currentUrlTree)));
                    resolvePromise(true);
                } else {
                    _this.resetUrlToCurrentUrlTree();
                    _this.events.next(new NavigationCancel(id, _this.serializeUrl(url), ''));
                    resolvePromise(false);
                }
            }, function (e) {
                if (isNavigationCancelingError(e)) {
                    _this.navigated = true;
                    _this.resetStateAndUrl(storedState, storedUrl, rawUrl);
                    _this.events.next(new NavigationCancel(id, _this.serializeUrl(url), e.message));
                    resolvePromise(false);
                } else {
                    _this.resetStateAndUrl(storedState, storedUrl, rawUrl);
                    _this.events.next(new NavigationError(id, _this.serializeUrl(url), e));
                    try {
                        resolvePromise(_this.errorHandler(e));
                    } catch (ee) {
                        rejectPromise(ee);
                    }
                }
            });
        };
        Router.prototype.setBrowserUrl = function (url, replaceUrl, id) {
            var path = this.urlSerializer.serialize(url);
            if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
                this.location.replaceState(path, '', { navigationId: id });
            } else {
                this.location.go(path, '', { navigationId: id });
            }
        };
        Router.prototype.resetStateAndUrl = function (storedState, storedUrl, rawUrl) {
            this.routerState = storedState;
            this.currentUrlTree = storedUrl;
            this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
            this.resetUrlToCurrentUrlTree();
        };
        Router.prototype.resetUrlToCurrentUrlTree = function () {
            this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', { navigationId: this.lastSuccessfulId });
        };
        return Router;
    }();
    export { Router };
    var ActivateRoutes = /** @class */function () {
        function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {
            this.routeReuseStrategy = routeReuseStrategy;
            this.futureState = futureState;
            this.currState = currState;
            this.forwardEvent = forwardEvent;
        }
        ActivateRoutes.prototype.activate = function (parentContexts) {
            var futureRoot = this.futureState._root;
            var currRoot = this.currState ? this.currState._root : null;
            this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
            advanceActivatedRoute(this.futureState.root);
            this.activateChildRoutes(futureRoot, currRoot, parentContexts);
        };
        // De-activate the child route that are not re-used for the future state
        ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            // Recurse on the routes active in the future state to de-activate deeper children
            futureNode.children.forEach(function (futureChild) {
                var childOutletName = futureChild.value.outlet;
                _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
                delete children[childOutletName];
            });
            // De-activate the routes that will not be re-used
            forEach(children, function (v, childName) {
                _this.deactivateRouteAndItsChildren(v, contexts);
            });
        };
        ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            if (future === curr) {
                // Reusing the node, check to see if the children need to be de-activated
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContext.getContext(future.outlet);
                    if (context) {
                        this.deactivateChildRoutes(futureNode, currNode, context.children);
                    }
                } else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.deactivateChildRoutes(futureNode, currNode, parentContext);
                }
            } else {
                if (curr) {
                    // Deactivate the current route which will not be re-used
                    this.deactivateRouteAndItsChildren(currNode, parentContext);
                }
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
            if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
                this.detachAndStoreRouteSubtree(route, parentContexts);
            } else {
                this.deactivateRouteAndOutlet(route, parentContexts);
            }
        };
        ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
            var context = parentContexts.getContext(route.value.outlet);
            if (context && context.outlet) {
                var componentRef = context.outlet.detach();
                var contexts = context.children.onOutletDeactivated();
                this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
            }
        };
        ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
            var _this = this;
            var context = parentContexts.getContext(route.value.outlet);
            if (context) {
                var children = nodeChildrenAsMap(route);
                var contexts_1 = route.value.component ? context.children : parentContexts;
                forEach(children, function (v, k) {
                    return _this.deactivateRouteAndItsChildren(v, contexts_1);
                });
                if (context.outlet) {
                    // Destroy the component
                    context.outlet.deactivate();
                    // Destroy the contexts for all the outlets that were in the component
                    context.children.onOutletDeactivated();
                }
            }
        };
        ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
            var _this = this;
            var children = nodeChildrenAsMap(currNode);
            futureNode.children.forEach(function (c) {
                _this.activateRoutes(c, children[c.value.outlet], contexts);
                _this.forwardEvent(new ActivationEnd(c.value.snapshot));
            });
            if (futureNode.children.length) {
                this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
            }
        };
        ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
            var future = futureNode.value;
            var curr = currNode ? currNode.value : null;
            advanceActivatedRoute(future);
            // reusing the node
            if (future === curr) {
                if (future.component) {
                    // If we have a normal route, we need to go through an outlet.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    this.activateChildRoutes(futureNode, currNode, context.children);
                } else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, currNode, parentContexts);
                }
            } else {
                if (future.component) {
                    // if we have a normal route, we need to place the component into the outlet and recurse.
                    var context = parentContexts.getOrCreateContext(future.outlet);
                    if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                        var stored = this.routeReuseStrategy.retrieve(future.snapshot);
                        this.routeReuseStrategy.store(future.snapshot, null);
                        context.children.onOutletReAttached(stored.contexts);
                        context.attachRef = stored.componentRef;
                        context.route = stored.route.value;
                        if (context.outlet) {
                            // Attach right away when the outlet has already been instantiated
                            // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                            context.outlet.attach(stored.componentRef, stored.route.value);
                        }
                        advanceActivatedRouteNodeAndItsChildren(stored.route);
                    } else {
                        var config = parentLoadedConfig(future.snapshot);
                        var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                        context.attachRef = null;
                        context.route = future;
                        context.resolver = cmpFactoryResolver;
                        if (context.outlet) {
                            // Activate the outlet when it has already been instantiated
                            // Otherwise it will get activated from its `ngOnInit` when instantiated
                            context.outlet.activateWith(future, cmpFactoryResolver);
                        }
                        this.activateChildRoutes(futureNode, null, context.children);
                    }
                } else {
                    // if we have a componentless route, we recurse but keep the same outlet map.
                    this.activateChildRoutes(futureNode, null, parentContexts);
                }
            }
        };
        return ActivateRoutes;
    }();
    function advanceActivatedRouteNodeAndItsChildren(node) {
        advanceActivatedRoute(node.value);
        node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
    }
    function parentLoadedConfig(snapshot) {
        for (var s = snapshot.parent; s; s = s.parent) {
            var route = s.routeConfig;
            if (route && route._loadedConfig) return route._loadedConfig;
            if (route && route.component) return null;
        }
        return null;
    }
    function validateCommands(commands) {
        for (var i = 0; i < commands.length; i++) {
            var cmd = commands[i];
            if (cmd == null) {
                throw new Error("The requested path contains " + cmd + " segment at index " + i);
            }
        }
    }
});
//# sourceMappingURL=router.js.map