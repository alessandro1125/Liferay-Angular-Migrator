Liferay.Loader.define('@example-angular-liferay$angular/router@6.1.10/esm5/src/url_tree', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { PRIMARY_OUTLET, convertToParamMap } from './shared';
    import { forEach, shallowEqual } from './utils/collection';
    export function createEmptyUrlTree() {
        return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
    }
    export function containsTree(container, containee, exact) {
        if (exact) {
            return equalQueryParams(container.queryParams, containee.queryParams) && equalSegmentGroups(container.root, containee.root);
        }
        return containsQueryParams(container.queryParams, containee.queryParams) && containsSegmentGroup(container.root, containee.root);
    }
    function equalQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return shallowEqual(container, containee);
    }
    function equalSegmentGroups(container, containee) {
        if (!equalPath(container.segments, containee.segments)) return false;
        if (container.numberOfChildren !== containee.numberOfChildren) return false;
        for (var c in containee.children) {
            if (!container.children[c]) return false;
            if (!equalSegmentGroups(container.children[c], containee.children[c])) return false;
        }
        return true;
    }
    function containsQueryParams(container, containee) {
        // TODO: This does not handle array params correctly.
        return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every(function (key) {
            return containee[key] === container[key];
        });
    }
    function containsSegmentGroup(container, containee) {
        return containsSegmentGroupHelper(container, containee, containee.segments);
    }
    function containsSegmentGroupHelper(container, containee, containeePaths) {
        if (container.segments.length > containeePaths.length) {
            var current = container.segments.slice(0, containeePaths.length);
            if (!equalPath(current, containeePaths)) return false;
            if (containee.hasChildren()) return false;
            return true;
        } else if (container.segments.length === containeePaths.length) {
            if (!equalPath(container.segments, containeePaths)) return false;
            for (var c in containee.children) {
                if (!container.children[c]) return false;
                if (!containsSegmentGroup(container.children[c], containee.children[c])) return false;
            }
            return true;
        } else {
            var current = containeePaths.slice(0, container.segments.length);
            var next = containeePaths.slice(container.segments.length);
            if (!equalPath(container.segments, current)) return false;
            if (!container.children[PRIMARY_OUTLET]) return false;
            return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
        }
    }
    /**
     * @description
     *
     * Represents the parsed URL.
     *
     * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
     * serialized tree.
     * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree =
     *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
     *     const f = tree.fragment; // return 'fragment'
     *     const q = tree.queryParams; // returns {debug: 'true'}
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
     *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
     *     g.children['support'].segments; // return 1 segment 'help'
     *   }
     * }
     * ```
     *
     *
     */
    var UrlTree = /** @class */function () {
        /** @internal */
        function UrlTree(
        /** The root segment group of the URL tree */
        root,
        /** The query params of the URL */
        queryParams,
        /** The fragment of the URL */
        fragment) {
            this.root = root;
            this.queryParams = queryParams;
            this.fragment = fragment;
        }
        Object.defineProperty(UrlTree.prototype, "queryParamMap", {
            get: function () {
                if (!this._queryParamMap) {
                    this._queryParamMap = convertToParamMap(this.queryParams);
                }
                return this._queryParamMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlTree.prototype.toString = function () {
            return DEFAULT_SERIALIZER.serialize(this);
        };
        return UrlTree;
    }();
    export { UrlTree };
    /**
     * @description
     *
     * Represents the parsed URL segment group.
     *
     * See `UrlTree` for more information.
     *
     *
     */
    var UrlSegmentGroup = /** @class */function () {
        function UrlSegmentGroup(
        /** The URL segments of this group. See `UrlSegment` for more information */
        segments,
        /** The list of children of this group */
        children) {
            var _this = this;
            this.segments = segments;
            this.children = children;
            /** The parent node in the url tree */
            this.parent = null;
            forEach(children, function (v, k) {
                return v.parent = _this;
            });
        }
        /** Whether the segment has child segments */
        UrlSegmentGroup.prototype.hasChildren = function () {
            return this.numberOfChildren > 0;
        };
        Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
            /** Number of child segments */
            get: function () {
                return Object.keys(this.children).length;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegmentGroup.prototype.toString = function () {
            return serializePaths(this);
        };
        return UrlSegmentGroup;
    }();
    export { UrlSegmentGroup };
    /**
     * @description
     *
     * Represents a single URL segment.
     *
     * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
     * parameters associated with the segment.
     *
     * @usageNotes
     *Â ### Example
     *
     * ```
     * @Component({templateUrl:'template.html'})
     * class MyComponent {
     *   constructor(router: Router) {
     *     const tree: UrlTree = router.parseUrl('/team;id=33');
     *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
     *     const s: UrlSegment[] = g.segments;
     *     s[0].path; // returns 'team'
     *     s[0].parameters; // returns {id: 33}
     *   }
     * }
     * ```
     *
     *
     */
    var UrlSegment = /** @class */function () {
        function UrlSegment(
        /** The path part of a URL segment */
        path,
        /** The matrix parameters associated with a segment */
        parameters) {
            this.path = path;
            this.parameters = parameters;
        }
        Object.defineProperty(UrlSegment.prototype, "parameterMap", {
            get: function () {
                if (!this._parameterMap) {
                    this._parameterMap = convertToParamMap(this.parameters);
                }
                return this._parameterMap;
            },
            enumerable: true,
            configurable: true
        });
        /** @docsNotRequired */
        UrlSegment.prototype.toString = function () {
            return serializePath(this);
        };
        return UrlSegment;
    }();
    export { UrlSegment };
    export function equalSegments(as, bs) {
        return equalPath(as, bs) && as.every(function (a, i) {
            return shallowEqual(a.parameters, bs[i].parameters);
        });
    }
    export function equalPath(as, bs) {
        if (as.length !== bs.length) return false;
        return as.every(function (a, i) {
            return a.path === bs[i].path;
        });
    }
    export function mapChildrenIntoArray(segment, fn) {
        var res = [];
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet === PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        forEach(segment.children, function (child, childOutlet) {
            if (childOutlet !== PRIMARY_OUTLET) {
                res = res.concat(fn(child, childOutlet));
            }
        });
        return res;
    }
    /**
     * @description
     *
     * Serializes and deserializes a URL string into a URL tree.
     *
     * The url serialization strategy is customizable. You can
     * make all URLs case insensitive by providing a custom UrlSerializer.
     *
     * See `DefaultUrlSerializer` for an example of a URL serializer.
     *
     *
     */
    var UrlSerializer = /** @class */function () {
        function UrlSerializer() {}
        return UrlSerializer;
    }();
    export { UrlSerializer };
    /**
     * @description
     *
     * A default implementation of the `UrlSerializer`.
     *
     * Example URLs:
     *
     * ```
     * /inbox/33(popup:compose)
     * /inbox/33;open=true/messages/44
     * ```
     *
     * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
     * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
     * specify route specific parameters.
     *
     *
     */
    var DefaultUrlSerializer = /** @class */function () {
        function DefaultUrlSerializer() {}
        /** Parses a url into a `UrlTree` */
        DefaultUrlSerializer.prototype.parse = function (url) {
            var p = new UrlParser(url);
            return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
        };
        /** Converts a `UrlTree` into a url */
        DefaultUrlSerializer.prototype.serialize = function (tree) {
            var segment = "/" + serializeSegment(tree.root, true);
            var query = serializeQueryParams(tree.queryParams);
            var fragment = typeof tree.fragment === "string" ? "#" + encodeUriFragment(tree.fragment) : '';
            return "" + segment + query + fragment;
        };
        return DefaultUrlSerializer;
    }();
    export { DefaultUrlSerializer };
    var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
    export function serializePaths(segment) {
        return segment.segments.map(function (p) {
            return serializePath(p);
        }).join('/');
    }
    function serializeSegment(segment, root) {
        if (!segment.hasChildren()) {
            return serializePaths(segment);
        }
        if (root) {
            var primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : '';
            var children_1 = [];
            forEach(segment.children, function (v, k) {
                if (k !== PRIMARY_OUTLET) {
                    children_1.push(k + ":" + serializeSegment(v, false));
                }
            });
            return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
        } else {
            var children = mapChildrenIntoArray(segment, function (v, k) {
                if (k === PRIMARY_OUTLET) {
                    return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
                }
                return [k + ":" + serializeSegment(v, false)];
            });
            return serializePaths(segment) + "/(" + children.join('//') + ")";
        }
    }
    /**
     * Encodes a URI string with the default encoding. This function will only ever be called from
     * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need
     * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't
     * have to be encoded per https://url.spec.whatwg.org.
     */
    function encodeUriString(s) {
        return encodeURIComponent(s).replace(/%40/g, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',');
    }
    /**
     * This function should be used to encode both keys and values in a query string key/value. In
     * the following URL, you need to call encodeUriQuery on "k" and "v":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    export function encodeUriQuery(s) {
        return encodeUriString(s).replace(/%3B/gi, ';');
    }
    /**
     * This function should be used to encode a URL fragment. In the following URL, you need to call
     * encodeUriFragment on "f":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    export function encodeUriFragment(s) {
        return encodeURI(s);
    }
    /**
     * This function should be run on any URI segment as well as the key and value in a key/value
     * pair for matrix params. In the following URL, you need to call encodeUriSegment on "html",
     * "mk", and "mv":
     *
     * http://www.site.org/html;mk=mv?k=v#f
     */
    export function encodeUriSegment(s) {
        return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
    }
    export function decode(s) {
        return decodeURIComponent(s);
    }
    // Query keys/values should have the "+" replaced first, as "+" in a query string is " ".
    // decodeURIComponent function will not decode "+" as a space.
    export function decodeQuery(s) {
        return decode(s.replace(/\+/g, '%20'));
    }
    export function serializePath(path) {
        return "" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);
    }
    function serializeMatrixParams(params) {
        return Object.keys(params).map(function (key) {
            return ";" + encodeUriSegment(key) + "=" + encodeUriSegment(params[key]);
        }).join('');
    }
    function serializeQueryParams(params) {
        var strParams = Object.keys(params).map(function (name) {
            var value = params[name];
            return Array.isArray(value) ? value.map(function (v) {
                return encodeUriQuery(name) + "=" + encodeUriQuery(v);
            }).join('&') : encodeUriQuery(name) + "=" + encodeUriQuery(value);
        });
        return strParams.length ? "?" + strParams.join("&") : '';
    }
    var SEGMENT_RE = /^[^\/()?;=#]+/;
    function matchSegments(str) {
        var match = str.match(SEGMENT_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_RE = /^[^=?&#]+/;
    // Return the name of the query param at the start of the string or an empty string
    function matchQueryParams(str) {
        var match = str.match(QUERY_PARAM_RE);
        return match ? match[0] : '';
    }
    var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
    // Return the value of the query param at the start of the string or an empty string
    function matchUrlQueryParamValue(str) {
        var match = str.match(QUERY_PARAM_VALUE_RE);
        return match ? match[0] : '';
    }
    var UrlParser = /** @class */function () {
        function UrlParser(url) {
            this.url = url;
            this.remaining = url;
        }
        UrlParser.prototype.parseRootSegment = function () {
            this.consumeOptional('/');
            if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
                return new UrlSegmentGroup([], {});
            }
            // The root segment group never has segments
            return new UrlSegmentGroup([], this.parseChildren());
        };
        UrlParser.prototype.parseQueryParams = function () {
            var params = {};
            if (this.consumeOptional('?')) {
                do {
                    this.parseQueryParam(params);
                } while (this.consumeOptional('&'));
            }
            return params;
        };
        UrlParser.prototype.parseFragment = function () {
            return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
        };
        UrlParser.prototype.parseChildren = function () {
            if (this.remaining === '') {
                return {};
            }
            this.consumeOptional('/');
            var segments = [];
            if (!this.peekStartsWith('(')) {
                segments.push(this.parseSegment());
            }
            while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
                this.capture('/');
                segments.push(this.parseSegment());
            }
            var children = {};
            if (this.peekStartsWith('/(')) {
                this.capture('/');
                children = this.parseParens(true);
            }
            var res = {};
            if (this.peekStartsWith('(')) {
                res = this.parseParens(false);
            }
            if (segments.length > 0 || Object.keys(children).length > 0) {
                res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
            }
            return res;
        };
        // parse a segment with its matrix parameters
        // ie `name;k1=v1;k2`
        UrlParser.prototype.parseSegment = function () {
            var path = matchSegments(this.remaining);
            if (path === '' && this.peekStartsWith(';')) {
                throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
            }
            this.capture(path);
            return new UrlSegment(decode(path), this.parseMatrixParams());
        };
        UrlParser.prototype.parseMatrixParams = function () {
            var params = {};
            while (this.consumeOptional(';')) {
                this.parseParam(params);
            }
            return params;
        };
        UrlParser.prototype.parseParam = function (params) {
            var key = matchSegments(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchSegments(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            params[decode(key)] = decode(value);
        };
        // Parse a single query parameter `name[=value]`
        UrlParser.prototype.parseQueryParam = function (params) {
            var key = matchQueryParams(this.remaining);
            if (!key) {
                return;
            }
            this.capture(key);
            var value = '';
            if (this.consumeOptional('=')) {
                var valueMatch = matchUrlQueryParamValue(this.remaining);
                if (valueMatch) {
                    value = valueMatch;
                    this.capture(value);
                }
            }
            var decodedKey = decodeQuery(key);
            var decodedVal = decodeQuery(value);
            if (params.hasOwnProperty(decodedKey)) {
                // Append to existing values
                var currentVal = params[decodedKey];
                if (!Array.isArray(currentVal)) {
                    currentVal = [currentVal];
                    params[decodedKey] = currentVal;
                }
                currentVal.push(decodedVal);
            } else {
                // Create a new value
                params[decodedKey] = decodedVal;
            }
        };
        // parse `(a/b//outlet_name:c/d)`
        UrlParser.prototype.parseParens = function (allowPrimary) {
            var segments = {};
            this.capture('(');
            while (!this.consumeOptional(')') && this.remaining.length > 0) {
                var path = matchSegments(this.remaining);
                var next = this.remaining[path.length];
                // if is is not one of these characters, then the segment was unescaped
                // or the group was not closed
                if (next !== '/' && next !== ')' && next !== ';') {
                    throw new Error("Cannot parse url '" + this.url + "'");
                }
                var outletName = undefined;
                if (path.indexOf(':') > -1) {
                    outletName = path.substr(0, path.indexOf(':'));
                    this.capture(outletName);
                    this.capture(':');
                } else if (allowPrimary) {
                    outletName = PRIMARY_OUTLET;
                }
                var children = this.parseChildren();
                segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
                this.consumeOptional('//');
            }
            return segments;
        };
        UrlParser.prototype.peekStartsWith = function (str) {
            return this.remaining.startsWith(str);
        };
        // Consumes the prefix when it is present and returns whether it has been consumed
        UrlParser.prototype.consumeOptional = function (str) {
            if (this.peekStartsWith(str)) {
                this.remaining = this.remaining.substring(str.length);
                return true;
            }
            return false;
        };
        UrlParser.prototype.capture = function (str) {
            if (!this.consumeOptional(str)) {
                throw new Error("Expected \"" + str + "\".");
            }
        };
        return UrlParser;
    }();
});
//# sourceMappingURL=url_tree.js.map