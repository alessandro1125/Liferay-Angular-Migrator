{"version":3,"sources":["../../../../../../../../../packages/router/src/config.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, NgModuleRef, Type} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {EmptyOutletComponent} from './components/empty_outlet';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * @description\n *\n * Represents router configuration.\n *\n * `Routes` is an array of route configurations. Each one has the following properties:\n *\n * - `path` is a string that uses the route matcher DSL.\n * - `pathMatch` is a string that specifies the matching strategy.\n * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.\n * - `component` is a component type.\n * - `redirectTo` is the url fragment which will replace the current matched segment.\n * - `outlet` is the name of the outlet the component should be placed into.\n * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See\n *   `CanActivate` for more info.\n * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See\n *   `CanActivateChild` for more info.\n * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See\n *   `CanDeactivate` for more info.\n * - `canLoad` is an array of DI tokens used to look up CanLoad handlers. See\n *   `CanLoad` for more info.\n * - `data` is additional data provided to the component via `ActivatedRoute`.\n * - `resolve` is a map of DI tokens used to look up data resolvers. See `Resolve` for more\n *   info.\n * - `runGuardsAndResolvers` defines when guards and resolvers will be run. By default they run only\n *    when the matrix parameters of the route change. When set to `paramsOrQueryParamsChange` they\n *    will also run when query params change. And when set to `always`, they will run every time.\n * - `children` is an array of child route definitions.\n * - `loadChildren` is a reference to lazy loaded child routes. See `LoadChildren` for more\n *   info.\n *\n * @usageNotes\n * ### Simple Configuration\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/bob`, the router will create the team component with the user\n * component in it.\n *\n * ### Multiple Outlets\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to\n * the chat component. The chat component will be placed into the aux outlet.\n *\n * ### Wild Cards\n *\n * ```\n * [{\n *   path: '**',\n *   component: Sink\n * }]\n * ```\n *\n * Regardless of where you navigate to, the router will instantiate the sink component.\n *\n * ### Redirects\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to '/team/11/legacy/user/jim', the router will change the url to\n * '/team/11/user/jim', and then will instantiate the team component with the user component\n * in it.\n *\n * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the\n * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.\n *\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any url segments. Let's look at the following configuration:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11`, the router will instantiate the AllUsers component.\n *\n * Empty-path routes can have children.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with\n * the user component in it.\n *\n * An empty path route inherits its parent's params and data. This is because it cannot have its\n * own params, and, as a result, it often uses its parent's params and data as its own.\n *\n * ### Matching Strategy\n *\n * By default the router will look at what is left in the url, and check if it starts with\n * the specified path (e.g., `/team/11/user` starts with `team/:id`).\n *\n * We can change the matching strategy to make sure that the path covers the whole unconsumed url,\n * which is akin to `unconsumedUrl === path` or `$` regular expressions.\n *\n * This is particularly important when redirecting empty-path routes.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * Since an empty path is a prefix of any url, even when navigating to '/main', the router will\n * still apply the redirect.\n *\n * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to\n * '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * It is useful at times to have the ability to share parameters between sibling components.\n *\n * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\n * of them require some id parameter.\n *\n * One way to do that would be to have a bogus parent component, so both the siblings can get the id\n * parameter from it. This is not ideal. Instead, you can use a componentless route.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux\n * child components next to each other. In this example, the application component\n * has to have the primary and aux outlets defined.\n *\n * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into\n * the `params`, `data`, and `resolve` of the children. This is done because there is no component\n * that can inject the activated route of the componentless parent.\n *\n * This is especially useful when child components are defined as follows:\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * With this configuration in place, navigating to '/parent/10' will create the main child and aux\n * components.\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up our application load time by splitting it into multiple bundles, and\n * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of\n * providing the children property, you can provide the `loadChildren` property, as follows:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   loadChildren: 'team'\n * }]\n * ```\n *\n * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.\n * Then it will extract the set of routes defined in that NgModule, and will transparently add\n * those routes to the main configuration.\n *\n */\nexport type Routes = Route[];\n\n/**\n * @description Represents the results of the URL matching.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @experimental\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[]; posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * @description\n *\n * A function matching URLs\n *\n * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't\n * expressive enough.\n *\n * For instance, the following matcher matches html files.\n *\n * ```\n * export function htmlFiles(url: UrlSegment[]) {\n *   return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * export const routes = [{ matcher: htmlFiles, component: AnyComponent }];\n * ```\n *\n * @experimental\n */\nexport type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) =>\n    UrlMatchResult;\n\n/**\n * @description\n *\n * Represents the static data associated with a particular route.\n *\n * See `Routes` for more details.\n *\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n * @description\n *\n * Represents the resolved data associated with a particular route.\n *\n * See `Routes` for more details.\n *\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n * @description\n *\n * The type of `loadChildren`.\n *\n * See `Routes` for more details.\n *\n */\nexport type LoadChildrenCallback = () =>\n    Type<any>| NgModuleFactory<any>| Promise<Type<any>>| Observable<Type<any>>;\n\n/**\n * @description\n *\n * The type of `loadChildren`.\n *\n * See `Routes` for more details.\n *\n */\nexport type LoadChildren = string | LoadChildrenCallback;\n\n/**\n * @description\n *\n * The type of `queryParamsHandling`.\n *\n * See `RouterLink` for more details.\n *\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * @description\n *\n * The type of `runGuardsAndResolvers`.\n *\n * See `Routes` for more details.\n * @experimental\n */\nexport type RunGuardsAndResolvers = 'paramsChange' | 'paramsOrQueryParamsChange' | 'always';\n\n/**\n * See `Routes` for more details.\n *\n */\nexport interface Route {\n  path?: string;\n  pathMatch?: string;\n  matcher?: UrlMatcher;\n  component?: Type<any>;\n  redirectTo?: string;\n  outlet?: string;\n  canActivate?: any[];\n  canActivateChild?: any[];\n  canDeactivate?: any[];\n  canLoad?: any[];\n  data?: Data;\n  resolve?: ResolveData;\n  children?: Routes;\n  loadChildren?: LoadChildren;\n  runGuardsAndResolvers?: RunGuardsAndResolvers;\n  /**\n   * Filled for routes with `loadChildren` once the module has been loaded\n   * @internal\n   */\n  _loadedConfig?: LoadedRouterConfig;\n}\n\nexport class LoadedRouterConfig {\n  constructor(public routes: Route[], public module: NgModuleRef<any>) {}\n}\n\nexport function validateConfig(config: Routes, parentPath: string = ''): void {\n  // forEach doesn't iterate undefined values\n  for (let i = 0; i < config.length; i++) {\n    const route: Route = config[i];\n    const fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n\nfunction validateNode(route: Route, fullPath: string): void {\n  if (!route) {\n    throw new Error(`\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n  }\n  if (Array.isArray(route)) {\n    throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);\n  }\n  if (!route.component && !route.children && !route.loadChildren &&\n      (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n  }\n  if (route.redirectTo && route.children) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n  }\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n  }\n  if (route.children && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n  }\n  if (route.redirectTo && route.component) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`);\n  }\n  if (route.path && route.matcher) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n  }\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);\n  }\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n  }\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(`Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    const exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`);\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n\n/**\n * Makes a copy of the config and adds any default required properties.\n */\nexport function standardizeConfig(r: Route): Route {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? {...r, children} : {...r};\n  if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {\n    c.component = EmptyOutletComponent;\n  }\n  return c;\n}\n"],"sourceRoot":""}