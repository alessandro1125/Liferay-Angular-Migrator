{"version":3,"sources":["../../../../../../../packages/router/upgrade/src/upgrade.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,aAAQ,QAAR,QAAuB,iBAAvB;AACA,aAAQ,sBAAR,QAAmE,eAAnE;AACA,aAAQ,MAAR,QAAqB,iBAArB;AACA,aAAQ,aAAR,QAA4B,yBAA5B;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,WAAA,MAAa,2BAA2B;AACtC,iBAAS,sBAD6B;AAEtC,eAAO,IAF+B;AAGtC,oBAAU,gBAAE,6BAH0B;AAItC,cAAM,CAAC,aAAD;AAJgC,KAAxC;;;;;;AAUA,WAAM,SAAA,6BAAA,CAAwC,SAAxC,EAAgE;AACpE,eAAO,MAAK;AAAG,8BAAkB,SAAlB;AAA+B,SAA9C;AACD;;;;;;;;;;;;;AAYD,WAAM,SAAA,iBAAA,CAA4B,SAA5B,EAAoD;AACxD,YAAI,CAAC,UAAU,SAAf,EAA0B;AACxB,kBAAM,IAAI,KAAJ,CAAU;;;OAAV,CAAN;AAID;;AAED,cAAM,SAAiB,UAAU,QAAV,CAAmB,GAAnB,CAAuB,MAAvB,CAAvB;;AACA,cAAM,WAAqB,UAAU,QAAV,CAAmB,GAAnB,CAAuB,QAAvB,CAA3B;AAEA,kBAAU,SAAV,CAAoB,GAApB,CAAwB,YAAxB,EACK,GADL,CACS,sBADT,EACiC,CAAC,CAAD,EAAS,IAAT,EAAuB,EAAvB,KAAqC;;AAChE,kBAAM,MAAM,WAAW,IAAX,CAAZ;;AACA,kBAAM,OAAO,SAAS,SAAT,CAAmB,IAAI,QAAvB,CAAb;AACA,mBAAO,aAAP,CAAqB,OAAO,IAAI,MAAX,GAAoB,IAAI,IAA7C;AACD,SALL;AAMD;;;;;;;;;;;;;;;;;;;AAoBD,QAAI,MAAJ;;;;;AACA,aAAA,UAAA,CAAoB,GAApB,EAA+B;AAC7B,YAAI,CAAC,MAAL,EAAa;AACX,qBAAS,SAAS,aAAT,CAAuB,GAAvB,CAAT;AACD;AAED,eAAO,YAAP,CAAoB,MAApB,EAA4B,GAA5B;AACA,eAAO,YAAP,CAAoB,MAApB,EAA4B,OAAO,IAAnC;AAEA,eAAO;;AAEL,sBAAU,IAAI,OAAO,QAAP,CAAgB,OAAhB,CAAwB,KAAxB,EAA+B,EAA/B,CAAkC,EAF3C;AAGL,oBAAQ,OAAO,MAHV;AAIL,kBAAM,OAAO;AAJR,SAAP;AAMD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Location} from '@angular/common';\nimport {APP_BOOTSTRAP_LISTENER, ComponentRef, InjectionToken} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {UpgradeModule} from '@angular/upgrade/static';\n\n/**\n * @description\n *\n * Creates an initializer that in addition to setting up the Angular\n * router sets up the ngRoute integration.\n *\n * ```\n * @NgModule({\n *  imports: [\n *   RouterModule.forRoot(SOME_ROUTES),\n *   UpgradeModule\n * ],\n * providers: [\n *   RouterUpgradeInitializer\n * ]\n * })\n * export class AppModule {\n *   ngDoBootstrap() {}\n * }\n * ```\n *\n * @experimental\n */\nexport const RouterUpgradeInitializer = {\n  provide: APP_BOOTSTRAP_LISTENER,\n  multi: true,\n  useFactory: locationSyncBootstrapListener as(ngUpgrade: UpgradeModule) => () => void,\n  deps: [UpgradeModule]\n};\n\n/**\n * @internal\n */\nexport function locationSyncBootstrapListener(ngUpgrade: UpgradeModule) {\n  return () => { setUpLocationSync(ngUpgrade); };\n}\n\n/**\n * @description\n *\n * Sets up a location synchronization.\n *\n * History.pushState does not fire onPopState, so the Angular location\n * doesn't detect it. The workaround is to attach a location change listener\n *\n * @experimental\n */\nexport function setUpLocationSync(ngUpgrade: UpgradeModule) {\n  if (!ngUpgrade.$injector) {\n    throw new Error(`\n        RouterUpgradeInitializer can be used only after UpgradeModule.bootstrap has been called.\n        Remove RouterUpgradeInitializer and call setUpLocationSync after UpgradeModule.bootstrap.\n      `);\n  }\n\n  const router: Router = ngUpgrade.injector.get(Router);\n  const location: Location = ngUpgrade.injector.get(Location);\n\n  ngUpgrade.$injector.get('$rootScope')\n      .$on('$locationChangeStart', (_: any, next: string, __: string) => {\n        const url = resolveUrl(next);\n        const path = location.normalize(url.pathname);\n        router.navigateByUrl(path + url.search + url.hash);\n      });\n}\n\n/**\n * Normalize and parse a URL.\n *\n * - Normalizing means that a relative URL will be resolved into an absolute URL in the context of\n *   the application document.\n * - Parsing means that the anchor's `protocol`, `hostname`, `port`, `pathname` and related\n *   properties are all populated to reflect the normalized URL.\n *\n * While this approach has wide compatibility, it doesn't work as expected on IE. On IE, normalizing\n * happens similar to other browsers, but the parsed components will not be set. (E.g. if you assign\n * `a.href = 'foo'`, then `a.protocol`, `a.host`, etc. will not be correctly updated.)\n * We work around that by performing the parsing in a 2nd step by taking a previously normalized URL\n * and assigning it again. This correctly populates all properties.\n *\n * See\n * https://github.com/angular/angular.js/blob/2c7400e7d07b0f6cec1817dab40b9250ce8ebce6/src/ng/urlUtils.js#L26-L33\n * for more info.\n */\nlet anchor: HTMLAnchorElement|undefined;\nfunction resolveUrl(url: string): {pathname: string, search: string, hash: string} {\n  if (!anchor) {\n    anchor = document.createElement('a');\n  }\n\n  anchor.setAttribute('href', url);\n  anchor.setAttribute('href', anchor.href);\n\n  return {\n    // IE does not start `pathname` with `/` like other browsers.\n    pathname: `/${anchor.pathname.replace(/^\\//, '')}`,\n    search: anchor.search,\n    hash: anchor.hash\n  };\n}\n"],"sourceRoot":""}