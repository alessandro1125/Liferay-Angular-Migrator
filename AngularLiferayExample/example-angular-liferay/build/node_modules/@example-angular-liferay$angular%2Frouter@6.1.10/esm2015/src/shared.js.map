{"version":3,"sources":["../../../../../../packages/router/src/shared.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAmBA,SAAA,MAAa,iBAAiB,SAA9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,QAAA,WAAA,CAAA;;;;AAGE,gBAAY,MAAZ,EAA0B;AAAI,WAAK,MAAL,GAAc,UAAU,EAAxB;AAA6B;;;;;AAE3D,QAAI,IAAJ,EAAgB;AAAa,aAAO,KAAK,MAAL,CAAY,cAAZ,CAA2B,IAA3B,CAAP;AAA0C;;;;;AAEvE,QAAI,IAAJ,EAAgB;AACd,UAAI,KAAK,GAAL,CAAS,IAAT,CAAJ,EAAoB;;AAClB,cAAM,IAAI,KAAK,MAAL,CAAY,IAAZ,CAAV;AACA,eAAO,MAAM,OAAN,CAAc,CAAd,IAAmB,EAAE,CAAF,CAAnB,GAA0B,CAAjC;AACD;AAED,aAAO,IAAP;AACD;;;;;AAED,WAAO,IAAP,EAAmB;AACjB,UAAI,KAAK,GAAL,CAAS,IAAT,CAAJ,EAAoB;;AAClB,cAAM,IAAI,KAAK,MAAL,CAAY,IAAZ,CAAV;AACA,eAAO,MAAM,OAAN,CAAc,CAAd,IAAmB,CAAnB,GAAuB,CAAC,CAAD,CAA9B;AACD;AAED,aAAO,EAAP;AACD;;;;AAED,QAAI,IAAJ,GAAQ;AAAe,aAAO,OAAO,IAAP,CAAY,KAAK,MAAjB,CAAP;AAAkC;AAzB3D;;;;;;;;;;;;AAiCA,SAAM,SAAA,iBAAA,CAA4B,MAA5B,EAA0C;AAC9C,WAAO,IAAI,WAAJ,CAAgB,MAAhB,CAAP;AACD;;AAED,QAAM,6BAA6B,4BAAnC;;;;;AAEA,SAAM,SAAA,wBAAA,CAAmC,OAAnC,EAAkD;;AACtD,UAAM,QAAQ,MAAM,+BAA+B,OAArC,CAAd;AACA,oBAAC,KAAD,CAAe,0BAAf,IAA6C,IAA7C;AACA,WAAO,KAAP;AACD;;;;;AAED,SAAM,SAAA,0BAAA,CAAqC,KAArC,EAAiD;AACrD,WAAO,SAAS,gBAAC,KAAD,CAAe,0BAAf,CAAhB;AACD;;;;;;;AAGD,SAAM,SAAA,iBAAA,CACF,QADE,EACsB,YADtB,EACqD,KADrD,EACiE;;AACrE,UAAM,QAAK,gBAAG,MAAM,IAAT,CAAgB,KAAhB,CAAsB,GAAtB,CAAX;AAEA,QAAI,MAAM,MAAN,GAAe,SAAS,MAA5B,EAAoC;;AAElC,aAAO,IAAP;AACD;AAED,QAAI,MAAM,SAAN,KAAoB,MAApB,KACC,aAAa,WAAb,MAA8B,MAAM,MAAN,GAAe,SAAS,MADvD,CAAJ,EACoE;;AAElE,aAAO,IAAP;AACD;;AAED,UAAM,YAAyC,EAA/C;;AAGA,SAAK,IAAI,QAAQ,CAAjB,EAAoB,QAAQ,MAAM,MAAlC,EAA0C,OAA1C,EAAmD;;AACjD,YAAM,OAAO,MAAM,KAAN,CAAb;;AACA,YAAM,UAAU,SAAS,KAAT,CAAhB;;AACA,YAAM,cAAc,KAAK,UAAL,CAAgB,GAAhB,CAApB;AACA,UAAI,WAAJ,EAAiB;AACf,kBAAU,KAAK,SAAL,CAAe,CAAf,CAAV,IAA+B,OAA/B;AACD,OAFD,MAEO,IAAI,SAAS,QAAQ,IAArB,EAA2B;;AAEhC,eAAO,IAAP;AACD;AACF;AAED,WAAO,EAAC,UAAU,SAAS,KAAT,CAAe,CAAf,EAAkB,MAAM,MAAxB,CAAX,EAA4C,SAA5C,EAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './config';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n\n/**\n * @description\n *\n * Name of the primary outlet.\n *\n *\n */\nexport const PRIMARY_OUTLET = 'primary';\n\n/**\n * A collection of parameters.\n *\n *\n */\nexport type Params = {\n  [key: string]: any\n};\n\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n *\n */\nexport interface ParamMap {\n  has(name: string): boolean;\n  /**\n   * Return a single value for the given parameter name:\n   * - the value when the parameter has a single value,\n   * - the first value if the parameter has multiple values,\n   * - `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Return an array of values for the given parameter name.\n   *\n   * If there is no such parameter, an empty array is returned.\n   */\n  getAll(name: string): string[];\n\n  /** Name of the parameters */\n  readonly keys: string[];\n}\n\nclass ParamsAsMap implements ParamMap {\n  private params: Params;\n\n  constructor(params: Params) { this.params = params || {}; }\n\n  has(name: string): boolean { return this.params.hasOwnProperty(name); }\n\n  get(name: string): string|null {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n\n  getAll(name: string): string[] {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n\n  get keys(): string[] { return Object.keys(this.params); }\n}\n\n/**\n * Convert a `Params` instance to a `ParamMap`.\n *\n *\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\nconst NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n\nexport function navigationCancelingError(message: string) {\n  const error = Error('NavigationCancelingError: ' + message);\n  (error as any)[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n\nexport function isNavigationCancelingError(error: Error) {\n  return error && (error as any)[NAVIGATION_CANCELING_ERROR];\n}\n\n// Matches the route configuration (`route`) against the actual URL (`segments`).\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const parts = route.path !.split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n"],"sourceRoot":""}