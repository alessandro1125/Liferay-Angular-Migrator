{"version":3,"sources":["../../../../../../packages/router/src/apply_redirects.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModuleRef} from '@angular/core';\nimport {EmptyError, Observable, Observer, from, of } from 'rxjs';\nimport {catchError, concatAll, first, map, mergeMap} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, Route, Routes} from './config';\nimport {RouterConfigLoader} from './router_config_loader';\nimport {PRIMARY_OUTLET, Params, defaultUrlMatcher, navigationCancelingError} from './shared';\nimport {UrlSegment, UrlSegmentGroup, UrlSerializer, UrlTree} from './url_tree';\nimport {andObservables, forEach, waitForMap, wrapIntoObservable} from './utils/collection';\n\nclass NoMatch {\n  public segmentGroup: UrlSegmentGroup|null;\n\n  constructor(segmentGroup?: UrlSegmentGroup) { this.segmentGroup = segmentGroup || null; }\n}\n\nclass AbsoluteRedirect {\n  constructor(public urlTree: UrlTree) {}\n}\n\nfunction noMatch(segmentGroup: UrlSegmentGroup): Observable<UrlSegmentGroup> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new NoMatch(segmentGroup)));\n}\n\nfunction absoluteRedirect(newTree: UrlTree): Observable<any> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new AbsoluteRedirect(newTree)));\n}\n\nfunction namedOutletsRedirect(redirectTo: string): Observable<any> {\n  return new Observable<UrlSegmentGroup>(\n      (obs: Observer<UrlSegmentGroup>) => obs.error(new Error(\n          `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`)));\n}\n\nfunction canLoadFails(route: Route): Observable<LoadedRouterConfig> {\n  return new Observable<LoadedRouterConfig>(\n      (obs: Observer<LoadedRouterConfig>) => obs.error(navigationCancelingError(\n          `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`)));\n}\n\n/**\n * Returns the `UrlTree` with the redirection applied.\n *\n * Lazy modules are loaded along the way.\n */\nexport function applyRedirects(\n    moduleInjector: Injector, configLoader: RouterConfigLoader, urlSerializer: UrlSerializer,\n    urlTree: UrlTree, config: Routes): Observable<UrlTree> {\n  return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();\n}\n\nclass ApplyRedirects {\n  private allowRedirects: boolean = true;\n  private ngModule: NgModuleRef<any>;\n\n  constructor(\n      moduleInjector: Injector, private configLoader: RouterConfigLoader,\n      private urlSerializer: UrlSerializer, private urlTree: UrlTree, private config: Routes) {\n    this.ngModule = moduleInjector.get(NgModuleRef);\n  }\n\n  apply(): Observable<UrlTree> {\n    const expanded$ =\n        this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);\n    const urlTrees$ = expanded$.pipe(\n        map((rootSegmentGroup: UrlSegmentGroup) => this.createUrlTree(\n                rootSegmentGroup, this.urlTree.queryParams, this.urlTree.fragment !)));\n    return urlTrees$.pipe(catchError((e: any) => {\n      if (e instanceof AbsoluteRedirect) {\n        // after an absolute redirect we do not apply any more redirects!\n        this.allowRedirects = false;\n        // we need to run matching, so we can fetch all lazy-loaded modules\n        return this.match(e.urlTree);\n      }\n\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private match(tree: UrlTree): Observable<UrlTree> {\n    const expanded$ =\n        this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);\n    const mapped$ = expanded$.pipe(\n        map((rootSegmentGroup: UrlSegmentGroup) =>\n                this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment !)));\n    return mapped$.pipe(catchError((e: any): Observable<UrlTree> => {\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n\n      throw e;\n    }));\n  }\n\n  private noMatchError(e: NoMatch): any {\n    return new Error(`Cannot match any routes. URL Segment: '${e.segmentGroup}'`);\n  }\n\n  private createUrlTree(rootCandidate: UrlSegmentGroup, queryParams: Params, fragment: string):\n      UrlTree {\n    const root = rootCandidate.segments.length > 0 ?\n        new UrlSegmentGroup([], {[PRIMARY_OUTLET]: rootCandidate}) :\n        rootCandidate;\n    return new UrlTree(root, queryParams, fragment);\n  }\n\n  private expandSegmentGroup(\n      ngModule: NgModuleRef<any>, routes: Route[], segmentGroup: UrlSegmentGroup,\n      outlet: string): Observable<UrlSegmentGroup> {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.expandChildren(ngModule, routes, segmentGroup)\n          .pipe(map((children: any) => new UrlSegmentGroup([], children)));\n    }\n\n    return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);\n  }\n\n  // Recursively expand segment groups for all the child outlets\n  private expandChildren(\n      ngModule: NgModuleRef<any>, routes: Route[],\n      segmentGroup: UrlSegmentGroup): Observable<{[name: string]: UrlSegmentGroup}> {\n    return waitForMap(\n        segmentGroup.children,\n        (childOutlet, child) => this.expandSegmentGroup(ngModule, routes, child, childOutlet));\n  }\n\n  private expandSegment(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[],\n      segments: UrlSegment[], outlet: string,\n      allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    return of (...routes).pipe(\n        map((r: any) => {\n          const expanded$ = this.expandSegmentAgainstRoute(\n              ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);\n          return expanded$.pipe(catchError((e: any) => {\n            if (e instanceof NoMatch) {\n              // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -\n              // talk to Jason\n              return of (null) as any;\n            }\n            throw e;\n          }));\n        }),\n        concatAll(), first((s: any) => !!s), catchError((e: any, _: any) => {\n          if (e instanceof EmptyError || e.name === 'EmptyError') {\n            if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {\n              return of (new UrlSegmentGroup([], {}));\n            }\n            throw new NoMatch(segmentGroup);\n          }\n          throw e;\n        }));\n  }\n\n  private noLeftoversInUrl(segmentGroup: UrlSegmentGroup, segments: UrlSegment[], outlet: string):\n      boolean {\n    return segments.length === 0 && !segmentGroup.children[outlet];\n  }\n\n  private expandSegmentAgainstRoute(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      paths: UrlSegment[], outlet: string, allowRedirects: boolean): Observable<UrlSegmentGroup> {\n    if (getOutlet(route) !== outlet) {\n      return noMatch(segmentGroup);\n    }\n\n    if (route.redirectTo === undefined) {\n      return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);\n    }\n\n    if (allowRedirects && this.allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(\n          ngModule, segmentGroup, routes, route, paths, outlet);\n    }\n\n    return noMatch(segmentGroup);\n  }\n\n  private expandSegmentAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      return this.expandWildCardWithParamsAgainstRouteUsingRedirect(\n          ngModule, routes, route, outlet);\n    }\n\n    return this.expandRegularSegmentAgainstRouteUsingRedirect(\n        ngModule, segmentGroup, routes, route, segments, outlet);\n  }\n\n  private expandWildCardWithParamsAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, routes: Route[], route: Route,\n      outlet: string): Observable<UrlSegmentGroup> {\n    const newTree = this.applyRedirectCommands([], route.redirectTo !, {});\n    if (route.redirectTo !.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      const group = new UrlSegmentGroup(newSegments, {});\n      return this.expandSegment(ngModule, group, routes, newSegments, outlet, false);\n    }));\n  }\n\n  private expandRegularSegmentAgainstRouteUsingRedirect(\n      ngModule: NgModuleRef<any>, segmentGroup: UrlSegmentGroup, routes: Route[], route: Route,\n      segments: UrlSegment[], outlet: string): Observable<UrlSegmentGroup> {\n    const {matched, consumedSegments, lastChild, positionalParamSegments} =\n        match(segmentGroup, route, segments);\n    if (!matched) return noMatch(segmentGroup);\n\n    const newTree = this.applyRedirectCommands(\n        consumedSegments, route.redirectTo !, <any>positionalParamSegments);\n    if (route.redirectTo !.startsWith('/')) {\n      return absoluteRedirect(newTree);\n    }\n\n    return this.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments: UrlSegment[]) => {\n      return this.expandSegment(\n          ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet,\n          false);\n    }));\n  }\n\n  private matchSegmentAgainstRoute(\n      ngModule: NgModuleRef<any>, rawSegmentGroup: UrlSegmentGroup, route: Route,\n      segments: UrlSegment[]): Observable<UrlSegmentGroup> {\n    if (route.path === '**') {\n      if (route.loadChildren) {\n        return this.configLoader.load(ngModule.injector, route)\n            .pipe(map((cfg: LoadedRouterConfig) => {\n              route._loadedConfig = cfg;\n              return new UrlSegmentGroup(segments, {});\n            }));\n      }\n\n      return of (new UrlSegmentGroup(segments, {}));\n    }\n\n    const {matched, consumedSegments, lastChild} = match(rawSegmentGroup, route, segments);\n    if (!matched) return noMatch(rawSegmentGroup);\n\n    const rawSlicedSegments = segments.slice(lastChild);\n    const childConfig$ = this.getChildConfig(ngModule, route);\n\n    return childConfig$.pipe(mergeMap((routerConfig: LoadedRouterConfig) => {\n      const childModule = routerConfig.module;\n      const childConfig = routerConfig.routes;\n\n      const {segmentGroup, slicedSegments} =\n          split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig);\n\n      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n        const expanded$ = this.expandChildren(childModule, childConfig, segmentGroup);\n        return expanded$.pipe(\n            map((children: any) => new UrlSegmentGroup(consumedSegments, children)));\n      }\n\n      if (childConfig.length === 0 && slicedSegments.length === 0) {\n        return of (new UrlSegmentGroup(consumedSegments, {}));\n      }\n\n      const expanded$ = this.expandSegment(\n          childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);\n      return expanded$.pipe(\n          map((cs: UrlSegmentGroup) =>\n                  new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children)));\n    }));\n  }\n\n  private getChildConfig(ngModule: NgModuleRef<any>, route: Route): Observable<LoadedRouterConfig> {\n    if (route.children) {\n      // The children belong to the same module\n      return of (new LoadedRouterConfig(route.children, ngModule));\n    }\n\n    if (route.loadChildren) {\n      // lazy children belong to the loaded module\n      if (route._loadedConfig !== undefined) {\n        return of (route._loadedConfig);\n      }\n\n      return runCanLoadGuard(ngModule.injector, route).pipe(mergeMap((shouldLoad: boolean) => {\n        if (shouldLoad) {\n          return this.configLoader.load(ngModule.injector, route)\n              .pipe(map((cfg: LoadedRouterConfig) => {\n                route._loadedConfig = cfg;\n                return cfg;\n              }));\n        }\n        return canLoadFails(route);\n      }));\n    }\n\n    return of (new LoadedRouterConfig([], ngModule));\n  }\n\n  private lineralizeSegments(route: Route, urlTree: UrlTree): Observable<UrlSegment[]> {\n    let res: UrlSegment[] = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of (res);\n      }\n\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(route.redirectTo !);\n      }\n\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n\n  private applyRedirectCommands(\n      segments: UrlSegment[], redirectTo: string, posParams: {[k: string]: UrlSegment}): UrlTree {\n    return this.applyRedirectCreatreUrlTree(\n        redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n  }\n\n  private applyRedirectCreatreUrlTree(\n      redirectTo: string, urlTree: UrlTree, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlTree {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(\n        newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams),\n        urlTree.fragment);\n  }\n\n  private createQueryParams(redirectToParams: Params, actualParams: Params): Params {\n    const res: Params = {};\n    forEach(redirectToParams, (v: any, k: string) => {\n      const copySourceValue = typeof v === 'string' && v.startsWith(':');\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n\n  private createSegmentGroup(\n      redirectTo: string, group: UrlSegmentGroup, segments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegmentGroup {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n\n    let children: {[n: string]: UrlSegmentGroup} = {};\n    forEach(group.children, (child: UrlSegmentGroup, name: string) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n\n  private createSegments(\n      redirectTo: string, redirectToSegments: UrlSegment[], actualSegments: UrlSegment[],\n      posParams: {[k: string]: UrlSegment}): UrlSegment[] {\n    return redirectToSegments.map(\n        s => s.path.startsWith(':') ? this.findPosParam(redirectTo, s, posParams) :\n                                      this.findOrReturn(s, actualSegments));\n  }\n\n  private findPosParam(\n      redirectTo: string, redirectToUrlSegment: UrlSegment,\n      posParams: {[k: string]: UrlSegment}): UrlSegment {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos)\n      throw new Error(\n          `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n\n  private findOrReturn(redirectToUrlSegment: UrlSegment, actualSegments: UrlSegment[]): UrlSegment {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n}\n\nfunction runCanLoadGuard(moduleInjector: Injector, route: Route): Observable<boolean> {\n  const canLoad = route.canLoad;\n  if (!canLoad || canLoad.length === 0) return of (true);\n\n  const obs = from(canLoad).pipe(map((injectionToken: any) => {\n    const guard = moduleInjector.get(injectionToken);\n    return wrapIntoObservable(guard.canLoad ? guard.canLoad(route) : guard(route));\n  }));\n\n  return andObservables(obs);\n}\n\nfunction match(segmentGroup: UrlSegmentGroup, route: Route, segments: UrlSegment[]): {\n  matched: boolean,\n  consumedSegments: UrlSegment[],\n  lastChild: number,\n  positionalParamSegments: {[k: string]: UrlSegment}\n} {\n  if (route.path === '') {\n    if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return {matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n    }\n\n    return {matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {}};\n  }\n\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n\n  if (!res) {\n    return {\n      matched: false,\n      consumedSegments: <any[]>[],\n      lastChild: 0,\n      positionalParamSegments: {},\n    };\n  }\n\n  return {\n    matched: true,\n    consumedSegments: res.consumed !,\n    lastChild: res.consumed.length !,\n    positionalParamSegments: res.posParams !,\n  };\n}\n\nfunction split(\n    segmentGroup: UrlSegmentGroup, consumedSegments: UrlSegment[], slicedSegments: UrlSegment[],\n    config: Route[]) {\n  if (slicedSegments.length > 0 &&\n      containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        consumedSegments, createChildrenForEmptySegments(\n                              config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {segmentGroup: mergeTrivialChildren(s), slicedSegments: []};\n  }\n\n  if (slicedSegments.length === 0 &&\n      containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {\n    const s = new UrlSegmentGroup(\n        segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(\n                                   segmentGroup, slicedSegments, config, segmentGroup.children));\n    return {segmentGroup: mergeTrivialChildren(s), slicedSegments};\n  }\n\n  return {segmentGroup, slicedSegments};\n}\n\nfunction mergeTrivialChildren(s: UrlSegmentGroup): UrlSegmentGroup {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n\n  return s;\n}\n\nfunction addEmptySegmentsToChildrenIfNeeded(\n    segmentGroup: UrlSegmentGroup, slicedSegments: UrlSegment[], routes: Route[],\n    children: {[name: string]: UrlSegmentGroup}): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  for (const r of routes) {\n    if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n    }\n  }\n  return {...children, ...res};\n}\n\nfunction createChildrenForEmptySegments(\n    routes: Route[], primarySegmentGroup: UrlSegmentGroup): {[name: string]: UrlSegmentGroup} {\n  const res: {[name: string]: UrlSegmentGroup} = {};\n  res[PRIMARY_OUTLET] = primarySegmentGroup;\n  for (const r of routes) {\n    if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {\n      res[getOutlet(r)] = new UrlSegmentGroup([], {});\n    }\n  }\n  return res;\n}\n\nfunction containsEmptyPathRedirectsWithNamedOutlets(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(\n      r => isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\n\nfunction containsEmptyPathRedirects(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], routes: Route[]): boolean {\n  return routes.some(r => isEmptyPathRedirect(segmentGroup, segments, r));\n}\n\nfunction isEmptyPathRedirect(\n    segmentGroup: UrlSegmentGroup, segments: UrlSegment[], r: Route): boolean {\n  if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {\n    return false;\n  }\n\n  return r.path === '' && r.redirectTo !== undefined;\n}\n\nfunction getOutlet(route: Route): string {\n  return route.outlet || PRIMARY_OUTLET;\n}\n"],"sourceRoot":""}