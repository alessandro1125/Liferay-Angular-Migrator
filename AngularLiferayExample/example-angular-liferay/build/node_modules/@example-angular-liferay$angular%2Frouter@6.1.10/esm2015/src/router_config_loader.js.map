{"version":3,"sources":["../../../../../../packages/router/src/router_config_loader.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,aAAkB,cAAlB,EAA4C,eAA5C,QAAyF,eAAzF;AAEA,aAAoB,IAApB,EAA0B,EAA1B,QAAoC,MAApC;AACA,aAAQ,GAAR,EAAa,QAAb,QAA4B,gBAA5B;AACA,aAAsB,kBAAtB,EAAiD,iBAAjD,QAAyE,UAAzE;AACA,aAAQ,OAAR,EAAiB,kBAAjB,QAA0C,oBAA1C;;;;;AAMA,WAAA,MAAa,SAAS,IAAI,cAAJ,CAA8B,QAA9B,CAAtB;AAEA,WAAM,MAAA,kBAAA,CAAA;;;;;;;AACJ,oBACY,MADZ,EACmD,QADnD,EAEY,mBAFZ,EAGY,iBAHZ,EAGY;AAFA,iBAAA,MAAA,GAAA,MAAA;AAAuC,iBAAA,QAAA,GAAA,QAAA;AACvC,iBAAA,mBAAA,GAAA,mBAAA;AACA,iBAAA,iBAAA,GAAA,iBAAA;AAA0C;;;;;;AAEtD,aAAK,cAAL,EAA+B,KAA/B,EAA2C;AACzC,gBAAI,KAAK,mBAAT,EAA8B;AAC5B,qBAAK,mBAAL,CAAyB,KAAzB;AACD;;AAED,kBAAM,iBAAiB,KAAK,iBAAL,EAAsB,gBAAC,MAAM,YAA7B,CAAvB;AAEA,mBAAO,eAAe,IAAf,CAAoB,IAAK,OAAD,IAAkC;AAC/D,oBAAI,KAAK,iBAAT,EAA4B;AAC1B,yBAAK,iBAAL,CAAuB,KAAvB;AACD;;AAED,sBAAM,SAAS,QAAQ,MAAR,CAAe,cAAf,CAAf;AAEA,uBAAO,IAAI,kBAAJ,CACH,QAAQ,OAAO,QAAP,CAAgB,GAAhB,CAAoB,MAApB,CAAR,EAAqC,GAArC,CAAyC,iBAAzC,CADG,EAC0D,MAD1D,CAAP;AAED,aAT0B,CAApB,CAAP;AAUD;;;;;AAEO,0BAAkB,YAAlB,EAA4C;AAClD,gBAAI,OAAO,YAAP,KAAwB,QAA5B,EAAsC;AACpC,uBAAO,KAAK,KAAK,MAAL,CAAY,IAAZ,CAAiB,YAAjB,CAAL,CAAP;AACD,aAFD,MAEO;AACL,uBAAO,mBAAmB,cAAnB,EAAmC,IAAnC,CAAwC,SAAU,CAAD,IAAW;AACjE,wBAAI,aAAa,eAAjB,EAAkC;AAChC,+BAAO,GAAI,CAAJ,CAAP;AACD,qBAFD,MAEO;AACL,+BAAO,KAAK,KAAK,QAAL,CAAc,kBAAd,CAAiC,CAAjC,CAAL,CAAP;AACD;AACF,iBAN8C,CAAxC,CAAP;AAOD;;AApCC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, InjectionToken, Injector, NgModuleFactory, NgModuleFactoryLoader} from '@angular/core';\n// TODO(i): switch to fromPromise once it's expored in rxjs\nimport {Observable, from, of } from 'rxjs';\nimport {map, mergeMap} from 'rxjs/operators';\nimport {LoadChildren, LoadedRouterConfig, Route, standardizeConfig} from './config';\nimport {flatten, wrapIntoObservable} from './utils/collection';\n\n/**\n * @docsNotRequired\n * @experimental\n */\nexport const ROUTES = new InjectionToken<Route[][]>('ROUTES');\n\nexport class RouterConfigLoader {\n  constructor(\n      private loader: NgModuleFactoryLoader, private compiler: Compiler,\n      private onLoadStartListener?: (r: Route) => void,\n      private onLoadEndListener?: (r: Route) => void) {}\n\n  load(parentInjector: Injector, route: Route): Observable<LoadedRouterConfig> {\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n\n    const moduleFactory$ = this.loadModuleFactory(route.loadChildren !);\n\n    return moduleFactory$.pipe(map((factory: NgModuleFactory<any>) => {\n      if (this.onLoadEndListener) {\n        this.onLoadEndListener(route);\n      }\n\n      const module = factory.create(parentInjector);\n\n      return new LoadedRouterConfig(\n          flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);\n    }));\n  }\n\n  private loadModuleFactory(loadChildren: LoadChildren): Observable<NgModuleFactory<any>> {\n    if (typeof loadChildren === 'string') {\n      return from(this.loader.load(loadChildren));\n    } else {\n      return wrapIntoObservable(loadChildren()).pipe(mergeMap((t: any) => {\n        if (t instanceof NgModuleFactory) {\n          return of (t);\n        } else {\n          return from(this.compiler.compileModuleAsync(t));\n        }\n      }));\n    }\n  }\n}\n"],"sourceRoot":""}