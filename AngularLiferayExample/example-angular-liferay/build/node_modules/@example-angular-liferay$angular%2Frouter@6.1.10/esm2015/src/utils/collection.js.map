{"version":3,"sources":["../../../../../../../packages/router/src/utils/collection.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatAll, every, last as lastValue, map, mergeAll} from 'rxjs/operators';\n\nimport {PRIMARY_OUTLET} from '../shared';\n\nexport function shallowEqualArrays(a: any[], b: any[]): boolean {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\n\nexport function shallowEqual(a: {[x: string]: any}, b: {[x: string]: any}): boolean {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) {\n    return false;\n  }\n  let key: string;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (a[key] !== b[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Flattens single-level nested arrays.\n */\nexport function flatten<T>(arr: T[][]): T[] {\n  return Array.prototype.concat.apply([], arr);\n}\n\n/**\n * Return the last element of an array.\n */\nexport function last<T>(a: T[]): T|null {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\n\n/**\n * Verifys all booleans in an array are `true`.\n */\nexport function and(bools: boolean[]): boolean {\n  return !bools.some(v => !v);\n}\n\nexport function forEach<K, V>(map: {[key: string]: V}, callback: (v: V, k: string) => void): void {\n  for (const prop in map) {\n    if (map.hasOwnProperty(prop)) {\n      callback(map[prop], prop);\n    }\n  }\n}\n\nexport function waitForMap<A, B>(\n    obj: {[k: string]: A}, fn: (k: string, a: A) => Observable<B>): Observable<{[k: string]: B}> {\n  if (Object.keys(obj).length === 0) {\n    return of ({});\n  }\n\n  const waitHead: Observable<B>[] = [];\n  const waitTail: Observable<B>[] = [];\n  const res: {[k: string]: B} = {};\n\n  forEach(obj, (a: A, k: string) => {\n    const mapped = fn(k, a).pipe(map((r: B) => res[k] = r));\n    if (k === PRIMARY_OUTLET) {\n      waitHead.push(mapped);\n    } else {\n      waitTail.push(mapped);\n    }\n  });\n\n  // Closure compiler has problem with using spread operator here. So just using Array.concat.\n  return of .apply(null, waitHead.concat(waitTail)).pipe(concatAll(), lastValue(), map(() => res));\n}\n\n/**\n * ANDs Observables by merging all input observables, reducing to an Observable verifying all\n * input Observables return `true`.\n */\nexport function andObservables(observables: Observable<Observable<any>>): Observable<boolean> {\n  return observables.pipe(mergeAll(), every((result: any) => result === true));\n}\n\nexport function wrapIntoObservable<T>(value: T | NgModuleFactory<T>| Promise<T>| Observable<T>):\n    Observable<T> {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of (value as T);\n}\n"],"sourceRoot":""}