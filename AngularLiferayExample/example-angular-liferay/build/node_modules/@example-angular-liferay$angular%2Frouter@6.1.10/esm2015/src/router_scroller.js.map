{"version":3,"sources":["../../../../../../packages/router/src/router_scroller.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAYA,aAAQ,aAAR,EAAuB,eAAvB,EAAwC,MAAxC,QAAqD,UAArD;AAGA,WAAM,MAAA,cAAA,CAAA;;;;;;AAWJ,oBACY,MADZ,EAE4C,gBAF5C,EAEwF,UAGhF,EALR,EAKU;AAJE,iBAAA,MAAA,GAAA,MAAA;AACgC,iBAAA,gBAAA,GAAA,gBAAA;AAA4C,iBAAA,OAAA,GAAA,OAAA;0BAPvE,C;8BACoD,Y;8BAChD,C;yBAC8B,E;;AASjD,oBAAQ,yBAAR,GAAoC,QAAQ,yBAAR,IAAqC,UAAzE;AACA,oBAAQ,eAAR,GAA0B,QAAQ,eAAR,IAA2B,UAArD;AACD;;;;AAED,eAAI;;;;AAIF,gBAAI,KAAK,OAAL,CAAa,yBAAb,KAA2C,UAA/C,EAA2D;AACzD,qBAAK,gBAAL,CAAsB,2BAAtB,CAAkD,QAAlD;AACD;AACD,iBAAK,wBAAL,GAAgC,KAAK,kBAAL,EAAhC;AACA,iBAAK,wBAAL,GAAgC,KAAK,mBAAL,EAAhC;AACD;;;;AAEO,6BAAkB;AACxB,mBAAO,KAAK,MAAL,CAAY,MAAZ,CAAmB,SAAnB,CAA6B,KAAI;AACtC,oBAAI,aAAa,eAAjB,EAAkC;;AAEhC,yBAAK,KAAL,CAAW,KAAK,MAAhB,IAA0B,KAAK,gBAAL,CAAsB,iBAAtB,EAA1B;AACA,yBAAK,UAAL,GAAkB,EAAE,iBAApB;AACA,yBAAK,UAAL,GAAkB,EAAE,aAAF,GAAkB,EAAE,aAAF,CAAgB,YAAlC,GAAiD,CAAnE;AACD,iBALD,MAKO,IAAI,aAAa,aAAjB,EAAgC;AACrC,yBAAK,MAAL,GAAc,EAAE,EAAhB;AACA,yBAAK,mBAAL,CAAyB,CAAzB,EAA4B,KAAK,MAAL,CAAY,QAAZ,CAAqB,EAAE,iBAAvB,EAA0C,QAAtE;AACD;AACF,aAVM,CAAP;;;;;AAaM,8BAAmB;AACzB,mBAAO,KAAK,MAAL,CAAY,MAAZ,CAAmB,SAAnB,CAA6B,KAAI;AACtC,oBAAI,EAAE,aAAa,MAAf,CAAJ,EAA4B;;AAE5B,oBAAI,EAAE,QAAN,EAAgB;AACd,wBAAI,KAAK,OAAL,CAAa,yBAAb,KAA2C,KAA/C,EAAsD;AACpD,6BAAK,gBAAL,CAAsB,gBAAtB,CAAuC,CAAC,CAAD,EAAI,CAAJ,CAAvC;AACD,qBAFD,MAEO,IAAI,KAAK,OAAL,CAAa,yBAAb,KAA2C,SAA/C,EAA0D;AAC/D,6BAAK,gBAAL,CAAsB,gBAAtB,CAAuC,EAAE,QAAzC;AACD;;AAEF,iBAPD,MAOO;AACL,wBAAI,EAAE,MAAF,IAAY,KAAK,OAAL,CAAa,eAAb,KAAiC,SAAjD,EAA4D;AAC1D,6BAAK,gBAAL,CAAsB,cAAtB,CAAqC,EAAE,MAAvC;AACD,qBAFD,MAEO,IAAI,KAAK,OAAL,CAAa,yBAAb,KAA2C,UAA/C,EAA2D;AAChE,6BAAK,gBAAL,CAAsB,gBAAtB,CAAuC,CAAC,CAAD,EAAI,CAAJ,CAAvC;AACD;AACF;AACF,aAjBM,CAAP;;;;;;;AAoBM,4BAAoB,WAApB,EAAgD,MAAhD,EAAmE;AACzE,iBAAK,MAAL,CAAY,YAAZ,CAAyB,IAAI,MAAJ,CACrB,WADqB,EACR,KAAK,UAAL,KAAoB,UAApB,GAAiC,KAAK,KAAL,CAAW,KAAK,UAAhB,CAAjC,GAA+D,IADvD,EAC6D,MAD7D,CAAzB;;;;;AAIF,sBAAW;AACT,gBAAI,KAAK,wBAAT,EAAmC;AACjC,qBAAK,wBAAL,CAA8B,WAA9B;AACD;AACD,gBAAI,KAAK,wBAAT,EAAmC;AACjC,qBAAK,wBAAL,CAA8B,WAA9B;AACD;AACF;AAhFG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewportScroller} from '@angular/common';\nimport {OnDestroy} from '@angular/core';\nimport {Unsubscribable} from 'rxjs';\n\nimport {NavigationEnd, NavigationStart, Scroll} from './events';\nimport {Router} from './router';\n\nexport class RouterScroller implements OnDestroy {\n  // TODO(issue/24571): remove '!'.\n  private routerEventsSubscription !: Unsubscribable;\n  // TODO(issue/24571): remove '!'.\n  private scrollEventsSubscription !: Unsubscribable;\n\n  private lastId = 0;\n  private lastSource: 'imperative'|'popstate'|'hashchange'|undefined = 'imperative';\n  private restoredId = 0;\n  private store: {[key: string]: [number, number]} = {};\n\n  constructor(\n      private router: Router,\n      /** @docsNotRequired */ public readonly viewportScroller: ViewportScroller, private options: {\n        scrollPositionRestoration?: 'disabled' | 'enabled' | 'top',\n        anchorScrolling?: 'disabled'|'enabled'\n      } = {}) {\n    // Default both options to 'disabled'\n    options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';\n    options.anchorScrolling = options.anchorScrolling || 'disabled';\n  }\n\n  init(): void {\n    // we want to disable the automatic scrolling because having two places\n    // responsible for scrolling results race conditions, especially given\n    // that browser don't implement this behavior consistently\n    if (this.options.scrollPositionRestoration !== 'disabled') {\n      this.viewportScroller.setHistoryScrollRestoration('manual');\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n\n  private createScrollEvents() {\n    return this.router.events.subscribe(e => {\n      if (e instanceof NavigationStart) {\n        // store the scroll position of the current stable navigations.\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.router.parseUrl(e.urlAfterRedirects).fragment);\n      }\n    });\n  }\n\n  private consumeScrollEvents() {\n    return this.router.events.subscribe(e => {\n      if (!(e instanceof Scroll)) return;\n      // a popstate event. The pop state event will always ignore anchor scrolling.\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === 'top') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === 'enabled') {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n        // imperative navigation \"forward\"\n      } else {\n        if (e.anchor && this.options.anchorScrolling === 'enabled') {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== 'disabled') {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n\n  private scheduleScrollEvent(routerEvent: NavigationEnd, anchor: string|null): void {\n    this.router.triggerEvent(new Scroll(\n        routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));\n  }\n\n  ngOnDestroy() {\n    if (this.routerEventsSubscription) {\n      this.routerEventsSubscription.unsubscribe();\n    }\n    if (this.scrollEventsSubscription) {\n      this.scrollEventsSubscription.unsubscribe();\n    }\n  }\n}\n"],"sourceRoot":""}