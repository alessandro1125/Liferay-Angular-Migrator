{"version":3,"sources":["../../../../../../packages/router/src/pre_activation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '@angular/core';\nimport {Observable, from, of } from 'rxjs';\nimport {concatMap, every, first, last, map, mergeMap, reduce} from 'rxjs/operators';\n\nimport {LoadedRouterConfig, ResolveData, RunGuardsAndResolvers} from './config';\nimport {ActivationStart, ChildActivationStart, Event} from './events';\nimport {ChildrenOutletContexts, OutletContext} from './router_outlet_context';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot, equalParamsAndUrlSegments, inheritedParamsDataResolve} from './router_state';\nimport {andObservables, forEach, shallowEqual, wrapIntoObservable} from './utils/collection';\nimport {TreeNode, nodeChildrenAsMap} from './utils/tree';\n\nclass CanActivate {\n  readonly route: ActivatedRouteSnapshot;\n  constructor(public path: ActivatedRouteSnapshot[]) {\n    this.route = this.path[this.path.length - 1];\n  }\n}\n\nclass CanDeactivate {\n  constructor(public component: Object|null, public route: ActivatedRouteSnapshot) {}\n}\n\n/**\n * This class bundles the actions involved in preactivation of a route.\n */\nexport class PreActivation {\n  private canActivateChecks: CanActivate[] = [];\n  private canDeactivateChecks: CanDeactivate[] = [];\n\n  constructor(\n      private future: RouterStateSnapshot, private curr: RouterStateSnapshot,\n      private moduleInjector: Injector, private forwardEvent?: (evt: Event) => void) {}\n\n  initialize(parentContexts: ChildrenOutletContexts): void {\n    const futureRoot = this.future._root;\n    const currRoot = this.curr ? this.curr._root : null;\n    this.setupChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n  }\n\n  checkGuards(): Observable<boolean> {\n    if (!this.isDeactivating() && !this.isActivating()) {\n      return of (true);\n    }\n    const canDeactivate$ = this.runCanDeactivateChecks();\n    return canDeactivate$.pipe(mergeMap(\n        (canDeactivate: boolean) => canDeactivate ? this.runCanActivateChecks() : of (false)));\n  }\n\n  resolveData(paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    if (!this.isActivating()) return of (null);\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap(\n                (check: CanActivate) => this.runResolve(check.route, paramsInheritanceStrategy)),\n            reduce((_: any, __: any) => _));\n  }\n\n  isDeactivating(): boolean { return this.canDeactivateChecks.length !== 0; }\n\n  isActivating(): boolean { return this.canActivateChecks.length !== 0; }\n\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupChildRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>|null,\n      contexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const prevChildren = nodeChildrenAsMap(currNode);\n\n    // Process the children of the future route\n    futureNode.children.forEach(c => {\n      this.setupRouteGuards(\n          c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]));\n      delete prevChildren[c.value.outlet];\n    });\n\n    // Process any children left from the current route (not active for the future route)\n    forEach(\n        prevChildren, (v: TreeNode<ActivatedRouteSnapshot>, k: string) =>\n                          this.deactivateRouteAndItsChildren(v, contexts !.getContext(k)));\n  }\n\n  /**\n   * Iterates over child routes and calls recursive `setupRouteGuards` to get `this` instance in\n   * proper state to run `checkGuards()` method.\n   */\n  private setupRouteGuards(\n      futureNode: TreeNode<ActivatedRouteSnapshot>, currNode: TreeNode<ActivatedRouteSnapshot>,\n      parentContexts: ChildrenOutletContexts|null, futurePath: ActivatedRouteSnapshot[]): void {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n\n    // reusing the node\n    if (curr && future.routeConfig === curr.routeConfig) {\n      const shouldRunGuardsAndResolvers = this.shouldRunGuardsAndResolvers(\n          curr, future, future.routeConfig !.runGuardsAndResolvers);\n      if (shouldRunGuardsAndResolvers) {\n        this.canActivateChecks.push(new CanActivate(futurePath));\n      } else {\n        // we need to set the data\n        future.data = curr.data;\n        future._resolvedData = curr._resolvedData;\n      }\n\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(\n            futureNode, currNode, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, currNode, parentContexts, futurePath);\n      }\n\n      if (shouldRunGuardsAndResolvers) {\n        const outlet = context !.outlet !;\n        this.canDeactivateChecks.push(new CanDeactivate(outlet.component, curr));\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, context);\n      }\n\n      this.canActivateChecks.push(new CanActivate(futurePath));\n      // If we have a component, we need to go through an outlet.\n      if (future.component) {\n        this.setupChildRouteGuards(futureNode, null, context ? context.children : null, futurePath);\n\n        // if we have a componentless route, we recurse but keep the same outlet map.\n      } else {\n        this.setupChildRouteGuards(futureNode, null, parentContexts, futurePath);\n      }\n    }\n  }\n\n  private shouldRunGuardsAndResolvers(\n      curr: ActivatedRouteSnapshot, future: ActivatedRouteSnapshot,\n      mode: RunGuardsAndResolvers|undefined): boolean {\n    switch (mode) {\n      case 'always':\n        return true;\n\n      case 'paramsOrQueryParamsChange':\n        return !equalParamsAndUrlSegments(curr, future) ||\n            !shallowEqual(curr.queryParams, future.queryParams);\n\n      case 'paramsChange':\n      default:\n        return !equalParamsAndUrlSegments(curr, future);\n    }\n  }\n\n  private deactivateRouteAndItsChildren(\n      route: TreeNode<ActivatedRouteSnapshot>, context: OutletContext|null): void {\n    const children = nodeChildrenAsMap(route);\n    const r = route.value;\n\n    forEach(children, (node: TreeNode<ActivatedRouteSnapshot>, childName: string) => {\n      if (!r.component) {\n        this.deactivateRouteAndItsChildren(node, context);\n      } else if (context) {\n        this.deactivateRouteAndItsChildren(node, context.children.getContext(childName));\n      } else {\n        this.deactivateRouteAndItsChildren(node, null);\n      }\n    });\n\n    if (!r.component) {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    } else if (context && context.outlet && context.outlet.isActivated) {\n      this.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));\n    } else {\n      this.canDeactivateChecks.push(new CanDeactivate(null, r));\n    }\n  }\n\n  private runCanDeactivateChecks(): Observable<boolean> {\n    return from(this.canDeactivateChecks)\n        .pipe(\n            mergeMap((check: CanDeactivate) => this.runCanDeactivate(check.component, check.route)),\n            every((result: boolean) => result === true));\n  }\n\n  private runCanActivateChecks(): Observable<boolean> {\n    return from(this.canActivateChecks)\n        .pipe(\n            concatMap((check: CanActivate) => andObservables(from([\n                        this.fireChildActivationStart(check.route.parent),\n                        this.fireActivationStart(check.route), this.runCanActivateChild(check.path),\n                        this.runCanActivate(check.route)\n                      ]))),\n            every((result: boolean) => result === true));\n    // this.fireChildActivationStart(check.path),\n  }\n\n  /**\n   * This should fire off `ActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  /**\n   * This should fire off `ChildActivationStart` events for each route being activated at this\n   * level.\n   * In other words, if you're activating `a` and `b` below, `path` will contain the\n   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always\n   * return\n   * `true` so checks continue to run.\n   */\n  private fireChildActivationStart(snapshot: ActivatedRouteSnapshot|null): Observable<boolean> {\n    if (snapshot !== null && this.forwardEvent) {\n      this.forwardEvent(new ChildActivationStart(snapshot));\n    }\n    return of (true);\n  }\n\n  private runCanActivate(future: ActivatedRouteSnapshot): Observable<boolean> {\n    const canActivate = future.routeConfig ? future.routeConfig.canActivate : null;\n    if (!canActivate || canActivate.length === 0) return of (true);\n    const obs = from(canActivate).pipe(map((c: any) => {\n      const guard = this.getToken(c, future);\n      let observable: Observable<boolean>;\n      if (guard.canActivate) {\n        observable = wrapIntoObservable(guard.canActivate(future, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(future, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return andObservables(obs);\n  }\n\n  private runCanActivateChild(path: ActivatedRouteSnapshot[]): Observable<boolean> {\n    const future = path[path.length - 1];\n\n    const canActivateChildGuards = path.slice(0, path.length - 1)\n                                       .reverse()\n                                       .map(p => this.extractCanActivateChild(p))\n                                       .filter(_ => _ !== null);\n\n    return andObservables(from(canActivateChildGuards).pipe(map((d: any) => {\n      const obs = from(d.guards).pipe(map((c: any) => {\n        const guard = this.getToken(c, d.node);\n        let observable: Observable<boolean>;\n        if (guard.canActivateChild) {\n          observable = wrapIntoObservable(guard.canActivateChild(future, this.future));\n        } else {\n          observable = wrapIntoObservable(guard(future, this.future));\n        }\n        return observable.pipe(first());\n      }));\n      return andObservables(obs);\n    })));\n  }\n\n  private extractCanActivateChild(p: ActivatedRouteSnapshot):\n      {node: ActivatedRouteSnapshot, guards: any[]}|null {\n    const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n    if (!canActivateChild || canActivateChild.length === 0) return null;\n    return {node: p, guards: canActivateChild};\n  }\n\n  private runCanDeactivate(component: Object|null, curr: ActivatedRouteSnapshot):\n      Observable<boolean> {\n    const canDeactivate = curr && curr.routeConfig ? curr.routeConfig.canDeactivate : null;\n    if (!canDeactivate || canDeactivate.length === 0) return of (true);\n    const canDeactivate$ = from(canDeactivate).pipe(mergeMap((c: any) => {\n      const guard = this.getToken(c, curr);\n      let observable: Observable<boolean>;\n      if (guard.canDeactivate) {\n        observable =\n            wrapIntoObservable(guard.canDeactivate(component, curr, this.curr, this.future));\n      } else {\n        observable = wrapIntoObservable(guard(component, curr, this.curr, this.future));\n      }\n      return observable.pipe(first());\n    }));\n    return canDeactivate$.pipe(every((result: any) => result === true));\n  }\n\n  private runResolve(\n      future: ActivatedRouteSnapshot,\n      paramsInheritanceStrategy: 'emptyOnly'|'always'): Observable<any> {\n    const resolve = future._resolve;\n    return this.resolveNode(resolve, future).pipe(map((resolvedData: any): any => {\n      future._resolvedData = resolvedData;\n      future.data = {...future.data,\n                     ...inheritedParamsDataResolve(future, paramsInheritanceStrategy).resolve};\n      return null;\n    }));\n  }\n\n  private resolveNode(resolve: ResolveData, future: ActivatedRouteSnapshot): Observable<any> {\n    const keys = Object.keys(resolve);\n    if (keys.length === 0) {\n      return of ({});\n    }\n    if (keys.length === 1) {\n      const key = keys[0];\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        return {[key]: value};\n      }));\n    }\n    const data: {[k: string]: any} = {};\n    const runningResolvers$ = from(keys).pipe(mergeMap((key: string) => {\n      return this.getResolver(resolve[key], future).pipe(map((value: any) => {\n        data[key] = value;\n        return value;\n      }));\n    }));\n    return runningResolvers$.pipe(last(), map(() => data));\n  }\n\n  private getResolver(injectionToken: any, future: ActivatedRouteSnapshot): Observable<any> {\n    const resolver = this.getToken(injectionToken, future);\n    return resolver.resolve ? wrapIntoObservable(resolver.resolve(future, this.future)) :\n                              wrapIntoObservable(resolver(future, this.future));\n  }\n\n  private getToken(token: any, snapshot: ActivatedRouteSnapshot): any {\n    const config = closestLoadedConfig(snapshot);\n    const injector = config ? config.module.injector : this.moduleInjector;\n    return injector.get(token);\n  }\n}\n\n\nfunction closestLoadedConfig(snapshot: ActivatedRouteSnapshot): LoadedRouterConfig|null {\n  if (!snapshot) return null;\n\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route && route._loadedConfig) return route._loadedConfig;\n  }\n\n  return null;\n}\n"],"sourceRoot":""}