Liferay.Loader.define('@example-angular-liferay$angular/platform-browser-dynamic@6.1.10/esm5/src/compiler_factory', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { Compiler, Inject, InjectionToken, Optional, PACKAGE_ROOT_URL, TRANSLATIONS, isDevMode, ÉµConsole as Console, ViewEncapsulation, Injector, TRANSLATIONS_FORMAT, MissingTranslationStrategy } from '@angular/core';
    import { StaticSymbolCache, JitCompiler, ProviderMeta, I18NHtmlParser, ViewCompiler, CompileMetadataResolver, UrlResolver, TemplateParser, NgModuleCompiler, JitSummaryResolver, SummaryResolver, StyleCompiler, PipeResolver, ElementSchemaRegistry, DomElementSchemaRegistry, ResourceLoader, NgModuleResolver, HtmlParser, CompileReflector, CompilerConfig, DirectiveNormalizer, DirectiveResolver, Lexer, Parser } from '@angular/compiler';
    import { JitReflector } from './compiler_reflector';
    export var ERROR_COLLECTOR_TOKEN = new InjectionToken('ErrorCollector');
    /**
     * A default provider for {@link PACKAGE_ROOT_URL} that maps to '/'.
     */
    export var DEFAULT_PACKAGE_URL_PROVIDER = {
        provide: PACKAGE_ROOT_URL,
        useValue: '/'
    };
    var _NO_RESOURCE_LOADER = {
        get: function (url) {
            throw new Error("No ResourceLoader implementation has been provided. Can't read the url \"" + url + "\"");
        }
    };
    var baseHtmlParser = new InjectionToken('HtmlParser');
    var CompilerImpl = /** @class */function () {
        function CompilerImpl(injector, _metadataResolver, templateParser, styleCompiler, viewCompiler, ngModuleCompiler, summaryResolver, compileReflector, compilerConfig, console) {
            this._metadataResolver = _metadataResolver;
            this._delegate = new JitCompiler(_metadataResolver, templateParser, styleCompiler, viewCompiler, ngModuleCompiler, summaryResolver, compileReflector, compilerConfig, console, this.getExtraNgModuleProviders.bind(this));
            this.injector = injector;
        }
        CompilerImpl.prototype.getExtraNgModuleProviders = function () {
            return [this._metadataResolver.getProviderMetadata(new ProviderMeta(Compiler, { useValue: this }))];
        };
        CompilerImpl.prototype.compileModuleSync = function (moduleType) {
            return this._delegate.compileModuleSync(moduleType);
        };
        CompilerImpl.prototype.compileModuleAsync = function (moduleType) {
            return this._delegate.compileModuleAsync(moduleType);
        };
        CompilerImpl.prototype.compileModuleAndAllComponentsSync = function (moduleType) {
            var result = this._delegate.compileModuleAndAllComponentsSync(moduleType);
            return {
                ngModuleFactory: result.ngModuleFactory,
                componentFactories: result.componentFactories
            };
        };
        CompilerImpl.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {
            return this._delegate.compileModuleAndAllComponentsAsync(moduleType).then(function (result) {
                return {
                    ngModuleFactory: result.ngModuleFactory,
                    componentFactories: result.componentFactories
                };
            });
        };
        CompilerImpl.prototype.loadAotSummaries = function (summaries) {
            this._delegate.loadAotSummaries(summaries);
        };
        CompilerImpl.prototype.hasAotSummary = function (ref) {
            return this._delegate.hasAotSummary(ref);
        };
        CompilerImpl.prototype.getComponentFactory = function (component) {
            return this._delegate.getComponentFactory(component);
        };
        CompilerImpl.prototype.clearCache = function () {
            this._delegate.clearCache();
        };
        CompilerImpl.prototype.clearCacheFor = function (type) {
            this._delegate.clearCacheFor(type);
        };
        CompilerImpl.prototype.getModuleId = function (moduleType) {
            var meta = this._metadataResolver.getNgModuleMetadata(moduleType);
            return meta && meta.id || undefined;
        };
        return CompilerImpl;
    }();
    export { CompilerImpl };
    /**
     * A set of providers that provide `JitCompiler` and its dependencies to use for
     * template compilation.
     */
    export var COMPILER_PROVIDERS = [{ provide: CompileReflector, useValue: new JitReflector() }, { provide: ResourceLoader, useValue: _NO_RESOURCE_LOADER }, { provide: JitSummaryResolver, deps: [] }, { provide: SummaryResolver, useExisting: JitSummaryResolver }, { provide: Console, deps: [] }, { provide: Lexer, deps: [] }, { provide: Parser, deps: [Lexer] }, {
        provide: baseHtmlParser,
        useClass: HtmlParser,
        deps: []
    }, {
        provide: I18NHtmlParser,
        useFactory: function (parser, translations, format, config, console) {
            translations = translations || '';
            var missingTranslation = translations ? config.missingTranslation : MissingTranslationStrategy.Ignore;
            return new I18NHtmlParser(parser, translations, format, missingTranslation, console);
        },
        deps: [baseHtmlParser, [new Optional(), new Inject(TRANSLATIONS)], [new Optional(), new Inject(TRANSLATIONS_FORMAT)], [CompilerConfig], [Console]]
    }, {
        provide: HtmlParser,
        useExisting: I18NHtmlParser
    }, {
        provide: TemplateParser, deps: [CompilerConfig, CompileReflector, Parser, ElementSchemaRegistry, I18NHtmlParser, Console]
    }, { provide: DirectiveNormalizer, deps: [ResourceLoader, UrlResolver, HtmlParser, CompilerConfig] }, { provide: CompileMetadataResolver, deps: [CompilerConfig, HtmlParser, NgModuleResolver, DirectiveResolver, PipeResolver, SummaryResolver, ElementSchemaRegistry, DirectiveNormalizer, Console, [Optional, StaticSymbolCache], CompileReflector, [Optional, ERROR_COLLECTOR_TOKEN]] }, DEFAULT_PACKAGE_URL_PROVIDER, { provide: StyleCompiler, deps: [UrlResolver] }, { provide: ViewCompiler, deps: [CompileReflector] }, { provide: NgModuleCompiler, deps: [CompileReflector] }, { provide: CompilerConfig, useValue: new CompilerConfig() }, { provide: Compiler, useClass: CompilerImpl, deps: [Injector, CompileMetadataResolver, TemplateParser, StyleCompiler, ViewCompiler, NgModuleCompiler, SummaryResolver, CompileReflector, CompilerConfig, Console] }, { provide: DomElementSchemaRegistry, deps: [] }, { provide: ElementSchemaRegistry, useExisting: DomElementSchemaRegistry }, { provide: UrlResolver, deps: [PACKAGE_ROOT_URL] }, { provide: DirectiveResolver, deps: [CompileReflector] }, { provide: PipeResolver, deps: [CompileReflector] }, { provide: NgModuleResolver, deps: [CompileReflector] }];
    /**
     * @experimental
     */
    var JitCompilerFactory = /** @class */function () {
        /* @internal */
        function JitCompilerFactory(defaultOptions) {
            var compilerOptions = {
                useJit: true,
                defaultEncapsulation: ViewEncapsulation.Emulated,
                missingTranslation: MissingTranslationStrategy.Warning
            };
            this._defaultOptions = tslib_1.__spread([compilerOptions], defaultOptions);
        }
        JitCompilerFactory.prototype.createCompiler = function (options) {
            if (options === void 0) {
                options = [];
            }
            var opts = _mergeOptions(this._defaultOptions.concat(options));
            var injector = Injector.create([COMPILER_PROVIDERS, {
                provide: CompilerConfig,
                useFactory: function () {
                    return new CompilerConfig({
                        // let explicit values from the compiler options overwrite options
                        // from the app providers
                        useJit: opts.useJit,
                        jitDevMode: isDevMode(),
                        // let explicit values from the compiler options overwrite options
                        // from the app providers
                        defaultEncapsulation: opts.defaultEncapsulation,
                        missingTranslation: opts.missingTranslation,
                        preserveWhitespaces: opts.preserveWhitespaces
                    });
                },
                deps: []
            }, opts.providers]);
            return injector.get(Compiler);
        };
        return JitCompilerFactory;
    }();
    export { JitCompilerFactory };
    function _mergeOptions(optionsArr) {
        return {
            useJit: _lastDefined(optionsArr.map(function (options) {
                return options.useJit;
            })),
            defaultEncapsulation: _lastDefined(optionsArr.map(function (options) {
                return options.defaultEncapsulation;
            })),
            providers: _mergeArrays(optionsArr.map(function (options) {
                return options.providers;
            })),
            missingTranslation: _lastDefined(optionsArr.map(function (options) {
                return options.missingTranslation;
            })),
            preserveWhitespaces: _lastDefined(optionsArr.map(function (options) {
                return options.preserveWhitespaces;
            }))
        };
    }
    function _lastDefined(args) {
        for (var i = args.length - 1; i >= 0; i--) {
            if (args[i] !== undefined) {
                return args[i];
            }
        }
        return undefined;
    }
    function _mergeArrays(parts) {
        var result = [];
        parts.forEach(function (part) {
            return part && result.push.apply(result, tslib_1.__spread(part));
        });
        return result;
    }
});
//# sourceMappingURL=compiler_factory.js.map