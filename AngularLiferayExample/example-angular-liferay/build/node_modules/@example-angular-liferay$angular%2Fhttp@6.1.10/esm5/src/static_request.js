Liferay.Loader.define('@example-angular-liferay$angular/http@6.1.10/esm5/src/static_request', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { Body } from './body';
    import { ContentType } from './enums';
    import { Headers } from './headers';
    import { normalizeMethodName } from './http_utils';
    import { URLSearchParams } from './url_search_params';
    // TODO(jeffbcross): properly implement body accessors
    /**
     * Creates `Request` instances from provided values.
     *
     * The Request's interface is inspired by the Request constructor defined in the [Fetch
     * Spec](https://fetch.spec.whatwg.org/#request-class),
     * but is considered a static value whose body can be accessed many times. There are other
     * differences in the implementation, but this is the most significant.
     *
     * `Request` instances are typically created by higher-level classes, like {@link Http} and
     * {@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
     * One such example is when creating services that wrap higher-level services, like {@link Http},
     * where it may be useful to generate a `Request` with arbitrary headers and search params.
     *
     * ```typescript
     * import {Injectable, Injector} from '@angular/core';
     * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '@angular/http';
     *
     * @Injectable()
     * class AutoAuthenticator {
     *   constructor(public http:Http) {}
     *   request(url:string) {
     *     return this.http.request(new Request({
     *       method: RequestMethod.Get,
     *       url: url,
     *       search: 'password=123'
     *     }));
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
     * var authenticator = injector.get(AutoAuthenticator);
     * authenticator.request('people.json').subscribe(res => {
     *   //URL should have included '?password=123'
     *   console.log('people', res.json());
     * });
     * ```
     *
     * @deprecated see https://angular.io/guide/http
     */
    var Request = /** @class */function (_super) {
        tslib_1.__extends(Request, _super);
        function Request(requestOptions) {
            var _this = _super.call(this) || this;
            // TODO: assert that url is present
            var url = requestOptions.url;
            _this.url = requestOptions.url;
            var paramsArg = requestOptions.params || requestOptions.search;
            if (paramsArg) {
                var params = void 0;
                if (typeof paramsArg === 'object' && !(paramsArg instanceof URLSearchParams)) {
                    params = urlEncodeParams(paramsArg).toString();
                } else {
                    params = paramsArg.toString();
                }
                if (params.length > 0) {
                    var prefix = '?';
                    if (_this.url.indexOf('?') != -1) {
                        prefix = _this.url[_this.url.length - 1] == '&' ? '' : '&';
                    }
                    // TODO: just delete search-query-looking string in url?
                    _this.url = url + prefix + params;
                }
            }
            _this._body = requestOptions.body;
            _this.method = normalizeMethodName(requestOptions.method);
            // TODO(jeffbcross): implement behavior
            // Defaults to 'omit', consistent with browser
            _this.headers = new Headers(requestOptions.headers);
            _this.contentType = _this.detectContentType();
            _this.withCredentials = requestOptions.withCredentials;
            _this.responseType = requestOptions.responseType;
            return _this;
        }
        /**
         * Returns the content type enum based on header options.
         */
        Request.prototype.detectContentType = function () {
            switch (this.headers.get('content-type')) {
                case 'application/json':
                    return ContentType.JSON;
                case 'application/x-www-form-urlencoded':
                    return ContentType.FORM;
                case 'multipart/form-data':
                    return ContentType.FORM_DATA;
                case 'text/plain':
                case 'text/html':
                    return ContentType.TEXT;
                case 'application/octet-stream':
                    return this._body instanceof ArrayBuffer ? ContentType.ARRAY_BUFFER : ContentType.BLOB;
                default:
                    return this.detectContentTypeFromBody();
            }
        };
        /**
         * Returns the content type of request's body based on its type.
         */
        Request.prototype.detectContentTypeFromBody = function () {
            if (this._body == null) {
                return ContentType.NONE;
            } else if (this._body instanceof URLSearchParams) {
                return ContentType.FORM;
            } else if (this._body instanceof FormData) {
                return ContentType.FORM_DATA;
            } else if (this._body instanceof Blob) {
                return ContentType.BLOB;
            } else if (this._body instanceof ArrayBuffer) {
                return ContentType.ARRAY_BUFFER;
            } else if (this._body && typeof this._body === 'object') {
                return ContentType.JSON;
            } else {
                return ContentType.TEXT;
            }
        };
        /**
         * Returns the request's body according to its type. If body is undefined, return
         * null.
         */
        Request.prototype.getBody = function () {
            switch (this.contentType) {
                case ContentType.JSON:
                    return this.text();
                case ContentType.FORM:
                    return this.text();
                case ContentType.FORM_DATA:
                    return this._body;
                case ContentType.TEXT:
                    return this.text();
                case ContentType.BLOB:
                    return this.blob();
                case ContentType.ARRAY_BUFFER:
                    return this.arrayBuffer();
                default:
                    return null;
            }
        };
        return Request;
    }(Body);
    export { Request };
    function urlEncodeParams(params) {
        var searchParams = new URLSearchParams();
        Object.keys(params).forEach(function (key) {
            var value = params[key];
            if (value && Array.isArray(value)) {
                value.forEach(function (element) {
                    return searchParams.append(key, element.toString());
                });
            } else {
                searchParams.append(key, value.toString());
            }
        });
        return searchParams;
    }
    var noop = function () {};
    var ɵ0 = noop;
    var w = typeof window == 'object' ? window : noop;
    var FormData = w /** TODO #9100 */['FormData'] || noop;
    var Blob = w /** TODO #9100 */['Blob'] || noop;
    export var ArrayBuffer = w /** TODO #9100 */['ArrayBuffer'] || noop;
    export { ɵ0 };
});
//# sourceMappingURL=static_request.js.map