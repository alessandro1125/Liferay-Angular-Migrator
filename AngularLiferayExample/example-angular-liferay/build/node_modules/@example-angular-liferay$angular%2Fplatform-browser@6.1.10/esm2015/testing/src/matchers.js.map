{"version":3,"sources":["../../../../../../../packages/platform-browser/testing/src/matchers.ts"],"names":[],"mappings":";;;;;;;;;;;;;AASA,aAAc,WAAW,MAAzB,QAAsC,eAAtC;AACA,aAAQ,gBAAR,QAA+B,uBAA/B;AACA,aAAQ,EAAR,EAAY,WAAW,MAAvB,QAAoC,2BAApC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyFA,UAAM,UAAO,gBAAS,OAAO,MAAP,KAAkB,WAAlB,GAAgC,MAAhC,GAAyC,MAA/D;;;;;;;;AASA,WAAA,MAAa,SAAgD,QAAQ,MAArE;;;;;AAOA,oBAAC,GAAD,CAAa,SAAb,CAAuB,iBAAvB,IAA4C,YAAA;;AAC1C,cAAM,IAAI,IAAV;AACA,YAAI,CAAC,CAAL,EAAQ;AACN,mBAAO,KAAK,CAAZ;AACD;;AACD,cAAM,MAAa,EAAnB;AACA,UAAE,OAAF,CAAU,CAAC,CAAD,EAAS,CAAT,KAAmB;AAAG,gBAAI,IAAJ,CAAS,GAAG,OAAO,CAAP,CAAS,IAAI,OAAO,CAAP,CAAS,EAAlC;AAAwC,SAAxE;AACA,eAAO,KAAK,IAAI,IAAJ,CAAS,GAAT,CAAa,IAAzB;AACD,KARD;AAUA,YAAQ,UAAR,CAAmB,YAAA;;;AAGjB,gBAAQ,uBAAR,CAAgC,SAAA,UAAA,CAAoB,MAApB,EAAiC,QAAjC,EAA8C;AAC5E,gBAAI,kBAAkB,GAAtB,EAA2B;;AACzB,oBAAI,OAAO,OAAO,IAAP,KAAgB,SAAS,IAApC;AACA,oBAAI,IAAJ,EAAU;AACR,2BAAO,OAAP,CAAe,CAAC,CAAD,EAAS,CAAT,KAAmB;AAChC,+BAAO,QAAQ,QAAQ,YAAR,CAAqB,MAArB,CAA4B,CAA5B,EAA+B,SAAS,GAAT,CAAa,CAAb,CAA/B,CAAf;AACD,qBAFD;AAGD;AACD,uBAAO,IAAP;AACD,aARD,MAQO;;AAEL,uBAAA,iBAAO;AAAP;AACD;AACF,SAbD;AAcA,gBAAQ,WAAR,CAAoB;AAClB,yBAAa,YAAA;AACX,uBAAO;AACL,6BAAS,UAAS,MAAT,EAAoB;;AAC3B,8BAAM,OAAO,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,OAAO,IAAd,KAAuB,UAAlE;AACA,+BAAO,EAAC,MAAM,IAAP,EAAW;;;AAAE,gCAAI,OAAJ,GAAW;AAAK,uCAAO,cAAc,MAAd,GAAuB,kBAA9B;AAAmD,6BAAhF,EAAP;AACD;AAJI,iBAAP;AAMD,aARiB;AAUlB,8BAAkB,YAAA;AAChB,uBAAO;AACL,6BAAS,UAAS,MAAT,EAAsB,aAAtB,EAAwC;;AAC/C,8BAAM,OAAO,OAAO,MAAP,KAAkB,QAAlB,IAA8B,kBAAkB,aAA7D;AACA,+BAAO;AACL,kCAAM,IADD;;;;AAEL,gCAAI,OAAJ,GAAW;AACT,uCAAO,cAAc,MAAd,GAAuB,wBAAvB,GAAkD,aAAzD;AACD;AAJI,yBAAP;AAMD;AATI,iBAAP;AAWD,aAtBiB;AAwBlB,wBAAY,YAAA;AACV,uBAAO;AACL,6BAAS,UAAS,MAAT,EAAsB,YAAtB,EAA0C;;AACjD,8BAAM,aAAa,YAAY,MAAZ,CAAnB;AACA,+BAAO;AACL,kCAAM,cAAc,YADf;;;;AAEL,gCAAI,OAAJ,GAAW;AAAK,uCAAO,cAAc,UAAd,GAA2B,kBAA3B,GAAgD,YAAvD;AAAsE;AAFjF,yBAAP;AAID;AAPI,iBAAP;AASD,aAlCiB;AAoClB,4BAAgB,YAAA;AACd,uBAAO,EAAC,SAAS,WAAW,KAAX,CAAV,EAA6B,iBAAiB,WAAW,IAAX,CAA9C,EAAP;;;;;AAEA,yBAAA,UAAA,CAAoB,KAApB,EAAkC;AAChC,2BAAO,UAAS,MAAT,EAAsB,SAAtB,EAAuC;AAC5C,+BAAO;AACL,kCAAM,SAAS,QAAT,CAAkB,MAAlB,EAA0B,SAA1B,KAAwC,CAAC,KAD1C;;;;AAEL,gCAAI,OAAJ,GAAW;AACT,uCAAO,YAAY,OAAO,SAAS,IAAI,QAAQ,MAAR,GAAiB,EAAE,6BAA6B,SAAS,GAAhG;AACD;AAJI,yBAAP;AAMD,qBAPD;AAQD;AACF,aAjDiB;AAmDlB,4BAAgB,YAAA;AACd,uBAAO;AACL,6BAAS,UAAS,MAAT,EAAsB,MAAtB,EAA0D;;AACjE,4BAAI,SAAJ;AACA,4BAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,wCAAY,SAAS,QAAT,CAAkB,MAAlB,EAA0B,MAA1B,CAAZ;AACD,yBAFD,MAEO;AACL,wCAAY,OAAO,IAAP,CAAY,MAAZ,EAAoB,MAApB,KAA+B,CAA3C;AACA,mCAAO,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B,QAAO;AACjC,4CAAY,aAAa,SAAS,QAAT,CAAkB,MAAlB,EAA0B,IAA1B,EAAgC,OAAO,IAAP,CAAhC,CAAzB;AACD,6BAFD;AAGD;AAED,+BAAO;AACL,kCAAM,SADD;;;;AAEL,gCAAI,OAAJ,GAAW;;AACT,sCAAM,mBAAmB,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,SAAL,CAAe,MAAf,CAA/D;AACA,uCAAO,YAAY,OAAO,SAAS,IAAI,CAAC,SAAD,GAAa,GAAb,GAAmB,MAAM;4BAClD,OAAO,MAAP,KAAkB,QAAlB,GAA6B,UAA7B,GAA0C,QAAQ,KAAK,gBAAgB,GADrF;AAED;AANI,yBAAP;AAQD;AApBI,iBAAP;AAsBD,aA1EiB;AA4ElB,4BAAgB,YAAA;AACd,uBAAO;AACL,6BAAS,UAAS,MAAT,EAAsB,YAAtB,EAAuC;;AAC9C,8BAAM,eAAe,OAAO,QAAP,EAArB;AACA,+BAAO;AACL,kCAAM,aAAa,OAAb,CAAqB,YAArB,IAAqC,CAAC,CADvC;;;;AAEL,gCAAI,OAAJ,GAAW;AAAK,uCAAO,cAAc,YAAd,GAA6B,cAA7B,GAA8C,YAArD;AAAoE;AAF/E,yBAAP;AAID;AAPI,iBAAP;AASD,aAtFiB;AAwFlB,yBAAa,YAAA;AACX,uBAAO;AACL,6BAAS,UAAS,YAAT,EAA4B,iBAA5B,EAAkD;;AACzD,8BAAM,WAAW,OAAO,IAAP,CAAY,kBAAkB,SAA9B,CAAjB;;AAEA,8BAAM,gBAAuB,EAA7B;AACA,iCAAS,OAAT,CAAkB,CAAD,IAAM;AACrB,gCAAI,CAAC,aAAa,WAAb,CAAyB,SAAzB,CAAmC,CAAnC,CAAL,EAA4C,cAAc,IAAd,CAAmB,CAAnB;AAC7C,yBAFD;AAIA,+BAAO;AACL,kCAAM,cAAc,MAAd,IAAwB,CADzB;;;;AAEL,gCAAI,OAAJ,GAAW;AACT,uCAAO,cAAc,YAAd,GAA6B,kCAA7B,GACH,cAAc,IAAd,CAAmB,IAAnB,CADJ;AAED;AALI,yBAAP;AAOD;AAhBI,iBAAP;AAkBD,aA3GiB;AA6GlB,gCAAoB,YAAA;AAClB,uBAAO;AACL,6BAAS,UAAS,aAAT,EAA6B,qBAA7B,EAA6D;;AACpE,8BAAM,aAAa,UAAU,CAAV,CAAnB;;AACA,8BAAM,QAAS,GAAD,IAAyB,CAAC,GAAD,EAAM,UAAN,EAAkB,MAAlB,CAAyB,OAAzB,EAAkC,IAAlC,CAAuC,IAAvC,CAAvC;;AAGA,4BAAI,EAAE,yBAAyB,gBAA3B,CAAJ,EAAkD;AAChD,mCAAO;AACL,sCAAM,KADD;AAEL,yCAAS,MACL,8DAA8D,cAAc,WAAd,CAA0B,IAAI,GADvF;AAFJ,6BAAP;AAKD;;AAED,8BAAM,QAAQ,CAAC,CAAC,cAAc,YAAd,CAA2B,KAA3B,CAAiC,GAAG,SAAH,CAAa,qBAAb,CAAjC,CAAhB;AACA,+BAAO,QACH,EAAC,MAAM,IAAP,EADG,GAEH,EAAC,MAAM,KAAP,EAAc,SAAS,MAAM,YAAY,sBAAsB,IAAI,UAA5C,CAAvB,EAFJ;AAGD;AAlBI,iBAAP;AAoBD;AAlIiB,SAApB;AAoID,KArJD;;;;;AAuJA,aAAA,WAAA,CAAqB,CAArB,EAA2B;;AACzB,cAAM,WAAY,CAAD,IAAW;;AAC1B,kBAAM,WAAW,SAAS,UAAT,CAAoB,CAApB,CAAjB;AACA,mBAAO,YAAY,SAAS,MAAT,GAAkB,CAArC;AACD,SAHD;AAKA,YAAI,aAAa,KAAjB,EAAwB;AACtB,mBAAO,EAAE,GAAF,CAAM,WAAN,EAAmB,IAAnB,CAAwB,EAAxB,CAAP;AACD;AAED,YAAI,SAAS,aAAT,CAAuB,CAAvB,CAAJ,EAA+B;AAC7B,mBAAO,EAAP;AACD;AAED,YAAI,SAAS,aAAT,CAAuB,CAAvB,KAA6B,SAAS,OAAT,CAAiB,CAAjB,KAAuB,SAAxD,EAAmE;AACjE,mBAAO,YAAY,MAAM,SAAN,CAAgB,KAAhB,CAAsB,KAAtB,CAA4B,SAAS,mBAAT,CAA6B,CAA7B,CAA5B,CAAZ,CAAP;AACD;AAED,YAAI,SAAS,aAAT,CAAuB,CAAvB,CAAJ,EAA+B;AAC7B,mBAAO,YAAY,SAAS,gBAAT,CAA0B,SAAS,aAAT,CAAuB,CAAvB,CAA1B,CAAZ,CAAP;AACD;AAED,YAAI,SAAS,CAAT,CAAJ,EAAiB;AACf,mBAAO,YAAY,SAAS,gBAAT,CAA0B,CAA1B,CAAZ,CAAP;AACD;AAED,eAAA,iBAAO,SAAS,OAAT,CAAiB,CAAjB;AAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type, ɵglobal as global} from '@angular/core';\nimport {ComponentFixture} from '@angular/core/testing';\nimport {By, ɵgetDOM as getDOM} from '@angular/platform-browser';\n\n\n\n/**\n * Jasmine matchers that check Angular specific conditions.\n */\nexport interface NgMatchers<T = any> extends jasmine.Matchers<T> {\n  /**\n   * Expect the value to be a `Promise`.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toBePromise'}\n   */\n  toBePromise(): boolean;\n\n  /**\n   * Expect the value to be an instance of a class.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toBeAnInstanceOf'}\n   */\n  toBeAnInstanceOf(expected: any): boolean;\n\n  /**\n   * Expect the element to have exactly the given text.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toHaveText'}\n   */\n  toHaveText(expected: string): boolean;\n\n  /**\n   * Expect the element to have the given CSS class.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toHaveCssClass'}\n   */\n  toHaveCssClass(expected: string): boolean;\n\n  /**\n   * Expect the element to have the given CSS styles.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toHaveCssStyle'}\n   */\n  toHaveCssStyle(expected: {[k: string]: string}|string): boolean;\n\n  /**\n   * Expect a class to implement the interface of the given class.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toImplement'}\n   */\n  toImplement(expected: any): boolean;\n\n  /**\n   * Expect an exception to contain the given error text.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example testing/ts/matchers.ts region='toContainError'}\n   */\n  toContainError(expected: any): boolean;\n\n  /**\n   * Expect a component of the given type to show.\n   */\n  toContainComponent(expectedComponentType: Type<any>, expectationFailOutput?: any): boolean;\n\n  /**\n   * Invert the matchers.\n   */\n  not: NgMatchers<T>;\n}\n\nconst _global = <any>(typeof window === 'undefined' ? global : window);\n\n/**\n * Jasmine matching function with Angular matchers mixed in.\n *\n * ## Example\n *\n * {@example testing/ts/matchers.ts region='toHaveText'}\n */\nexport const expect: <T = any>(actual: T) => NgMatchers<T> = _global.expect;\n\n\n// Some Map polyfills don't polyfill Map.toString correctly, which\n// gives us bad error messages in tests.\n// The only way to do this in Jasmine is to monkey patch a method\n// to the object :-(\n(Map as any).prototype['jasmineToString'] = function() {\n  const m = this;\n  if (!m) {\n    return '' + m;\n  }\n  const res: any[] = [];\n  m.forEach((v: any, k: any) => { res.push(`${String(k)}:${String(v)}`); });\n  return `{ ${res.join(',')} }`;\n};\n\n_global.beforeEach(function() {\n  // Custom handler for Map as we use Jasmine 2.4, and support for maps is not\n  // added until Jasmine 2.6.\n  jasmine.addCustomEqualityTester(function compareMap(actual: any, expected: any): boolean {\n    if (actual instanceof Map) {\n      let pass = actual.size === expected.size;\n      if (pass) {\n        actual.forEach((v: any, k: any) => {\n          pass = pass && jasmine.matchersUtil.equals(v, expected.get(k));\n        });\n      }\n      return pass;\n    } else {\n      // TODO(misko): we should change the return, but jasmine.d.ts is not null safe\n      return undefined !;\n    }\n  });\n  jasmine.addMatchers({\n    toBePromise: function() {\n      return {\n        compare: function(actual: any) {\n          const pass = typeof actual === 'object' && typeof actual.then === 'function';\n          return {pass: pass, get message() { return 'Expected ' + actual + ' to be a promise'; }};\n        }\n      };\n    },\n\n    toBeAnInstanceOf: function() {\n      return {\n        compare: function(actual: any, expectedClass: any) {\n          const pass = typeof actual === 'object' && actual instanceof expectedClass;\n          return {\n            pass: pass,\n            get message() {\n              return 'Expected ' + actual + ' to be an instance of ' + expectedClass;\n            }\n          };\n        }\n      };\n    },\n\n    toHaveText: function() {\n      return {\n        compare: function(actual: any, expectedText: string) {\n          const actualText = elementText(actual);\n          return {\n            pass: actualText == expectedText,\n            get message() { return 'Expected ' + actualText + ' to be equal to ' + expectedText; }\n          };\n        }\n      };\n    },\n\n    toHaveCssClass: function() {\n      return {compare: buildError(false), negativeCompare: buildError(true)};\n\n      function buildError(isNot: boolean) {\n        return function(actual: any, className: string) {\n          return {\n            pass: getDOM().hasClass(actual, className) == !isNot,\n            get message() {\n              return `Expected ${actual.outerHTML} ${isNot ? 'not ' : ''}to contain the CSS class \"${className}\"`;\n            }\n          };\n        };\n      }\n    },\n\n    toHaveCssStyle: function() {\n      return {\n        compare: function(actual: any, styles: {[k: string]: string}|string) {\n          let allPassed: boolean;\n          if (typeof styles === 'string') {\n            allPassed = getDOM().hasStyle(actual, styles);\n          } else {\n            allPassed = Object.keys(styles).length !== 0;\n            Object.keys(styles).forEach(prop => {\n              allPassed = allPassed && getDOM().hasStyle(actual, prop, styles[prop]);\n            });\n          }\n\n          return {\n            pass: allPassed,\n            get message() {\n              const expectedValueStr = typeof styles === 'string' ? styles : JSON.stringify(styles);\n              return `Expected ${actual.outerHTML} ${!allPassed ? ' ' : 'not '}to contain the\n                      CSS ${typeof styles === 'string' ? 'property' : 'styles'} \"${expectedValueStr}\"`;\n            }\n          };\n        }\n      };\n    },\n\n    toContainError: function() {\n      return {\n        compare: function(actual: any, expectedText: any) {\n          const errorMessage = actual.toString();\n          return {\n            pass: errorMessage.indexOf(expectedText) > -1,\n            get message() { return 'Expected ' + errorMessage + ' to contain ' + expectedText; }\n          };\n        }\n      };\n    },\n\n    toImplement: function() {\n      return {\n        compare: function(actualObject: any, expectedInterface: any) {\n          const intProps = Object.keys(expectedInterface.prototype);\n\n          const missedMethods: any[] = [];\n          intProps.forEach((k) => {\n            if (!actualObject.constructor.prototype[k]) missedMethods.push(k);\n          });\n\n          return {\n            pass: missedMethods.length == 0,\n            get message() {\n              return 'Expected ' + actualObject + ' to have the following methods: ' +\n                  missedMethods.join(', ');\n            }\n          };\n        }\n      };\n    },\n\n    toContainComponent: function() {\n      return {\n        compare: function(actualFixture: any, expectedComponentType: Type<any>) {\n          const failOutput = arguments[2];\n          const msgFn = (msg: string): string => [msg, failOutput].filter(Boolean).join(', ');\n\n          // verify correct actual type\n          if (!(actualFixture instanceof ComponentFixture)) {\n            return {\n              pass: false,\n              message: msgFn(\n                  `Expected actual to be of type \\'ComponentFixture\\' [actual=${actualFixture.constructor.name}]`)\n            };\n          }\n\n          const found = !!actualFixture.debugElement.query(By.directive(expectedComponentType));\n          return found ?\n              {pass: true} :\n              {pass: false, message: msgFn(`Expected ${expectedComponentType.name} to show`)};\n        }\n      };\n    }\n  });\n});\n\nfunction elementText(n: any): string {\n  const hasNodes = (n: any) => {\n    const children = getDOM().childNodes(n);\n    return children && children.length > 0;\n  };\n\n  if (n instanceof Array) {\n    return n.map(elementText).join('');\n  }\n\n  if (getDOM().isCommentNode(n)) {\n    return '';\n  }\n\n  if (getDOM().isElementNode(n) && getDOM().tagName(n) == 'CONTENT') {\n    return elementText(Array.prototype.slice.apply(getDOM().getDistributedNodes(n)));\n  }\n\n  if (getDOM().hasShadowRoot(n)) {\n    return elementText(getDOM().childNodesAsList(getDOM().getShadowRoot(n)));\n  }\n\n  if (hasNodes(n)) {\n    return elementText(getDOM().childNodesAsList(n));\n  }\n\n  return getDOM().getText(n) !;\n}\n"],"sourceRoot":""}