Liferay.Loader.define('@example-angular-liferay$angular/platform-browser@6.1.10/esm2015/testing/src/matchers', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { ɵglobal as global } from '@angular/core';
    import { ComponentFixture } from '@angular/core/testing';
    import { By, ɵgetDOM as getDOM } from '@angular/platform-browser';
    /**
     * Jasmine matchers that check Angular specific conditions.
     * @record
     * @template T
     */
    export function NgMatchers() {}
    /**
     * Expect the value to be a `Promise`.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toBePromise'}
     * @type {?}
     */
    NgMatchers.prototype.toBePromise;
    /**
     * Expect the value to be an instance of a class.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toBeAnInstanceOf'}
     * @type {?}
     */
    NgMatchers.prototype.toBeAnInstanceOf;
    /**
     * Expect the element to have exactly the given text.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toHaveText'}
     * @type {?}
     */
    NgMatchers.prototype.toHaveText;
    /**
     * Expect the element to have the given CSS class.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toHaveCssClass'}
     * @type {?}
     */
    NgMatchers.prototype.toHaveCssClass;
    /**
     * Expect the element to have the given CSS styles.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toHaveCssStyle'}
     * @type {?}
     */
    NgMatchers.prototype.toHaveCssStyle;
    /**
     * Expect a class to implement the interface of the given class.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toImplement'}
     * @type {?}
     */
    NgMatchers.prototype.toImplement;
    /**
     * Expect an exception to contain the given error text.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example testing/ts/matchers.ts region='toContainError'}
     * @type {?}
     */
    NgMatchers.prototype.toContainError;
    /**
     * Expect a component of the given type to show.
     * @type {?}
     */
    NgMatchers.prototype.toContainComponent;
    /**
     * Invert the matchers.
     * @type {?}
     */
    NgMatchers.prototype.not;
    /** @type {?} */
    const _global = /** @type {?} */typeof window === 'undefined' ? global : window;
    /** *
     * Jasmine matching function with Angular matchers mixed in.
     *
     * ## Example
     *
     * {\@example testing/ts/matchers.ts region='toHaveText'}
      @type {?} */
    export const expect = _global.expect;
    // Some Map polyfills don't polyfill Map.toString correctly, which
    // gives us bad error messages in tests.
    // The only way to do this in Jasmine is to monkey patch a method
    // to the object :-(
    /** @type {?} */Map.prototype['jasmineToString'] = function () {
        /** @type {?} */
        const m = this;
        if (!m) {
            return '' + m;
        }
        /** @type {?} */
        const res = [];
        m.forEach((v, k) => {
            res.push(`${String(k)}:${String(v)}`);
        });
        return `{ ${res.join(',')} }`;
    };
    _global.beforeEach(function () {
        // Custom handler for Map as we use Jasmine 2.4, and support for maps is not
        // added until Jasmine 2.6.
        jasmine.addCustomEqualityTester(function compareMap(actual, expected) {
            if (actual instanceof Map) {
                /** @type {?} */
                let pass = actual.size === expected.size;
                if (pass) {
                    actual.forEach((v, k) => {
                        pass = pass && jasmine.matchersUtil.equals(v, expected.get(k));
                    });
                }
                return pass;
            } else {
                // TODO(misko): we should change the return, but jasmine.d.ts is not null safe
                return (/** @type {?} */undefined
                );
            }
        });
        jasmine.addMatchers({
            toBePromise: function () {
                return {
                    compare: function (actual) {
                        /** @type {?} */
                        const pass = typeof actual === 'object' && typeof actual.then === 'function';
                        return { pass: pass, /**
                                             * @return {?}
                                             */
                            get message() {
                                return 'Expected ' + actual + ' to be a promise';
                            } };
                    }
                };
            },
            toBeAnInstanceOf: function () {
                return {
                    compare: function (actual, expectedClass) {
                        /** @type {?} */
                        const pass = typeof actual === 'object' && actual instanceof expectedClass;
                        return {
                            pass: pass,
                            /**
                             * @return {?}
                             */
                            get message() {
                                return 'Expected ' + actual + ' to be an instance of ' + expectedClass;
                            }
                        };
                    }
                };
            },
            toHaveText: function () {
                return {
                    compare: function (actual, expectedText) {
                        /** @type {?} */
                        const actualText = elementText(actual);
                        return {
                            pass: actualText == expectedText,
                            /**
                             * @return {?}
                             */
                            get message() {
                                return 'Expected ' + actualText + ' to be equal to ' + expectedText;
                            }
                        };
                    }
                };
            },
            toHaveCssClass: function () {
                return { compare: buildError(false), negativeCompare: buildError(true) };
                /**
                 * @param {?} isNot
                 * @return {?}
                 */
                function buildError(isNot) {
                    return function (actual, className) {
                        return {
                            pass: getDOM().hasClass(actual, className) == !isNot,
                            /**
                             * @return {?}
                             */
                            get message() {
                                return `Expected ${actual.outerHTML} ${isNot ? 'not ' : ''}to contain the CSS class "${className}"`;
                            }
                        };
                    };
                }
            },
            toHaveCssStyle: function () {
                return {
                    compare: function (actual, styles) {
                        /** @type {?} */
                        let allPassed;
                        if (typeof styles === 'string') {
                            allPassed = getDOM().hasStyle(actual, styles);
                        } else {
                            allPassed = Object.keys(styles).length !== 0;
                            Object.keys(styles).forEach(prop => {
                                allPassed = allPassed && getDOM().hasStyle(actual, prop, styles[prop]);
                            });
                        }
                        return {
                            pass: allPassed,
                            /**
                             * @return {?}
                             */
                            get message() {
                                /** @type {?} */
                                const expectedValueStr = typeof styles === 'string' ? styles : JSON.stringify(styles);
                                return `Expected ${actual.outerHTML} ${!allPassed ? ' ' : 'not '}to contain the
                      CSS ${typeof styles === 'string' ? 'property' : 'styles'} "${expectedValueStr}"`;
                            }
                        };
                    }
                };
            },
            toContainError: function () {
                return {
                    compare: function (actual, expectedText) {
                        /** @type {?} */
                        const errorMessage = actual.toString();
                        return {
                            pass: errorMessage.indexOf(expectedText) > -1,
                            /**
                             * @return {?}
                             */
                            get message() {
                                return 'Expected ' + errorMessage + ' to contain ' + expectedText;
                            }
                        };
                    }
                };
            },
            toImplement: function () {
                return {
                    compare: function (actualObject, expectedInterface) {
                        /** @type {?} */
                        const intProps = Object.keys(expectedInterface.prototype);
                        /** @type {?} */
                        const missedMethods = [];
                        intProps.forEach(k => {
                            if (!actualObject.constructor.prototype[k]) missedMethods.push(k);
                        });
                        return {
                            pass: missedMethods.length == 0,
                            /**
                             * @return {?}
                             */
                            get message() {
                                return 'Expected ' + actualObject + ' to have the following methods: ' + missedMethods.join(', ');
                            }
                        };
                    }
                };
            },
            toContainComponent: function () {
                return {
                    compare: function (actualFixture, expectedComponentType) {
                        /** @type {?} */
                        const failOutput = arguments[2];
                        /** @type {?} */
                        const msgFn = msg => [msg, failOutput].filter(Boolean).join(', ');
                        // verify correct actual type
                        if (!(actualFixture instanceof ComponentFixture)) {
                            return {
                                pass: false,
                                message: msgFn(`Expected actual to be of type \'ComponentFixture\' [actual=${actualFixture.constructor.name}]`)
                            };
                        }
                        /** @type {?} */
                        const found = !!actualFixture.debugElement.query(By.directive(expectedComponentType));
                        return found ? { pass: true } : { pass: false, message: msgFn(`Expected ${expectedComponentType.name} to show`) };
                    }
                };
            }
        });
    });
    /**
     * @param {?} n
     * @return {?}
     */
    function elementText(n) {
        /** @type {?} */
        const hasNodes = n => {
            /** @type {?} */
            const children = getDOM().childNodes(n);
            return children && children.length > 0;
        };
        if (n instanceof Array) {
            return n.map(elementText).join('');
        }
        if (getDOM().isCommentNode(n)) {
            return '';
        }
        if (getDOM().isElementNode(n) && getDOM().tagName(n) == 'CONTENT') {
            return elementText(Array.prototype.slice.apply(getDOM().getDistributedNodes(n)));
        }
        if (getDOM().hasShadowRoot(n)) {
            return elementText(getDOM().childNodesAsList(getDOM().getShadowRoot(n)));
        }
        if (hasNodes(n)) {
            return elementText(getDOM().childNodesAsList(n));
        }
        return (/** @type {?} */getDOM().getText(n)
        );
    }
});
//# sourceMappingURL=matchers.js.map