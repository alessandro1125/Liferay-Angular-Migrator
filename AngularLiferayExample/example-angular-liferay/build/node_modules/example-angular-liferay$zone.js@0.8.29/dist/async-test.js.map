{"version":3,"sources":["async-test.js"],"names":["global","factory","exports","module","define","amd","_global","window","self","AsyncTestZoneSpec","finishCallback","failCallback","namePrefix","_pendingMicroTasks","_pendingMacroTasks","_alreadyErrored","_isSync","runZone","Zone","current","unresolvedChainedPromiseCount","supportWaitUnresolvedChainedPromise","name","properties","__symbol__","prototype","isUnresolvedChainedPromisePending","_finishCallbackIfDone","_this","run","setTimeout","patchPromiseForTest","Promise","unPatchPromiseForTest","onScheduleTask","delegate","target","task","type","data","symbolParentUnresolved","scheduleTask","onInvokeTask","applyThis","applyArgs","invokeTask","onCancelTask","cancelTask","onInvoke","parentZoneDelegate","currentZone","targetZone","source","invoke","afterTaskCounts","_taskCounts","onHandleError","error","result","handleError","onHasTask","hasTaskState","hasTask","change","microTask","macroTask","__load_patch","api","symbol","asyncTest","fn","jasmine","done","fail","e","runInTestZone","err","Error","context","undefined","ProxyZoneSpec","proxyZoneSpec","get","assertPresent","proxyZone","getZoneWith","previousDelegate","getDelegate","parent","testZoneSpec","setDelegate","runGuarded"],"mappings":"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","file":"async-test.js","sourcesContent":["/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(factory());\n}(this, (function () { 'use strict';\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar _global = typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global;\nvar AsyncTestZoneSpec = /** @class */ (function () {\n    function AsyncTestZoneSpec(finishCallback, failCallback, namePrefix) {\n        this.finishCallback = finishCallback;\n        this.failCallback = failCallback;\n        this._pendingMicroTasks = false;\n        this._pendingMacroTasks = false;\n        this._alreadyErrored = false;\n        this._isSync = false;\n        this.runZone = Zone.current;\n        this.unresolvedChainedPromiseCount = 0;\n        this.supportWaitUnresolvedChainedPromise = false;\n        this.name = 'asyncTestZone for ' + namePrefix;\n        this.properties = { 'AsyncTestZoneSpec': this };\n        this.supportWaitUnresolvedChainedPromise =\n            _global[Zone.__symbol__('supportWaitUnResolvedChainedPromise')] === true;\n    }\n    AsyncTestZoneSpec.prototype.isUnresolvedChainedPromisePending = function () {\n        return this.unresolvedChainedPromiseCount > 0;\n    };\n    AsyncTestZoneSpec.prototype._finishCallbackIfDone = function () {\n        var _this = this;\n        if (!(this._pendingMicroTasks || this._pendingMacroTasks ||\n            (this.supportWaitUnresolvedChainedPromise && this.isUnresolvedChainedPromisePending()))) {\n            // We do this because we would like to catch unhandled rejected promises.\n            this.runZone.run(function () {\n                setTimeout(function () {\n                    if (!_this._alreadyErrored && !(_this._pendingMicroTasks || _this._pendingMacroTasks)) {\n                        _this.finishCallback();\n                    }\n                }, 0);\n            });\n        }\n    };\n    AsyncTestZoneSpec.prototype.patchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n        }\n        var patchPromiseForTest = Promise[Zone.__symbol__('patchPromiseForTest')];\n        if (patchPromiseForTest) {\n            patchPromiseForTest();\n        }\n    };\n    AsyncTestZoneSpec.prototype.unPatchPromiseForTest = function () {\n        if (!this.supportWaitUnresolvedChainedPromise) {\n            return;\n        }\n        var unPatchPromiseForTest = Promise[Zone.__symbol__('unPatchPromiseForTest')];\n        if (unPatchPromiseForTest) {\n            unPatchPromiseForTest();\n        }\n    };\n    AsyncTestZoneSpec.prototype.onScheduleTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        if (task.type === 'microTask' && task.data && task.data instanceof Promise) {\n            // check whether the promise is a chained promise\n            if (task.data[AsyncTestZoneSpec.symbolParentUnresolved] === true) {\n                // chained promise is being scheduled\n                this.unresolvedChainedPromiseCount--;\n            }\n        }\n        return delegate.scheduleTask(target, task);\n    };\n    AsyncTestZoneSpec.prototype.onInvokeTask = function (delegate, current, target, task, applyThis, applyArgs) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n    };\n    AsyncTestZoneSpec.prototype.onCancelTask = function (delegate, current, target, task) {\n        if (task.type !== 'eventTask') {\n            this._isSync = false;\n        }\n        return delegate.cancelTask(target, task);\n    };\n    // Note - we need to use onInvoke at the moment to call finish when a test is\n    // fully synchronous. TODO(juliemr): remove this when the logic for\n    // onHasTask changes and it calls whenever the task queues are dirty.\n    // updated by(JiaLiPassion), only call finish callback when no task\n    // was scheduled/invoked/canceled.\n    AsyncTestZoneSpec.prototype.onInvoke = function (parentZoneDelegate, currentZone, targetZone, delegate, applyThis, applyArgs, source) {\n        try {\n            this._isSync = true;\n            return parentZoneDelegate.invoke(targetZone, delegate, applyThis, applyArgs, source);\n        }\n        finally {\n            var afterTaskCounts = parentZoneDelegate._taskCounts;\n            if (this._isSync) {\n                this._finishCallbackIfDone();\n            }\n        }\n    };\n    AsyncTestZoneSpec.prototype.onHandleError = function (parentZoneDelegate, currentZone, targetZone, error) {\n        // Let the parent try to handle the error.\n        var result = parentZoneDelegate.handleError(targetZone, error);\n        if (result) {\n            this.failCallback(error);\n            this._alreadyErrored = true;\n        }\n        return false;\n    };\n    AsyncTestZoneSpec.prototype.onHasTask = function (delegate, current, target, hasTaskState) {\n        delegate.hasTask(target, hasTaskState);\n        if (hasTaskState.change == 'microTask') {\n            this._pendingMicroTasks = hasTaskState.microTask;\n            this._finishCallbackIfDone();\n        }\n        else if (hasTaskState.change == 'macroTask') {\n            this._pendingMacroTasks = hasTaskState.macroTask;\n            this._finishCallbackIfDone();\n        }\n    };\n    AsyncTestZoneSpec.symbolParentUnresolved = Zone.__symbol__('parentUnresolved');\n    return AsyncTestZoneSpec;\n}());\n// Export the class so that new instances can be created with proper\n// constructor params.\nZone['AsyncTestZoneSpec'] = AsyncTestZoneSpec;\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nZone.__load_patch('asynctest', function (global, Zone, api) {\n    /**\n     * Wraps a test function in an asynchronous test zone. The test will automatically\n     * complete when all asynchronous calls within this zone are done.\n     */\n    Zone[api.symbol('asyncTest')] = function asyncTest(fn) {\n        // If we're running using the Jasmine test framework, adapt to call the 'done'\n        // function when asynchronous activity is finished.\n        if (global.jasmine) {\n            // Not using an arrow function to preserve context passed from call site\n            return function (done) {\n                if (!done) {\n                    // if we run beforeEach in @angular/core/testing/testing_internal then we get no done\n                    // fake it here and assume sync.\n                    done = function () { };\n                    done.fail = function (e) {\n                        throw e;\n                    };\n                }\n                runInTestZone(fn, this, done, function (err) {\n                    if (typeof err === 'string') {\n                        return done.fail(new Error(err));\n                    }\n                    else {\n                        done.fail(err);\n                    }\n                });\n            };\n        }\n        // Otherwise, return a promise which will resolve when asynchronous activity\n        // is finished. This will be correctly consumed by the Mocha framework with\n        // it('...', async(myFn)); or can be used in a custom framework.\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            var _this = this;\n            return new Promise(function (finishCallback, failCallback) {\n                runInTestZone(fn, _this, finishCallback, failCallback);\n            });\n        };\n    };\n    function runInTestZone(fn, context, finishCallback, failCallback) {\n        var currentZone = Zone.current;\n        var AsyncTestZoneSpec = Zone['AsyncTestZoneSpec'];\n        if (AsyncTestZoneSpec === undefined) {\n            throw new Error('AsyncTestZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/async-test.js');\n        }\n        var ProxyZoneSpec = Zone['ProxyZoneSpec'];\n        if (ProxyZoneSpec === undefined) {\n            throw new Error('ProxyZoneSpec is needed for the async() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js/dist/proxy.js');\n        }\n        var proxyZoneSpec = ProxyZoneSpec.get();\n        ProxyZoneSpec.assertPresent();\n        // We need to create the AsyncTestZoneSpec outside the ProxyZone.\n        // If we do it in ProxyZone then we will get to infinite recursion.\n        var proxyZone = Zone.current.getZoneWith('ProxyZoneSpec');\n        var previousDelegate = proxyZoneSpec.getDelegate();\n        proxyZone.parent.run(function () {\n            var testZoneSpec = new AsyncTestZoneSpec(function () {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's\n                    // sill this one. Otherwise, assume\n                    // it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(function () {\n                    finishCallback();\n                });\n            }, function (error) {\n                // Need to restore the original zone.\n                if (proxyZoneSpec.getDelegate() == testZoneSpec) {\n                    // Only reset the zone spec if it's sill this one. Otherwise, assume it's OK.\n                    proxyZoneSpec.setDelegate(previousDelegate);\n                }\n                testZoneSpec.unPatchPromiseForTest();\n                currentZone.run(function () {\n                    failCallback(error);\n                });\n            }, 'test');\n            proxyZoneSpec.setDelegate(testZoneSpec);\n            testZoneSpec.patchPromiseForTest();\n        });\n        return Zone.current.runGuarded(fn, context);\n    }\n});\n\n})));\n"]}