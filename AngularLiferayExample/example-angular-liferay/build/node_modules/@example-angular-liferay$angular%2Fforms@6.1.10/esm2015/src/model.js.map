{"version":3,"sources":["../../../../../../packages/forms/src/model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from './directives/validators';\nimport {toObservable} from './validators';\n\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = (<string>path).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return (<Array<string|number>>path).reduce((v: AbstractControl, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls.hasOwnProperty(name as string) ? v.controls[name] : null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at(<number>name) || null;\n    }\n\n    return null;\n  }, control);\n}\n\nfunction coerceToValidator(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): ValidatorFn|\n    null {\n  const validator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).validators :\n                                       validatorOrOpts) as ValidatorFn |\n      ValidatorFn[] | null;\n\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\nfunction coerceToAsyncValidator(\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null, validatorOrOpts?: ValidatorFn |\n        ValidatorFn[] | AbstractControlOptions | null): AsyncValidatorFn|null {\n  const origAsyncValidator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).asyncValidators :\n                                       asyncValidator) as AsyncValidatorFn |\n      AsyncValidatorFn | null;\n\n  return Array.isArray(origAsyncValidator) ? composeAsyncValidators(origAsyncValidator) :\n                                             origAsyncValidator || null;\n}\n\nexport type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @experimental\n */\nexport interface AbstractControlOptions {\n  /**\n   * List of validators applied to control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * List of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\n\nfunction isOptionsObj(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): boolean {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingDirty !: boolean;\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingTouched !: boolean;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _updateOn !: FormHooks;\n\n  // TODO(issue/24571): remove '!'.\n  private _parent !: FormGroup | FormArray;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For a `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value: any;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validator The function that determines the synchronous validity of this control.\n   * @param asyncValidator The function that determines the asynchronous validity of this\n   * control.\n   */\n  constructor(public validator: ValidatorFn|null, public asyncValidator: AsyncValidatorFn|null) {}\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray { return this._parent; }\n\n  /**\n   * The validation status of the control. There are four possible\n   * validation status values:\n   *\n   * * **VALID**: This control has passed all validation checks.\n   * * **INVALID**: This control has failed at least one validation check.\n   * * **PENDING**: This control is in the midst of conducting a validation check.\n   * * **DISABLED**: This control is exempt from validation checks.\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly status !: string;\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean { return this.status === VALID; }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean { return this.status === INVALID; }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean { return this.status == PENDING; }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * @see `status`\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean { return this.status === DISABLED; }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   */\n  get enabled(): boolean { return this.status !== DISABLED; }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly errors !: ValidationErrors | null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  public readonly pristine: boolean = true;\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean { return !this.pristine; }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  public readonly touched: boolean = false;\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean { return !this.touched; }\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly valueChanges !: Observable<any>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly statusChanges !: Observable<any>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn|ValidatorFn[]|null): void {\n    this.validator = coerceToValidator(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n\n  /**\n   * Empties out the sync validator list.\n   */\n  clearValidators(): void { this.validator = null; }\n\n  /**\n   * Empties out the async validator list.\n   */\n  clearAsyncValidators(): void { this.asyncValidator = null; }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value; compare `markAsDirty`;\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild(\n        (control: AbstractControl) => { control.markAsUntouched({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's is changed through the UI; compare `markAsTouched`.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsDirty(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   *  @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   */\n  markAsPristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild((control: AbstractControl) => { control.markAsPristine({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      (this.statusChanges as EventEmitter<any>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   *  @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = DISABLED;\n    (this as{errors: ValidationErrors | null}).errors = null;\n    this._forEachChild(\n        (control: AbstractControl) => { control.disable({...opts, onlySelf: true}); });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   *  @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = VALID;\n    this._forEachChild(\n        (control: AbstractControl) => { control.enable({...opts, onlySelf: true}); });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(opts: {onlySelf?: boolean, emitEvent?: boolean}) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n\n  /**\n   * @param parent Sets the parent of the control\n   */\n  setParent(parent: FormGroup|FormArray): void { this._parent = parent; }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: any, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: any, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: any, options?: Object): void;\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      (this as{errors: ValidationErrors | null}).errors = this._runValidator();\n      (this as{status: string}).status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    (this as{status: string}).status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors|null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      (this as{status: string}).status = PENDING;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription =\n          obs.subscribe((errors: ValidationErrors | null) => this.setErrors(errors, {emitEvent}));\n    }\n  }\n\n  private _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @usageNotes\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {\n    (this as{errors: ValidationErrors | null}).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name']);`\n   */\n  get(path: Array<string|number>|string): AbstractControl|null { return _find(this, path, '.'); }\n\n  /**\n   * Reports error data for a specific error occurring in this control or in another control.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   *\n   * @returns The error data if the control with the given path has the given error, otherwise null\n   * or undefined.\n   */\n  getError(errorCode: string, path?: string[]): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   * @returns True when the control with the given path has the error, otherwise false.\n   */\n  hasError(errorCode: string, path?: string[]): boolean { return !!this.getError(errorCode, path); }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(emitEvent: boolean): void {\n    (this as{status: string}).status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    (this as{valueChanges: Observable<any>}).valueChanges = new EventEmitter();\n    (this as{statusChanges: Observable<any>}).statusChanges = new EventEmitter();\n  }\n\n\n  private _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: Function): void;\n\n  /** @internal */\n  abstract _anyControls(condition: Function): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n\n  /** @internal */\n  _isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void { this._onCollectionChange = fn; }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {\n    if (isOptionsObj(opts) && (opts as AbstractControlOptions).updateOn != null) {\n      this._updateOn = (opts as AbstractControlOptions).updateOn !;\n    }\n  }\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the three fundamental building blocks of Angular forms, along with\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n *```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a sync validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to an initial value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n *\n*/\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n\n  /** @internal */\n  _pendingValue: any;\n\n  /** @internal */\n  _pendingChange: any;\n\n  /**\n  * Creates a new `FormControl` instance.\n  *\n  * @param formState Initializes the control with an initial value,\n  * or an object that defines the initial value and disabled state.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      formState: any = null,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n    this._initObservables();\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control proopagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    (this as{value: any}).value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(\n          (changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see `setValue` for options\n   */\n  patchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(formState: any = null, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n\n  /**\n   * @internal\n   */\n  _updateValue() {}\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: Function): boolean { return false; }\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean { return this.disabled; }\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void { this._onChange.push(fn); }\n\n  /**\n   * @internal\n   */\n  _clearChangeFns(): void {\n    this._onChange = [];\n    this._onDisabledChange = [];\n    this._onCollectionChange = () => {};\n  }\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: Function): void {}\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      (this as{value: any}).value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      (this as{value: any}).value = this._pendingValue = formState;\n    }\n  }\n}\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n */\nexport class FormGroup extends AbstractControl {\n  /**\n  * Creates a new `FormGroup` instance.\n  *\n  * @param controls A collection of child controls. The key for each child is the name\n  * under which it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: {[key: string]: AbstractControl},\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param name The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you excluding the value of a control.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n   * console.log(this.form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  reset(value: any = {}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : (<any>control).getRawValue();\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(k => cb(this.controls[k], k));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  _updateValue(): void { (this as{value: any}).value = this._reduceValue(); }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    let res = false;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n\n  /** @internal */\n  _reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _reduceChildren(initValue: any, fn: Function) {\n    let res = initValue;\n    this._forEachChild(\n        (control: AbstractControl, name: string) => { res = fn(res, control, name); });\n    return res;\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n  * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n *\n */\nexport class FormArray extends AbstractControl {\n  /**\n  * Creates a new `FormArray` instance.\n  *\n  * @param controls An array of child controls. Each child control is given an index\n  * where it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: AbstractControl[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number): AbstractControl { return this.controls[index]; }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control\n   */\n  removeAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The `AbstractControl` control to replace the existing control\n   */\n  setControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   */\n  get length(): number { return this.controls.length; }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  setValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * this.arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * console.log(this.arr.get(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  reset(value: any = [], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : (<any>control).getRawValue();\n    });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this.controls.reduce((updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => { cb(control, index); });\n  }\n\n  /** @internal */\n  _updateValue(): void {\n    (this as{value: any}).value =\n        this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n  }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  private _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n"],"sourceRoot":""}