{"version":3,"sources":["../../../../../../packages/forms/src/validators.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, ɵisObservable as isObservable, ɵisPromise as isPromise} from '@angular/core';\nimport {Observable, forkJoin, from} from 'rxjs';\nimport {map} from 'rxjs/operators';\nimport {AsyncValidatorFn, ValidationErrors, Validator, ValidatorFn} from './directives/validators';\nimport {AbstractControl, FormControl} from './model';\n\nfunction isEmptyInputValue(value: any): boolean {\n  // we don't check for string here so it also works with arrays\n  return value == null || value.length === 0;\n}\n\n/**\n * @description\n * An `InjectionToken` for registering additional synchronous validators used with `AbstractControl`s.\n *\n * @see `NG_ASYNC_VALIDATORS`\n *\n * @usageNotes\n *\n * ### Providing a custom validator\n *\n * The following example registers a custom validator directive. Adding the validator to the\n * existing collection of validators requires the `multi: true` option.\n *\n * ```typescript\n * @Directive({\n *   selector: '[customValidator]',\n *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]\n * })\n * class CustomValidatorDirective implements Validator {\n *   validate(control: AbstractControl): ValidationErrors | null {\n *     return { 'custom': true };\n *   }\n * }\n * ```\n *\n */\nexport const NG_VALIDATORS = new InjectionToken<Array<Validator|Function>>('NgValidators');\n\n/**\n * @description\n * An `InjectionToken` for registering additional asynchronous validators used with `AbstractControl`s.\n *\n * @see `NG_VALIDATORS`\n *\n */\nexport const NG_ASYNC_VALIDATORS =\n    new InjectionToken<Array<Validator|Function>>('NgAsyncValidators');\n\nconst EMAIL_REGEXP =\n    /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n\n/**\n * @description\n * Provides a set of built-in validators that can be used by form controls.\n *\n * A validator is a function that processes a `FormControl` or collection of\n * controls and returns an error map or null. A null map means that validation has passed.\n *\n * @see [Form Validation](/guide/form-validation)\n *\n */\nexport class Validators {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```typescript\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static min(min: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return !isNaN(value) && value < min ? {'min': {'min': min, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   * The validator exists only as a function and not as a directive.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```typescript\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   */\n  static max(max: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value = parseFloat(control.value);\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return !isNaN(value) && value > max ? {'max': {'max': max, 'actual': control.value}} : null;\n    };\n  }\n\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static required(control: AbstractControl): ValidationErrors|null {\n    return isEmptyInputValue(control.value) ? {'required': true} : null;\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```typescript\n   * const control = new FormControl('', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    return control.value === true ? null : {'required': true};\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```typescript\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (isEmptyInputValue(control.value)) {\n      return null;  // don't validate empty values to allow optional controls\n    }\n    return EMAIL_REGEXP.test(control.value) ? null : {'email': true};\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use the\n   * the HTML5 `minlength` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```typescript\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` if the validation check fails, otherwise `null`.\n   */\n  static minLength(minLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const length: number = control.value ? control.value.length : 0;\n      return length < minLength ?\n          {'minlength': {'requiredLength': minLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * @description\n   * Validator that requires the length of the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use the\n   * the HTML5 `maxlength` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```typescript\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   */\n  static maxLength(maxLength: number): ValidatorFn {\n    return (control: AbstractControl): ValidationErrors | null => {\n      const length: number = control.value ? control.value.length : 0;\n      return length > maxLength ?\n          {'maxlength': {'requiredLength': maxLength, 'actualLength': length}} :\n          null;\n    };\n  }\n\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided\n   * by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```typescript\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   */\n  static pattern(pattern: string|RegExp): ValidatorFn {\n    if (!pattern) return Validators.nullValidator;\n    let regex: RegExp;\n    let regexStr: string;\n    if (typeof pattern === 'string') {\n      regexStr = '';\n\n      if (pattern.charAt(0) !== '^') regexStr += '^';\n\n      regexStr += pattern;\n\n      if (pattern.charAt(pattern.length - 1) !== '$') regexStr += '$';\n\n      regex = new RegExp(regexStr);\n    } else {\n      regexStr = pattern.toString();\n      regex = pattern;\n    }\n    return (control: AbstractControl): ValidationErrors | null => {\n      if (isEmptyInputValue(control.value)) {\n        return null;  // don't validate empty values to allow optional controls\n      }\n      const value: string = control.value;\n      return regex.test(value) ? null :\n                                 {'pattern': {'requiredPattern': regexStr, 'actualValue': value}};\n    };\n  }\n\n  /**\n   * @description\n   * Validator that performs no operation.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null { return null; }\n\n  /**\n   * @description\n   * Compose multiple validators into a single function that returns the union\n   * of the individual error maps for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error maps of the validators if the validation check fails, otherwise `null`.\n   */\n  static compose(validators: null): null;\n  static compose(validators: (ValidatorFn|null|undefined)[]): ValidatorFn|null;\n  static compose(validators: (ValidatorFn|null|undefined)[]|null): ValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: ValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      return _mergeErrors(_executeValidators(control, presentValidators));\n    };\n  }\n\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n  */\n  static composeAsync(validators: (AsyncValidatorFn|null)[]): AsyncValidatorFn|null {\n    if (!validators) return null;\n    const presentValidators: AsyncValidatorFn[] = validators.filter(isPresent) as any;\n    if (presentValidators.length == 0) return null;\n\n    return function(control: AbstractControl) {\n      const observables = _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return forkJoin(observables).pipe(map(_mergeErrors));\n    };\n  }\n}\n\nfunction isPresent(o: any): boolean {\n  return o != null;\n}\n\nexport function toObservable(r: any): Observable<any> {\n  const obs = isPromise(r) ? from(r) : r;\n  if (!(isObservable(obs))) {\n    throw new Error(`Expected validator to return Promise or Observable.`);\n  }\n  return obs;\n}\n\nfunction _executeValidators(control: AbstractControl, validators: ValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _executeAsyncValidators(control: AbstractControl, validators: AsyncValidatorFn[]): any[] {\n  return validators.map(v => v(control));\n}\n\nfunction _mergeErrors(arrayOfErrors: ValidationErrors[]): ValidationErrors|null {\n  const res: {[key: string]: any} =\n      arrayOfErrors.reduce((res: ValidationErrors | null, errors: ValidationErrors | null) => {\n        return errors != null ? {...res !, ...errors} : res !;\n      }, {});\n  return Object.keys(res).length === 0 ? null : res;\n}\n"],"sourceRoot":""}