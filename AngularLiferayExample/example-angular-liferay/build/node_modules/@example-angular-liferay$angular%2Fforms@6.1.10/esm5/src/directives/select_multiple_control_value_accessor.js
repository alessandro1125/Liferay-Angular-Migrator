Liferay.Loader.define('@example-angular-liferay$angular/forms@6.1.10/esm5/src/directives/select_multiple_control_value_accessor', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { Directive, ElementRef, Host, Input, Optional, Renderer2, forwardRef, ÉµlooseIdentical as looseIdentical } from '@angular/core';
    import { NG_VALUE_ACCESSOR } from './control_value_accessor';
    export var SELECT_MULTIPLE_VALUE_ACCESSOR = {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(function () {
            return SelectMultipleControlValueAccessor;
        }),
        multi: true
    };
    function _buildValueString(id, value) {
        if (id == null) return "" + value;
        if (typeof value === 'string') value = "'" + value + "'";
        if (value && typeof value === 'object') value = 'Object';
        return (id + ": " + value).slice(0, 50);
    }
    function _extractId(valueString) {
        return valueString.split(':')[0];
    }
    /** Mock interface for HTMLCollection */
    var HTMLCollection = /** @class */function () {
        function HTMLCollection() {}
        return HTMLCollection;
    }();
    /**
     * The accessor for writing a value and listening to changes on a select element.
     *
     * @usageNotes
     * ### Caveat: Options selection
     *
     * Angular uses object identity to select options. It's possible for the identities of items
     * to change while the data does not. This can happen, for example, if the items are produced
     * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the
     * second response will produce objects with different identities.
     *
     * To customize the default option comparison algorithm, `<select multiple>` supports `compareWith`
     * input. `compareWith` takes a **function** which has two arguments: `option1` and `option2`.
     * If `compareWith` is given, Angular selects options by the return value of the function.
     *
     * ### Syntax
     *
     * ```
     * <select multiple [compareWith]="compareFn"  [(ngModel)]="selectedCountries">
     *     <option *ngFor="let country of countries" [ngValue]="country">
     *         {{country.name}}
     *     </option>
     * </select>
     *
     * compareFn(c1: Country, c2: Country): boolean {
     *     return c1 && c2 ? c1.id === c2.id : c1 === c2;
     * }
     * ```
     *
     * @ngModule ReactiveFormsModule
     * @ngModule FormsModule
     */
    var SelectMultipleControlValueAccessor = /** @class */function () {
        function SelectMultipleControlValueAccessor(_renderer, _elementRef) {
            this._renderer = _renderer;
            this._elementRef = _elementRef;
            /** @internal */
            this._optionMap = new Map();
            /** @internal */
            this._idCounter = 0;
            this.onChange = function (_) {};
            this.onTouched = function () {};
            this._compareWith = looseIdentical;
        }
        Object.defineProperty(SelectMultipleControlValueAccessor.prototype, "compareWith", {
            set: function (fn) {
                if (typeof fn !== 'function') {
                    throw new Error("compareWith must be a function, but received " + JSON.stringify(fn));
                }
                this._compareWith = fn;
            },
            enumerable: true,
            configurable: true
        });
        SelectMultipleControlValueAccessor.prototype.writeValue = function (value) {
            var _this = this;
            this.value = value;
            var optionSelectedStateSetter;
            if (Array.isArray(value)) {
                // convert values to ids
                var ids_1 = value.map(function (v) {
                    return _this._getOptionId(v);
                });
                optionSelectedStateSetter = function (opt, o) {
                    opt._setSelected(ids_1.indexOf(o.toString()) > -1);
                };
            } else {
                optionSelectedStateSetter = function (opt, o) {
                    opt._setSelected(false);
                };
            }
            this._optionMap.forEach(optionSelectedStateSetter);
        };
        SelectMultipleControlValueAccessor.prototype.registerOnChange = function (fn) {
            var _this = this;
            this.onChange = function (_) {
                var selected = [];
                if (_.hasOwnProperty('selectedOptions')) {
                    var options = _.selectedOptions;
                    for (var i = 0; i < options.length; i++) {
                        var opt = options.item(i);
                        var val = _this._getOptionValue(opt.value);
                        selected.push(val);
                    }
                }
                // Degrade on IE
                else {
                        var options = _.options;
                        for (var i = 0; i < options.length; i++) {
                            var opt = options.item(i);
                            if (opt.selected) {
                                var val = _this._getOptionValue(opt.value);
                                selected.push(val);
                            }
                        }
                    }
                _this.value = selected;
                fn(selected);
            };
        };
        SelectMultipleControlValueAccessor.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        SelectMultipleControlValueAccessor.prototype.setDisabledState = function (isDisabled) {
            this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
        };
        /** @internal */
        SelectMultipleControlValueAccessor.prototype._registerOption = function (value) {
            var id = (this._idCounter++).toString();
            this._optionMap.set(id, value);
            return id;
        };
        /** @internal */
        SelectMultipleControlValueAccessor.prototype._getOptionId = function (value) {
            var e_1, _a;
            try {
                for (var _b = tslib_1.__values(Array.from(this._optionMap.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var id = _c.value;
                    if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
                }
            } catch (e_1_1) {
                e_1 = { error: e_1_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_1) throw e_1.error;
                }
            }
            return null;
        };
        /** @internal */
        SelectMultipleControlValueAccessor.prototype._getOptionValue = function (valueString) {
            var id = _extractId(valueString);
            return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
        };
        tslib_1.__decorate([Input(), tslib_1.__metadata("design:type", Function), tslib_1.__metadata("design:paramtypes", [Function])], SelectMultipleControlValueAccessor.prototype, "compareWith", null);
        SelectMultipleControlValueAccessor = tslib_1.__decorate([Directive({
            selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
            host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
            providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
        }), tslib_1.__metadata("design:paramtypes", [Renderer2, ElementRef])], SelectMultipleControlValueAccessor);
        return SelectMultipleControlValueAccessor;
    }();
    export { SelectMultipleControlValueAccessor };
    /**
     * Marks `<option>` as dynamic, so Angular can be notified when options change.
     *
     * @usageNotes
     * ### Example
     *
     * ```
     * <select multiple name="city" ngModel>
     *   <option *ngFor="let c of cities" [value]="c"></option>
     * </select>
     * ```
     * @ngModule FormsModule
     * @ngModule ReactiveFormsModule
     */
    var NgSelectMultipleOption = /** @class */function () {
        function NgSelectMultipleOption(_element, _renderer, _select) {
            this._element = _element;
            this._renderer = _renderer;
            this._select = _select;
            if (this._select) {
                this.id = this._select._registerOption(this);
            }
        }
        Object.defineProperty(NgSelectMultipleOption.prototype, "ngValue", {
            set: function (value) {
                if (this._select == null) return;
                this._value = value;
                this._setElementValue(_buildValueString(this.id, value));
                this._select.writeValue(this._select.value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgSelectMultipleOption.prototype, "value", {
            set: function (value) {
                if (this._select) {
                    this._value = value;
                    this._setElementValue(_buildValueString(this.id, value));
                    this._select.writeValue(this._select.value);
                } else {
                    this._setElementValue(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        /** @internal */
        NgSelectMultipleOption.prototype._setElementValue = function (value) {
            this._renderer.setProperty(this._element.nativeElement, 'value', value);
        };
        /** @internal */
        NgSelectMultipleOption.prototype._setSelected = function (selected) {
            this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
        };
        NgSelectMultipleOption.prototype.ngOnDestroy = function () {
            if (this._select) {
                this._select._optionMap.delete(this.id);
                this._select.writeValue(this._select.value);
            }
        };
        tslib_1.__decorate([Input('ngValue'), tslib_1.__metadata("design:type", Object), tslib_1.__metadata("design:paramtypes", [Object])], NgSelectMultipleOption.prototype, "ngValue", null);
        tslib_1.__decorate([Input('value'), tslib_1.__metadata("design:type", Object), tslib_1.__metadata("design:paramtypes", [Object])], NgSelectMultipleOption.prototype, "value", null);
        NgSelectMultipleOption = tslib_1.__decorate([Directive({ selector: 'option' }), tslib_1.__param(2, Optional()), tslib_1.__param(2, Host()), tslib_1.__metadata("design:paramtypes", [ElementRef, Renderer2, SelectMultipleControlValueAccessor])], NgSelectMultipleOption);
        return NgSelectMultipleOption;
    }();
    export { NgSelectMultipleOption };
});
//# sourceMappingURL=select_multiple_control_value_accessor.js.map