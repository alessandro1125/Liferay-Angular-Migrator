Liferay.Loader.define('@example-angular-liferay$angular/forms@6.1.10/esm5/src/directives/ng_model_group', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { Directive, Host, Inject, Input, Optional, Self, SkipSelf, forwardRef } from '@angular/core';
    import { NG_ASYNC_VALIDATORS, NG_VALIDATORS } from '../validators';
    import { AbstractFormGroupDirective } from './abstract_form_group_directive';
    import { ControlContainer } from './control_container';
    import { NgForm } from './ng_form';
    import { TemplateDrivenErrors } from './template_driven_errors';
    export var modelGroupProvider = {
        provide: ControlContainer,
        useExisting: forwardRef(function () {
            return NgModelGroup;
        })
    };
    /**
     * @description
     *
     * Creates and binds a `FormGroup` instance to a DOM element.
     *
     * This directive can only be used as a child of `NgForm` (or in other words,
     * within `<form>` tags).
     *
     * Use this directive if you'd like to create a sub-group within a form. This can
     * come in handy if you want to validate a sub-group of your form separately from
     * the rest of your form, or if some values in your domain model make more sense to
     * consume together in a nested object.
     *
     * Pass in the name you'd like this sub-group to have and it will become the key
     * for the sub-group in the form's full value. You can also export the directive into
     * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
     *
     * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
     *
     * @ngModule FormsModule
     */
    var NgModelGroup = /** @class */function (_super) {
        tslib_1.__extends(NgModelGroup, _super);
        function NgModelGroup(parent, validators, asyncValidators) {
            var _this = _super.call(this) || this;
            _this._parent = parent;
            _this._validators = validators;
            _this._asyncValidators = asyncValidators;
            return _this;
        }
        NgModelGroup_1 = NgModelGroup;
        /** @internal */
        NgModelGroup.prototype._checkParentType = function () {
            if (!(this._parent instanceof NgModelGroup_1) && !(this._parent instanceof NgForm)) {
                TemplateDrivenErrors.modelGroupParentException();
            }
        };
        var NgModelGroup_1;
        tslib_1.__decorate([Input('ngModelGroup'), tslib_1.__metadata("design:type", String)], NgModelGroup.prototype, "name", void 0);
        NgModelGroup = NgModelGroup_1 = tslib_1.__decorate([Directive({ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' }), tslib_1.__param(0, Host()), tslib_1.__param(0, SkipSelf()), tslib_1.__param(1, Optional()), tslib_1.__param(1, Self()), tslib_1.__param(1, Inject(NG_VALIDATORS)), tslib_1.__param(2, Optional()), tslib_1.__param(2, Self()), tslib_1.__param(2, Inject(NG_ASYNC_VALIDATORS)), tslib_1.__metadata("design:paramtypes", [ControlContainer, Array, Array])], NgModelGroup);
        return NgModelGroup;
    }(AbstractFormGroupDirective);
    export { NgModelGroup };
});
//# sourceMappingURL=ng_model_group.js.map