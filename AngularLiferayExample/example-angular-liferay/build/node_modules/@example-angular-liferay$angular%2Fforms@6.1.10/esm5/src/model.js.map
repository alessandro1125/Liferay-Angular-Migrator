{"version":3,"sources":["../../../../../../../../../packages/forms/src/model.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '@angular/core';\nimport {Observable} from 'rxjs';\nimport {composeAsyncValidators, composeValidators} from './directives/shared';\nimport {AsyncValidatorFn, ValidationErrors, ValidatorFn} from './directives/validators';\nimport {toObservable} from './validators';\n\n/**\n * Reports that a FormControl is valid, meaning that no errors exist in the input value.\n *\n * @see `status`\n */\nexport const VALID = 'VALID';\n\n/**\n * Reports that a FormControl is invalid, meaning that an error exists in the input value.\n *\n * @see `status`\n */\nexport const INVALID = 'INVALID';\n\n/**\n * Reports that a FormControl is pending, meaning that that async validation is occurring and\n * errors are not yet available for the input value.\n *\n * @see `markAsPending`\n * @see `status`\n */\nexport const PENDING = 'PENDING';\n\n/**\n * Reports that a FormControl is disabled, meaning that the control is exempt from ancestor\n * calculations of validity or value.\n *\n * @see `markAsDisabled`\n * @see `status`\n */\nexport const DISABLED = 'DISABLED';\n\nfunction _find(control: AbstractControl, path: Array<string|number>| string, delimiter: string) {\n  if (path == null) return null;\n\n  if (!(path instanceof Array)) {\n    path = (<string>path).split(delimiter);\n  }\n  if (path instanceof Array && (path.length === 0)) return null;\n\n  return (<Array<string|number>>path).reduce((v: AbstractControl, name) => {\n    if (v instanceof FormGroup) {\n      return v.controls.hasOwnProperty(name as string) ? v.controls[name] : null;\n    }\n\n    if (v instanceof FormArray) {\n      return v.at(<number>name) || null;\n    }\n\n    return null;\n  }, control);\n}\n\nfunction coerceToValidator(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): ValidatorFn|\n    null {\n  const validator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).validators :\n                                       validatorOrOpts) as ValidatorFn |\n      ValidatorFn[] | null;\n\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\n\nfunction coerceToAsyncValidator(\n    asyncValidator?: AsyncValidatorFn | AsyncValidatorFn[] | null, validatorOrOpts?: ValidatorFn |\n        ValidatorFn[] | AbstractControlOptions | null): AsyncValidatorFn|null {\n  const origAsyncValidator =\n      (isOptionsObj(validatorOrOpts) ? (validatorOrOpts as AbstractControlOptions).asyncValidators :\n                                       asyncValidator) as AsyncValidatorFn |\n      AsyncValidatorFn | null;\n\n  return Array.isArray(origAsyncValidator) ? composeAsyncValidators(origAsyncValidator) :\n                                             origAsyncValidator || null;\n}\n\nexport type FormHooks = 'change' | 'blur' | 'submit';\n\n/**\n * Interface for options provided to an `AbstractControl`.\n *\n * @experimental\n */\nexport interface AbstractControlOptions {\n  /**\n   * List of validators applied to control.\n   */\n  validators?: ValidatorFn|ValidatorFn[]|null;\n  /**\n   * List of async validators applied to control.\n   */\n  asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;\n  /**\n   * The event name for control to update upon.\n   */\n  updateOn?: 'change'|'blur'|'submit';\n}\n\n\nfunction isOptionsObj(\n    validatorOrOpts?: ValidatorFn | ValidatorFn[] | AbstractControlOptions | null): boolean {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&\n      typeof validatorOrOpts === 'object';\n}\n\n\n/**\n * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.\n *\n * It provides some of the shared behavior that all controls and groups of controls have, like\n * running validators, calculating status, and resetting state. It also defines the properties\n * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be\n * instantiated directly.\n *\n * @see [Forms Guide](/guide/forms)\n * @see [Reactive Forms Guide](/guide/reactive-forms)\n * @see [Dynamic Forms Guide](/guide/dynamic-form)\n *\n */\nexport abstract class AbstractControl {\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingDirty !: boolean;\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _pendingTouched !: boolean;\n\n  /** @internal */\n  _onCollectionChange = () => {};\n\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _updateOn !: FormHooks;\n\n  // TODO(issue/24571): remove '!'.\n  private _parent !: FormGroup | FormArray;\n  private _asyncValidationSubscription: any;\n\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For a `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  public readonly value: any;\n\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validator The function that determines the synchronous validity of this control.\n   * @param asyncValidator The function that determines the asynchronous validity of this\n   * control.\n   */\n  constructor(public validator: ValidatorFn|null, public asyncValidator: AsyncValidatorFn|null) {}\n\n  /**\n   * The parent control.\n   */\n  get parent(): FormGroup|FormArray { return this._parent; }\n\n  /**\n   * The validation status of the control. There are four possible\n   * validation status values:\n   *\n   * * **VALID**: This control has passed all validation checks.\n   * * **INVALID**: This control has failed at least one validation check.\n   * * **PENDING**: This control is in the midst of conducting a validation check.\n   * * **DISABLED**: This control is exempt from validation checks.\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly status !: string;\n\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid(): boolean { return this.status === VALID; }\n\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid(): boolean { return this.status === INVALID; }\n\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see `status`\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending(): boolean { return this.status == PENDING; }\n\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * @see `status`\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled(): boolean { return this.status === DISABLED; }\n\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @see `status`\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   */\n  get enabled(): boolean { return this.status !== DISABLED; }\n\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly errors !: ValidationErrors | null;\n\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  public readonly pristine: boolean = true;\n\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty(): boolean { return !this.pristine; }\n\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  public readonly touched: boolean = false;\n\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched(): boolean { return !this.touched; }\n\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly valueChanges !: Observable<any>;\n\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   */\n  // TODO(issue/24571): remove '!'.\n  public readonly statusChanges !: Observable<any>;\n\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn(): FormHooks {\n    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');\n  }\n\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing sync validators.\n   */\n  setValidators(newValidator: ValidatorFn|ValidatorFn[]|null): void {\n    this.validator = coerceToValidator(newValidator);\n  }\n\n  /**\n   * Sets the async validators that are active on this control. Calling this\n   * overwrites any existing async validators.\n   */\n  setAsyncValidators(newValidator: AsyncValidatorFn|AsyncValidatorFn[]|null): void {\n    this.asyncValidator = coerceToAsyncValidator(newValidator);\n  }\n\n  /**\n   * Empties out the sync validator list.\n   */\n  clearValidators(): void { this.validator = null; }\n\n  /**\n   * Empties out the async validator list.\n   */\n  clearAsyncValidators(): void { this.asyncValidator = null; }\n\n  /**\n   * Marks the control as `touched`. A control is touched by focus and\n   * blur events that do not change the value; compare `markAsDirty`;\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = true;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `untouched`.\n   *\n   * If the control has any children, also marks all children as `untouched`\n   * and recalculates the `touched` status of all parent controls.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after the marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = false;\n    this._pendingTouched = false;\n\n    this._forEachChild(\n        (control: AbstractControl) => { control.markAsUntouched({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `dirty`. A control becomes dirty when\n   * the control's is changed through the UI; compare `markAsTouched`.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   */\n  markAsDirty(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = false;\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pristine`.\n   *\n   * If the control has any children, marks all children as `pristine`,\n   * and recalculates the `pristine` status of all parent\n   * controls.\n   *\n   *  @param opts Configuration options that determine how the control emits events after\n   * marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   */\n  markAsPristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = true;\n    this._pendingDirty = false;\n\n    this._forEachChild((control: AbstractControl) => { control.markAsPristine({onlySelf: true}); });\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /**\n   * Marks the control as `pending`.\n   *\n   * A control is pending while the control performs async validation.\n   *\n   *  @param opts Configuration options that determine how the control propagates changes and\n   * emits events after marking is applied.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`\n   * observable emits an event with the latest status the control is marked pending.\n   * When false, no events are emitted.\n   *\n   */\n  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = PENDING;\n\n    if (opts.emitEvent !== false) {\n      (this.statusChanges as EventEmitter<any>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(opts);\n    }\n  }\n\n  /**\n   * Disables the control. This means the control is exempt from validation checks and\n   * excluded from the aggregate value of any parent. Its status is `DISABLED`.\n   *\n   * If the control has children, all children are also disabled.\n   *\n   *  @param opts Configuration options that determine how the control propagates\n   * changes and emits events after the control is disabled.\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is disabled.\n   * When false, no events are emitted.\n   */\n  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = DISABLED;\n    (this as{errors: ValidationErrors | null}).errors = null;\n    this._forEachChild(\n        (control: AbstractControl) => { control.disable({...opts, onlySelf: true}); });\n    this._updateValue();\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   *  @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    (this as{status: string}).status = VALID;\n    this._forEachChild(\n        (control: AbstractControl) => { control.enable({...opts, onlySelf: true}); });\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n\n    this._updateAncestors(opts);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n\n  private _updateAncestors(opts: {onlySelf?: boolean, emitEvent?: boolean}) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      this._parent._updatePristine();\n      this._parent._updateTouched();\n    }\n  }\n\n  /**\n   * @param parent Sets the parent of the control\n   */\n  setParent(parent: FormGroup|FormArray): void { this._parent = parent; }\n\n  /**\n   * Sets the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract setValue(value: any, options?: Object): void;\n\n  /**\n   * Patches the value of the control. Abstract method (implemented in sub-classes).\n   */\n  abstract patchValue(value: any, options?: Object): void;\n\n  /**\n   * Resets the control. Abstract method (implemented in sub-classes).\n   */\n  abstract reset(value?: any, options?: Object): void;\n\n  /**\n   * Recalculates the value and validation status of the control.\n   *\n   * By default, it also updates the value and validity of its ancestors.\n   *\n   * @param opts Configuration options determine how the control propagates changes and emits events\n   * after updates and validity checks are applied.\n   * * `onlySelf`: When true, only update this control. When false or not supplied,\n   * update all direct ancestors. Default is false..\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is updated.\n   * When false, no events are emitted.\n   */\n  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._setInitialStatus();\n    this._updateValue();\n\n    if (this.enabled) {\n      this._cancelExistingSubscription();\n      (this as{errors: ValidationErrors | null}).errors = this._runValidator();\n      (this as{status: string}).status = this._calculateStatus();\n\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(opts.emitEvent);\n      }\n    }\n\n    if (opts.emitEvent !== false) {\n      (this.valueChanges as EventEmitter<any>).emit(this.value);\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}) {\n    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});\n  }\n\n  private _setInitialStatus() {\n    (this as{status: string}).status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n\n  private _runValidator(): ValidationErrors|null {\n    return this.validator ? this.validator(this) : null;\n  }\n\n  private _runAsyncValidator(emitEvent?: boolean): void {\n    if (this.asyncValidator) {\n      (this as{status: string}).status = PENDING;\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription =\n          obs.subscribe((errors: ValidationErrors | null) => this.setErrors(errors, {emitEvent}));\n    }\n  }\n\n  private _cancelExistingSubscription(): void {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n    }\n  }\n\n  /**\n   * Sets errors on a form control when running validations manually, rather than automatically.\n   *\n   * Calling `setErrors` also updates the validity of the parent control.\n   *\n   * @usageNotes\n   * ### Manually set the errors for a control\n   *\n   * ```\n   * const login = new FormControl('someLogin');\n   * login.setErrors({\n   *   notUnique: true\n   * });\n   *\n   * expect(login.valid).toEqual(false);\n   * expect(login.errors).toEqual({ notUnique: true });\n   *\n   * login.setValue('someOtherLogin');\n   *\n   * expect(login.valid).toEqual(true);\n   * ```\n   */\n  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {\n    (this as{errors: ValidationErrors | null}).errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false);\n  }\n\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name']);`\n   */\n  get(path: Array<string|number>|string): AbstractControl|null { return _find(this, path, '.'); }\n\n  /**\n   * Reports error data for a specific error occurring in this control or in another control.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   *\n   * @returns The error data if the control with the given path has the given error, otherwise null\n   * or undefined.\n   */\n  getError(errorCode: string, path?: string[]): any {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n\n  /**\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The error code for which to retrieve data\n   * @param path The path to a control to check. If not supplied, checks for the error in this\n   * control.\n   * @returns True when the control with the given path has the error, otherwise false.\n   */\n  hasError(errorCode: string, path?: string[]): boolean { return !!this.getError(errorCode, path); }\n\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root(): AbstractControl {\n    let x: AbstractControl = this;\n\n    while (x._parent) {\n      x = x._parent;\n    }\n\n    return x;\n  }\n\n  /** @internal */\n  _updateControlsErrors(emitEvent: boolean): void {\n    (this as{status: string}).status = this._calculateStatus();\n\n    if (emitEvent) {\n      (this.statusChanges as EventEmitter<string>).emit(this.status);\n    }\n\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent);\n    }\n  }\n\n  /** @internal */\n  _initObservables() {\n    (this as{valueChanges: Observable<any>}).valueChanges = new EventEmitter();\n    (this as{statusChanges: Observable<any>}).statusChanges = new EventEmitter();\n  }\n\n\n  private _calculateStatus(): string {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n\n  /** @internal */\n  abstract _updateValue(): void;\n\n  /** @internal */\n  abstract _forEachChild(cb: Function): void;\n\n  /** @internal */\n  abstract _anyControls(condition: Function): boolean;\n\n  /** @internal */\n  abstract _allControlsDisabled(): boolean;\n\n  /** @internal */\n  abstract _syncPendingControls(): boolean;\n\n  /** @internal */\n  _anyControlsHaveStatus(status: string): boolean {\n    return this._anyControls((control: AbstractControl) => control.status === status);\n  }\n\n  /** @internal */\n  _anyControlsDirty(): boolean {\n    return this._anyControls((control: AbstractControl) => control.dirty);\n  }\n\n  /** @internal */\n  _anyControlsTouched(): boolean {\n    return this._anyControls((control: AbstractControl) => control.touched);\n  }\n\n  /** @internal */\n  _updatePristine(opts: {onlySelf?: boolean} = {}): void {\n    (this as{pristine: boolean}).pristine = !this._anyControlsDirty();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts);\n    }\n  }\n\n  /** @internal */\n  _updateTouched(opts: {onlySelf?: boolean} = {}): void {\n    (this as{touched: boolean}).touched = this._anyControlsTouched();\n\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts);\n    }\n  }\n\n  /** @internal */\n  _onDisabledChange: Function[] = [];\n\n  /** @internal */\n  _isBoxedValue(formState: any): boolean {\n    return typeof formState === 'object' && formState !== null &&\n        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;\n  }\n\n  /** @internal */\n  _registerOnCollectionChange(fn: () => void): void { this._onCollectionChange = fn; }\n\n  /** @internal */\n  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {\n    if (isOptionsObj(opts) && (opts as AbstractControlOptions).updateOn != null) {\n      this._updateOn = (opts as AbstractControlOptions).updateOn !;\n    }\n  }\n}\n\n/**\n * Tracks the value and validation status of an individual form control.\n *\n * This is one of the three fundamental building blocks of Angular forms, along with\n * `FormGroup` and `FormArray`. It extends the `AbstractControl` class that\n * implements most of the base functionality for accessing the value, validation status,\n * user interactions and events.\n *\n * @see `AbstractControl`\n * @see [Reactive Forms Guide](guide/reactive-forms)\n * @see [Usage Notes](#usage-notes)\n *\n * @usageNotes\n *\n * ### Initializing Form Controls\n *\n * Instantiate a `FormControl`, with an initial value.\n *\n * ```ts\n * const control = new FormControl('some value');\n * console.log(control.value);     // 'some value'\n *```\n *\n * The following example initializes the control with a form state object. The `value`\n * and `disabled` keys are required in this case.\n *\n * ```ts\n * const control = new FormControl({ value: 'n/a', disabled: true });\n * console.log(control.value);     // 'n/a'\n * console.log(control.status);    // 'DISABLED'\n * ```\n *\n * The following example initializes the control with a sync validator.\n *\n * ```ts\n * const control = new FormControl('', Validators.required);\n * console.log(control.value);      // ''\n * console.log(control.status);     // 'INVALID'\n * ```\n *\n * The following example initializes the control using an options object.\n *\n * ```ts\n * const control = new FormControl('', {\n *    validators: Validators.required,\n *    asyncValidators: myAsyncValidator\n * });\n * ```\n *\n * ### Configure the control to update on a blur event\n *\n * Set the `updateOn` option to `'blur'` to update on the blur `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'blur' });\n * ```\n *\n * ### Configure the control to update on a submit event\n *\n * Set the `updateOn` option to `'submit'` to update on a submit `event`.\n *\n * ```ts\n * const control = new FormControl('', { updateOn: 'submit' });\n * ```\n *\n * ### Reset the control back to an initial value\n *\n * You reset to a specific form state by passing through a standalone\n * value or a form state object that contains both a value and a disabled state\n * (these are the only two properties that cannot be calculated).\n *\n * ```ts\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n *\n * control.reset('Drew');\n *\n * console.log(control.value); // 'Drew'\n * ```\n *\n * ### Reset the control back to an initial value and disabled\n *\n * ```\n * const control = new FormControl('Nancy');\n *\n * console.log(control.value); // 'Nancy'\n * console.log(control.status); // 'VALID'\n *\n * control.reset({ value: 'Drew', disabled: true });\n *\n * console.log(control.value); // 'Drew'\n * console.log(control.status); // 'DISABLED'\n *\n*/\nexport class FormControl extends AbstractControl {\n  /** @internal */\n  _onChange: Function[] = [];\n\n  /** @internal */\n  _pendingValue: any;\n\n  /** @internal */\n  _pendingChange: any;\n\n  /**\n  * Creates a new `FormControl` instance.\n  *\n  * @param formState Initializes the control with an initial value,\n  * or an object that defines the initial value and disabled state.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      formState: any = null,\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n    this._initObservables();\n  }\n\n  /**\n   * Sets a new value for the form control.\n   *\n   * @param value The new value for the control.\n   * @param options Configuration options that determine how the control proopagates changes\n   * and emits events when the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * * `emitModelToViewChange`: When true or not supplied  (the default), each change triggers an\n   * `onChange` event to\n   * update the view.\n   * * `emitViewToModelChange`: When true or not supplied (the default), each change triggers an\n   * `ngModelChange`\n   * event to update the model.\n   *\n   */\n  setValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    (this as{value: any}).value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach(\n          (changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of a control.\n   *\n   * This function is functionally the same as {@link FormControl#setValue setValue} at this level.\n   * It exists for symmetry with {@link FormGroup#patchValue patchValue} on `FormGroups` and\n   * `FormArrays`, where it does behave differently.\n   *\n   * @see `setValue` for options\n   */\n  patchValue(value: any, options: {\n    onlySelf?: boolean,\n    emitEvent?: boolean,\n    emitModelToViewChange?: boolean,\n    emitViewToModelChange?: boolean\n  } = {}): void {\n    this.setValue(value, options);\n  }\n\n  /**\n   * Resets the form control, marking it `pristine` and `untouched`, and setting\n   * the value to null.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   *\n   */\n  reset(formState: any = null, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n\n  /**\n   * @internal\n   */\n  _updateValue() {}\n\n  /**\n   * @internal\n   */\n  _anyControls(condition: Function): boolean { return false; }\n\n  /**\n   * @internal\n   */\n  _allControlsDisabled(): boolean { return this.disabled; }\n\n  /**\n   * Register a listener for change events.\n   *\n   * @param fn The method that is called when the value changes\n   */\n  registerOnChange(fn: Function): void { this._onChange.push(fn); }\n\n  /**\n   * @internal\n   */\n  _clearChangeFns(): void {\n    this._onChange = [];\n    this._onDisabledChange = [];\n    this._onCollectionChange = () => {};\n  }\n\n  /**\n   * Register a listener for disabled events.\n   *\n   * @param fn The method that is called when the disabled status changes.\n   */\n  registerOnDisabledChange(fn: (isDisabled: boolean) => void): void {\n    this._onDisabledChange.push(fn);\n  }\n\n  /**\n   * @internal\n   */\n  _forEachChild(cb: Function): void {}\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    if (this.updateOn === 'submit') {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {onlySelf: true, emitModelToViewChange: false});\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private _applyFormState(formState: any) {\n    if (this._isBoxedValue(formState)) {\n      (this as{value: any}).value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({onlySelf: true, emitEvent: false}) :\n                           this.enable({onlySelf: true, emitEvent: false});\n    } else {\n      (this as{value: any}).value = this._pendingValue = formState;\n    }\n  }\n}\n\n/**\n * Tracks the value and validity state of a group of `FormControl` instances.\n *\n * A `FormGroup` aggregates the values of each child `FormControl` into one object,\n * with each control name as the key.  It calculates its status by reducing the status values\n * of its children. For example, if one of the controls in a group is invalid, the entire\n * group becomes invalid.\n *\n * `FormGroup` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormArray`.\n *\n * When instantiating a `FormGroup`, pass in a collection of child controls as the first\n * argument. The key for each child registers the name for the control.\n *\n * @usageNotes\n *\n * ### Create a form group with 2 controls\n *\n * ```\n * const form = new FormGroup({\n *   first: new FormControl('Nancy', Validators.minLength(2)),\n *   last: new FormControl('Drew'),\n * });\n *\n * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}\n * console.log(form.status);  // 'VALID'\n * ```\n *\n * ### Create a form group with a group-level validator\n *\n * You include group-level validators as the second arg, or group-level async\n * validators as the third arg. These come in handy when you want to perform validation\n * that considers the value of more than one child control.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('', Validators.minLength(2)),\n *   passwordConfirm: new FormControl('', Validators.minLength(2)),\n * }, passwordMatchValidator);\n *\n *\n * function passwordMatchValidator(g: FormGroup) {\n *    return g.get('password').value === g.get('passwordConfirm').value\n *       ? null : {'mismatch': true};\n * }\n * ```\n *\n * Like `FormControl` instances, you choose to pass in\n * validators and async validators as part of an options object.\n *\n * ```\n * const form = new FormGroup({\n *   password: new FormControl('')\n *   passwordConfirm: new FormControl('')\n * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });\n * ```\n *\n * ### Set the updateOn property for all controls in a form group\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * group level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const c = new FormGroup({\n *   one: new FormControl()\n * }, { updateOn: 'blur' });\n * ```\n */\nexport class FormGroup extends AbstractControl {\n  /**\n  * Creates a new `FormGroup` instance.\n  *\n  * @param controls A collection of child controls. The key for each child is the name\n  * under which it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: {[key: string]: AbstractControl},\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Registers a control with the group's list of controls.\n   *\n   * This method does not update the value or validity of the control.\n   * Use {@link FormGroup#addControl addControl} instead.\n   *\n   * @param name The control name to register in the collection\n   * @param control Provides the control for the given name\n   */\n  registerControl(name: string, control: AbstractControl): AbstractControl {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n\n  /**\n   * Add a control to this group.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to add to the collection\n   * @param control Provides the control for the given name\n   */\n  addControl(name: string, control: AbstractControl): void {\n    this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Remove a control from this group.\n   *\n   * @param name The control name to remove from the collection\n   */\n  removeControl(name: string): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param name The control name to replace in the collection\n   * @param control Provides the control for the given name\n   */\n  setControl(name: string, control: AbstractControl): void {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {});\n    delete (this.controls[name]);\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Check whether there is an enabled control with the given name in the group.\n   *\n   * Reports false for disabled controls. If you'd like to check for existence in the group\n   * only, use {@link AbstractControl#get get} instead.\n   *\n   * @param name The control name to check for existence in the collection\n   *\n   * @returns false for disabled controls, true otherwise.\n   */\n  contains(controlName: string): boolean {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you excluding the value of a control.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    this._checkAllValuesPresent(value);\n    Object.keys(value).forEach(name => {\n      this._throwIfControlMissing(name);\n      this.controls[name].setValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: {[key: string]: any}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}):\n      void {\n    Object.keys(value).forEach(name => {\n      if (this.controls[name]) {\n        this.controls[name].patchValue(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormGroup`, marks all descendants are marked `pristine` and `untouched`, and\n   * the value of all descendants to null.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param formState Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(this.form.value);  // {first: 'name', last: 'last name'}\n   * console.log(this.form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  reset(value: any = {}, options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      control.reset(value[name], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   * The `value` property is the best way to get the value of the group, because\n   * it excludes disabled controls in the `FormGroup`.\n   */\n  getRawValue(): any {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          acc[name] = control instanceof FormControl ? control.value : (<any>control).getRawValue();\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this._reduceChildren(false, (updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(name: string): void {\n    if (!Object.keys(this.controls).length) {\n      throw new Error(`\n        There are no form controls registered with this group yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.controls[name]) {\n      throw new Error(`Cannot find form control with name: ${name}.`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: (v: any, k: string) => void): void {\n    Object.keys(this.controls).forEach(k => cb(this.controls[k], k));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n\n  /** @internal */\n  _updateValue(): void { (this as{value: any}).value = this._reduceValue(); }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    let res = false;\n    this._forEachChild((control: AbstractControl, name: string) => {\n      res = res || (this.contains(name) && condition(control));\n    });\n    return res;\n  }\n\n  /** @internal */\n  _reduceValue() {\n    return this._reduceChildren(\n        {}, (acc: {[k: string]: AbstractControl}, control: AbstractControl, name: string) => {\n          if (control.enabled || this.disabled) {\n            acc[name] = control.value;\n          }\n          return acc;\n        });\n  }\n\n  /** @internal */\n  _reduceChildren(initValue: any, fn: Function) {\n    let res = initValue;\n    this._forEachChild(\n        (control: AbstractControl, name: string) => { res = fn(res, control, name); });\n    return res;\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, name: string) => {\n      if (value[name] === undefined) {\n        throw new Error(`Must supply a value for form control with name: '${name}'.`);\n      }\n    });\n  }\n}\n\n/**\n * Tracks the value and validity state of an array of `FormControl`,\n * `FormGroup` or `FormArray` instances.\n *\n * A `FormArray` aggregates the values of each child `FormControl` into an array.\n * It calculates its status by reducing the status values of its children. For example, if one of\n * the controls in a `FormArray` is invalid, the entire array becomes invalid.\n *\n * `FormArray` is one of the three fundamental building blocks used to define forms in Angular,\n * along with `FormControl` and `FormGroup`.\n *\n * @usageNotes\n *\n * ### Create an array of form controls\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy', Validators.minLength(2)),\n *   new FormControl('Drew'),\n * ]);\n *\n * console.log(arr.value);   // ['Nancy', 'Drew']\n * console.log(arr.status);  // 'VALID'\n * ```\n *\n * ### Create a form array with array-level validators\n *\n * You include array-level validators and async validators. These come in handy\n * when you want to perform validation that considers the value of more than one child\n * control.\n *\n * The two types of validators are passed in separately as the second and third arg\n * respectively, or together as part of an options object.\n *\n * ```\n * const arr = new FormArray([\n *   new FormControl('Nancy'),\n *   new FormControl('Drew')\n * ], {validators: myValidator, asyncValidators: myAsyncValidator});\n * ```\n *\n  * ### Set the updateOn property for all controls in a form array\n *\n * The options object is used to set a default value for each child\n * control's `updateOn` property. If you set `updateOn` to `'blur'` at the\n * array level, all child controls default to 'blur', unless the child\n * has explicitly specified a different `updateOn` value.\n *\n * ```ts\n * const arr = new FormArray([\n *    new FormControl()\n * ], {updateOn: 'blur'});\n * ```\n *\n * ### Adding or removing controls from a form array\n *\n * To change the controls in the array, use the `push`, `insert`, or `removeAt` methods\n * in `FormArray` itself. These methods ensure the controls are properly tracked in the\n * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate\n * the `FormArray` directly, as that result in strange and unexpected behavior such\n * as broken change detection.\n *\n *\n */\nexport class FormArray extends AbstractControl {\n  /**\n  * Creates a new `FormArray` instance.\n  *\n  * @param controls An array of child controls. Each child control is given an index\n  * where it is registered.\n  *\n  * @param validatorOrOpts A synchronous validator function, or an array of\n  * such functions, or an `AbstractControlOptions` object that contains validation functions\n  * and a validation trigger.\n  *\n  * @param asyncValidator A single async validator or array of async validator functions\n  *\n  */\n  constructor(\n      public controls: AbstractControl[],\n      validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null,\n      asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|null) {\n    super(\n        coerceToValidator(validatorOrOpts),\n        coerceToAsyncValidator(asyncValidator, validatorOrOpts));\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({onlySelf: true, emitEvent: false});\n  }\n\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control\n   */\n  at(index: number): AbstractControl { return this.controls[index]; }\n\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   */\n  push(control: AbstractControl): void {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control\n   * @param control Form control to be inserted\n   */\n  insert(index: number, control: AbstractControl): void {\n    this.controls.splice(index, 0, control);\n\n    this._registerControl(control);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control\n   */\n  removeAt(index: number): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n    this.updateValueAndValidity();\n  }\n\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control\n   * @param control The `AbstractControl` control to replace the existing control\n   */\n  setControl(index: number, control: AbstractControl): void {\n    if (this.controls[index]) this.controls[index]._registerOnCollectionChange(() => {});\n    this.controls.splice(index, 1);\n\n    if (control) {\n      this.controls.splice(index, 0, control);\n      this._registerControl(control);\n    }\n\n    this.updateValueAndValidity();\n    this._onCollectionChange();\n  }\n\n  /**\n   * Length of the control array.\n   */\n  get length(): number { return this.controls.length; }\n\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  setValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._checkAllValuesPresent(value);\n    value.forEach((newValue: any, index: number) => {\n      this._throwIfControlMissing(index);\n      this.at(index).setValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  patchValue(value: any[], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    value.forEach((newValue: any, index: number) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {onlySelf: true, emitEvent: options.emitEvent});\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```\n   * this.arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(this.arr.value);  // ['name', 'last name']\n   * console.log(this.arr.get(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  reset(value: any = [], options: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {\n    this._forEachChild((control: AbstractControl, index: number) => {\n      control.reset(value[index], {onlySelf: true, emitEvent: options.emitEvent});\n    });\n    this.updateValueAndValidity(options);\n    this._updatePristine(options);\n    this._updateTouched(options);\n  }\n\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   * For enabled controls only, the `value` property is the best way to get the value of the array.\n   */\n  getRawValue(): any[] {\n    return this.controls.map((control: AbstractControl) => {\n      return control instanceof FormControl ? control.value : (<any>control).getRawValue();\n    });\n  }\n\n  /** @internal */\n  _syncPendingControls(): boolean {\n    let subtreeUpdated = this.controls.reduce((updated: boolean, child: AbstractControl) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({onlySelf: true});\n    return subtreeUpdated;\n  }\n\n  /** @internal */\n  _throwIfControlMissing(index: number): void {\n    if (!this.controls.length) {\n      throw new Error(`\n        There are no form controls registered with this array yet.  If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      `);\n    }\n    if (!this.at(index)) {\n      throw new Error(`Cannot find form control at index ${index}`);\n    }\n  }\n\n  /** @internal */\n  _forEachChild(cb: Function): void {\n    this.controls.forEach((control: AbstractControl, index: number) => { cb(control, index); });\n  }\n\n  /** @internal */\n  _updateValue(): void {\n    (this as{value: any}).value =\n        this.controls.filter((control) => control.enabled || this.disabled)\n            .map((control) => control.value);\n  }\n\n  /** @internal */\n  _anyControls(condition: Function): boolean {\n    return this.controls.some((control: AbstractControl) => control.enabled && condition(control));\n  }\n\n  /** @internal */\n  _setUpControls(): void {\n    this._forEachChild((control: AbstractControl) => this._registerControl(control));\n  }\n\n  /** @internal */\n  _checkAllValuesPresent(value: any): void {\n    this._forEachChild((control: AbstractControl, i: number) => {\n      if (value[i] === undefined) {\n        throw new Error(`Must supply a value for form control at index: ${i}.`);\n      }\n    });\n  }\n\n  /** @internal */\n  _allControlsDisabled(): boolean {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n\n  private _registerControl(control: AbstractControl) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n}\n"],"sourceRoot":""}