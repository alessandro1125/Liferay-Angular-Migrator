{"version":3,"sources":["http.js"],"names":["Injectable","InjectionToken","Inject","PLATFORM_ID","Injector","NgModule","of","Observable","concatMap","filter","map","DOCUMENT","ɵparseCookieValue","HttpHandler","HttpBackend","HttpHeaders","constructor","headers","normalizedNames","Map","lazyUpdate","lazyInit","split","forEach","line","index","indexOf","name","slice","key","toLowerCase","value","trim","maybeSetNormalizedName","has","get","push","set","Object","keys","values","length","init","Array","from","getAll","append","clone","op","delete","lcName","copyFrom","update","applyUpdate","other","concat","base","undefined","toDelete","existing","fn","HttpUrlEncodingCodec","encodeKey","standardEncoding","encodeValue","decodeKey","decodeURIComponent","decodeValue","paramParser","rawParams","codec","map$$1","params","param","eqIdx","val","list","v","encodeURIComponent","replace","HttpParams","options","updates","cloneFrom","encoder","fromString","fromObject","Error","isArray","res","toString","eKey","join","idx","splice","mightHaveBody","method","isArrayBuffer","ArrayBuffer","isBlob","Blob","isFormData","FormData","HttpRequest","url","third","fourth","body","reportProgress","withCredentials","responseType","toUpperCase","urlWithParams","qIdx","sep","serializeBody","JSON","stringify","detectContentTypeHeader","type","setHeaders","reduce","setParams","HttpEventType","Sent","UploadProgress","ResponseHeader","DownloadProgress","Response","User","HttpResponseBase","defaultStatus","defaultStatusText","status","statusText","ok","HttpHeaderResponse","HttpResponse","HttpErrorResponse","message","error","addBody","observe","HttpClient","handler","request","first","req","events$","pipe","handle","res$","event","head","jsonp","callbackParam","patch","post","put","decorators","ctorParameters","HttpInterceptorHandler","next","interceptor","intercept","HTTP_INTERCEPTORS","NoopInterceptor","nextRequestId","JSONP_ERR_NO_CALLBACK","JSONP_ERR_WRONG_METHOD","JSONP_ERR_WRONG_RESPONSE_TYPE","JsonpCallbackContext","JsonpClientBackend","callbackMap","document","nextCallback","observer","callback","node","createElement","src","finished","cancelled","data","cleanup","parentNode","removeChild","onLoad","complete","onError","addEventListener","appendChild","removeEventListener","args","JsonpInterceptor","XSSI_PREFIX","getResponseUrl","xhr","responseURL","test","getAllResponseHeaders","getResponseHeader","XhrFactory","BrowserXhr","build","XMLHttpRequest","HttpXhrBackend","xhrFactory","open","setRequestHeader","detectedType","reqBody","headerResponse","partialFromXhr","response","responseText","originalBody","parse","text","sentHeaders","onDownProgress","progressEvent","loaded","lengthComputable","total","partialText","onUpProgress","progress","upload","send","abort","XSRF_COOKIE_NAME","XSRF_HEADER_NAME","HttpXsrfTokenExtractor","HttpXsrfCookieExtractor","doc","platform","cookieName","lastCookieString","lastToken","parseCount","getToken","cookieString","cookie","String","HttpXsrfInterceptor","tokenService","headerName","lcUrl","startsWith","token","HttpInterceptingHandler","backend","injector","chain","interceptors","reduceRight","jsonpCallbackContext","window","HttpClientXsrfModule","disable","ngModule","providers","provide","useClass","withOptions","useValue","useExisting","multi","HttpClientModule","imports","HttpClientJsonpModule","useFactory","ɵangular_packages_common_http_http_a","ɵangular_packages_common_http_http_b","ɵangular_packages_common_http_http_c","ɵangular_packages_common_http_http_d","ɵangular_packages_common_http_http_g","ɵangular_packages_common_http_http_h","ɵangular_packages_common_http_http_e","ɵangular_packages_common_http_http_f","ɵHttpInterceptingHandler"],"mappings":"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","file":"http.js","sourcesContent":["/**\n * @license Angular v6.1.10\n * (c) 2010-2018 Google, Inc. https://angular.io/\n * License: MIT\n */\n\nimport { Injectable, InjectionToken, Inject, PLATFORM_ID, Injector, NgModule } from '@angular/core';\nimport { of, Observable } from 'rxjs';\nimport { concatMap, filter, map } from 'rxjs/operators';\nimport { DOCUMENT, ɵparseCookieValue } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a\n * `HttpResponse`.\n *\n * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the\n * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the\n * `HttpBackend`.\n *\n * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.\n *\n *\n * @abstract\n */\nclass HttpHandler {\n}\n/**\n * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.\n *\n * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.\n *\n * When injected, `HttpBackend` dispatches requests directly to the backend, without going\n * through the interceptor chain.\n *\n *\n * @abstract\n */\nclass HttpBackend {\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Immutable set of Http headers, with lazy parsing.\n *\n */\nclass HttpHeaders {\n    /**\n     * @param {?=} headers\n     */\n    constructor(headers) {\n        /**\n         * Internal map of lowercased header names to the normalized\n         * form of the name (the form seen first).\n         */\n        this.normalizedNames = new Map();\n        /**\n         * Queued updates to be materialized the next initialization.\n         */\n        this.lazyUpdate = null;\n        if (!headers) {\n            this.headers = new Map();\n        }\n        else if (typeof headers === 'string') {\n            this.lazyInit = () => {\n                this.headers = new Map();\n                headers.split('\\n').forEach(line => {\n                    /** @type {?} */\n                    const index = line.indexOf(':');\n                    if (index > 0) {\n                        /** @type {?} */\n                        const name = line.slice(0, index);\n                        /** @type {?} */\n                        const key = name.toLowerCase();\n                        /** @type {?} */\n                        const value = line.slice(index + 1).trim();\n                        this.maybeSetNormalizedName(name, key);\n                        if (this.headers.has(key)) {\n                            /** @type {?} */ ((this.headers.get(key))).push(value);\n                        }\n                        else {\n                            this.headers.set(key, [value]);\n                        }\n                    }\n                });\n            };\n        }\n        else {\n            this.lazyInit = () => {\n                this.headers = new Map();\n                Object.keys(headers).forEach(name => {\n                    /** @type {?} */\n                    let values = headers[name];\n                    /** @type {?} */\n                    const key = name.toLowerCase();\n                    if (typeof values === 'string') {\n                        values = [values];\n                    }\n                    if (values.length > 0) {\n                        this.headers.set(key, values);\n                        this.maybeSetNormalizedName(name, key);\n                    }\n                });\n            };\n        }\n    }\n    /**\n     * Checks for existence of header by given name.\n     * @param {?} name\n     * @return {?}\n     */\n    has(name) {\n        this.init();\n        return this.headers.has(name.toLowerCase());\n    }\n    /**\n     * Returns first header that matches given name.\n     * @param {?} name\n     * @return {?}\n     */\n    get(name) {\n        this.init();\n        /** @type {?} */\n        const values = this.headers.get(name.toLowerCase());\n        return values && values.length > 0 ? values[0] : null;\n    }\n    /**\n     * Returns the names of the headers\n     * @return {?}\n     */\n    keys() {\n        this.init();\n        return Array.from(this.normalizedNames.values());\n    }\n    /**\n     * Returns list of header values for a given name.\n     * @param {?} name\n     * @return {?}\n     */\n    getAll(name) {\n        this.init();\n        return this.headers.get(name.toLowerCase()) || null;\n    }\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    append(name, value) {\n        return this.clone({ name, value, op: 'a' });\n    }\n    /**\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    set(name, value) {\n        return this.clone({ name, value, op: 's' });\n    }\n    /**\n     * @param {?} name\n     * @param {?=} value\n     * @return {?}\n     */\n    delete(name, value) {\n        return this.clone({ name, value, op: 'd' });\n    }\n    /**\n     * @param {?} name\n     * @param {?} lcName\n     * @return {?}\n     */\n    maybeSetNormalizedName(name, lcName) {\n        if (!this.normalizedNames.has(lcName)) {\n            this.normalizedNames.set(lcName, name);\n        }\n    }\n    /**\n     * @return {?}\n     */\n    init() {\n        if (!!this.lazyInit) {\n            if (this.lazyInit instanceof HttpHeaders) {\n                this.copyFrom(this.lazyInit);\n            }\n            else {\n                this.lazyInit();\n            }\n            this.lazyInit = null;\n            if (!!this.lazyUpdate) {\n                this.lazyUpdate.forEach(update => this.applyUpdate(update));\n                this.lazyUpdate = null;\n            }\n        }\n    }\n    /**\n     * @param {?} other\n     * @return {?}\n     */\n    copyFrom(other) {\n        other.init();\n        Array.from(other.headers.keys()).forEach(key => {\n            this.headers.set(key, /** @type {?} */ ((other.headers.get(key))));\n            this.normalizedNames.set(key, /** @type {?} */ ((other.normalizedNames.get(key))));\n        });\n    }\n    /**\n     * @param {?} update\n     * @return {?}\n     */\n    clone(update) {\n        /** @type {?} */\n        const clone = new HttpHeaders();\n        clone.lazyInit =\n            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;\n        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n        return clone;\n    }\n    /**\n     * @param {?} update\n     * @return {?}\n     */\n    applyUpdate(update) {\n        /** @type {?} */\n        const key = update.name.toLowerCase();\n        switch (update.op) {\n            case 'a':\n            case 's':\n                /** @type {?} */\n                let value = /** @type {?} */ ((update.value));\n                if (typeof value === 'string') {\n                    value = [value];\n                }\n                if (value.length === 0) {\n                    return;\n                }\n                this.maybeSetNormalizedName(update.name, key);\n                /** @type {?} */\n                const base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];\n                base.push(...value);\n                this.headers.set(key, base);\n                break;\n            case 'd':\n                /** @type {?} */\n                const toDelete = /** @type {?} */ (update.value);\n                if (!toDelete) {\n                    this.headers.delete(key);\n                    this.normalizedNames.delete(key);\n                }\n                else {\n                    /** @type {?} */\n                    let existing = this.headers.get(key);\n                    if (!existing) {\n                        return;\n                    }\n                    existing = existing.filter(value => toDelete.indexOf(value) === -1);\n                    if (existing.length === 0) {\n                        this.headers.delete(key);\n                        this.normalizedNames.delete(key);\n                    }\n                    else {\n                        this.headers.set(key, existing);\n                    }\n                }\n                break;\n        }\n    }\n    /**\n     * \\@internal\n     * @param {?} fn\n     * @return {?}\n     */\n    forEach(fn) {\n        this.init();\n        Array.from(this.normalizedNames.keys())\n            .forEach(key => fn(/** @type {?} */ ((this.normalizedNames.get(key))), /** @type {?} */ ((this.headers.get(key)))));\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\n * serialize and parse URL parameter keys and values.\n *\n *\n */\nclass HttpUrlEncodingCodec {\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    encodeKey(key) { return standardEncoding(key); }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    encodeValue(value) { return standardEncoding(value); }\n    /**\n     * @param {?} key\n     * @return {?}\n     */\n    decodeKey(key) { return decodeURIComponent(key); }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    decodeValue(value) { return decodeURIComponent(value); }\n}\n/**\n * @param {?} rawParams\n * @param {?} codec\n * @return {?}\n */\nfunction paramParser(rawParams, codec) {\n    /** @type {?} */\n    const map$$1 = new Map();\n    if (rawParams.length > 0) {\n        /** @type {?} */\n        const params = rawParams.split('&');\n        params.forEach((param) => {\n            /** @type {?} */\n            const eqIdx = param.indexOf('=');\n            const [key, val] = eqIdx == -1 ?\n                [codec.decodeKey(param), ''] :\n                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n            /** @type {?} */\n            const list = map$$1.get(key) || [];\n            list.push(val);\n            map$$1.set(key, list);\n        });\n    }\n    return map$$1;\n}\n/**\n * @param {?} v\n * @return {?}\n */\nfunction standardEncoding(v) {\n    return encodeURIComponent(v)\n        .replace(/%40/gi, '@')\n        .replace(/%3A/gi, ':')\n        .replace(/%24/gi, '$')\n        .replace(/%2C/gi, ',')\n        .replace(/%3B/gi, ';')\n        .replace(/%2B/gi, '+')\n        .replace(/%3D/gi, '=')\n        .replace(/%3F/gi, '?')\n        .replace(/%2F/gi, '/');\n}\n/**\n * An HTTP request/response body that represents serialized parameters,\n * per the MIME type `application/x-www-form-urlencoded`.\n *\n * This class is immutable - all mutation operations return a new instance.\n *\n *\n */\nclass HttpParams {\n    /**\n     * @param {?=} options\n     */\n    constructor(options = /** @type {?} */ ({})) {\n        this.updates = null;\n        this.cloneFrom = null;\n        this.encoder = options.encoder || new HttpUrlEncodingCodec();\n        if (!!options.fromString) {\n            if (!!options.fromObject) {\n                throw new Error(`Cannot specify both fromString and fromObject.`);\n            }\n            this.map = paramParser(options.fromString, this.encoder);\n        }\n        else if (!!options.fromObject) {\n            this.map = new Map();\n            Object.keys(options.fromObject).forEach(key => {\n                /** @type {?} */\n                const value = (/** @type {?} */ (options.fromObject))[key]; /** @type {?} */\n                ((this.map)).set(key, Array.isArray(value) ? value : [value]);\n            });\n        }\n        else {\n            this.map = null;\n        }\n    }\n    /**\n     * Check whether the body has one or more values for the given parameter name.\n     * @param {?} param\n     * @return {?}\n     */\n    has(param) {\n        this.init();\n        return /** @type {?} */ ((this.map)).has(param);\n    }\n    /**\n     * Get the first value for the given parameter name, or `null` if it's not present.\n     * @param {?} param\n     * @return {?}\n     */\n    get(param) {\n        this.init();\n        /** @type {?} */\n        const res = /** @type {?} */ ((this.map)).get(param);\n        return !!res ? res[0] : null;\n    }\n    /**\n     * Get all values for the given parameter name, or `null` if it's not present.\n     * @param {?} param\n     * @return {?}\n     */\n    getAll(param) {\n        this.init();\n        return /** @type {?} */ ((this.map)).get(param) || null;\n    }\n    /**\n     * Get all the parameter names for this body.\n     * @return {?}\n     */\n    keys() {\n        this.init();\n        return Array.from(/** @type {?} */ ((this.map)).keys());\n    }\n    /**\n     * Construct a new body with an appended value for the given parameter name.\n     * @param {?} param\n     * @param {?} value\n     * @return {?}\n     */\n    append(param, value) { return this.clone({ param, value, op: 'a' }); }\n    /**\n     * Construct a new body with a new value for the given parameter name.\n     * @param {?} param\n     * @param {?} value\n     * @return {?}\n     */\n    set(param, value) { return this.clone({ param, value, op: 's' }); }\n    /**\n     * Construct a new body with either the given value for the given parameter\n     * removed, if a value is given, or all values for the given parameter removed\n     * if not.\n     * @param {?} param\n     * @param {?=} value\n     * @return {?}\n     */\n    delete(param, value) { return this.clone({ param, value, op: 'd' }); }\n    /**\n     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are\n     * separated by `&`s.\n     * @return {?}\n     */\n    toString() {\n        this.init();\n        return this.keys()\n            .map(key => {\n            /** @type {?} */\n            const eKey = this.encoder.encodeKey(key);\n            return /** @type {?} */ ((/** @type {?} */ ((this.map)).get(key))).map(value => eKey + '=' + this.encoder.encodeValue(value)).join('&');\n        })\n            .join('&');\n    }\n    /**\n     * @param {?} update\n     * @return {?}\n     */\n    clone(update) {\n        /** @type {?} */\n        const clone = new HttpParams(/** @type {?} */ ({ encoder: this.encoder }));\n        clone.cloneFrom = this.cloneFrom || this;\n        clone.updates = (this.updates || []).concat([update]);\n        return clone;\n    }\n    /**\n     * @return {?}\n     */\n    init() {\n        if (this.map === null) {\n            this.map = new Map();\n        }\n        if (this.cloneFrom !== null) {\n            this.cloneFrom.init();\n            this.cloneFrom.keys().forEach(key => /** @type {?} */ ((this.map)).set(key, /** @type {?} */ ((/** @type {?} */ ((/** @type {?} */ ((this.cloneFrom)).map)).get(key))))); /** @type {?} */\n            ((this.updates)).forEach(update => {\n                switch (update.op) {\n                    case 'a':\n                    case 's':\n                        /** @type {?} */\n                        const base = (update.op === 'a' ? /** @type {?} */ ((this.map)).get(update.param) : undefined) || [];\n                        base.push(/** @type {?} */ ((update.value))); /** @type {?} */\n                        ((this.map)).set(update.param, base);\n                        break;\n                    case 'd':\n                        if (update.value !== undefined) {\n                            /** @type {?} */\n                            let base = /** @type {?} */ ((this.map)).get(update.param) || [];\n                            /** @type {?} */\n                            const idx = base.indexOf(update.value);\n                            if (idx !== -1) {\n                                base.splice(idx, 1);\n                            }\n                            if (base.length > 0) {\n                                /** @type {?} */ ((this.map)).set(update.param, base);\n                            }\n                            else {\n                                /** @type {?} */ ((this.map)).delete(update.param);\n                            }\n                        }\n                        else {\n                            /** @type {?} */ ((this.map)).delete(update.param);\n                            break;\n                        }\n                }\n            });\n            this.cloneFrom = null;\n        }\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Determine whether the given HTTP method may include a body.\n * @param {?} method\n * @return {?}\n */\nfunction mightHaveBody(method) {\n    switch (method) {\n        case 'DELETE':\n        case 'GET':\n        case 'HEAD':\n        case 'OPTIONS':\n        case 'JSONP':\n            return false;\n        default:\n            return true;\n    }\n}\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isArrayBuffer(value) {\n    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isBlob(value) {\n    return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n * @param {?} value\n * @return {?}\n */\nfunction isFormData(value) {\n    return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n *\n * @template T\n */\nclass HttpRequest {\n    /**\n     * @param {?} method\n     * @param {?} url\n     * @param {?=} third\n     * @param {?=} fourth\n     */\n    constructor(method, url, third, fourth) {\n        this.url = url;\n        /**\n         * The request body, or `null` if one isn't set.\n         *\n         * Bodies are not enforced to be immutable, as they can include a reference to any\n         * user-defined data type. However, interceptors should take care to preserve\n         * idempotence by treating them as such.\n         */\n        this.body = null;\n        /**\n         * Whether this request should be made in a way that exposes progress events.\n         *\n         * Progress events are expensive (change detection runs on each event) and so\n         * they should only be requested if the consumer intends to monitor them.\n         */\n        this.reportProgress = false;\n        /**\n         * Whether this request should be sent with outgoing credentials (cookies).\n         */\n        this.withCredentials = false;\n        /**\n         * The expected response type of the server.\n         *\n         * This is used to parse the response appropriately before returning it to\n         * the requestee.\n         */\n        this.responseType = 'json';\n        this.method = method.toUpperCase();\n        /** @type {?} */\n        let options;\n        // Check whether a body argument is expected. The only valid way to omit\n        // the body argument is to use a known no-body method like GET.\n        if (mightHaveBody(this.method) || !!fourth) {\n            // Body is the third argument, options are the fourth.\n            this.body = (third !== undefined) ? /** @type {?} */ (third) : null;\n            options = fourth;\n        }\n        else {\n            // No body required, options are the third argument. The body stays null.\n            options = /** @type {?} */ (third);\n        }\n        // If options have been passed, interpret them.\n        if (options) {\n            // Normalize reportProgress and withCredentials.\n            this.reportProgress = !!options.reportProgress;\n            this.withCredentials = !!options.withCredentials;\n            // Override default response type of 'json' if one is provided.\n            if (!!options.responseType) {\n                this.responseType = options.responseType;\n            }\n            // Override headers if they're provided.\n            if (!!options.headers) {\n                this.headers = options.headers;\n            }\n            if (!!options.params) {\n                this.params = options.params;\n            }\n        }\n        // If no headers have been passed in, construct a new HttpHeaders instance.\n        if (!this.headers) {\n            this.headers = new HttpHeaders();\n        }\n        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n        if (!this.params) {\n            this.params = new HttpParams();\n            this.urlWithParams = url;\n        }\n        else {\n            /** @type {?} */\n            const params = this.params.toString();\n            if (params.length === 0) {\n                // No parameters, the visible URL is just the URL given at creation time.\n                this.urlWithParams = url;\n            }\n            else {\n                /** @type {?} */\n                const qIdx = url.indexOf('?');\n                /** @type {?} */\n                const sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n                this.urlWithParams = url + sep + params;\n            }\n        }\n    }\n    /**\n     * Transform the free-form body into a serialized format suitable for\n     * transmission to the server.\n     * @return {?}\n     */\n    serializeBody() {\n        // If no body is present, no need to serialize it.\n        if (this.body === null) {\n            return null;\n        }\n        // Check whether the body is already in a serialized form. If so,\n        // it can just be returned directly.\n        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n            typeof this.body === 'string') {\n            return this.body;\n        }\n        // Check whether the body is an instance of HttpUrlEncodedParams.\n        if (this.body instanceof HttpParams) {\n            return this.body.toString();\n        }\n        // Check whether the body is an object or array, and serialize with JSON if so.\n        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n            Array.isArray(this.body)) {\n            return JSON.stringify(this.body);\n        }\n        // Fall back on toString() for everything else.\n        return (/** @type {?} */ (this.body)).toString();\n    }\n    /**\n     * Examine the body and attempt to infer an appropriate MIME type\n     * for it.\n     *\n     * If no such type can be inferred, this method will return `null`.\n     * @return {?}\n     */\n    detectContentTypeHeader() {\n        // An empty body has no content type.\n        if (this.body === null) {\n            return null;\n        }\n        // FormData bodies rely on the browser's content type assignment.\n        if (isFormData(this.body)) {\n            return null;\n        }\n        // Blobs usually have their own content type. If it doesn't, then\n        // no type can be inferred.\n        if (isBlob(this.body)) {\n            return this.body.type || null;\n        }\n        // Array buffers have unknown contents and thus no type can be inferred.\n        if (isArrayBuffer(this.body)) {\n            return null;\n        }\n        // Technically, strings could be a form of JSON data, but it's safe enough\n        // to assume they're plain strings.\n        if (typeof this.body === 'string') {\n            return 'text/plain';\n        }\n        // `HttpUrlEncodedParams` has its own content-type.\n        if (this.body instanceof HttpParams) {\n            return 'application/x-www-form-urlencoded;charset=UTF-8';\n        }\n        // Arrays, objects, and numbers will be encoded as JSON.\n        if (typeof this.body === 'object' || typeof this.body === 'number' ||\n            Array.isArray(this.body)) {\n            return 'application/json';\n        }\n        // No type could be inferred.\n        return null;\n    }\n    /**\n     * @param {?=} update\n     * @return {?}\n     */\n    clone(update = {}) {\n        /** @type {?} */\n        const method = update.method || this.method;\n        /** @type {?} */\n        const url = update.url || this.url;\n        /** @type {?} */\n        const responseType = update.responseType || this.responseType;\n        /** @type {?} */\n        const body = (update.body !== undefined) ? update.body : this.body;\n        /** @type {?} */\n        const withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n        /** @type {?} */\n        const reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n        /** @type {?} */\n        let headers = update.headers || this.headers;\n        /** @type {?} */\n        let params = update.params || this.params;\n        // Check whether the caller has asked to add headers.\n        if (update.setHeaders !== undefined) {\n            // Set every requested header.\n            headers =\n                Object.keys(update.setHeaders)\n                    .reduce((headers, name) => headers.set(name, /** @type {?} */ ((update.setHeaders))[name]), headers);\n        }\n        // Check whether the caller has asked to set params.\n        if (update.setParams) {\n            // Set every requested param.\n            params = Object.keys(update.setParams)\n                .reduce((params, param) => params.set(param, /** @type {?} */ ((update.setParams))[param]), params);\n        }\n        // Finally, construct the new HttpRequest using the pieces from above.\n        return new HttpRequest(method, url, body, {\n            params, headers, reportProgress, responseType, withCredentials,\n        });\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @enum {number} */\nconst HttpEventType = {\n    /**\n       * The request was sent out over the wire.\n       */\n    Sent: 0,\n    /**\n       * An upload progress event was received.\n       */\n    UploadProgress: 1,\n    /**\n       * The response status code and headers were received.\n       */\n    ResponseHeader: 2,\n    /**\n       * A download progress event was received.\n       */\n    DownloadProgress: 3,\n    /**\n       * The full response including the body was received.\n       */\n    Response: 4,\n    /**\n       * A custom event from an interceptor or a backend.\n       */\n    User: 5,\n};\nHttpEventType[HttpEventType.Sent] = 'Sent';\nHttpEventType[HttpEventType.UploadProgress] = 'UploadProgress';\nHttpEventType[HttpEventType.ResponseHeader] = 'ResponseHeader';\nHttpEventType[HttpEventType.DownloadProgress] = 'DownloadProgress';\nHttpEventType[HttpEventType.Response] = 'Response';\nHttpEventType[HttpEventType.User] = 'User';\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n *\n * @abstract\n */\nclass HttpResponseBase {\n    /**\n     * Super-constructor for all responses.\n     *\n     * The single parameter accepted is an initialization hash. Any properties\n     * of the response passed there will override the default values.\n     * @param {?} init\n     * @param {?=} defaultStatus\n     * @param {?=} defaultStatusText\n     */\n    constructor(init, defaultStatus = 200, defaultStatusText = 'OK') {\n        // If the hash has values passed, use them to initialize the response.\n        // Otherwise use the default values.\n        this.headers = init.headers || new HttpHeaders();\n        this.status = init.status !== undefined ? init.status : defaultStatus;\n        this.statusText = init.statusText || defaultStatusText;\n        this.url = init.url || null;\n        // Cache the ok value to avoid defining a getter.\n        this.ok = this.status >= 200 && this.status < 300;\n    }\n}\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n *\n */\nclass HttpHeaderResponse extends HttpResponseBase {\n    /**\n     * Create a new `HttpHeaderResponse` with the given parameters.\n     * @param {?=} init\n     */\n    constructor(init = {}) {\n        super(init);\n        this.type = HttpEventType.ResponseHeader;\n    }\n    /**\n     * Copy this `HttpHeaderResponse`, overriding its contents with the\n     * given parameter hash.\n     * @param {?=} update\n     * @return {?}\n     */\n    clone(update = {}) {\n        // Perform a straightforward initialization of the new HttpHeaderResponse,\n        // overriding the current parameters with new ones if given.\n        return new HttpHeaderResponse({\n            headers: update.headers || this.headers,\n            status: update.status !== undefined ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n *\n * @template T\n */\nclass HttpResponse extends HttpResponseBase {\n    /**\n     * Construct a new `HttpResponse`.\n     * @param {?=} init\n     */\n    constructor(init = {}) {\n        super(init);\n        this.type = HttpEventType.Response;\n        this.body = init.body !== undefined ? init.body : null;\n    }\n    /**\n     * @param {?=} update\n     * @return {?}\n     */\n    clone(update = {}) {\n        return new HttpResponse({\n            body: (update.body !== undefined) ? update.body : this.body,\n            headers: update.headers || this.headers,\n            status: (update.status !== undefined) ? update.status : this.status,\n            statusText: update.statusText || this.statusText,\n            url: update.url || this.url || undefined,\n        });\n    }\n}\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n *\n */\nclass HttpErrorResponse extends HttpResponseBase {\n    /**\n     * @param {?} init\n     */\n    constructor(init) {\n        // Initialize with a default status of 0 / Unknown Error.\n        super(init, 0, 'Unknown Error');\n        this.name = 'HttpErrorResponse';\n        /**\n         * Errors are never okay, even when the status code is in the 2xx success range.\n         */\n        this.ok = false;\n        // If the response was successful, then this was a parse error. Otherwise, it was\n        // a protocol-level failure of some sort. Either the request failed in transit\n        // or the server returned an unsuccessful status code.\n        if (this.status >= 200 && this.status < 300) {\n            this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n        }\n        else {\n            this.message =\n                `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n        }\n        this.error = init.error || null;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n * @template T\n * @param {?} options\n * @param {?} body\n * @return {?}\n */\nfunction addBody(options, body) {\n    return {\n        body,\n        headers: options.headers,\n        observe: options.observe,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        responseType: options.responseType,\n        withCredentials: options.withCredentials,\n    };\n}\n/**\n * Perform HTTP requests.\n *\n * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies according to which\n * signature is called (mainly the values of `observe` and `responseType`).\n *\n *\n */\nclass HttpClient {\n    /**\n     * @param {?} handler\n     */\n    constructor(handler) {\n        this.handler = handler;\n    }\n    /**\n     * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n     * fires the request through the chain of registered interceptors and on to the\n     * server.\n     *\n     * This method can be called in one of two ways. Either an `HttpRequest`\n     * instance can be passed directly as the only parameter, or a method can be\n     * passed as the first parameter, a string URL as the second, and an\n     * options hash as the third.\n     *\n     * If a `HttpRequest` object is passed directly, an `Observable` of the\n     * raw `HttpEvent` stream will be returned.\n     *\n     * If a request is instead built by providing a URL, the options object\n     * determines the return type of `request()`. In addition to configuring\n     * request parameters such as the outgoing headers and/or the body, the options\n     * hash specifies two key pieces of information about the request: the\n     * `responseType` and what to `observe`.\n     *\n     * The `responseType` value determines how a successful response body will be\n     * parsed. If `responseType` is the default `json`, a type interface for the\n     * resulting object may be passed as a type parameter to `request()`.\n     *\n     * The `observe` value determines the return type of `request()`, based on what\n     * the consumer is interested in observing. A value of `events` will return an\n     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,\n     * including progress events by default. A value of `response` will return an\n     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`\n     * depends on the `responseType` and any optionally provided type parameter.\n     * A value of `body` will return an `Observable<T>` with the same `T` body type.\n     * @param {?} first\n     * @param {?=} url\n     * @param {?=} options\n     * @return {?}\n     */\n    request(first, url, options = {}) {\n        /** @type {?} */\n        let req;\n        // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n        if (first instanceof HttpRequest) {\n            // It is. The other arguments must be undefined (per the signatures) and can be\n            // ignored.\n            req = /** @type {?} */ (first);\n        }\n        else {\n            /** @type {?} */\n            let headers = undefined;\n            if (options.headers instanceof HttpHeaders) {\n                headers = options.headers;\n            }\n            else {\n                headers = new HttpHeaders(options.headers);\n            }\n            /** @type {?} */\n            let params = undefined;\n            if (!!options.params) {\n                if (options.params instanceof HttpParams) {\n                    params = options.params;\n                }\n                else {\n                    params = new HttpParams(/** @type {?} */ ({ fromObject: options.params }));\n                }\n            }\n            // Construct the request.\n            req = new HttpRequest(first, /** @type {?} */ ((url)), (options.body !== undefined ? options.body : null), {\n                headers,\n                params,\n                reportProgress: options.reportProgress,\n                // By default, JSON is assumed to be returned for all calls.\n                responseType: options.responseType || 'json',\n                withCredentials: options.withCredentials,\n            });\n        }\n        /** @type {?} */\n        const events$ = of(req).pipe(concatMap((req) => this.handler.handle(req)));\n        // If coming via the API signature which accepts a previously constructed HttpRequest,\n        // the only option is to get the event stream. Otherwise, return the event stream if\n        // that is what was requested.\n        if (first instanceof HttpRequest || options.observe === 'events') {\n            return events$;\n        }\n        /** @type {?} */\n        const res$ = /** @type {?} */ (events$.pipe(filter((event) => event instanceof HttpResponse)));\n        // Decide which stream to return.\n        switch (options.observe || 'body') {\n            case 'body':\n                // The requested stream is the body. Map the response stream to the response\n                // body. This could be done more simply, but a misbehaving interceptor might\n                // transform the response body into a different format and ignore the requested\n                // responseType. Guard against this by validating that the response is of the\n                // requested type.\n                switch (req.responseType) {\n                    case 'arraybuffer':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is an ArrayBuffer.\n                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                                throw new Error('Response is not an ArrayBuffer.');\n                            }\n                            return res.body;\n                        }));\n                    case 'blob':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a Blob.\n                            if (res.body !== null && !(res.body instanceof Blob)) {\n                                throw new Error('Response is not a Blob.');\n                            }\n                            return res.body;\n                        }));\n                    case 'text':\n                        return res$.pipe(map((res) => {\n                            // Validate that the body is a string.\n                            if (res.body !== null && typeof res.body !== 'string') {\n                                throw new Error('Response is not a string.');\n                            }\n                            return res.body;\n                        }));\n                    case 'json':\n                    default:\n                        // No validation needed for JSON responses, as they can be of any type.\n                        return res$.pipe(map((res) => res.body));\n                }\n            case 'response':\n                // The response stream was requested directly, so return it.\n                return res$;\n            default:\n                // Guard against new future observe types being added.\n                throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n        }\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * DELETE request to be executed on the server. See the individual overloads for\n     * details of `delete()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    delete(url, options = {}) {\n        return this.request('DELETE', url, /** @type {?} */ (options));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * GET request to be executed on the server. See the individual overloads for\n     * details of `get()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    get(url, options = {}) {\n        return this.request('GET', url, /** @type {?} */ (options));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * HEAD request to be executed on the server. See the individual overloads for\n     * details of `head()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    head(url, options = {}) {\n        return this.request('HEAD', url, /** @type {?} */ (options));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause a request\n     * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n     *\n     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n     * If no such interceptor is reached, then the `JSONP` request will likely be\n     * rejected by the configured backend.\n     * @template T\n     * @param {?} url\n     * @param {?} callbackParam\n     * @return {?}\n     */\n    jsonp(url, callbackParam) {\n        return this.request('JSONP', url, {\n            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n            observe: 'body',\n            responseType: 'json',\n        });\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * OPTIONS request to be executed on the server. See the individual overloads for\n     * details of `options()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?=} options\n     * @return {?}\n     */\n    options(url, options = {}) {\n        return this.request('OPTIONS', url, /** @type {?} */ (options));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * PATCH request to be executed on the server. See the individual overloads for\n     * details of `patch()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?} body\n     * @param {?=} options\n     * @return {?}\n     */\n    patch(url, body, options = {}) {\n        return this.request('PATCH', url, addBody(options, body));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * POST request to be executed on the server. See the individual overloads for\n     * details of `post()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?} body\n     * @param {?=} options\n     * @return {?}\n     */\n    post(url, body, options = {}) {\n        return this.request('POST', url, addBody(options, body));\n    }\n    /**\n     * Constructs an `Observable` which, when subscribed, will cause the configured\n     * PUT request to be executed on the server. See the individual overloads for\n     * details of `put()`'s return type based on the provided options.\n     * @param {?} url\n     * @param {?} body\n     * @param {?=} options\n     * @return {?}\n     */\n    put(url, body, options = {}) {\n        return this.request('PUT', url, addBody(options, body));\n    }\n}\nHttpClient.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nHttpClient.ctorParameters = () => [\n    { type: HttpHandler }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n *\n *\n */\nclass HttpInterceptorHandler {\n    /**\n     * @param {?} next\n     * @param {?} interceptor\n     */\n    constructor(next, interceptor) {\n        this.next = next;\n        this.interceptor = interceptor;\n    }\n    /**\n     * @param {?} req\n     * @return {?}\n     */\n    handle(req) {\n        return this.interceptor.intercept(req, this.next);\n    }\n}\n/** *\n * A multi-provider token which represents the array of `HttpInterceptor`s that\n * are registered.\n *\n *\n  @type {?} */\nconst HTTP_INTERCEPTORS = new InjectionToken('HTTP_INTERCEPTORS');\nclass NoopInterceptor {\n    /**\n     * @param {?} req\n     * @param {?} next\n     * @return {?}\n     */\n    intercept(req, next) {\n        return next.handle(req);\n    }\n}\nNoopInterceptor.decorators = [\n    { type: Injectable }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nlet nextRequestId = 0;\n/** @type {?} */\nconst JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n/** @type {?} */\nconst JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\n/** @type {?} */\nconst JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n * @abstract\n */\nclass JsonpCallbackContext {\n}\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n *\n *\n */\nclass JsonpClientBackend {\n    /**\n     * @param {?} callbackMap\n     * @param {?} document\n     */\n    constructor(callbackMap, document) {\n        this.callbackMap = callbackMap;\n        this.document = document;\n    }\n    /**\n     * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n     * @return {?}\n     */\n    nextCallback() { return `ng_jsonp_callback_${nextRequestId++}`; }\n    /**\n     * Process a JSONP request and return an event stream of the results.\n     * @param {?} req\n     * @return {?}\n     */\n    handle(req) {\n        // Firstly, check both the method and response type. If either doesn't match\n        // then the request was improperly routed here and cannot be handled.\n        if (req.method !== 'JSONP') {\n            throw new Error(JSONP_ERR_WRONG_METHOD);\n        }\n        else if (req.responseType !== 'json') {\n            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n        }\n        // Everything else happens inside the Observable boundary.\n        return new Observable((observer) => {\n            /** @type {?} */\n            const callback = this.nextCallback();\n            /** @type {?} */\n            const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n            /** @type {?} */\n            const node = this.document.createElement('script');\n            node.src = url;\n            /** @type {?} */\n            let body = null;\n            /** @type {?} */\n            let finished = false;\n            /** @type {?} */\n            let cancelled = false;\n            // Set the response callback in this.callbackMap (which will be the window\n            // object in the browser. The script being loaded via the <script> tag will\n            // eventually call this callback.\n            this.callbackMap[callback] = (data) => {\n                // Data has been received from the JSONP script. Firstly, delete this callback.\n                delete this.callbackMap[callback];\n                // Next, make sure the request wasn't cancelled in the meantime.\n                if (cancelled) {\n                    return;\n                }\n                // Set state to indicate data was received.\n                body = data;\n                finished = true;\n            };\n            /** @type {?} */\n            const cleanup = () => {\n                // Remove the <script> tag if it's still on the page.\n                if (node.parentNode) {\n                    node.parentNode.removeChild(node);\n                }\n                // Remove the response callback from the callbackMap (window object in the\n                // browser).\n                delete this.callbackMap[callback];\n            };\n            /** @type {?} */\n            const onLoad = (event) => {\n                // Do nothing if the request has been cancelled.\n                if (cancelled) {\n                    return;\n                }\n                // Cleanup the page.\n                cleanup();\n                // Check whether the response callback has run.\n                if (!finished) {\n                    // It hasn't, something went wrong with the request. Return an error via\n                    // the Observable error path. All JSONP errors have status 0.\n                    observer.error(new HttpErrorResponse({\n                        url,\n                        status: 0,\n                        statusText: 'JSONP Error',\n                        error: new Error(JSONP_ERR_NO_CALLBACK),\n                    }));\n                    return;\n                }\n                // Success. body either contains the response body or null if none was\n                // returned.\n                observer.next(new HttpResponse({\n                    body,\n                    status: 200,\n                    statusText: 'OK', url,\n                }));\n                // Complete the stream, the response is over.\n                observer.complete();\n            };\n            /** @type {?} */\n            const onError = (error) => {\n                // If the request was already cancelled, no need to emit anything.\n                if (cancelled) {\n                    return;\n                }\n                cleanup();\n                // Wrap the error in a HttpErrorResponse.\n                observer.error(new HttpErrorResponse({\n                    error,\n                    status: 0,\n                    statusText: 'JSONP Error', url,\n                }));\n            };\n            // Subscribe to both the success (load) and error events on the <script> tag,\n            // and add it to the page.\n            node.addEventListener('load', onLoad);\n            node.addEventListener('error', onError);\n            this.document.body.appendChild(node);\n            // The request has now been successfully sent.\n            observer.next({ type: HttpEventType.Sent });\n            // Cancellation handler.\n            return () => {\n                // Track the cancellation so event listeners won't do anything even if already scheduled.\n                cancelled = true;\n                // Remove the event listeners so they won't run if the events later fire.\n                node.removeEventListener('load', onLoad);\n                node.removeEventListener('error', onError);\n                // And finally, clean up the page.\n                cleanup();\n            };\n        });\n    }\n}\nJsonpClientBackend.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nJsonpClientBackend.ctorParameters = () => [\n    { type: JsonpCallbackContext },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n *\n */\nclass JsonpInterceptor {\n    /**\n     * @param {?} jsonp\n     */\n    constructor(jsonp) {\n        this.jsonp = jsonp;\n    }\n    /**\n     * @param {?} req\n     * @param {?} next\n     * @return {?}\n     */\n    intercept(req, next) {\n        if (req.method === 'JSONP') {\n            return this.jsonp.handle(/** @type {?} */ (req));\n        }\n        // Fall through for normal HTTP requests.\n        return next.handle(req);\n    }\n}\nJsonpInterceptor.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nJsonpInterceptor.ctorParameters = () => [\n    { type: JsonpClientBackend }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n * @param {?} xhr\n * @return {?}\n */\nfunction getResponseUrl(xhr) {\n    if ('responseURL' in xhr && xhr.responseURL) {\n        return xhr.responseURL;\n    }\n    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n        return xhr.getResponseHeader('X-Request-URL');\n    }\n    return null;\n}\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n *\n *\n * @abstract\n */\nclass XhrFactory {\n}\n/**\n * A factory for \\@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n *\n *\n */\nclass BrowserXhr {\n    constructor() { }\n    /**\n     * @return {?}\n     */\n    build() { return /** @type {?} */ ((new XMLHttpRequest())); }\n}\nBrowserXhr.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nBrowserXhr.ctorParameters = () => [];\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n *\n *\n */\nclass HttpXhrBackend {\n    /**\n     * @param {?} xhrFactory\n     */\n    constructor(xhrFactory) {\n        this.xhrFactory = xhrFactory;\n    }\n    /**\n     * Process a request and return a stream of response events.\n     * @param {?} req\n     * @return {?}\n     */\n    handle(req) {\n        // Quick check to give a better error message when a user attempts to use\n        // HttpClient.jsonp() without installing the JsonpClientModule\n        if (req.method === 'JSONP') {\n            throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n        }\n        // Everything happens on Observable subscription.\n        return new Observable((observer) => {\n            /** @type {?} */\n            const xhr = this.xhrFactory.build();\n            xhr.open(req.method, req.urlWithParams);\n            if (!!req.withCredentials) {\n                xhr.withCredentials = true;\n            }\n            // Add all the requested headers.\n            req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n            // Add an Accept header if one isn't present already.\n            if (!req.headers.has('Accept')) {\n                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n            }\n            // Auto-detect the Content-Type header if one isn't present already.\n            if (!req.headers.has('Content-Type')) {\n                /** @type {?} */\n                const detectedType = req.detectContentTypeHeader();\n                // Sometimes Content-Type detection fails.\n                if (detectedType !== null) {\n                    xhr.setRequestHeader('Content-Type', detectedType);\n                }\n            }\n            // Set the responseType if one was requested.\n            if (req.responseType) {\n                /** @type {?} */\n                const responseType = req.responseType.toLowerCase();\n                // JSON responses need to be processed as text. This is because if the server\n                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n                // xhr.response will be null, and xhr.responseText cannot be accessed to\n                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n                // is parsed by first requesting text and then applying JSON.parse.\n                xhr.responseType = /** @type {?} */ (((responseType !== 'json') ? responseType : 'text'));\n            }\n            /** @type {?} */\n            const reqBody = req.serializeBody();\n            /** @type {?} */\n            let headerResponse = null;\n            /** @type {?} */\n            const partialFromXhr = () => {\n                if (headerResponse !== null) {\n                    return headerResponse;\n                }\n                /** @type {?} */\n                const status = xhr.status === 1223 ? 204 : xhr.status;\n                /** @type {?} */\n                const statusText = xhr.statusText || 'OK';\n                /** @type {?} */\n                const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n                /** @type {?} */\n                const url = getResponseUrl(xhr) || req.url;\n                // Construct the HttpHeaderResponse and memoize it.\n                headerResponse = new HttpHeaderResponse({ headers, status, statusText, url });\n                return headerResponse;\n            };\n            /** @type {?} */\n            const onLoad = () => {\n                let { headers, status, statusText, url } = partialFromXhr();\n                /** @type {?} */\n                let body = null;\n                if (status !== 204) {\n                    // Use XMLHttpRequest.response if set, responseText otherwise.\n                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n                }\n                // Normalize another potential bug (this one comes from CORS).\n                if (status === 0) {\n                    status = !!body ? 200 : 0;\n                }\n                /** @type {?} */\n                let ok = status >= 200 && status < 300;\n                // Check whether the body needs to be parsed as JSON (in many cases the browser\n                // will have done that already).\n                if (req.responseType === 'json' && typeof body === 'string') {\n                    /** @type {?} */\n                    const originalBody = body;\n                    body = body.replace(XSSI_PREFIX, '');\n                    try {\n                        // Attempt the parse. If it fails, a parse error should be delivered to the user.\n                        body = body !== '' ? JSON.parse(body) : null;\n                    }\n                    catch (error) {\n                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a\n                        // JSON response. Restore the original body (including any XSSI prefix) to deliver\n                        // a better error response.\n                        body = originalBody;\n                        // If this was an error request to begin with, leave it as a string, it probably\n                        // just isn't JSON. Otherwise, deliver the parsing error to the user.\n                        if (ok) {\n                            // Even though the response status was 2xx, this is still an error.\n                            ok = false;\n                            // The parse error contains the text of the body that failed to parse.\n                            body = /** @type {?} */ ({ error, text: body });\n                        }\n                    }\n                }\n                if (ok) {\n                    // A successful response is delivered on the event stream.\n                    observer.next(new HttpResponse({\n                        body,\n                        headers,\n                        status,\n                        statusText,\n                        url: url || undefined,\n                    }));\n                    // The full body has been received and delivered, no further events\n                    // are possible. This request is complete.\n                    observer.complete();\n                }\n                else {\n                    // An unsuccessful request is delivered on the error channel.\n                    observer.error(new HttpErrorResponse({\n                        // The error in this case is the response body (error from the server).\n                        error: body,\n                        headers,\n                        status,\n                        statusText,\n                        url: url || undefined,\n                    }));\n                }\n            };\n            /** @type {?} */\n            const onError = (error) => {\n                /** @type {?} */\n                const res = new HttpErrorResponse({\n                    error,\n                    status: xhr.status || 0,\n                    statusText: xhr.statusText || 'Unknown Error',\n                });\n                observer.error(res);\n            };\n            /** @type {?} */\n            let sentHeaders = false;\n            /** @type {?} */\n            const onDownProgress = (event) => {\n                // Send the HttpResponseHeaders event if it hasn't been sent already.\n                if (!sentHeaders) {\n                    observer.next(partialFromXhr());\n                    sentHeaders = true;\n                }\n                /** @type {?} */\n                let progressEvent = {\n                    type: HttpEventType.DownloadProgress,\n                    loaded: event.loaded,\n                };\n                // Set the total number of bytes in the event if it's available.\n                if (event.lengthComputable) {\n                    progressEvent.total = event.total;\n                }\n                // If the request was for text content and a partial response is\n                // available on XMLHttpRequest, include it in the progress event\n                // to allow for streaming reads.\n                if (req.responseType === 'text' && !!xhr.responseText) {\n                    progressEvent.partialText = xhr.responseText;\n                }\n                // Finally, fire the event.\n                observer.next(progressEvent);\n            };\n            /** @type {?} */\n            const onUpProgress = (event) => {\n                /** @type {?} */\n                let progress = {\n                    type: HttpEventType.UploadProgress,\n                    loaded: event.loaded,\n                };\n                // If the total number of bytes being uploaded is available, include\n                // it.\n                if (event.lengthComputable) {\n                    progress.total = event.total;\n                }\n                // Send the event.\n                observer.next(progress);\n            };\n            // By default, register for load and error events.\n            xhr.addEventListener('load', onLoad);\n            xhr.addEventListener('error', onError);\n            // Progress events are only enabled if requested.\n            if (req.reportProgress) {\n                // Download progress is always enabled if requested.\n                xhr.addEventListener('progress', onDownProgress);\n                // Upload progress depends on whether there is a body to upload.\n                if (reqBody !== null && xhr.upload) {\n                    xhr.upload.addEventListener('progress', onUpProgress);\n                }\n            }\n            // Fire the request, and notify the event stream that it was fired.\n            xhr.send(reqBody);\n            observer.next({ type: HttpEventType.Sent });\n            // This is the return from the Observable function, which is the\n            // request cancellation handler.\n            return () => {\n                // On a cancellation, remove all registered event listeners.\n                xhr.removeEventListener('error', onError);\n                xhr.removeEventListener('load', onLoad);\n                if (req.reportProgress) {\n                    xhr.removeEventListener('progress', onDownProgress);\n                    if (reqBody !== null && xhr.upload) {\n                        xhr.upload.removeEventListener('progress', onUpProgress);\n                    }\n                }\n                // Finally, abort the in-flight request.\n                xhr.abort();\n            };\n        });\n    }\n}\nHttpXhrBackend.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nHttpXhrBackend.ctorParameters = () => [\n    { type: XhrFactory }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');\n/** @type {?} */\nconst XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n *\n * @abstract\n */\nclass HttpXsrfTokenExtractor {\n}\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nclass HttpXsrfCookieExtractor {\n    /**\n     * @param {?} doc\n     * @param {?} platform\n     * @param {?} cookieName\n     */\n    constructor(doc, platform, cookieName) {\n        this.doc = doc;\n        this.platform = platform;\n        this.cookieName = cookieName;\n        this.lastCookieString = '';\n        this.lastToken = null;\n        /**\n         * \\@internal for testing\n         */\n        this.parseCount = 0;\n    }\n    /**\n     * @return {?}\n     */\n    getToken() {\n        if (this.platform === 'server') {\n            return null;\n        }\n        /** @type {?} */\n        const cookieString = this.doc.cookie || '';\n        if (cookieString !== this.lastCookieString) {\n            this.parseCount++;\n            this.lastToken = ɵparseCookieValue(cookieString, this.cookieName);\n            this.lastCookieString = cookieString;\n        }\n        return this.lastToken;\n    }\n}\nHttpXsrfCookieExtractor.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nHttpXsrfCookieExtractor.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },\n    { type: String, decorators: [{ type: Inject, args: [XSRF_COOKIE_NAME,] }] }\n];\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nclass HttpXsrfInterceptor {\n    /**\n     * @param {?} tokenService\n     * @param {?} headerName\n     */\n    constructor(tokenService, headerName) {\n        this.tokenService = tokenService;\n        this.headerName = headerName;\n    }\n    /**\n     * @param {?} req\n     * @param {?} next\n     * @return {?}\n     */\n    intercept(req, next) {\n        /** @type {?} */\n        const lcUrl = req.url.toLowerCase();\n        // Skip both non-mutating requests and absolute URLs.\n        // Non-mutating requests don't require a token, and absolute URLs require special handling\n        // anyway as the cookie set\n        // on our origin is not the same as the token expected by another origin.\n        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n            lcUrl.startsWith('https://')) {\n            return next.handle(req);\n        }\n        /** @type {?} */\n        const token = this.tokenService.getToken();\n        // Be careful not to overwrite an existing header of the same name.\n        if (token !== null && !req.headers.has(this.headerName)) {\n            req = req.clone({ headers: req.headers.set(this.headerName, token) });\n        }\n        return next.handle(req);\n    }\n}\nHttpXsrfInterceptor.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nHttpXsrfInterceptor.ctorParameters = () => [\n    { type: HttpXsrfTokenExtractor },\n    { type: String, decorators: [{ type: Inject, args: [XSRF_HEADER_NAME,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n/**\n * An injectable `HttpHandler` that applies multiple interceptors\n * to a request before passing it to the given `HttpBackend`.\n *\n * The interceptors are loaded lazily from the injector, to allow\n * interceptors to themselves inject classes depending indirectly\n * on `HttpInterceptingHandler` itself.\n * @see `HttpInterceptor`\n */\nclass HttpInterceptingHandler {\n    /**\n     * @param {?} backend\n     * @param {?} injector\n     */\n    constructor(backend, injector) {\n        this.backend = backend;\n        this.injector = injector;\n        this.chain = null;\n    }\n    /**\n     * @param {?} req\n     * @return {?}\n     */\n    handle(req) {\n        if (this.chain === null) {\n            /** @type {?} */\n            const interceptors = this.injector.get(HTTP_INTERCEPTORS, []);\n            this.chain = interceptors.reduceRight((next, interceptor) => new HttpInterceptorHandler(next, interceptor), this.backend);\n        }\n        return this.chain.handle(req);\n    }\n}\nHttpInterceptingHandler.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nHttpInterceptingHandler.ctorParameters = () => [\n    { type: HttpBackend },\n    { type: Injector }\n];\n/**\n * Factory function that determines where to store JSONP callbacks.\n *\n * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist\n * in test environments. In that case, callbacks are stored on an anonymous object instead.\n *\n *\n * @return {?}\n */\nfunction jsonpCallbackContext() {\n    if (typeof window === 'object') {\n        return window;\n    }\n    return {};\n}\n/**\n * Configures XSRF protection support for outgoing requests.\n *\n * For a server that supports a cookie-based XSRF protection system,\n * use directly to configure XSRF protection with the correct\n * cookie and header names.\n *\n * If no names are supplied, the default cookie name is `XSRF-TOKEN`\n * and the default header name is `X-XSRF-TOKEN`.\n *\n *\n */\nclass HttpClientXsrfModule {\n    /**\n     * Disable the default XSRF protection.\n     * @return {?}\n     */\n    static disable() {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: [\n                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },\n            ],\n        };\n    }\n    /**\n     * Configure XSRF protection.\n     * @param {?=} options An object that can specify either or both\n     * cookie name or header name.\n     * - Cookie name default is `XSRF-TOKEN`.\n     * - Header name default is `X-XSRF-TOKEN`.\n     *\n     * @return {?}\n     */\n    static withOptions(options = {}) {\n        return {\n            ngModule: HttpClientXsrfModule,\n            providers: [\n                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],\n                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],\n            ],\n        };\n    }\n}\nHttpClientXsrfModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [\n                    HttpXsrfInterceptor,\n                    { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },\n                    { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },\n                    { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },\n                    { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },\n                ],\n            },] }\n];\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for XSRF. Automatically imported by `HttpClientModule`.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.\n *\n *\n */\nclass HttpClientModule {\n}\nHttpClientModule.decorators = [\n    { type: NgModule, args: [{\n                /**\n                   * Optional configuration for XSRF protection.\n                   */\n                imports: [\n                    HttpClientXsrfModule.withOptions({\n                        cookieName: 'XSRF-TOKEN',\n                        headerName: 'X-XSRF-TOKEN',\n                    }),\n                ],\n                /**\n                   * Configures the [dependency injector](guide/glossary#injector) where it is imported\n                   * with supporting services for HTTP communications.\n                   */\n                providers: [\n                    HttpClient,\n                    { provide: HttpHandler, useClass: HttpInterceptingHandler },\n                    HttpXhrBackend,\n                    { provide: HttpBackend, useExisting: HttpXhrBackend },\n                    BrowserXhr,\n                    { provide: XhrFactory, useExisting: BrowserXhr },\n                ],\n            },] }\n];\n/**\n * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`\n * with supporting services for JSONP.\n * Without this module, Jsonp requests reach the backend\n * with method JSONP, where they are rejected.\n *\n * You can add interceptors to the chain behind `HttpClient` by binding them to the\n * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.\n *\n *\n */\nclass HttpClientJsonpModule {\n}\nHttpClientJsonpModule.decorators = [\n    { type: NgModule, args: [{\n                providers: [\n                    JsonpClientBackend,\n                    { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },\n                    { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },\n                ],\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NoopInterceptor as ɵangular_packages_common_http_http_a, JsonpCallbackContext as ɵangular_packages_common_http_http_b, jsonpCallbackContext as ɵangular_packages_common_http_http_c, BrowserXhr as ɵangular_packages_common_http_http_d, HttpXsrfCookieExtractor as ɵangular_packages_common_http_http_g, HttpXsrfInterceptor as ɵangular_packages_common_http_http_h, XSRF_COOKIE_NAME as ɵangular_packages_common_http_http_e, XSRF_HEADER_NAME as ɵangular_packages_common_http_http_f, HttpBackend, HttpHandler, HttpClient, HttpHeaders, HTTP_INTERCEPTORS, JsonpClientBackend, JsonpInterceptor, HttpClientJsonpModule, HttpClientModule, HttpClientXsrfModule, HttpInterceptingHandler as ɵHttpInterceptingHandler, HttpParams, HttpUrlEncodingCodec, HttpRequest, HttpErrorResponse, HttpEventType, HttpHeaderResponse, HttpResponse, HttpResponseBase, HttpXhrBackend, XhrFactory, HttpXsrfTokenExtractor };\n//# sourceMappingURL=http.js.map\n"]}