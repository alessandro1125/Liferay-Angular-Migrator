{"version":3,"sources":["../../../../../../../packages/common/src/i18n/format_number.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NumberFormatStyle, NumberSymbol, getLocaleNumberFormat, getLocaleNumberSymbol, getNumberOfCurrencyDigits} from './locale_data_api';\n\nexport const NUMBER_FORMAT_REGEXP = /^(\\d+)?\\.((\\d+)(-(\\d+))?)?$/;\nconst MAX_DIGITS = 22;\nconst DECIMAL_SEP = '.';\nconst ZERO_CHAR = '0';\nconst PATTERN_SEP = ';';\nconst GROUP_SEP = ',';\nconst DIGIT_CHAR = '#';\nconst CURRENCY_CHAR = 'Â¤';\nconst PERCENT_CHAR = '%';\n\n/**\n * Transforms a number to a locale string based on a style and a format\n */\nfunction formatNumberToLocaleString(\n    value: number, pattern: ParsedNumberFormat, locale: string, groupSymbol: NumberSymbol,\n    decimalSymbol: NumberSymbol, digitsInfo?: string, isPercent = false): string {\n  let formattedText = '';\n  let isZero = false;\n\n  if (!isFinite(value)) {\n    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);\n  } else {\n    let parsedNumber = parseNumber(value);\n\n    if (isPercent) {\n      parsedNumber = toPercent(parsedNumber);\n    }\n\n    let minInt = pattern.minInt;\n    let minFraction = pattern.minFrac;\n    let maxFraction = pattern.maxFrac;\n\n    if (digitsInfo) {\n      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);\n      if (parts === null) {\n        throw new Error(`${digitsInfo} is not a valid digit info`);\n      }\n      const minIntPart = parts[1];\n      const minFractionPart = parts[3];\n      const maxFractionPart = parts[5];\n      if (minIntPart != null) {\n        minInt = parseIntAutoRadix(minIntPart);\n      }\n      if (minFractionPart != null) {\n        minFraction = parseIntAutoRadix(minFractionPart);\n      }\n      if (maxFractionPart != null) {\n        maxFraction = parseIntAutoRadix(maxFractionPart);\n      } else if (minFractionPart != null && minFraction > maxFraction) {\n        maxFraction = minFraction;\n      }\n    }\n\n    roundNumber(parsedNumber, minFraction, maxFraction);\n\n    let digits = parsedNumber.digits;\n    let integerLen = parsedNumber.integerLen;\n    const exponent = parsedNumber.exponent;\n    let decimals = [];\n    isZero = digits.every(d => !d);\n\n    // pad zeros for small numbers\n    for (; integerLen < minInt; integerLen++) {\n      digits.unshift(0);\n    }\n\n    // pad zeros for small numbers\n    for (; integerLen < 0; integerLen++) {\n      digits.unshift(0);\n    }\n\n    // extract decimals digits\n    if (integerLen > 0) {\n      decimals = digits.splice(integerLen, digits.length);\n    } else {\n      decimals = digits;\n      digits = [0];\n    }\n\n    // format the integer digits with grouping separators\n    const groups = [];\n    if (digits.length >= pattern.lgSize) {\n      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(''));\n    }\n\n    while (digits.length > pattern.gSize) {\n      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(''));\n    }\n\n    if (digits.length) {\n      groups.unshift(digits.join(''));\n    }\n\n    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));\n\n    // append the decimal digits\n    if (decimals.length) {\n      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join('');\n    }\n\n    if (exponent) {\n      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + '+' + exponent;\n    }\n  }\n\n  if (value < 0 && !isZero) {\n    formattedText = pattern.negPre + formattedText + pattern.negSuf;\n  } else {\n    formattedText = pattern.posPre + formattedText + pattern.posSuf;\n  }\n\n  return formattedText;\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as currency using locale rules.\n *\n * Use `currency` to format a number as currency.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `currency` is the string that represents the currency, it can be its symbol or its name.\n * - `currencyCode` is the [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) currency code, such\n *    as `USD` for the US dollar and `EUR` for the euro.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatCurrency(\n    value: number, locale: string, currency: string, currencyCode?: string,\n    digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n\n  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode !);\n  pattern.maxFrac = pattern.minFrac;\n\n  const res = formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);\n  return res\n      .replace(CURRENCY_CHAR, currency)\n      // if we have 2 time the currency character, the second one is ignored\n      .replace(CURRENCY_CHAR, '');\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as a percentage according to locale rules.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatPercent(value: number, locale: string, digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  const res = formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);\n  return res.replace(\n      new RegExp(PERCENT_CHAR, 'g'), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));\n}\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Formats a number as text. Group sizing and separator and other locale-specific\n * configurations are based on the locale.\n *\n * Where:\n * - `value` is a number.\n * - `locale` is a `string` defining the locale to use.\n * - `digitInfo` See {@link DecimalPipe} for more details.\n *\n *\n */\nexport function formatNumber(value: number, locale: string, digitsInfo?: string): string {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  return formatNumberToLocaleString(\n      value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);\n}\n\ninterface ParsedNumberFormat {\n  minInt: number;\n  // the minimum number of digits required in the fraction part of the number\n  minFrac: number;\n  // the maximum number of digits required in the fraction part of the number\n  maxFrac: number;\n  // the prefix for a positive number\n  posPre: string;\n  // the suffix for a positive number\n  posSuf: string;\n  // the prefix for a negative number (e.g. `-` or `(`))\n  negPre: string;\n  // the suffix for a negative number (e.g. `)`)\n  negSuf: string;\n  // number of digits in each group of separated digits\n  gSize: number;\n  // number of digits in the last group of digits before the decimal separator\n  lgSize: number;\n}\n\nfunction parseNumberFormat(format: string, minusSign = '-'): ParsedNumberFormat {\n  const p = {\n    minInt: 1,\n    minFrac: 0,\n    maxFrac: 0,\n    posPre: '',\n    posSuf: '',\n    negPre: '',\n    negSuf: '',\n    gSize: 0,\n    lgSize: 0\n  };\n\n  const patternParts = format.split(PATTERN_SEP);\n  const positive = patternParts[0];\n  const negative = patternParts[1];\n\n  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ?\n      positive.split(DECIMAL_SEP) :\n      [\n        positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1),\n        positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)\n      ],\n        integer = positiveParts[0], fraction = positiveParts[1] || '';\n\n  p.posPre = integer.substr(0, integer.indexOf(DIGIT_CHAR));\n\n  for (let i = 0; i < fraction.length; i++) {\n    const ch = fraction.charAt(i);\n    if (ch === ZERO_CHAR) {\n      p.minFrac = p.maxFrac = i + 1;\n    } else if (ch === DIGIT_CHAR) {\n      p.maxFrac = i + 1;\n    } else {\n      p.posSuf += ch;\n    }\n  }\n\n  const groups = integer.split(GROUP_SEP);\n  p.gSize = groups[1] ? groups[1].length : 0;\n  p.lgSize = (groups[2] || groups[1]) ? (groups[2] || groups[1]).length : 0;\n\n  if (negative) {\n    const trunkLen = positive.length - p.posPre.length - p.posSuf.length,\n          pos = negative.indexOf(DIGIT_CHAR);\n\n    p.negPre = negative.substr(0, pos).replace(/'/g, '');\n    p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, '');\n  } else {\n    p.negPre = minusSign + p.posPre;\n    p.negSuf = p.posSuf;\n  }\n\n  return p;\n}\n\ninterface ParsedNumber {\n  // an array of digits containing leading zeros as necessary\n  digits: number[];\n  // the exponent for numbers that would need more than `MAX_DIGITS` digits in `d`\n  exponent: number;\n  // the number of the digits in `d` that are to the left of the decimal point\n  integerLen: number;\n}\n\n// Transforms a parsed number into a percentage by multiplying it by 100\nfunction toPercent(parsedNumber: ParsedNumber): ParsedNumber {\n  // if the number is 0, don't do anything\n  if (parsedNumber.digits[0] === 0) {\n    return parsedNumber;\n  }\n\n  // Getting the current number of decimals\n  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;\n  if (parsedNumber.exponent) {\n    parsedNumber.exponent += 2;\n  } else {\n    if (fractionLen === 0) {\n      parsedNumber.digits.push(0, 0);\n    } else if (fractionLen === 1) {\n      parsedNumber.digits.push(0);\n    }\n    parsedNumber.integerLen += 2;\n  }\n\n  return parsedNumber;\n}\n\n/**\n * Parses a number.\n * Significant bits of this parse algorithm came from https://github.com/MikeMcl/big.js/\n */\nfunction parseNumber(num: number): ParsedNumber {\n  let numStr = Math.abs(num) + '';\n  let exponent = 0, digits, integerLen;\n  let i, j, zeros;\n\n  // Decimal point?\n  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {\n    numStr = numStr.replace(DECIMAL_SEP, '');\n  }\n\n  // Exponential form?\n  if ((i = numStr.search(/e/i)) > 0) {\n    // Work out the exponent.\n    if (integerLen < 0) integerLen = i;\n    integerLen += +numStr.slice(i + 1);\n    numStr = numStr.substring(0, i);\n  } else if (integerLen < 0) {\n    // There was no decimal point or exponent so it is an integer.\n    integerLen = numStr.length;\n  }\n\n  // Count the number of leading zeros.\n  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) { /* empty */\n  }\n\n  if (i === (zeros = numStr.length)) {\n    // The digits are all zero.\n    digits = [0];\n    integerLen = 1;\n  } else {\n    // Count the number of trailing zeros\n    zeros--;\n    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;\n\n    // Trailing zeros are insignificant so ignore them\n    integerLen -= i;\n    digits = [];\n    // Convert string to array of digits without leading/trailing zeros.\n    for (j = 0; i <= zeros; i++, j++) {\n      digits[j] = Number(numStr.charAt(i));\n    }\n  }\n\n  // If the number overflows the maximum allowed digits then use an exponent.\n  if (integerLen > MAX_DIGITS) {\n    digits = digits.splice(0, MAX_DIGITS - 1);\n    exponent = integerLen - 1;\n    integerLen = 1;\n  }\n\n  return {digits, exponent, integerLen};\n}\n\n/**\n * Round the parsed number to the specified number of decimal places\n * This function changes the parsedNumber in-place\n */\nfunction roundNumber(parsedNumber: ParsedNumber, minFrac: number, maxFrac: number) {\n  if (minFrac > maxFrac) {\n    throw new Error(\n        `The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);\n  }\n\n  let digits = parsedNumber.digits;\n  let fractionLen = digits.length - parsedNumber.integerLen;\n  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);\n\n  // The index of the digit to where rounding is to occur\n  let roundAt = fractionSize + parsedNumber.integerLen;\n  let digit = digits[roundAt];\n\n  if (roundAt > 0) {\n    // Drop fractional digits beyond `roundAt`\n    digits.splice(Math.max(parsedNumber.integerLen, roundAt));\n\n    // Set non-fractional digits beyond `roundAt` to 0\n    for (let j = roundAt; j < digits.length; j++) {\n      digits[j] = 0;\n    }\n  } else {\n    // We rounded to zero so reset the parsedNumber\n    fractionLen = Math.max(0, fractionLen);\n    parsedNumber.integerLen = 1;\n    digits.length = Math.max(1, roundAt = fractionSize + 1);\n    digits[0] = 0;\n    for (let i = 1; i < roundAt; i++) digits[i] = 0;\n  }\n\n  if (digit >= 5) {\n    if (roundAt - 1 < 0) {\n      for (let k = 0; k > roundAt; k--) {\n        digits.unshift(0);\n        parsedNumber.integerLen++;\n      }\n      digits.unshift(1);\n      parsedNumber.integerLen++;\n    } else {\n      digits[roundAt - 1]++;\n    }\n  }\n\n  // Pad out with zeros to get the required fraction length\n  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);\n\n  let dropTrailingZeros = fractionSize !== 0;\n  // Minimal length = nb of decimals required + current nb of integers\n  // Any number besides that is optional and can be removed if it's a trailing 0\n  const minLen = minFrac + parsedNumber.integerLen;\n  // Do any carrying, e.g. a digit was rounded up to 10\n  const carry = digits.reduceRight(function(carry, d, i, digits) {\n    d = d + carry;\n    digits[i] = d < 10 ? d : d - 10;  // d % 10\n    if (dropTrailingZeros) {\n      // Do not keep meaningless fractional trailing zeros (e.g. 15.52000 --> 15.52)\n      if (digits[i] === 0 && i >= minLen) {\n        digits.pop();\n      } else {\n        dropTrailingZeros = false;\n      }\n    }\n    return d >= 10 ? 1 : 0;  // Math.floor(d / 10);\n  }, 0);\n  if (carry) {\n    digits.unshift(carry);\n    parsedNumber.integerLen++;\n  }\n}\n\nexport function parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"],"sourceRoot":""}