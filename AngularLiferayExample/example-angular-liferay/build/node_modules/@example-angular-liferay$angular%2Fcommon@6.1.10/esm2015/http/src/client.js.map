{"version":3,"sources":["../../../../../../../packages/common/http/src/client.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable, of } from 'rxjs';\nimport {concatMap, filter, map} from 'rxjs/operators';\n\nimport {HttpHandler} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpParams, HttpParamsOptions} from './params';\nimport {HttpRequest} from './request';\nimport {HttpEvent, HttpResponse} from './response';\n\n\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n */\nfunction addBody<T>(\n    options: {\n      headers?: HttpHeaders | {[header: string]: string | string[]},\n      observe?: HttpObserve,\n      params?: HttpParams | {[param: string]: string | string[]},\n      reportProgress?: boolean,\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n      withCredentials?: boolean,\n    },\n    body: T | null): any {\n  return {\n    body,\n    headers: options.headers,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n  };\n}\n\nexport type HttpObserve = 'body' | 'events' | 'response';\n\n/**\n * Perform HTTP requests.\n *\n * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies according to which\n * signature is called (mainly the values of `observe` and `responseType`).\n *\n *\n */\n@Injectable()\nexport class HttpClient {\n  constructor(private handler: HttpHandler) {}\n\n  /**\n   * Send the given `HttpRequest` and return a stream of `HttpEvents`.\n   */\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    params?: HttpParams|{[param: string]: string | string[]},\n    observe: 'events', reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as an `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<any>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    reportProgress?: boolean,\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<R>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<R>;\n\n  /**\n   * Construct a request in a manner where response type and requested `Observable` are not known\n   * statically.\n   *\n   * @return an `Observable` of whatever was requested, typed to `any`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    params?: HttpParams|{[param: string]: string | string[]},\n    observe?: HttpObserve,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  }): Observable<any>;\n\n  /**\n   * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n   * fires the request through the chain of registered interceptors and on to the\n   * server.\n   *\n   * This method can be called in one of two ways. Either an `HttpRequest`\n   * instance can be passed directly as the only parameter, or a method can be\n   * passed as the first parameter, a string URL as the second, and an\n   * options hash as the third.\n   *\n   * If a `HttpRequest` object is passed directly, an `Observable` of the\n   * raw `HttpEvent` stream will be returned.\n   *\n   * If a request is instead built by providing a URL, the options object\n   * determines the return type of `request()`. In addition to configuring\n   * request parameters such as the outgoing headers and/or the body, the options\n   * hash specifies two key pieces of information about the request: the\n   * `responseType` and what to `observe`.\n   *\n   * The `responseType` value determines how a successful response body will be\n   * parsed. If `responseType` is the default `json`, a type interface for the\n   * resulting object may be passed as a type parameter to `request()`.\n   *\n   * The `observe` value determines the return type of `request()`, based on what\n   * the consumer is interested in observing. A value of `events` will return an\n   * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,\n   * including progress events by default. A value of `response` will return an\n   * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`\n   * depends on the `responseType` and any optionally provided type parameter.\n   * A value of `body` will return an `Observable<T>` with the same `T` body type.\n   */\n  request(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders|{[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let req: HttpRequest<any>;\n    // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = first as HttpRequest<any>;\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming GET unless a method is\n      // provided.\n\n      // Figure out the headers.\n      let headers: HttpHeaders|undefined = undefined;\n      if (options.headers instanceof HttpHeaders) {\n        headers = options.headers;\n      } else {\n        headers = new HttpHeaders(options.headers);\n      }\n\n      // Sort out parameters.\n      let params: HttpParams|undefined = undefined;\n      if (!!options.params) {\n        if (options.params instanceof HttpParams) {\n          params = options.params;\n        } else {\n          params = new HttpParams({ fromObject: options.params } as HttpParamsOptions);\n        }\n      }\n\n      // Construct the request.\n      req = new HttpRequest(first, url !, (options.body !== undefined ? options.body : null), {\n        headers,\n        params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const events$: Observable<HttpEvent<any>> =\n        of (req).pipe(concatMap((req: HttpRequest<any>) => this.handler.handle(req)));\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const res$: Observable<HttpResponse<any>> = <Observable<HttpResponse<any>>>events$.pipe(\n        filter((event: HttpEvent<any>) => event instanceof HttpResponse));\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return res$.pipe(map((res: HttpResponse<any>) => {\n              // Validate that the body is an ArrayBuffer.\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new Error('Response is not an ArrayBuffer.');\n              }\n              return res.body;\n            }));\n          case 'blob':\n            return res$.pipe(map((res: HttpResponse<any>) => {\n              // Validate that the body is a Blob.\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new Error('Response is not a Blob.');\n              }\n              return res.body;\n            }));\n          case 'text':\n            return res$.pipe(map((res: HttpResponse<any>) => {\n              // Validate that the body is a string.\n              if (res.body !== null && typeof res.body !== 'string') {\n                throw new Error('Response is not a string.');\n              }\n              return res.body;\n            }));\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return res$.pipe(map((res: HttpResponse<any>) => res.body));\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  delete (url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  delete<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * DELETE request to be executed on the server. See the individual overloads for\n   * details of `delete()`'s return type based on the provided options.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('DELETE', url, options as any);\n  }\n\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  get(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  get<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * GET request to be executed on the server. See the individual overloads for\n   * details of `get()`'s return type based on the provided options.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('GET', url, options as any);\n  }\n\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n\n    /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  }): Observable<ArrayBuffer>;\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  head(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  head<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * HEAD request to be executed on the server. See the individual overloads for\n   * details of `head()`'s return type based on the provided options.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('HEAD', url, options as any);\n  }\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as an `Object`\n   */\n  jsonp(url: string, callbackParam: string): Observable<Object>;\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as type `T`.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause a request\n   * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n   *\n   * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n   * If no such interceptor is reached, then the `JSONP` request will likely be\n   * rejected by the configured backend.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T> {\n    return this.request<any>('JSONP', url, {\n      params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Make an OPTIONS request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  options(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  options<T>(url: string, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * OPTIONS request to be executed on the server. See the individual overloads for\n   * details of `options()`'s return type based on the provided options.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('OPTIONS', url, options as any);\n  }\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  patch(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  patch<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * PATCH request to be executed on the server. See the individual overloads for\n   * details of `patch()`'s return type based on the provided options.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PATCH', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  post(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  post<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * POST request to be executed on the server. See the individual overloads for\n   * details of `post()`'s return type based on the provided options.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('POST', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'events', responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe: 'response',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  put(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  put<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: 'body',\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n\n  /**\n   * Constructs an `Observable` which, when subscribed, will cause the configured\n   * PUT request to be executed on the server. See the individual overloads for\n   * details of `put()`'s return type based on the provided options.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders | {[header: string]: string | string[]},\n    observe?: HttpObserve,\n    params?: HttpParams|{[param: string]: string | string[]},\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PUT', url, addBody(options, body));\n  }\n}\n"],"sourceRoot":""}