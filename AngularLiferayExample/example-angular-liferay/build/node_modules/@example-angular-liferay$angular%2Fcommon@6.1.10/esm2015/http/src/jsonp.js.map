{"version":3,"sources":["../../../../../../../packages/common/http/src/jsonp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId: number = 0;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nexport abstract class JsonpCallbackContext { [key: string]: (data: any) => void; }\n\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n *\n *\n */\n@Injectable()\nexport class JsonpClientBackend implements HttpBackend {\n  constructor(private callbackMap: JsonpCallbackContext, @Inject(DOCUMENT) private document: any) {}\n\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  private nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n\n  /**\n   * Process a JSONP request and return an event stream of the results.\n   */\n  handle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let body: any|null = null;\n\n      // Whether the response callback has been called.\n      let finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the response is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\n}\n\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n *\n */\n@Injectable()\nexport class JsonpInterceptor {\n  constructor(private jsonp: JsonpClientBackend) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle(req as HttpRequest<never>);\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\n}\n"],"sourceRoot":""}