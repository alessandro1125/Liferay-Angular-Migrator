{"version":3,"sources":["../../../../../../../packages/common/http/src/interceptor.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,WAAQ,UAAR,EAAoB,cAApB,QAAyC,eAAzC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA,SAAM,MAAA,sBAAA,CAAA;;;;;AACJ,gBAAoB,IAApB,EAA+C,WAA/C,EAA2E;AAAvD,WAAA,IAAA,GAAA,IAAA;AAA2B,WAAA,WAAA,GAAA,WAAA;AAAgC;;;;;AAE/E,WAAO,GAAP,EAA4B;AAC1B,aAAO,KAAK,WAAL,CAAiB,SAAjB,CAA2B,GAA3B,EAAgC,KAAK,IAArC,CAAP;AACD;AALG;;;;;;;;;;;;;AAcN,SAAA,MAAa,oBAAoB,IAAI,cAAJ,CAAsC,mBAAtC,CAAjC;AAGA,SAAM,MAAA,eAAA,CAAA;;;;;;AACJ,cAAU,GAAV,EAAiC,IAAjC,EAAkD;AAChD,aAAO,KAAK,MAAL,CAAY,GAAZ,CAAP;AACD;AAHG;wCADL,U","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\n/**\n * Intercepts `HttpRequest` and handles them.\n *\n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n *\n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n *\n *\n */\nexport interface HttpInterceptor {\n  /**\n   * Intercept an outgoing `HttpRequest` and optionally transform it or the\n   * response.\n   *\n   * Typically an interceptor will transform the outgoing request before returning\n   * `next.handle(transformedReq)`. An interceptor may choose to transform the\n   * response event stream as well, by applying additional Rx operators on the stream\n   * returned by `next.handle()`.\n   *\n   * More rarely, an interceptor may choose to completely handle the request itself,\n   * and compose a new event stream instead of invoking `next.handle()`. This is\n   * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n   *\n   * It is also rare but valid for an interceptor to return multiple responses on the\n   * event stream for a single request.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n *\n *\n */\nexport class HttpInterceptorHandler implements HttpHandler {\n  constructor(private next: HttpHandler, private interceptor: HttpInterceptor) {}\n\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return this.interceptor.intercept(req, this.next);\n  }\n}\n\n/**\n * A multi-provider token which represents the array of `HttpInterceptor`s that\n * are registered.\n *\n *\n */\nexport const HTTP_INTERCEPTORS = new InjectionToken<HttpInterceptor[]>('HTTP_INTERCEPTORS');\n\n@Injectable()\nexport class NoopInterceptor implements HttpInterceptor {\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req);\n  }\n}\n"],"sourceRoot":""}