{"version":3,"sources":["../../../../../../../packages/common/http/src/xsrf.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,aAAQ,QAAR,EAAkB,qBAAqB,gBAAvC,QAA8D,iBAA9D;AACA,aAAQ,MAAR,EAAgB,UAAhB,EAA4B,cAA5B,EAA4C,WAA5C,QAA8D,eAA9D;;AAQA,WAAA,MAAa,mBAAmB,IAAI,cAAJ,CAA2B,kBAA3B,CAAhC;;AACA,WAAA,MAAa,mBAAmB,IAAI,cAAJ,CAA2B,kBAA3B,CAAhC;;;;;;;AAOA,WAAM,MAAA,sBAAA,CAAA;;;;;;;;;;;;;;AAaN,WAAM,MAAA,uBAAA,CAAA;;;;;;AASJ,oBAC8B,GAD9B,EACqE,QADrE,EAEsC,UAFtC,EAEwD;AAD1B,iBAAA,GAAA,GAAA,GAAA;AAAuC,iBAAA,QAAA,GAAA,QAAA;AAC/B,iBAAA,UAAA,GAAA,UAAA;oCAVH,E;6BACF,I;;;;8BAKZ,C;AAIuC;;;;AAE5D,mBAAQ;AACN,gBAAI,KAAK,QAAL,KAAkB,QAAtB,EAAgC;AAC9B,uBAAO,IAAP;AACD;;AACD,kBAAM,eAAe,KAAK,GAAL,CAAS,MAAT,IAAmB,EAAxC;AACA,gBAAI,iBAAiB,KAAK,gBAA1B,EAA4C;AAC1C,qBAAK,UAAL;AACA,qBAAK,SAAL,GAAiB,iBAAiB,YAAjB,EAA+B,KAAK,UAApC,CAAjB;AACA,qBAAK,gBAAL,GAAwB,YAAxB;AACD;AACD,mBAAO,KAAK,SAAZ;AACD;AAxBG;kDADL,U;;4FAWM,M,EAAM,MAAA,CAAC,QAAD,C,4CAA8B,M,EAAM,MAAA,CAAC,WAAD,C,4CAC1C,M,EAAM,MAAA,CAAC,gBAAD,C;;;;;;;;;;;;;;;;;;;;;AAoBb,WAAM,MAAA,mBAAA,CAAA;;;;;AACJ,oBACY,YADZ,EAEsC,UAFtC,EAEwD;AAD5C,iBAAA,YAAA,GAAA,YAAA;AAC0B,iBAAA,UAAA,GAAA,UAAA;AAAsB;;;;;;AAE5D,kBAAU,GAAV,EAAiC,IAAjC,EAAkD;;AAChD,kBAAM,QAAQ,IAAI,GAAJ,CAAQ,WAAR,EAAd;;;;;AAKA,gBAAI,IAAI,MAAJ,KAAe,KAAf,IAAwB,IAAI,MAAJ,KAAe,MAAvC,IAAiD,MAAM,UAAN,CAAiB,SAAjB,CAAjD,IACA,MAAM,UAAN,CAAiB,UAAjB,CADJ,EACkC;AAChC,uBAAO,KAAK,MAAL,CAAY,GAAZ,CAAP;AACD;;AACD,kBAAM,QAAQ,KAAK,YAAL,CAAkB,QAAlB,EAAd;;AAGA,gBAAI,UAAU,IAAV,IAAkB,CAAC,IAAI,OAAJ,CAAY,GAAZ,CAAgB,KAAK,UAArB,CAAvB,EAAyD;AACvD,sBAAM,IAAI,KAAJ,CAAU,EAAC,SAAS,IAAI,OAAJ,CAAY,GAAZ,CAAgB,KAAK,UAArB,EAAiC,KAAjC,CAAV,EAAV,CAAN;AACD;AACD,mBAAO,KAAK,MAAL,CAAY,GAAZ,CAAP;AACD;AAtBG;8CADL,U;;wDAG2B,sB,yCACrB,M,EAAM,MAAA,CAAC,gBAAD,C","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ÉµparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, PLATFORM_ID} from '@angular/core';\nimport {Observable} from 'rxjs';\n\nimport {HttpHandler} from './backend';\nimport {HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const XSRF_COOKIE_NAME = new InjectionToken<string>('XSRF_COOKIE_NAME');\nexport const XSRF_HEADER_NAME = new InjectionToken<string>('XSRF_HEADER_NAME');\n\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n *\n *\n */\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string|null;\n}\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\n@Injectable()\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\n  private lastCookieString: string = '';\n  private lastToken: string|null = null;\n\n  /**\n   * @internal for testing\n   */\n  parseCount: number = 0;\n\n  constructor(\n      @Inject(DOCUMENT) private doc: any, @Inject(PLATFORM_ID) private platform: string,\n      @Inject(XSRF_COOKIE_NAME) private cookieName: string) {}\n\n  getToken(): string|null {\n    if (this.platform === 'server') {\n      return null;\n    }\n    const cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\n@Injectable()\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n  constructor(\n      private tokenService: HttpXsrfTokenExtractor,\n      @Inject(XSRF_HEADER_NAME) private headerName: string) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n        lcUrl.startsWith('https://')) {\n      return next.handle(req);\n    }\n    const token = this.tokenService.getToken();\n\n    // Be careful not to overwrite an existing header of the same name.\n    if (token !== null && !req.headers.has(this.headerName)) {\n      req = req.clone({headers: req.headers.set(this.headerName, token)});\n    }\n    return next.handle(req);\n  }\n}\n"],"sourceRoot":""}