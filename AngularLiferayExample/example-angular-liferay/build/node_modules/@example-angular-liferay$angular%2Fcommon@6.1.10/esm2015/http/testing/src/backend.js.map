{"version":3,"sources":["../../../../../../../../packages/common/http/testing/src/backend.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpBackend, HttpEvent, HttpEventType, HttpRequest} from '@angular/common/http';\nimport {Injectable} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpTestingController, RequestMatch} from './api';\nimport {TestRequest} from './request';\n\n\n/**\n * A testing backend for `HttpClient` which both acts as an `HttpBackend`\n * and as the `HttpTestingController`.\n *\n * `HttpClientTestingBackend` works by keeping a list of all open requests.\n * As requests come in, they're added to the list. Users can assert that specific\n * requests were made and then flush them. In the end, a verify() method asserts\n * that no unexpected requests were made.\n *\n *\n */\n@Injectable()\nexport class HttpClientTestingBackend implements HttpBackend, HttpTestingController {\n  /**\n   * List of pending requests which have not yet been expected.\n   */\n  private open: TestRequest[] = [];\n\n  /**\n   * Handle an incoming request by queueing it in the list of open requests.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return new Observable((observer: Observer<any>) => {\n      const testReq = new TestRequest(req, observer);\n      this.open.push(testReq);\n      observer.next({ type: HttpEventType.Sent } as HttpEvent<any>);\n      return () => { testReq._cancelled = true; };\n    });\n  }\n\n  /**\n   * Helper function to search for requests in the list of open requests.\n   */\n  private _match(match: string|RequestMatch|((req: HttpRequest<any>) => boolean)): TestRequest[] {\n    if (typeof match === 'string') {\n      return this.open.filter(testReq => testReq.request.urlWithParams === match);\n    } else if (typeof match === 'function') {\n      return this.open.filter(testReq => match(testReq.request));\n    } else {\n      return this.open.filter(\n          testReq => (!match.method || testReq.request.method === match.method.toUpperCase()) &&\n              (!match.url || testReq.request.urlWithParams === match.url));\n    }\n  }\n\n  /**\n   * Search for requests in the list of open requests, and return all that match\n   * without asserting anything about the number of matches.\n   */\n  match(match: string|RequestMatch|((req: HttpRequest<any>) => boolean)): TestRequest[] {\n    const results = this._match(match);\n    results.forEach(result => {\n      const index = this.open.indexOf(result);\n      if (index !== -1) {\n        this.open.splice(index, 1);\n      }\n    });\n    return results;\n  }\n\n  /**\n   * Expect that a single outstanding request matches the given matcher, and return\n   * it.\n   *\n   * Requests returned through this API will no longer be in the list of open requests,\n   * and thus will not match twice.\n   */\n  expectOne(match: string|RequestMatch|((req: HttpRequest<any>) => boolean), description?: string):\n      TestRequest {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 1) {\n      throw new Error(\n          `Expected one matching request for criteria \"${description}\", found ${matches.length} requests.`);\n    }\n    if (matches.length === 0) {\n      throw new Error(`Expected one matching request for criteria \"${description}\", found none.`);\n    }\n    return matches[0];\n  }\n\n  /**\n   * Expect that no outstanding requests match the given matcher, and throw an error\n   * if any do.\n   */\n  expectNone(match: string|RequestMatch|((req: HttpRequest<any>) => boolean), description?: string):\n      void {\n    description = description || this.descriptionFromMatcher(match);\n    const matches = this.match(match);\n    if (matches.length > 0) {\n      throw new Error(\n          `Expected zero matching requests for criteria \"${description}\", found ${matches.length}.`);\n    }\n  }\n\n  /**\n   * Validate that there are no outstanding requests.\n   */\n  verify(opts: {ignoreCancelled?: boolean} = {}): void {\n    let open = this.open;\n    // It's possible that some requests may be cancelled, and this is expected.\n    // The user can ask to ignore open requests which have been cancelled.\n    if (opts.ignoreCancelled) {\n      open = open.filter(testReq => !testReq.cancelled);\n    }\n    if (open.length > 0) {\n      // Show the methods and URLs of open requests in the error, for convenience.\n      const requests = open.map(testReq => {\n                             const url = testReq.request.urlWithParams.split('?')[0];\n                             const method = testReq.request.method;\n                             return `${method} ${url}`;\n                           })\n                           .join(', ');\n      throw new Error(`Expected no open requests, found ${open.length}: ${requests}`);\n    }\n  }\n\n  private descriptionFromMatcher(matcher: string|RequestMatch|\n                                 ((req: HttpRequest<any>) => boolean)): string {\n    if (typeof matcher === 'string') {\n      return `Match URL: ${matcher}`;\n    } else if (typeof matcher === 'object') {\n      const method = matcher.method || '(any)';\n      const url = matcher.url || '(any)';\n      return `Match method: ${method}, URL: ${url}`;\n    } else {\n      return `Match by function: ${matcher.name}`;\n    }\n  }\n}\n"],"sourceRoot":""}