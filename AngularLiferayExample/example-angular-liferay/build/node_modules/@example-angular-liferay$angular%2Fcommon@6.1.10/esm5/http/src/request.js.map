{"version":3,"sources":["../../../../../../../../../../../packages/common/http/src/request.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\n\n/**\n * Construction interface for `HttpRequest`s.\n *\n * All values are optional and will override default values if provided.\n */\ninterface HttpRequestInit {\n  headers?: HttpHeaders;\n  reportProgress?: boolean;\n  params?: HttpParams;\n  responseType?: 'arraybuffer'|'blob'|'json'|'text';\n  withCredentials?: boolean;\n}\n\n/**\n * Determine whether the given HTTP method may include a body.\n */\nfunction mightHaveBody(method: string): boolean {\n  switch (method) {\n    case 'DELETE':\n    case 'GET':\n    case 'HEAD':\n    case 'OPTIONS':\n    case 'JSONP':\n      return false;\n    default:\n      return true;\n  }\n}\n\n/**\n * Safely assert whether the given value is an ArrayBuffer.\n *\n * In some execution environments ArrayBuffer is not defined.\n */\nfunction isArrayBuffer(value: any): value is ArrayBuffer {\n  return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;\n}\n\n/**\n * Safely assert whether the given value is a Blob.\n *\n * In some execution environments Blob is not defined.\n */\nfunction isBlob(value: any): value is Blob {\n  return typeof Blob !== 'undefined' && value instanceof Blob;\n}\n\n/**\n * Safely assert whether the given value is a FormData instance.\n *\n * In some execution environments FormData is not defined.\n */\nfunction isFormData(value: any): value is FormData {\n  return typeof FormData !== 'undefined' && value instanceof FormData;\n}\n\n/**\n * An outgoing HTTP request with an optional typed body.\n *\n * `HttpRequest` represents an outgoing request, including URL, method,\n * headers, body, and other request configuration options. Instances should be\n * assumed to be immutable. To modify a `HttpRequest`, the `clone`\n * method should be used.\n *\n *\n */\nexport class HttpRequest<T> {\n  /**\n   * The request body, or `null` if one isn't set.\n   *\n   * Bodies are not enforced to be immutable, as they can include a reference to any\n   * user-defined data type. However, interceptors should take care to preserve\n   * idempotence by treating them as such.\n   */\n  readonly body: T|null = null;\n\n  /**\n   * Outgoing headers for this request.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly headers !: HttpHeaders;\n\n  /**\n   * Whether this request should be made in a way that exposes progress events.\n   *\n   * Progress events are expensive (change detection runs on each event) and so\n   * they should only be requested if the consumer intends to monitor them.\n   */\n  readonly reportProgress: boolean = false;\n\n  /**\n   * Whether this request should be sent with outgoing credentials (cookies).\n   */\n  readonly withCredentials: boolean = false;\n\n  /**\n   * The expected response type of the server.\n   *\n   * This is used to parse the response appropriately before returning it to\n   * the requestee.\n   */\n  readonly responseType: 'arraybuffer'|'blob'|'json'|'text' = 'json';\n\n  /**\n   * The outgoing HTTP request method.\n   */\n  readonly method: string;\n\n  /**\n   * Outgoing URL parameters.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly params !: HttpParams;\n\n  /**\n   * The outgoing URL with all URL parameters set.\n   */\n  readonly urlWithParams: string;\n\n  constructor(method: 'DELETE'|'GET'|'HEAD'|'JSONP'|'OPTIONS', url: string, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(method: 'POST'|'PUT'|'PATCH', url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(method: string, url: string, body: T|null, init?: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  });\n  constructor(\n      method: string, readonly url: string, third?: T|{\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }|null,\n      fourth?: {\n        headers?: HttpHeaders,\n        reportProgress?: boolean,\n        params?: HttpParams,\n        responseType?: 'arraybuffer'|'blob'|'json'|'text',\n        withCredentials?: boolean,\n      }) {\n    this.method = method.toUpperCase();\n    // Next, need to figure out which argument holds the HttpRequestInit\n    // options, if any.\n    let options: HttpRequestInit|undefined;\n\n    // Check whether a body argument is expected. The only valid way to omit\n    // the body argument is to use a known no-body method like GET.\n    if (mightHaveBody(this.method) || !!fourth) {\n      // Body is the third argument, options are the fourth.\n      this.body = (third !== undefined) ? third as T : null;\n      options = fourth;\n    } else {\n      // No body required, options are the third argument. The body stays null.\n      options = third as HttpRequestInit;\n    }\n\n    // If options have been passed, interpret them.\n    if (options) {\n      // Normalize reportProgress and withCredentials.\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n\n      // Override default response type of 'json' if one is provided.\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n\n      // Override headers if they're provided.\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n\n      if (!!options.params) {\n        this.params = options.params;\n      }\n    }\n\n    // If no headers have been passed in, construct a new HttpHeaders instance.\n    if (!this.headers) {\n      this.headers = new HttpHeaders();\n    }\n\n    // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      // Encode the parameters to a string in preparation for inclusion in the URL.\n      const params = this.params.toString();\n      if (params.length === 0) {\n        // No parameters, the visible URL is just the URL given at creation time.\n        this.urlWithParams = url;\n      } else {\n        // Does the URL already have query parameters? Look for '?'.\n        const qIdx = url.indexOf('?');\n        // There are 3 cases to handle:\n        // 1) No existing parameters -> append '?' followed by params.\n        // 2) '?' exists and is followed by existing query string ->\n        //    append '&' followed by params.\n        // 3) '?' exists at the end of the url -> append params directly.\n        // This basically amounts to determining the character, if any, with\n        // which to join the URL and parameters.\n        const sep: string = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n\n  /**\n   * Transform the free-form body into a serialized format suitable for\n   * transmission to the server.\n   */\n  serializeBody(): ArrayBuffer|Blob|FormData|string|null {\n    // If no body is present, no need to serialize it.\n    if (this.body === null) {\n      return null;\n    }\n    // Check whether the body is already in a serialized form. If so,\n    // it can just be returned directly.\n    if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||\n        typeof this.body === 'string') {\n      return this.body;\n    }\n    // Check whether the body is an instance of HttpUrlEncodedParams.\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    // Check whether the body is an object or array, and serialize with JSON if so.\n    if (typeof this.body === 'object' || typeof this.body === 'boolean' ||\n        Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    // Fall back on toString() for everything else.\n    return (this.body as any).toString();\n  }\n\n  /**\n   * Examine the body and attempt to infer an appropriate MIME type\n   * for it.\n   *\n   * If no such type can be inferred, this method will return `null`.\n   */\n  detectContentTypeHeader(): string|null {\n    // An empty body has no content type.\n    if (this.body === null) {\n      return null;\n    }\n    // FormData bodies rely on the browser's content type assignment.\n    if (isFormData(this.body)) {\n      return null;\n    }\n    // Blobs usually have their own content type. If it doesn't, then\n    // no type can be inferred.\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    // Array buffers have unknown contents and thus no type can be inferred.\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    // Technically, strings could be a form of JSON data, but it's safe enough\n    // to assume they're plain strings.\n    if (typeof this.body === 'string') {\n      return 'text/plain';\n    }\n    // `HttpUrlEncodedParams` has its own content-type.\n    if (this.body instanceof HttpParams) {\n      return 'application/x-www-form-urlencoded;charset=UTF-8';\n    }\n    // Arrays, objects, and numbers will be encoded as JSON.\n    if (typeof this.body === 'object' || typeof this.body === 'number' ||\n        Array.isArray(this.body)) {\n      return 'application/json';\n    }\n    // No type could be inferred.\n    return null;\n  }\n\n  clone(): HttpRequest<T>;\n  clone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: T|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<T>;\n  clone<V>(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: V|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string},\n  }): HttpRequest<V>;\n  clone(update: {\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    params?: HttpParams,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n    body?: any|null,\n    method?: string,\n    url?: string,\n    setHeaders?: {[name: string]: string | string[]},\n    setParams?: {[param: string]: string};\n  } = {}): HttpRequest<any> {\n    // For method, url, and responseType, take the current value unless\n    // it is overridden in the update hash.\n    const method = update.method || this.method;\n    const url = update.url || this.url;\n    const responseType = update.responseType || this.responseType;\n\n    // The body is somewhat special - a `null` value in update.body means\n    // whatever current body is present is being overridden with an empty\n    // body, whereas an `undefined` value in update.body implies no\n    // override.\n    const body = (update.body !== undefined) ? update.body : this.body;\n\n    // Carefully handle the boolean options to differentiate between\n    // `false` and `undefined` in the update args.\n    const withCredentials =\n        (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;\n    const reportProgress =\n        (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;\n\n    // Headers and params may be appended to if `setHeaders` or\n    // `setParams` are used.\n    let headers = update.headers || this.headers;\n    let params = update.params || this.params;\n\n    // Check whether the caller has asked to add headers.\n    if (update.setHeaders !== undefined) {\n      // Set every requested header.\n      headers =\n          Object.keys(update.setHeaders)\n              .reduce((headers, name) => headers.set(name, update.setHeaders ![name]), headers);\n    }\n\n    // Check whether the caller has asked to set params.\n    if (update.setParams) {\n      // Set every requested param.\n      params = Object.keys(update.setParams)\n                   .reduce((params, param) => params.set(param, update.setParams ![param]), params);\n    }\n\n    // Finally, construct the new HttpRequest using the pieces from above.\n    return new HttpRequest(\n        method, url, body, {\n                               params, headers, reportProgress, responseType, withCredentials,\n                           });\n  }\n}\n"],"sourceRoot":""}