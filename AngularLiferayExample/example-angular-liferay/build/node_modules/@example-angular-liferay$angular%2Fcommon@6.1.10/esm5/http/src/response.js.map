{"version":3,"sources":["../../../../../../../../../../../packages/common/http/src/response.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpHeaders} from './headers';\n\n/**\n * Type enumeration for the different kinds of `HttpEvent`.\n *\n *\n */\nexport enum HttpEventType {\n  /**\n   * The request was sent out over the wire.\n   */\n  Sent,\n\n  /**\n   * An upload progress event was received.\n   */\n  UploadProgress,\n\n  /**\n   * The response status code and headers were received.\n   */\n  ResponseHeader,\n\n  /**\n   * A download progress event was received.\n   */\n  DownloadProgress,\n\n  /**\n   * The full response including the body was received.\n   */\n  Response,\n\n  /**\n   * A custom event from an interceptor or a backend.\n   */\n  User,\n}\n\n/**\n * Base interface for progress events.\n *\n *\n */\nexport interface HttpProgressEvent {\n  /**\n   * Progress event type is either upload or download.\n   */\n  type: HttpEventType.DownloadProgress|HttpEventType.UploadProgress;\n\n  /**\n   * Number of bytes uploaded or downloaded.\n   */\n  loaded: number;\n\n  /**\n   * Total number of bytes to upload or download. Depending on the request or\n   * response, this may not be computable and thus may not be present.\n   */\n  total?: number;\n}\n\n/**\n * A download progress event.\n *\n *\n */\nexport interface HttpDownloadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.DownloadProgress;\n\n  /**\n   * The partial response body as downloaded so far.\n   *\n   * Only present if the responseType was `text`.\n   */\n  partialText?: string;\n}\n\n/**\n * An upload progress event.\n *\n *\n */\nexport interface HttpUploadProgressEvent extends HttpProgressEvent {\n  type: HttpEventType.UploadProgress;\n}\n\n/**\n * An event indicating that the request was sent to the server. Useful\n * when a request may be retried multiple times, to distinguish between\n * retries on the final event stream.\n *\n *\n */\nexport interface HttpSentEvent { type: HttpEventType.Sent; }\n\n/**\n * A user-defined event.\n *\n * Grouping all custom events under this type ensures they will be handled\n * and forwarded by all implementations of interceptors.\n *\n *\n */\nexport interface HttpUserEvent<T> { type: HttpEventType.User; }\n\n/**\n * An error that represents a failed attempt to JSON.parse text coming back\n * from the server.\n *\n * It bundles the Error object with the actual response body that failed to parse.\n *\n *\n */\nexport interface HttpJsonParseError {\n  error: Error;\n  text: string;\n}\n\n/**\n * Union type for all possible events on the response stream.\n *\n * Typed according to the expected type of the response.\n *\n *\n */\nexport type HttpEvent<T> =\n    HttpSentEvent | HttpHeaderResponse | HttpResponse<T>| HttpProgressEvent | HttpUserEvent<T>;\n\n/**\n * Base class for both `HttpResponse` and `HttpHeaderResponse`.\n *\n *\n */\nexport abstract class HttpResponseBase {\n  /**\n   * All response headers.\n   */\n  readonly headers: HttpHeaders;\n\n  /**\n   * Response status code.\n   */\n  readonly status: number;\n\n  /**\n   * Textual description of response status code.\n   *\n   * Do not depend on this.\n   */\n  readonly statusText: string;\n\n  /**\n   * URL of the resource retrieved, or null if not available.\n   */\n  readonly url: string|null;\n\n  /**\n   * Whether the status code falls in the 2xx range.\n   */\n  readonly ok: boolean;\n\n  /**\n   * Type of the response, narrowed to either the full response or the header.\n   */\n  // TODO(issue/24571): remove '!'.\n  readonly type !: HttpEventType.Response | HttpEventType.ResponseHeader;\n\n  /**\n   * Super-constructor for all responses.\n   *\n   * The single parameter accepted is an initialization hash. Any properties\n   * of the response passed there will override the default values.\n   */\n  constructor(\n      init: {\n        headers?: HttpHeaders,\n        status?: number,\n        statusText?: string,\n        url?: string,\n      },\n      defaultStatus: number = 200, defaultStatusText: string = 'OK') {\n    // If the hash has values passed, use them to initialize the response.\n    // Otherwise use the default values.\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== undefined ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n\n    // Cache the ok value to avoid defining a getter.\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n}\n\n/**\n * A partial HTTP response which only includes the status and header data,\n * but no response body.\n *\n * `HttpHeaderResponse` is a `HttpEvent` available on the response\n * event stream, only when progress events are requested.\n *\n *\n */\nexport class HttpHeaderResponse extends HttpResponseBase {\n  /**\n   * Create a new `HttpHeaderResponse` with the given parameters.\n   */\n  constructor(init: {\n    headers?: HttpHeaders,\n    status?: number,\n    statusText?: string,\n    url?: string,\n  } = {}) {\n    super(init);\n  }\n\n  readonly type: HttpEventType.ResponseHeader = HttpEventType.ResponseHeader;\n\n  /**\n   * Copy this `HttpHeaderResponse`, overriding its contents with the\n   * given parameter hash.\n   */\n  clone(update: {headers?: HttpHeaders; status?: number; statusText?: string; url?: string;} = {}):\n      HttpHeaderResponse {\n    // Perform a straightforward initialization of the new HttpHeaderResponse,\n    // overriding the current parameters with new ones if given.\n    return new HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== undefined ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\n/**\n * A full HTTP response, including a typed response body (which may be `null`\n * if one was not returned).\n *\n * `HttpResponse` is a `HttpEvent` available on the response event\n * stream.\n *\n *\n */\nexport class HttpResponse<T> extends HttpResponseBase {\n  /**\n   * The response body, or `null` if one was not returned.\n   */\n  readonly body: T|null;\n\n  /**\n   * Construct a new `HttpResponse`.\n   */\n  constructor(init: {\n    body?: T | null, headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  } = {}) {\n    super(init);\n    this.body = init.body !== undefined ? init.body : null;\n  }\n\n  readonly type: HttpEventType.Response = HttpEventType.Response;\n\n  clone(): HttpResponse<T>;\n  clone(update: {headers?: HttpHeaders; status?: number; statusText?: string; url?: string;}):\n      HttpResponse<T>;\n  clone<V>(update: {\n    body?: V | null, headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  }): HttpResponse<V>;\n  clone(update: {\n    body?: any | null; headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  } = {}): HttpResponse<any> {\n    return new HttpResponse<any>({\n      body: (update.body !== undefined) ? update.body : this.body,\n      headers: update.headers || this.headers,\n      status: (update.status !== undefined) ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || undefined,\n    });\n  }\n}\n\n/**\n * A response that represents an error or failure, either from a\n * non-successful HTTP status, an error while executing the request,\n * or some other failure which occurred during the parsing of the response.\n *\n * Any error returned on the `Observable` response stream will be\n * wrapped in an `HttpErrorResponse` to provide additional context about\n * the state of the HTTP layer when the error occurred. The error property\n * will contain either a wrapped Error object or the error response returned\n * from the server.\n *\n *\n */\nexport class HttpErrorResponse extends HttpResponseBase implements Error {\n  readonly name = 'HttpErrorResponse';\n  readonly message: string;\n  readonly error: any|null;\n\n  /**\n   * Errors are never okay, even when the status code is in the 2xx success range.\n   */\n  readonly ok = false;\n\n  constructor(init: {\n    error?: any; headers?: HttpHeaders; status?: number; statusText?: string; url?: string;\n  }) {\n    // Initialize with a default status of 0 / Unknown Error.\n    super(init, 0, 'Unknown Error');\n\n    // If the response was successful, then this was a parse error. Otherwise, it was\n    // a protocol-level failure of some sort. Either the request failed in transit\n    // or the server returned an unsuccessful status code.\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || '(unknown url)'}`;\n    } else {\n      this.message =\n          `Http failure response for ${init.url || '(unknown url)'}: ${init.status} ${init.statusText}`;\n    }\n    this.error = init.error || null;\n  }\n}\n"],"sourceRoot":""}