{"version":3,"sources":["../../../../../../../../../../../packages/common/http/src/xhr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpRequest} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpUploadProgressEvent} from './response';\n\nconst XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n *\n *\n */\nexport abstract class XhrFactory { abstract build(): XMLHttpRequest; }\n\n/**\n * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n *\n *\n */\n@Injectable()\nexport class BrowserXhr implements XhrFactory {\n  constructor() {}\n  build(): any { return <any>(new XMLHttpRequest()); }\n}\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n *\n *\n */\n@Injectable()\nexport class HttpXhrBackend implements HttpBackend {\n  constructor(private xhrFactory: XhrFactory) {}\n\n  /**\n   * Process a request and return a stream of response events.\n   */\n  handle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.urlWithParams);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        const responseType = req.responseType.toLowerCase();\n\n        // JSON responses need to be processed as text. This is because if the server\n        // returns an XSSI-prefixed JSON response, the browser will fail to parse it,\n        // xhr.response will be null, and xhr.responseText cannot be accessed to\n        // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON\n        // is parsed by first requesting text and then applying JSON.parse.\n        xhr.responseType = ((responseType !== 'json') ? responseType : 'text') as any;\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (req.responseType === 'json' && typeof body === 'string') {\n          // Save the original body, before attempting XSSI prefix stripping.\n          const originalBody = body;\n          body = body.replace(XSSI_PREFIX, '');\n          try {\n            // Attempt the parse. If it fails, a parse error should be delivered to the user.\n            body = body !== '' ? JSON.parse(body) : null;\n          } catch (error) {\n            // Since the JSON.parse failed, it's reasonable to assume this might not have been a\n            // JSON response. Restore the original body (including any XSSI prefix) to deliver\n            // a better error response.\n            body = originalBody;\n\n            // If this was an error request to begin with, leave it as a string, it probably\n            // just isn't JSON. Otherwise, deliver the parsing error to the user.\n            if (ok) {\n              // Even though the response status was 2xx, this is still an error.\n              ok = false;\n              // The parse error contains the text of the body that failed to parse.\n              body = { error, text: body } as HttpJsonParseError;\n            }\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const onError = (error: ErrorEvent) => {\n        const res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const onUpProgress = (event: ProgressEvent) => {\n        // Upload progress events are simpler. Begin building the progress\n        // event.\n        let progress: HttpUploadProgressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded: event.loaded,\n        };\n\n        // If the total number of bytes being uploaded is available, include\n        // it.\n        if (event.lengthComputable) {\n          progress.total = event.total;\n        }\n\n        // Send the event.\n        observer.next(progress);\n      };\n\n      // By default, register for load and error events.\n      xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\n}\n"],"sourceRoot":""}