{"version":3,"sources":["../../../../../../../../../../../packages/common/http/src/jsonp.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable} from '@angular/core';\nimport {Observable, Observer} from 'rxjs';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet nextRequestId: number = 0;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n *\n * In the browser, this should always be the `window` object.\n *\n *\n */\nexport abstract class JsonpCallbackContext { [key: string]: (data: any) => void; }\n\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n *\n *\n */\n@Injectable()\nexport class JsonpClientBackend implements HttpBackend {\n  constructor(private callbackMap: JsonpCallbackContext, @Inject(DOCUMENT) private document: any) {}\n\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  private nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n\n  /**\n   * Process a JSONP request and return an event stream of the results.\n   */\n  handle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let body: any|null = null;\n\n      // Whether the response callback has been called.\n      let finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the response is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\n}\n\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n *\n *\n */\n@Injectable()\nexport class JsonpInterceptor {\n  constructor(private jsonp: JsonpClientBackend) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle(req as HttpRequest<never>);\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\n}\n"],"sourceRoot":""}