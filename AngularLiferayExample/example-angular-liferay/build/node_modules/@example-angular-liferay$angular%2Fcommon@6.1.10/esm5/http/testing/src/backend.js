Liferay.Loader.define('@example-angular-liferay$angular/common@6.1.10/esm5/http/testing/src/backend', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { HttpEventType } from '@angular/common/http';
    import { Injectable } from '@angular/core';
    import { Observable } from 'rxjs';
    import { TestRequest } from './request';
    /**
     * A testing backend for `HttpClient` which both acts as an `HttpBackend`
     * and as the `HttpTestingController`.
     *
     * `HttpClientTestingBackend` works by keeping a list of all open requests.
     * As requests come in, they're added to the list. Users can assert that specific
     * requests were made and then flush them. In the end, a verify() method asserts
     * that no unexpected requests were made.
     *
     *
     */
    var HttpClientTestingBackend = /** @class */function () {
        function HttpClientTestingBackend() {
            /**
             * List of pending requests which have not yet been expected.
             */
            this.open = [];
        }
        /**
         * Handle an incoming request by queueing it in the list of open requests.
         */
        HttpClientTestingBackend.prototype.handle = function (req) {
            var _this = this;
            return new Observable(function (observer) {
                var testReq = new TestRequest(req, observer);
                _this.open.push(testReq);
                observer.next({ type: HttpEventType.Sent });
                return function () {
                    testReq._cancelled = true;
                };
            });
        };
        /**
         * Helper function to search for requests in the list of open requests.
         */
        HttpClientTestingBackend.prototype._match = function (match) {
            if (typeof match === 'string') {
                return this.open.filter(function (testReq) {
                    return testReq.request.urlWithParams === match;
                });
            } else if (typeof match === 'function') {
                return this.open.filter(function (testReq) {
                    return match(testReq.request);
                });
            } else {
                return this.open.filter(function (testReq) {
                    return (!match.method || testReq.request.method === match.method.toUpperCase()) && (!match.url || testReq.request.urlWithParams === match.url);
                });
            }
        };
        /**
         * Search for requests in the list of open requests, and return all that match
         * without asserting anything about the number of matches.
         */
        HttpClientTestingBackend.prototype.match = function (match) {
            var _this = this;
            var results = this._match(match);
            results.forEach(function (result) {
                var index = _this.open.indexOf(result);
                if (index !== -1) {
                    _this.open.splice(index, 1);
                }
            });
            return results;
        };
        /**
         * Expect that a single outstanding request matches the given matcher, and return
         * it.
         *
         * Requests returned through this API will no longer be in the list of open requests,
         * and thus will not match twice.
         */
        HttpClientTestingBackend.prototype.expectOne = function (match, description) {
            description = description || this.descriptionFromMatcher(match);
            var matches = this.match(match);
            if (matches.length > 1) {
                throw new Error("Expected one matching request for criteria \"" + description + "\", found " + matches.length + " requests.");
            }
            if (matches.length === 0) {
                throw new Error("Expected one matching request for criteria \"" + description + "\", found none.");
            }
            return matches[0];
        };
        /**
         * Expect that no outstanding requests match the given matcher, and throw an error
         * if any do.
         */
        HttpClientTestingBackend.prototype.expectNone = function (match, description) {
            description = description || this.descriptionFromMatcher(match);
            var matches = this.match(match);
            if (matches.length > 0) {
                throw new Error("Expected zero matching requests for criteria \"" + description + "\", found " + matches.length + ".");
            }
        };
        /**
         * Validate that there are no outstanding requests.
         */
        HttpClientTestingBackend.prototype.verify = function (opts) {
            if (opts === void 0) {
                opts = {};
            }
            var open = this.open;
            // It's possible that some requests may be cancelled, and this is expected.
            // The user can ask to ignore open requests which have been cancelled.
            if (opts.ignoreCancelled) {
                open = open.filter(function (testReq) {
                    return !testReq.cancelled;
                });
            }
            if (open.length > 0) {
                // Show the methods and URLs of open requests in the error, for convenience.
                var requests = open.map(function (testReq) {
                    var url = testReq.request.urlWithParams.split('?')[0];
                    var method = testReq.request.method;
                    return method + " " + url;
                }).join(', ');
                throw new Error("Expected no open requests, found " + open.length + ": " + requests);
            }
        };
        HttpClientTestingBackend.prototype.descriptionFromMatcher = function (matcher) {
            if (typeof matcher === 'string') {
                return "Match URL: " + matcher;
            } else if (typeof matcher === 'object') {
                var method = matcher.method || '(any)';
                var url = matcher.url || '(any)';
                return "Match method: " + method + ", URL: " + url;
            } else {
                return "Match by function: " + matcher.name;
            }
        };
        HttpClientTestingBackend = tslib_1.__decorate([Injectable()], HttpClientTestingBackend);
        return HttpClientTestingBackend;
    }();
    export { HttpClientTestingBackend };
});
//# sourceMappingURL=backend.js.map