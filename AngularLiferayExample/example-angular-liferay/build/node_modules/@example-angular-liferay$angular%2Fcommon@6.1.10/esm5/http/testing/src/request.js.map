{"version":3,"sources":["../../../../../../../../../../../../../packages/common/http/testing/src/request.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {HttpErrorResponse, HttpEvent, HttpHeaders, HttpRequest, HttpResponse} from '@angular/common/http';\nimport {Observer} from 'rxjs';\n\n/**\n * A mock requests that was received and is ready to be answered.\n *\n * This interface allows access to the underlying `HttpRequest`, and allows\n * responding with `HttpEvent`s or `HttpErrorResponse`s.\n *\n *\n */\nexport class TestRequest {\n  /**\n   * Whether the request was cancelled after it was sent.\n   */\n  get cancelled(): boolean { return this._cancelled; }\n\n  /**\n   * @internal set by `HttpClientTestingBackend`\n   */\n  _cancelled = false;\n\n  constructor(public request: HttpRequest<any>, private observer: Observer<HttpEvent<any>>) {}\n\n  /**\n   * Resolve the request by returning a body plus additional HTTP information (such as response\n   * headers) if provided.\n   *\n   * Both successful and unsuccessful responses can be delivered via `flush()`.\n   */\n  flush(body: ArrayBuffer|Blob|string|number|Object|(string|number|Object|null)[]|null, opts: {\n    headers?: HttpHeaders | {[name: string]: string | string[]},\n    status?: number,\n    statusText?: string,\n  } = {}): void {\n    if (this.cancelled) {\n      throw new Error(`Cannot flush a cancelled request.`);\n    }\n    const url = this.request.urlWithParams;\n    const headers =\n        (opts.headers instanceof HttpHeaders) ? opts.headers : new HttpHeaders(opts.headers);\n    body = _maybeConvertBody(this.request.responseType, body);\n    let statusText: string|undefined = opts.statusText;\n    let status: number = opts.status !== undefined ? opts.status : 200;\n    if (opts.status === undefined) {\n      if (body === null) {\n        status = 204;\n        statusText = statusText || 'No Content';\n      } else {\n        statusText = statusText || 'OK';\n      }\n    }\n    if (statusText === undefined) {\n      throw new Error('statusText is required when setting a custom status.');\n    }\n    if (status >= 200 && status < 300) {\n      this.observer.next(new HttpResponse<any>({body, headers, status, statusText, url}));\n      this.observer.complete();\n    } else {\n      this.observer.error(new HttpErrorResponse({error: body, headers, status, statusText, url}));\n    }\n  }\n\n  /**\n   * Resolve the request by returning an `ErrorEvent` (e.g. simulating a network failure).\n   */\n  error(error: ErrorEvent, opts: {\n    headers?: HttpHeaders | {[name: string]: string | string[]},\n    status?: number,\n    statusText?: string,\n  } = {}): void {\n    if (this.cancelled) {\n      throw new Error(`Cannot return an error for a cancelled request.`);\n    }\n    if (opts.status && opts.status >= 200 && opts.status < 300) {\n      throw new Error(`error() called with a successful status.`);\n    }\n    const headers =\n        (opts.headers instanceof HttpHeaders) ? opts.headers : new HttpHeaders(opts.headers);\n    this.observer.error(new HttpErrorResponse({\n      error,\n      headers,\n      status: opts.status || 0,\n      statusText: opts.statusText || '',\n      url: this.request.urlWithParams,\n    }));\n  }\n\n  /**\n   * Deliver an arbitrary `HttpEvent` (such as a progress event) on the response stream for this\n   * request.\n   */\n  event(event: HttpEvent<any>): void {\n    if (this.cancelled) {\n      throw new Error(`Cannot send events to a cancelled request.`);\n    }\n    this.observer.next(event);\n  }\n}\n\n\n/**\n * Helper function to convert a response body to an ArrayBuffer.\n */\nfunction _toArrayBufferBody(\n    body: ArrayBuffer | Blob | string | number | Object |\n    (string | number | Object | null)[]): ArrayBuffer {\n  if (typeof ArrayBuffer === 'undefined') {\n    throw new Error('ArrayBuffer responses are not supported on this platform.');\n  }\n  if (body instanceof ArrayBuffer) {\n    return body;\n  }\n  throw new Error('Automatic conversion to ArrayBuffer is not supported for response type.');\n}\n\n/**\n * Helper function to convert a response body to a Blob.\n */\nfunction _toBlob(\n    body: ArrayBuffer | Blob | string | number | Object |\n    (string | number | Object | null)[]): Blob {\n  if (typeof Blob === 'undefined') {\n    throw new Error('Blob responses are not supported on this platform.');\n  }\n  if (body instanceof Blob) {\n    return body;\n  }\n  if (ArrayBuffer && body instanceof ArrayBuffer) {\n    return new Blob([body]);\n  }\n  throw new Error('Automatic conversion to Blob is not supported for response type.');\n}\n\n/**\n * Helper function to convert a response body to JSON data.\n */\nfunction _toJsonBody(\n    body: ArrayBuffer | Blob | string | number | Object | (string | number | Object | null)[],\n    format: string = 'JSON'): Object|string|number|(Object | string | number)[] {\n  if (typeof ArrayBuffer !== 'undefined' && body instanceof ArrayBuffer) {\n    throw new Error(`Automatic conversion to ${format} is not supported for ArrayBuffers.`);\n  }\n  if (typeof Blob !== 'undefined' && body instanceof Blob) {\n    throw new Error(`Automatic conversion to ${format} is not supported for Blobs.`);\n  }\n  if (typeof body === 'string' || typeof body === 'number' || typeof body === 'object' ||\n      Array.isArray(body)) {\n    return body;\n  }\n  throw new Error(`Automatic conversion to ${format} is not supported for response type.`);\n}\n\n/**\n * Helper function to convert a response body to a string.\n */\nfunction _toTextBody(\n    body: ArrayBuffer | Blob | string | number | Object |\n    (string | number | Object | null)[]): string {\n  if (typeof body === 'string') {\n    return body;\n  }\n  if (typeof ArrayBuffer !== 'undefined' && body instanceof ArrayBuffer) {\n    throw new Error('Automatic conversion to text is not supported for ArrayBuffers.');\n  }\n  if (typeof Blob !== 'undefined' && body instanceof Blob) {\n    throw new Error('Automatic conversion to text is not supported for Blobs.');\n  }\n  return JSON.stringify(_toJsonBody(body, 'text'));\n}\n\n/**\n * Convert a response body to the requested type.\n */\nfunction _maybeConvertBody(\n    responseType: string, body: ArrayBuffer | Blob | string | number | Object |\n        (string | number | Object | null)[] | null): ArrayBuffer|Blob|string|number|Object|\n    (string | number | Object | null)[]|null {\n  if (body === null) {\n    return null;\n  }\n  switch (responseType) {\n    case 'arraybuffer':\n      return _toArrayBufferBody(body);\n    case 'blob':\n      return _toBlob(body);\n    case 'json':\n      return _toJsonBody(body);\n    case 'text':\n      return _toTextBody(body);\n    default:\n      throw new Error(`Unsupported responseType: ${responseType}`);\n  }\n}\n"],"sourceRoot":""}