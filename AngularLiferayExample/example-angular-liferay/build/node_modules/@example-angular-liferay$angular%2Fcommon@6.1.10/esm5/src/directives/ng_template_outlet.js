Liferay.Loader.define('@example-angular-liferay$angular/common@6.1.10/esm5/src/directives/ng_template_outlet', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';
    /**
     * @ngModule CommonModule
     *
     * @description
     *
     * Inserts an embedded view from a prepared `TemplateRef`.
     *
     * You can attach a context object to the `EmbeddedViewRef` by setting `[ngTemplateOutletContext]`.
     * `[ngTemplateOutletContext]` should be an object, the object's keys will be available for binding
     * by the local template `let` declarations.
     *
     * @usageNotes
     * ```
     * <ng-container *ngTemplateOutlet="templateRefExp; context: contextExp"></ng-container>
     * ```
     *
     * Using the key `$implicit` in the context object will set its value as default.
     *
     * ### Example
     *
     * {@example common/ngTemplateOutlet/ts/module.ts region='NgTemplateOutlet'}
     *
     */
    var NgTemplateOutlet = /** @class */function () {
        function NgTemplateOutlet(_viewContainerRef) {
            this._viewContainerRef = _viewContainerRef;
        }
        NgTemplateOutlet.prototype.ngOnChanges = function (changes) {
            var recreateView = this._shouldRecreateView(changes);
            if (recreateView) {
                if (this._viewRef) {
                    this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._viewRef));
                }
                if (this.ngTemplateOutlet) {
                    this._viewRef = this._viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext);
                }
            } else {
                if (this._viewRef && this.ngTemplateOutletContext) {
                    this._updateExistingContext(this.ngTemplateOutletContext);
                }
            }
        };
        /**
         * We need to re-create existing embedded view if:
         * - templateRef has changed
         * - context has changes
         *
         * We mark context object as changed when the corresponding object
         * shape changes (new properties are added or existing properties are removed).
         * In other words we consider context with the same properties as "the same" even
         * if object reference changes (see https://github.com/angular/angular/issues/13407).
         */
        NgTemplateOutlet.prototype._shouldRecreateView = function (changes) {
            var ctxChange = changes['ngTemplateOutletContext'];
            return !!changes['ngTemplateOutlet'] || ctxChange && this._hasContextShapeChanged(ctxChange);
        };
        NgTemplateOutlet.prototype._hasContextShapeChanged = function (ctxChange) {
            var e_1, _a;
            var prevCtxKeys = Object.keys(ctxChange.previousValue || {});
            var currCtxKeys = Object.keys(ctxChange.currentValue || {});
            if (prevCtxKeys.length === currCtxKeys.length) {
                try {
                    for (var currCtxKeys_1 = tslib_1.__values(currCtxKeys), currCtxKeys_1_1 = currCtxKeys_1.next(); !currCtxKeys_1_1.done; currCtxKeys_1_1 = currCtxKeys_1.next()) {
                        var propName = currCtxKeys_1_1.value;
                        if (prevCtxKeys.indexOf(propName) === -1) {
                            return true;
                        }
                    }
                } catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                } finally {
                    try {
                        if (currCtxKeys_1_1 && !currCtxKeys_1_1.done && (_a = currCtxKeys_1.return)) _a.call(currCtxKeys_1);
                    } finally {
                        if (e_1) throw e_1.error;
                    }
                }
                return false;
            } else {
                return true;
            }
        };
        NgTemplateOutlet.prototype._updateExistingContext = function (ctx) {
            var e_2, _a;
            try {
                for (var _b = tslib_1.__values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var propName = _c.value;
                    this._viewRef.context[propName] = this.ngTemplateOutletContext[propName];
                }
            } catch (e_2_1) {
                e_2 = { error: e_2_1 };
            } finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                } finally {
                    if (e_2) throw e_2.error;
                }
            }
        };
        tslib_1.__decorate([Input(), tslib_1.__metadata("design:type", Object)], NgTemplateOutlet.prototype, "ngTemplateOutletContext", void 0);
        tslib_1.__decorate([Input(), tslib_1.__metadata("design:type", TemplateRef)], NgTemplateOutlet.prototype, "ngTemplateOutlet", void 0);
        NgTemplateOutlet = tslib_1.__decorate([Directive({ selector: '[ngTemplateOutlet]' }), tslib_1.__metadata("design:paramtypes", [ViewContainerRef])], NgTemplateOutlet);
        return NgTemplateOutlet;
    }();
    export { NgTemplateOutlet };
});
//# sourceMappingURL=ng_template_outlet.js.map