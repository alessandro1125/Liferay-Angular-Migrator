{"version":3,"sources":["../../../../../../../../../../packages/common/src/pipes/async_pipe.ts"],"names":[],"mappings":";;;;;;;;;;AAQA,aAAQ,iBAAR,EAAoD,IAApD,EAAyE,YAAzE,EAAuF,aAAvF,EAAsG,UAAtG,QAAuH,eAAvH;AAEA,aAAQ,wBAAR,QAAuC,+BAAvC;AASA,QAAA,qBAAA,aAAA,YAAA;AAAA,iBAAA,kBAAA,GAAA,CAQC;AAPC,2BAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,KAAnB,EAA2C,iBAA3C,EAAiE;AAC/D,mBAAO,MAAM,SAAN,CAAgB,EAAC,MAAM,iBAAP,EAA0B,OAAO,UAAC,CAAD,EAAO;AAAO,0BAAM,CAAN;AAAU,iBAAzD,EAAhB,CAAP;AACD,SAFD;AAIA,2BAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,YAAR,EAAsC;AAAU,yBAAa,WAAb;AAA6B,SAA7E;AAEA,2BAAA,SAAA,CAAA,SAAA,GAAA,UAAU,YAAV,EAAwC;AAAU,yBAAa,WAAb;AAA6B,SAA/E;AACF,eAAA,kBAAA;AAAC,KARD,EAAA;AAUA,QAAA,kBAAA,aAAA,YAAA;AAAA,iBAAA,eAAA,GAAA,CAQC;AAPC,wBAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,KAAnB,EAAwC,iBAAxC,EAA0E;AACxE,mBAAO,MAAM,IAAN,CAAW,iBAAX,EAA8B,UAAA,CAAA,EAAC;AAAM,sBAAM,CAAN;AAAU,aAA/C,CAAP;AACD,SAFD;AAIA,wBAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,YAAR,EAAkC,CAAU,CAA5C;AAEA,wBAAA,SAAA,CAAA,SAAA,GAAA,UAAU,YAAV,EAAoC,CAAU,CAA9C;AACF,eAAA,eAAA;AAAC,KARD,EAAA;AAUA,QAAM,mBAAmB,IAAI,eAAJ,EAAzB;AACA,QAAM,sBAAsB,IAAI,kBAAJ,EAA5B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,QAAA,YAAA,aAAA,YAAA;AAQE,iBAAA,SAAA,CAAoB,IAApB,EAA2C;AAAvB,iBAAA,IAAA,GAAA,IAAA;AAPZ,iBAAA,YAAA,GAAoB,IAApB;AACA,iBAAA,oBAAA,GAA4B,IAA5B;AAEA,iBAAA,aAAA,GAAoD,IAApD;AACA,iBAAA,IAAA,GAA4D,IAA5D;AACA,iBAAA,SAAA,GAAkC,IAAlC;AAEuC;sBARpC,S;AAUX,kBAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,gBAAI,KAAK,aAAT,EAAwB;AACtB,qBAAK,QAAL;AACD;AACF,SAJD;AAUA,kBAAA,SAAA,CAAA,SAAA,GAAA,UAAU,GAAV,EAA0D;AACxD,gBAAI,CAAC,KAAK,IAAV,EAAgB;AACd,oBAAI,GAAJ,EAAS;AACP,yBAAK,UAAL,CAAgB,GAAhB;AACD;AACD,qBAAK,oBAAL,GAA4B,KAAK,YAAjC;AACA,uBAAO,KAAK,YAAZ;AACD;AAED,gBAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,qBAAK,QAAL;AACA,uBAAO,KAAK,SAAL,CAAe,GAAf,CAAP;AACD;AAED,gBAAI,KAAK,YAAL,KAAsB,KAAK,oBAA/B,EAAqD;AACnD,uBAAO,KAAK,oBAAZ;AACD;AAED,iBAAK,oBAAL,GAA4B,KAAK,YAAjC;AACA,mBAAO,aAAa,IAAb,CAAkB,KAAK,YAAvB,CAAP;AACD,SApBD;AAsBQ,kBAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,GAAnB,EAAsE;AAAtE,gBAAA,QAAA,IAAA;AACE,iBAAK,IAAL,GAAY,GAAZ;AACA,iBAAK,SAAL,GAAiB,KAAK,eAAL,CAAqB,GAArB,CAAjB;AACA,iBAAK,aAAL,GAAqB,KAAK,SAAL,CAAe,kBAAf,CACjB,GADiB,EACZ,UAAC,KAAD,EAAc;AAAK,uBAAA,MAAK,kBAAL,CAAwB,GAAxB,EAAA,KAAA,CAAA;AAAmC,aAD1C,CAArB;AAED,SALO;AAOA,kBAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,GAAxB,EAA2E;AACzE,gBAAI,WAAW,GAAX,CAAJ,EAAqB;AACnB,uBAAO,gBAAP;AACD;AAED,gBAAI,cAAc,GAAd,CAAJ,EAAwB;AACtB,uBAAO,mBAAP;AACD;AAED,kBAAM,yBAAyB,WAAzB,EAAoC,GAApC,CAAN;AACD,SAVO;AAYA,kBAAA,SAAA,CAAA,QAAA,GAAR,YAAA;AACE,iBAAK,SAAL,CAAe,OAAf,CAAuB,KAAK,aAA5B;AACA,iBAAK,YAAL,GAAoB,IAApB;AACA,iBAAK,oBAAL,GAA4B,IAA5B;AACA,iBAAK,aAAL,GAAqB,IAArB;AACA,iBAAK,IAAL,GAAY,IAAZ;AACD,SANO;AAQA,kBAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,KAA3B,EAAuC,KAAvC,EAAoD;AAClD,gBAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB,qBAAK,YAAL,GAAoB,KAApB;AACA,qBAAK,IAAL,CAAU,YAAV;AACD;AACF,SALO;;AArEG,oBAAS,cAAA,QAAA,UAAA,CAAA,CADrB,KAAK,EAAC,MAAM,OAAP,EAAgB,MAAM,KAAtB,EAAL,CACqB,E,yCAQM,iB,EARN,CAAA,EAAT,SAAS,CAAT;AA2Eb,eAAA,SAAA;AAAC,KA3ED,EAAA;aAAa,S","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, EventEmitter, OnDestroy, Pipe, PipeTransform, WrappedValue, ɵisObservable, ɵisPromise} from '@angular/core';\nimport {Observable, SubscriptionLike} from 'rxjs';\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\ninterface SubscriptionStrategy {\n  createSubscription(async: Observable<any>|Promise<any>, updateLatestValue: any): SubscriptionLike\n      |Promise<any>;\n  dispose(subscription: SubscriptionLike|Promise<any>): void;\n  onDestroy(subscription: SubscriptionLike|Promise<any>): void;\n}\n\nclass ObservableStrategy implements SubscriptionStrategy {\n  createSubscription(async: Observable<any>, updateLatestValue: any): SubscriptionLike {\n    return async.subscribe({next: updateLatestValue, error: (e: any) => { throw e; }});\n  }\n\n  dispose(subscription: SubscriptionLike): void { subscription.unsubscribe(); }\n\n  onDestroy(subscription: SubscriptionLike): void { subscription.unsubscribe(); }\n}\n\nclass PromiseStrategy implements SubscriptionStrategy {\n  createSubscription(async: Promise<any>, updateLatestValue: (v: any) => any): Promise<any> {\n    return async.then(updateLatestValue, e => { throw e; });\n  }\n\n  dispose(subscription: Promise<any>): void {}\n\n  onDestroy(subscription: Promise<any>): void {}\n}\n\nconst _promiseStrategy = new PromiseStrategy();\nconst _observableStrategy = new ObservableStrategy();\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Unwraps a value from an asynchronous primitive.\n *\n * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has\n * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for\n * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid\n * potential memory leaks.\n *\n * @usageNotes\n *\n * ### Examples\n *\n * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the\n * promise.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}\n *\n * It's also possible to use `async` with Observables. The example below binds the `time` Observable\n * to the view. The Observable continuously updates the view with the current time.\n *\n * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}\n *\n */\n@Pipe({name: 'async', pure: false})\nexport class AsyncPipe implements OnDestroy, PipeTransform {\n  private _latestValue: any = null;\n  private _latestReturnedValue: any = null;\n\n  private _subscription: SubscriptionLike|Promise<any>|null = null;\n  private _obj: Observable<any>|Promise<any>|EventEmitter<any>|null = null;\n  private _strategy: SubscriptionStrategy = null !;\n\n  constructor(private _ref: ChangeDetectorRef) {}\n\n  ngOnDestroy(): void {\n    if (this._subscription) {\n      this._dispose();\n    }\n  }\n\n  transform<T>(obj: null): null;\n  transform<T>(obj: undefined): undefined;\n  transform<T>(obj: Observable<T>|null|undefined): T|null;\n  transform<T>(obj: Promise<T>|null|undefined): T|null;\n  transform(obj: Observable<any>|Promise<any>|null|undefined): any {\n    if (!this._obj) {\n      if (obj) {\n        this._subscribe(obj);\n      }\n      this._latestReturnedValue = this._latestValue;\n      return this._latestValue;\n    }\n\n    if (obj !== this._obj) {\n      this._dispose();\n      return this.transform(obj as any);\n    }\n\n    if (this._latestValue === this._latestReturnedValue) {\n      return this._latestReturnedValue;\n    }\n\n    this._latestReturnedValue = this._latestValue;\n    return WrappedValue.wrap(this._latestValue);\n  }\n\n  private _subscribe(obj: Observable<any>|Promise<any>|EventEmitter<any>): void {\n    this._obj = obj;\n    this._strategy = this._selectStrategy(obj);\n    this._subscription = this._strategy.createSubscription(\n        obj, (value: Object) => this._updateLatestValue(obj, value));\n  }\n\n  private _selectStrategy(obj: Observable<any>|Promise<any>|EventEmitter<any>): any {\n    if (ɵisPromise(obj)) {\n      return _promiseStrategy;\n    }\n\n    if (ɵisObservable(obj)) {\n      return _observableStrategy;\n    }\n\n    throw invalidPipeArgumentError(AsyncPipe, obj);\n  }\n\n  private _dispose(): void {\n    this._strategy.dispose(this._subscription !);\n    this._latestValue = null;\n    this._latestReturnedValue = null;\n    this._subscription = null;\n    this._obj = null;\n  }\n\n  private _updateLatestValue(async: any, value: Object): void {\n    if (async === this._obj) {\n      this._latestValue = value;\n      this._ref.markForCheck();\n    }\n  }\n}\n"],"sourceRoot":""}