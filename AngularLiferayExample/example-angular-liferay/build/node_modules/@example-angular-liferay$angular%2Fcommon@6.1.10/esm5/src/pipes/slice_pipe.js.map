{"version":3,"sources":["../../../../../../../../../../packages/common/src/pipes/slice_pipe.ts"],"names":[],"mappings":";;;;;;;;;;AAQA,aAAQ,IAAR,QAAkC,eAAlC;AACA,aAAQ,wBAAR,QAAuC,+BAAvC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,QAAA,YAAA,aAAA,YAAA;AAAA,iBAAA,SAAA,GAAA,CA2BC;sBA3BY,S;AACX;;;;;;;;;;;;;;;AAeA,kBAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAAsB,KAAtB,EAAqC,GAArC,EAAiD;AAC/C,gBAAI,SAAS,IAAb,EAAmB,OAAO,KAAP;AAEnB,gBAAI,CAAC,KAAK,QAAL,CAAc,KAAd,CAAL,EAA2B;AACzB,sBAAM,yBAAyB,WAAzB,EAAoC,KAApC,CAAN;AACD;AAED,mBAAO,MAAM,KAAN,CAAY,KAAZ,EAAmB,GAAnB,CAAP;AACD,SARD;AAUQ,kBAAA,SAAA,CAAA,QAAA,GAAR,UAAiB,GAAjB,EAAyB;AAAa,mBAAO,OAAO,GAAP,KAAe,QAAf,IAA2B,MAAM,OAAN,CAAc,GAAd,CAAlC;AAAuD,SAArF;;AA1BG,oBAAS,cAAA,QAAA,UAAA,CAAA,CADrB,KAAK,EAAC,MAAM,OAAP,EAAgB,MAAM,KAAtB,EAAL,CACqB,CAAA,EAAT,SAAS,CAAT;AA2Bb,eAAA,SAAA;AAAC,KA3BD,EAAA;aAAa,S","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Pipe, PipeTransform} from '@angular/core';\nimport {invalidPipeArgumentError} from './invalid_pipe_argument_error';\n\n/**\n * @ngModule CommonModule\n * @description\n *\n * Creates a new `Array` or `String` containing a subset (slice) of the elements.\n *\n * @usageNotes\n *\n * All behavior is based on the expected behavior of the JavaScript API `Array.prototype.slice()`\n * and `String.prototype.slice()`.\n *\n * When operating on an `Array`, the returned `Array` is always a copy even when all\n * the elements are being returned.\n *\n * When operating on a blank value, the pipe returns the blank value.\n *\n * ### List Example\n *\n * This `ngFor` example:\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_list'}\n *\n * produces the following:\n *\n * ```html\n * <li>b</li>\n * <li>c</li>\n * ```\n *\n * ### String Examples\n *\n * {@example common/pipes/ts/slice_pipe.ts region='SlicePipe_string'}\n *\n */\n\n@Pipe({name: 'slice', pure: false})\nexport class SlicePipe implements PipeTransform {\n  /**\n   * @param value a list or a string to be sliced.\n   * @param start the starting index of the subset to return:\n   *   - **a positive integer**: return the item at `start` index and all items after\n   *     in the list or string expression.\n   *   - **a negative integer**: return the item at `start` index from the end and all items after\n   *     in the list or string expression.\n   *   - **if positive and greater than the size of the expression**: return an empty list or\n   * string.\n   *   - **if negative and greater than the size of the expression**: return entire list or string.\n   * @param end the ending index of the subset to return:\n   *   - **omitted**: return all items until the end.\n   *   - **if positive**: return all items before `end` index of the list or string.\n   *   - **if negative**: return all items before `end` index from the end of the list or string.\n   */\n  transform(value: any, start: number, end?: number): any {\n    if (value == null) return value;\n\n    if (!this.supports(value)) {\n      throw invalidPipeArgumentError(SlicePipe, value);\n    }\n\n    return value.slice(start, end);\n  }\n\n  private supports(obj: any): boolean { return typeof obj === 'string' || Array.isArray(obj); }\n}\n"],"sourceRoot":""}