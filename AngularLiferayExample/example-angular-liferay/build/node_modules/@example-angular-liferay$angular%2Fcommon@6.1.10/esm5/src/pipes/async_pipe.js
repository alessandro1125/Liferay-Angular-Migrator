Liferay.Loader.define('@example-angular-liferay$angular/common@6.1.10/esm5/src/pipes/async_pipe', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { ChangeDetectorRef, Pipe, WrappedValue, ɵisObservable, ɵisPromise } from '@angular/core';
    import { invalidPipeArgumentError } from './invalid_pipe_argument_error';
    var ObservableStrategy = /** @class */function () {
        function ObservableStrategy() {}
        ObservableStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.subscribe({ next: updateLatestValue, error: function (e) {
                    throw e;
                } });
        };
        ObservableStrategy.prototype.dispose = function (subscription) {
            subscription.unsubscribe();
        };
        ObservableStrategy.prototype.onDestroy = function (subscription) {
            subscription.unsubscribe();
        };
        return ObservableStrategy;
    }();
    var PromiseStrategy = /** @class */function () {
        function PromiseStrategy() {}
        PromiseStrategy.prototype.createSubscription = function (async, updateLatestValue) {
            return async.then(updateLatestValue, function (e) {
                throw e;
            });
        };
        PromiseStrategy.prototype.dispose = function (subscription) {};
        PromiseStrategy.prototype.onDestroy = function (subscription) {};
        return PromiseStrategy;
    }();
    var _promiseStrategy = new PromiseStrategy();
    var _observableStrategy = new ObservableStrategy();
    /**
     * @ngModule CommonModule
     * @description
     *
     * Unwraps a value from an asynchronous primitive.
     *
     * The `async` pipe subscribes to an `Observable` or `Promise` and returns the latest value it has
     * emitted. When a new value is emitted, the `async` pipe marks the component to be checked for
     * changes. When the component gets destroyed, the `async` pipe unsubscribes automatically to avoid
     * potential memory leaks.
     *
     * @usageNotes
     *
     * ### Examples
     *
     * This example binds a `Promise` to the view. Clicking the `Resolve` button resolves the
     * promise.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipePromise'}
     *
     * It's also possible to use `async` with Observables. The example below binds the `time` Observable
     * to the view. The Observable continuously updates the view with the current time.
     *
     * {@example common/pipes/ts/async_pipe.ts region='AsyncPipeObservable'}
     *
     */
    var AsyncPipe = /** @class */function () {
        function AsyncPipe(_ref) {
            this._ref = _ref;
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
            this._strategy = null;
        }
        AsyncPipe_1 = AsyncPipe;
        AsyncPipe.prototype.ngOnDestroy = function () {
            if (this._subscription) {
                this._dispose();
            }
        };
        AsyncPipe.prototype.transform = function (obj) {
            if (!this._obj) {
                if (obj) {
                    this._subscribe(obj);
                }
                this._latestReturnedValue = this._latestValue;
                return this._latestValue;
            }
            if (obj !== this._obj) {
                this._dispose();
                return this.transform(obj);
            }
            if (this._latestValue === this._latestReturnedValue) {
                return this._latestReturnedValue;
            }
            this._latestReturnedValue = this._latestValue;
            return WrappedValue.wrap(this._latestValue);
        };
        AsyncPipe.prototype._subscribe = function (obj) {
            var _this = this;
            this._obj = obj;
            this._strategy = this._selectStrategy(obj);
            this._subscription = this._strategy.createSubscription(obj, function (value) {
                return _this._updateLatestValue(obj, value);
            });
        };
        AsyncPipe.prototype._selectStrategy = function (obj) {
            if (ɵisPromise(obj)) {
                return _promiseStrategy;
            }
            if (ɵisObservable(obj)) {
                return _observableStrategy;
            }
            throw invalidPipeArgumentError(AsyncPipe_1, obj);
        };
        AsyncPipe.prototype._dispose = function () {
            this._strategy.dispose(this._subscription);
            this._latestValue = null;
            this._latestReturnedValue = null;
            this._subscription = null;
            this._obj = null;
        };
        AsyncPipe.prototype._updateLatestValue = function (async, value) {
            if (async === this._obj) {
                this._latestValue = value;
                this._ref.markForCheck();
            }
        };
        var AsyncPipe_1;
        AsyncPipe = AsyncPipe_1 = tslib_1.__decorate([Pipe({ name: 'async', pure: false }), tslib_1.__metadata("design:paramtypes", [ChangeDetectorRef])], AsyncPipe);
        return AsyncPipe;
    }();
    export { AsyncPipe };
});
//# sourceMappingURL=async_pipe.js.map