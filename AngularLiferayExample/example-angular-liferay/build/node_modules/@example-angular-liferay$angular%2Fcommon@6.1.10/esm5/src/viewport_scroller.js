Liferay.Loader.define('@example-angular-liferay$angular/common@6.1.10/esm5/src/viewport_scroller', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { defineInjectable, inject } from '@angular/core';
    import { DOCUMENT } from './dom_tokens';
    /**
     * Manages the scroll position.
     */
    var ViewportScroller = /** @class */function () {
        function ViewportScroller() {}
        // De-sugared tree-shakable injection
        // See #23917
        /** @nocollapse */
        ViewportScroller.ngInjectableDef = defineInjectable({ providedIn: 'root', factory: function () {
                return new BrowserViewportScroller(inject(DOCUMENT), window);
            } });
        return ViewportScroller;
    }();
    export { ViewportScroller };
    /**
     * Manages the scroll position.
     */
    var BrowserViewportScroller = /** @class */function () {
        function BrowserViewportScroller(document, window) {
            this.document = document;
            this.window = window;
            this.offset = function () {
                return [0, 0];
            };
        }
        /**
         * Configures the top offset used when scrolling to an anchor.
         *
         * * When given a number, the service will always use the number.
         * * When given a function, the service will invoke the function every time it restores scroll
         * position.
         */
        BrowserViewportScroller.prototype.setOffset = function (offset) {
            if (Array.isArray(offset)) {
                this.offset = function () {
                    return offset;
                };
            } else {
                this.offset = offset;
            }
        };
        /**
         * Returns the current scroll position.
         */
        BrowserViewportScroller.prototype.getScrollPosition = function () {
            if (this.supportScrollRestoration()) {
                return [this.window.scrollX, this.window.scrollY];
            } else {
                return [0, 0];
            }
        };
        /**
         * Sets the scroll position.
         */
        BrowserViewportScroller.prototype.scrollToPosition = function (position) {
            if (this.supportScrollRestoration()) {
                this.window.scrollTo(position[0], position[1]);
            }
        };
        /**
         * Scrolls to the provided anchor.
         */
        BrowserViewportScroller.prototype.scrollToAnchor = function (anchor) {
            if (this.supportScrollRestoration()) {
                var elSelectedById = this.document.querySelector("#" + anchor);
                if (elSelectedById) {
                    this.scrollToElement(elSelectedById);
                    return;
                }
                var elSelectedByName = this.document.querySelector("[name='" + anchor + "']");
                if (elSelectedByName) {
                    this.scrollToElement(elSelectedByName);
                    return;
                }
            }
        };
        /**
         * Disables automatic scroll restoration provided by the browser.
         */
        BrowserViewportScroller.prototype.setHistoryScrollRestoration = function (scrollRestoration) {
            if (this.supportScrollRestoration()) {
                var history_1 = this.window.history;
                if (history_1 && history_1.scrollRestoration) {
                    history_1.scrollRestoration = scrollRestoration;
                }
            }
        };
        BrowserViewportScroller.prototype.scrollToElement = function (el) {
            var rect = el.getBoundingClientRect();
            var left = rect.left + this.window.pageXOffset;
            var top = rect.top + this.window.pageYOffset;
            var offset = this.offset();
            this.window.scrollTo(left - offset[0], top - offset[1]);
        };
        /**
         * We only support scroll restoration when we can get a hold of window.
         * This means that we do not support this behavior when running in a web worker.
         *
         * Lifting this restriction right now would require more changes in the dom adapter.
         * Since webworkers aren't widely used, we will lift it once RouterScroller is
         * battle-tested.
         */
        BrowserViewportScroller.prototype.supportScrollRestoration = function () {
            try {
                return !!this.window && !!this.window.scrollTo;
            } catch (e) {
                return false;
            }
        };
        return BrowserViewportScroller;
    }();
    export { BrowserViewportScroller };
    /**
     * Provides an empty implementation of the viewport scroller. This will
     * live in @angular/common as it will be used by both platform-server and platform-webworker.
     */
    var NullViewportScroller = /** @class */function () {
        function NullViewportScroller() {}
        /**
         * Empty implementation
         */
        NullViewportScroller.prototype.setOffset = function (offset) {};
        /**
         * Empty implementation
         */
        NullViewportScroller.prototype.getScrollPosition = function () {
            return [0, 0];
        };
        /**
         * Empty implementation
         */
        NullViewportScroller.prototype.scrollToPosition = function (position) {};
        /**
         * Empty implementation
         */
        NullViewportScroller.prototype.scrollToAnchor = function (anchor) {};
        /**
         * Empty implementation
         */
        NullViewportScroller.prototype.setHistoryScrollRestoration = function (scrollRestoration) {};
        return NullViewportScroller;
    }();
    export { NullViewportScroller };
});
//# sourceMappingURL=viewport_scroller.js.map