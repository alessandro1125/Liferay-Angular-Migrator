{"version":3,"sources":["../../../../../../../packages/compiler/src/output/abstract_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext { return new EmitterVisitorContext(0); }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) { this._lines = [new _EmittedLine(_indent)]; }\n\n  private get _currentLine(): _EmittedLine { return this._lines[this._lines.length - 1]; }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean { return this._currentLine.parts.length === 0; }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) { this._classes.push(clazz); }\n\n  popClass(): o.ClassStmt { return this._classes.pop() !; }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx] !;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) { return this._preambleLineCount = count; }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.multiline) {\n      ctx.println(stmt, `/* ${stmt.comment} */`);\n    } else {\n      stmt.comment.split('\\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });\n    }\n    return null;\n  }\n  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n    ctx.println(stmt, `/*${stmt.toString()}*/`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name !;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name !;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name !;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase !.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n"],"sourceRoot":""}