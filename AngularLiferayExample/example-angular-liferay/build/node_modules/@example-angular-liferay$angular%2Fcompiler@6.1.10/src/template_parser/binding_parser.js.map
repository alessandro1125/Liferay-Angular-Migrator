{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\n\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  getUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEvents);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig) !;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  // Parse an inline template binding. ie `<tag *tplKey=\"<tplValue>\">`\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[],\n      targetVars: ParsedVariable[]) {\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);\n\n    for (let i = 0; i < bindings.length; i++) {\n      const binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n\n  private _parseTemplateBindings(tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]): boolean {\n    const expr = this.parseInterpolation(value, sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(expression || 'undefined', false, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan));\n  }\n\n  private _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  createBoundElementProperty(elementSelector: string, boundProp: ParsedProperty):\n      BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined !;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined !;\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = BindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan);\n  }\n\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, targetEvents: ParsedEvent[]) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(\n              new ParsedEvent(eventName, phase, ParsedEventType.Animation, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null !, name]);\n    const ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([name !, ast.source !]);\n    targetEvents.push(new ParsedEvent(eventName, target, ParsedEventType.Regular, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n\n    try {\n      const ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName !.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg !, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n"],"sourceRoot":""}