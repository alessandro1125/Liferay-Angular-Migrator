{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {R3DependencyMetadata, compileFactoryFunction} from './render3/r3_factory';\nimport {mapToMapExpression} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: o.Expression;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let factory: o.Expression = o.NULL_EXPR;\n\n  function makeFn(ret: o.Expression): o.Expression {\n    return o.fn([], [new o.ReturnStatement(ret)], undefined, undefined, `${meta.name}_Factory`);\n  }\n\n  if (meta.useClass !== undefined || meta.useFactory !== undefined) {\n    // First, handle useClass and useFactory together, since both involve a similar call to\n    // `compileFactoryFunction`. Either dependencies are explicitly specified, in which case\n    // a factory function call is generated, or they're not specified and the calls are special-\n    // cased.\n    if (meta.deps !== undefined) {\n      // Either call `new meta.useClass(...)` or `meta.useFactory(...)`.\n      const fnOrClass: o.Expression = meta.useClass || meta.useFactory !;\n\n      // useNew: true if meta.useClass, false for meta.useFactory.\n      const useNew = meta.useClass !== undefined;\n\n      factory = compileFactoryFunction({\n        name: meta.name,\n        fnOrClass,\n        useNew,\n        injectFn: Identifiers.inject,\n        deps: meta.deps,\n      });\n    } else if (meta.useClass !== undefined) {\n      // Special case for useClass where the factory from the class's ngInjectableDef is used.\n      if (meta.useClass.isEquivalent(meta.type)) {\n        // For the injectable compiler, useClass represents a foreign type that should be\n        // instantiated to satisfy construction of the given type. It's not valid to specify\n        // useClass === type, since the useClass type is expected to already be compiled.\n        throw new Error(\n            `useClass is the same as the type, but no deps specified, which is invalid.`);\n      }\n      factory =\n          makeFn(new o.ReadPropExpr(new o.ReadPropExpr(meta.useClass, 'ngInjectableDef'), 'factory')\n                     .callFn([]));\n    } else if (meta.useFactory !== undefined) {\n      // Special case for useFactory where no arguments are passed.\n      factory = meta.useFactory.callFn([]);\n    } else {\n      // Can't happen - outer conditional guards against both useClass and useFactory being\n      // undefined.\n      throw new Error('Reached unreachable block in injectable compiler.');\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    factory = makeFn(meta.useValue);\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    factory = makeFn(o.importExpr(Identifiers.inject).callFn([meta.useExisting]));\n  } else {\n    // A strict type is compiled according to useClass semantics, except the dependencies are\n    // required.\n    if (meta.deps === undefined) {\n      throw new Error(`Type compilation of an injectable requires dependencies.`);\n    }\n    factory = compileFactoryFunction({\n      name: meta.name,\n      fnOrClass: meta.type,\n      useNew: true,\n      injectFn: Identifiers.inject,\n      deps: meta.deps,\n    });\n  }\n\n  const token = meta.type;\n  const providedIn = meta.providedIn;\n\n  const expression = o.importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(\n      {token, factory, providedIn})]);\n  const type = new o.ExpressionType(\n      o.importExpr(Identifiers.InjectableDef, [new o.ExpressionType(meta.type)]));\n\n  return {\n      expression, type,\n  };\n}\n"],"sourceRoot":""}