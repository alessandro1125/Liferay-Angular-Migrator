{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, BuiltinConverter, EventHandlerVars, LocalResolver, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder | null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName | StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {context: this.component, value: input.value} as Expression\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null !;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter:\n                (keys: {key: string, quoted: boolean}[]) => (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"],"sourceRoot":""}