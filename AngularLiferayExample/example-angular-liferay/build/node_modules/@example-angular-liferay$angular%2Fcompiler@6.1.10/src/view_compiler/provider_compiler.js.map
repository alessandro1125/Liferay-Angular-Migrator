{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DepFlags, NodeFlags} from '../core';\nimport {Identifiers, createTokenForExternalReference} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nexport function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  let flags = NodeFlags.None;\n  if (!providerAst.eager) {\n    flags |= NodeFlags.LazyProvider;\n  }\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= NodeFlags.PrivateProvider;\n  }\n  if (providerAst.isModule) {\n    flags |= NodeFlags.TypeModuleProvider;\n  }\n  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n        providerAst.providerType === ProviderAstType.Directive ||\n        providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n      multiProviderDef(ctx, flags, providerAst.providers) :\n      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n  return {\n    providerExpr,\n    flags: providerFlags, depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token),\n  };\n}\n\nfunction multiProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  const allDepDefs: o.Expression[] = [];\n  const allParams: o.FnParam[] = [];\n  const exprs = providers.map((provider, providerIndex) => {\n    let expr: o.Expression;\n    if (provider.useClass) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n    } else if (provider.useExisting) {\n      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n      expr = depExprs[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n    return expr;\n  });\n  const providerExpr =\n      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n  return {\n    providerExpr,\n    flags: flags | NodeFlags.TypeFactoryProvider,\n    depsExpr: o.literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n    return deps.map((dep, depIndex) => {\n      const paramName = `p${providerIndex}_${depIndex}`;\n      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return o.variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n    providerMeta: CompileProviderMetadata):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  let providerExpr: o.Expression;\n  let deps: CompileDiDependencyMetadata[];\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass !.reference);\n    flags |= NodeFlags.TypeDirective;\n    deps = providerMeta.deps || providerMeta.useClass !.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= NodeFlags.TypeClassProvider;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= NodeFlags.TypeFactoryProvider;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = o.NULL_EXPR;\n      flags |= NodeFlags.TypeUseExistingProvider;\n      deps = [{token: providerMeta.useExisting}];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= NodeFlags.TypeValueProvider;\n      deps = [];\n    }\n  }\n  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n  return {providerExpr, flags, depsExpr};\n}\n\nfunction tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n                                o.literal(tokenMeta.value);\n}\n\nexport function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token !);\n  let flags = DepFlags.None;\n  if (dep.isSkipSelf) {\n    flags |= DepFlags.SkipSelf;\n  }\n  if (dep.isOptional) {\n    flags |= DepFlags.Optional;\n  }\n  if (dep.isSelf) {\n    flags |= DepFlags.Self;\n  }\n  if (dep.isValue) {\n    flags |= DepFlags.Value;\n  }\n  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n}\n\nexport function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n  let nodeFlag = NodeFlags.None;\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = NodeFlags.AfterContentChecked;\n      break;\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = NodeFlags.AfterContentInit;\n      break;\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = NodeFlags.AfterViewChecked;\n      break;\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = NodeFlags.AfterViewInit;\n      break;\n    case LifecycleHooks.DoCheck:\n      nodeFlag = NodeFlags.DoCheck;\n      break;\n    case LifecycleHooks.OnChanges:\n      nodeFlag = NodeFlags.OnChanges;\n      break;\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = NodeFlags.OnDestroy;\n      break;\n    case LifecycleHooks.OnInit:\n      nodeFlag = NodeFlags.OnInit;\n      break;\n  }\n  return nodeFlag;\n}\n\nexport function componentFactoryResolverProviderDef(\n    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n    entryComponents: CompileEntryComponentMetadata[]): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  const entryComponentFactories =\n      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n  const classMeta = {\n    diDeps: [\n      {isValue: true, value: o.literalArr(entryComponentFactories)},\n      {token: token, isSkipSelf: true, isOptional: true},\n      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n    ],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n  };\n  const {providerExpr, flags: providerFlags, depsExpr} =\n      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n      });\n  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n}\n"],"sourceRoot":""}