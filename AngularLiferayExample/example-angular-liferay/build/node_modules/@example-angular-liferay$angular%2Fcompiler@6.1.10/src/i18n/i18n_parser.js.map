{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/i18n_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport * as html from '../ml_parser/ast';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(interpolationConfig: InterpolationConfig): (\n    nodes: html.Node[], meaning: string, description: string, id: string) => i18n.Message {\n  const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n\n  return (nodes: html.Node[], meaning: string, description: string, id: string) =>\n             visitor.toI18nMessage(nodes, meaning, description, id);\n}\n\nclass _I18nVisitor implements html.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _isIcu !: boolean;\n  // TODO(issue/24571): remove '!'.\n  private _icuDepth !: number;\n  // TODO(issue/24571): remove '!'.\n  private _placeholderRegistry !: PlaceholderRegistry;\n  // TODO(issue/24571): remove '!'.\n  private _placeholderToContent !: {[phName: string]: string};\n  // TODO(issue/24571): remove '!'.\n  private _placeholderToMessage !: {[phName: string]: i18n.Message};\n\n  constructor(\n      private _expressionParser: ExpressionParser,\n      private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(nodes: html.Node[], meaning: string, description: string, id: string):\n      i18n.Message {\n    this._isIcu = nodes.length == 1 && nodes[0] instanceof html.Expansion;\n    this._icuDepth = 0;\n    this._placeholderRegistry = new PlaceholderRegistry();\n    this._placeholderToContent = {};\n    this._placeholderToMessage = {};\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, {});\n\n    return new i18n.Message(\n        i18nodes, this._placeholderToContent, this._placeholderToMessage, meaning, description, id);\n  }\n\n  visitElement(el: html.Element, context: any): i18n.Node {\n    const children = html.visitAll(this, el.children);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName =\n        this._placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    this._placeholderToContent[startPhName] = el.sourceSpan !.toString();\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = this._placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      this._placeholderToContent[closePhName] = `</${el.name}>`;\n    }\n\n    return new i18n.TagPlaceholder(\n        el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan !);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, context: any): i18n.Node {\n    return this._visitTextWithInterpolation(text.value, text.sourceSpan !);\n  }\n\n  visitComment(comment: html.Comment, context: any): i18n.Node|null { return null; }\n\n  visitExpansion(icu: html.Expansion, context: any): i18n.Node {\n    this._icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n          caze.expression.map((node) => node.visit(this, {})), caze.expSourceSpan);\n    });\n    this._icuDepth--;\n\n    if (this._isIcu || this._icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = this._placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      this._placeholderToContent[expPh] = icu.switchValue;\n\n      return i18nIcu;\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations. We need to create a new visitor (they are not re-entrant) to compute the\n    // message id.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = this._placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    const visitor = new _I18nVisitor(this._expressionParser, this._interpolationConfig);\n    this._placeholderToMessage[phName] = visitor.toI18nMessage([icu], '', '', '');\n    return new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  private _visitTextWithInterpolation(text: string, sourceSpan: ParseSourceSpan): i18n.Node {\n    const splitInterpolation = this._expressionParser.splitInterpolation(\n        text, sourceSpan.start.toString(), this._interpolationConfig);\n\n    if (!splitInterpolation) {\n      // No expression, return a single text\n      return new i18n.Text(text, sourceSpan);\n    }\n\n    // Return a group of text + expressions\n    const nodes: i18n.Node[] = [];\n    const container = new i18n.Container(nodes, sourceSpan);\n    const {start: sDelimiter, end: eDelimiter} = this._interpolationConfig;\n\n    for (let i = 0; i < splitInterpolation.strings.length - 1; i++) {\n      const expression = splitInterpolation.expressions[i];\n      const baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n      const phName = this._placeholderRegistry.getPlaceholderName(baseName, expression);\n\n      if (splitInterpolation.strings[i].length) {\n        // No need to add empty strings\n        nodes.push(new i18n.Text(splitInterpolation.strings[i], sourceSpan));\n      }\n\n      nodes.push(new i18n.Placeholder(expression, phName, sourceSpan));\n      this._placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n    }\n\n    // The last index contains no expression\n    const lastStringIdx = splitInterpolation.strings.length - 1;\n    if (splitInterpolation.strings[lastStringIdx].length) {\n      nodes.push(new i18n.Text(splitInterpolation.strings[lastStringIdx], sourceSpan));\n    }\n    return container;\n  }\n}\n\nconst _CUSTOM_PH_EXP =\n    /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction _extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n"],"sourceRoot":""}