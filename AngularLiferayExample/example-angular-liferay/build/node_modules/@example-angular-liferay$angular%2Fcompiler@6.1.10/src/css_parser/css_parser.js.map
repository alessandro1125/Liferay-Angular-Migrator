{"version":3,"sources":["../../../../../../../packages/compiler/src/css_parser/css_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {BlockType, CssAst, CssAtRulePredicateAst, CssBlockAst, CssBlockDefinitionRuleAst, CssBlockRuleAst, CssDefinitionAst, CssInlineRuleAst, CssKeyframeDefinitionAst, CssKeyframeRuleAst, CssMediaQueryRuleAst, CssPseudoSelectorAst, CssRuleAst, CssSelectorAst, CssSelectorRuleAst, CssSimpleSelectorAst, CssStyleSheetAst, CssStyleValueAst, CssStylesBlockAst, CssUnknownRuleAst, CssUnknownTokenListAst, mergeTokens} from './css_ast';\nimport {CssLexer, CssLexerMode, CssScanner, CssToken, CssTokenType, generateErrorMessage, getRawMessage, isNewline} from './css_lexer';\n\nconst SPACE_OPERATOR = ' ';\n\nexport {CssToken} from './css_lexer';\nexport {BlockType} from './css_ast';\n\nconst SLASH_CHARACTER = '/';\nconst GT_CHARACTER = '>';\nconst TRIPLE_GT_OPERATOR_STR = '>>>';\nconst DEEP_OPERATOR_STR = '/deep/';\n\nconst EOF_DELIM_FLAG = 1;\nconst RBRACE_DELIM_FLAG = 2;\nconst LBRACE_DELIM_FLAG = 4;\nconst COMMA_DELIM_FLAG = 8;\nconst COLON_DELIM_FLAG = 16;\nconst SEMICOLON_DELIM_FLAG = 32;\nconst NEWLINE_DELIM_FLAG = 64;\nconst RPAREN_DELIM_FLAG = 128;\nconst LPAREN_DELIM_FLAG = 256;\nconst SPACE_DELIM_FLAG = 512;\n\nfunction _pseudoSelectorSupportsInnerSelectors(name: string): boolean {\n  return ['not', 'host', 'host-context'].indexOf(name) >= 0;\n}\n\nfunction isSelectorOperatorCharacter(code: number): boolean {\n  switch (code) {\n    case chars.$SLASH:\n    case chars.$TILDA:\n    case chars.$PLUS:\n    case chars.$GT:\n      return true;\n    default:\n      return chars.isWhitespace(code);\n  }\n}\n\nfunction getDelimFromCharacter(code: number): number {\n  switch (code) {\n    case chars.$EOF:\n      return EOF_DELIM_FLAG;\n    case chars.$COMMA:\n      return COMMA_DELIM_FLAG;\n    case chars.$COLON:\n      return COLON_DELIM_FLAG;\n    case chars.$SEMICOLON:\n      return SEMICOLON_DELIM_FLAG;\n    case chars.$RBRACE:\n      return RBRACE_DELIM_FLAG;\n    case chars.$LBRACE:\n      return LBRACE_DELIM_FLAG;\n    case chars.$RPAREN:\n      return RPAREN_DELIM_FLAG;\n    case chars.$SPACE:\n    case chars.$TAB:\n      return SPACE_DELIM_FLAG;\n    default:\n      return isNewline(code) ? NEWLINE_DELIM_FLAG : 0;\n  }\n}\n\nfunction characterContainsDelimiter(code: number, delimiters: number): boolean {\n  return (getDelimFromCharacter(code) & delimiters) > 0;\n}\n\nexport class ParsedCssResult {\n  constructor(public errors: CssParseError[], public ast: CssStyleSheetAst) {}\n}\n\nexport class CssParser {\n  private _errors: CssParseError[] = [];\n  // TODO(issue/24571): remove '!'.\n  private _file !: ParseSourceFile;\n  // TODO(issue/24571): remove '!'.\n  private _scanner !: CssScanner;\n  // TODO(issue/24571): remove '!'.\n  private _lastToken !: CssToken;\n\n  /**\n   * @param css the CSS code that will be parsed\n   * @param url the name of the CSS file containing the CSS source code\n   */\n  parse(css: string, url: string): ParsedCssResult {\n    const lexer = new CssLexer();\n    this._file = new ParseSourceFile(css, url);\n    this._scanner = lexer.scan(css, false);\n\n    const ast = this._parseStyleSheet(EOF_DELIM_FLAG);\n\n    const errors = this._errors;\n    this._errors = [];\n\n    const result = new ParsedCssResult(errors, ast);\n    this._file = null as any;\n    this._scanner = null as any;\n    return result;\n  }\n\n  /** @internal */\n  _parseStyleSheet(delimiters: number): CssStyleSheetAst {\n    const results: CssRuleAst[] = [];\n    this._scanner.consumeEmptyStatements();\n    while (this._scanner.peek != chars.$EOF) {\n      this._scanner.setMode(CssLexerMode.BLOCK);\n      results.push(this._parseRule(delimiters));\n    }\n    let span: ParseSourceSpan|null = null;\n    if (results.length > 0) {\n      const firstRule = results[0];\n      // we collect the last token like so incase there was an\n      // EOF token that was emitted sometime during the lexing\n      span = this._generateSourceSpan(firstRule, this._lastToken);\n    }\n    return new CssStyleSheetAst(span !, results);\n  }\n\n  /** @internal */\n  _getSourceContent(): string { return this._scanner != null ? this._scanner.input : ''; }\n\n  /** @internal */\n  _extractSourceContent(start: number, end: number): string {\n    return this._getSourceContent().substring(start, end + 1);\n  }\n\n  /** @internal */\n  _generateSourceSpan(start: CssToken|CssAst, end: CssToken|CssAst|null = null): ParseSourceSpan {\n    let startLoc: ParseLocation;\n    if (start instanceof CssAst) {\n      startLoc = start.location.start;\n    } else {\n      let token = start;\n      if (token == null) {\n        // the data here is invalid, however, if and when this does\n        // occur, any other errors associated with this will be collected\n        token = this._lastToken;\n      }\n      startLoc = new ParseLocation(this._file, token.index, token.line, token.column);\n    }\n\n    if (end == null) {\n      end = this._lastToken;\n    }\n\n    let endLine: number = -1;\n    let endColumn: number = -1;\n    let endIndex: number = -1;\n    if (end instanceof CssAst) {\n      endLine = end.location.end.line !;\n      endColumn = end.location.end.col !;\n      endIndex = end.location.end.offset !;\n    } else if (end instanceof CssToken) {\n      endLine = end.line;\n      endColumn = end.column;\n      endIndex = end.index;\n    }\n\n    const endLoc = new ParseLocation(this._file, endIndex, endLine, endColumn);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n\n  /** @internal */\n  _resolveBlockType(token: CssToken): BlockType {\n    switch (token.strValue) {\n      case '@-o-keyframes':\n      case '@-moz-keyframes':\n      case '@-webkit-keyframes':\n      case '@keyframes':\n        return BlockType.Keyframes;\n\n      case '@charset':\n        return BlockType.Charset;\n\n      case '@import':\n        return BlockType.Import;\n\n      case '@namespace':\n        return BlockType.Namespace;\n\n      case '@page':\n        return BlockType.Page;\n\n      case '@document':\n        return BlockType.Document;\n\n      case '@media':\n        return BlockType.MediaQuery;\n\n      case '@font-face':\n        return BlockType.FontFace;\n\n      case '@viewport':\n        return BlockType.Viewport;\n\n      case '@supports':\n        return BlockType.Supports;\n\n      default:\n        return BlockType.Unsupported;\n    }\n  }\n\n  /** @internal */\n  _parseRule(delimiters: number): CssRuleAst {\n    if (this._scanner.peek == chars.$AT) {\n      return this._parseAtRule(delimiters);\n    }\n    return this._parseSelectorRule(delimiters);\n  }\n\n  /** @internal */\n  _parseAtRule(delimiters: number): CssRuleAst {\n    const start = this._getScannerIndex();\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    const token = this._scan();\n    const startToken = token;\n\n    this._assertCondition(\n        token.type == CssTokenType.AtKeyword,\n        `The CSS Rule ${token.strValue} is not a valid [@] rule.`, token);\n\n    let block: CssBlockAst;\n    const type = this._resolveBlockType(token);\n    let span: ParseSourceSpan;\n    let tokens: CssToken[];\n    let endToken: CssToken;\n    let end: number;\n    let strValue: string;\n    let query: CssAtRulePredicateAst;\n    switch (type) {\n      case BlockType.Charset:\n      case BlockType.Namespace:\n      case BlockType.Import:\n        let value = this._parseValue(delimiters);\n        this._scanner.setMode(CssLexerMode.BLOCK);\n        this._scanner.consumeEmptyStatements();\n        span = this._generateSourceSpan(startToken, value);\n        return new CssInlineRuleAst(span, type, value);\n\n      case BlockType.Viewport:\n      case BlockType.FontFace:\n        block = this._parseStyleBlock(delimiters) !;\n        span = this._generateSourceSpan(startToken, block);\n        return new CssBlockRuleAst(span, type, block);\n\n      case BlockType.Keyframes:\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        // keyframes only have one identifier name\n        let name = tokens[0];\n        block = this._parseKeyframeBlock(delimiters);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssKeyframeRuleAst(span, name, block);\n\n      case BlockType.MediaQuery:\n        this._scanner.setMode(CssLexerMode.MEDIA_QUERY);\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        endToken = tokens[tokens.length - 1];\n        // we do not track the whitespace after the mediaQuery predicate ends\n        // so we have to calculate the end string value on our own\n        end = endToken.index + endToken.strValue.length - 1;\n        strValue = this._extractSourceContent(start, end);\n        span = this._generateSourceSpan(startToken, endToken);\n        query = new CssAtRulePredicateAst(span, strValue, tokens);\n        block = this._parseBlock(delimiters);\n        strValue = this._extractSourceContent(start, this._getScannerIndex() - 1);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssMediaQueryRuleAst(span, strValue, query, block);\n\n      case BlockType.Document:\n      case BlockType.Supports:\n      case BlockType.Page:\n        this._scanner.setMode(CssLexerMode.AT_RULE_QUERY);\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        endToken = tokens[tokens.length - 1];\n        // we do not track the whitespace after this block rule predicate ends\n        // so we have to calculate the end string value on our own\n        end = endToken.index + endToken.strValue.length - 1;\n        strValue = this._extractSourceContent(start, end);\n        span = this._generateSourceSpan(startToken, tokens[tokens.length - 1]);\n        query = new CssAtRulePredicateAst(span, strValue, tokens);\n        block = this._parseBlock(delimiters);\n        strValue = this._extractSourceContent(start, block.end.offset !);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssBlockDefinitionRuleAst(span, strValue, type, query, block);\n\n      // if a custom @rule { ... } is used it should still tokenize the insides\n      default:\n        let listOfTokens: CssToken[] = [];\n        let tokenName = token.strValue;\n        this._scanner.setMode(CssLexerMode.ALL);\n        this._error(\n            generateErrorMessage(\n                this._getSourceContent(),\n                `The CSS \"at\" rule \"${tokenName}\" is not allowed to used here`, token.strValue,\n                token.index, token.line, token.column),\n            token);\n\n        this._collectUntilDelim(delimiters | LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG)\n            .forEach((token) => { listOfTokens.push(token); });\n        if (this._scanner.peek == chars.$LBRACE) {\n          listOfTokens.push(this._consume(CssTokenType.Character, '{'));\n          this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG)\n              .forEach((token) => { listOfTokens.push(token); });\n          listOfTokens.push(this._consume(CssTokenType.Character, '}'));\n        }\n        endToken = listOfTokens[listOfTokens.length - 1];\n        span = this._generateSourceSpan(startToken, endToken);\n        return new CssUnknownRuleAst(span, tokenName, listOfTokens);\n    }\n  }\n\n  /** @internal */\n  _parseSelectorRule(delimiters: number): CssRuleAst {\n    const start = this._getScannerIndex();\n    const selectors = this._parseSelectors(delimiters);\n    const block = this._parseStyleBlock(delimiters);\n    let ruleAst: CssRuleAst;\n    let span: ParseSourceSpan;\n    const startSelector = selectors[0];\n    if (block != null) {\n      span = this._generateSourceSpan(startSelector, block);\n      ruleAst = new CssSelectorRuleAst(span, selectors, block);\n    } else {\n      const name = this._extractSourceContent(start, this._getScannerIndex() - 1);\n      const innerTokens: CssToken[] = [];\n      selectors.forEach((selector: CssSelectorAst) => {\n        selector.selectorParts.forEach((part: CssSimpleSelectorAst) => {\n          part.tokens.forEach((token: CssToken) => { innerTokens.push(token); });\n        });\n      });\n      const endToken = innerTokens[innerTokens.length - 1];\n      span = this._generateSourceSpan(startSelector, endToken);\n      ruleAst = new CssUnknownTokenListAst(span, name, innerTokens);\n    }\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    this._scanner.consumeEmptyStatements();\n    return ruleAst;\n  }\n\n  /** @internal */\n  _parseSelectors(delimiters: number): CssSelectorAst[] {\n    delimiters |= LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG;\n\n    const selectors: CssSelectorAst[] = [];\n    let isParsingSelectors = true;\n    while (isParsingSelectors) {\n      selectors.push(this._parseSelector(delimiters));\n\n      isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n\n      if (isParsingSelectors) {\n        this._consume(CssTokenType.Character, ',');\n        isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n        if (isParsingSelectors) {\n          this._scanner.consumeWhitespace();\n        }\n      }\n    }\n\n    return selectors;\n  }\n\n  /** @internal */\n  _scan(): CssToken {\n    const output = this._scanner.scan() !;\n    const token = output.token;\n    const error = output.error;\n    if (error != null) {\n      this._error(getRawMessage(error), token);\n    }\n    this._lastToken = token;\n    return token;\n  }\n\n  /** @internal */\n  _getScannerIndex(): number { return this._scanner.index; }\n\n  /** @internal */\n  _consume(type: CssTokenType, value: string|null = null): CssToken {\n    const output = this._scanner.consume(type, value);\n    const token = output.token;\n    const error = output.error;\n    if (error != null) {\n      this._error(getRawMessage(error), token);\n    }\n    this._lastToken = token;\n    return token;\n  }\n\n  /** @internal */\n  _parseKeyframeBlock(delimiters: number): CssBlockAst {\n    delimiters |= RBRACE_DELIM_FLAG;\n    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n\n    const definitions: CssKeyframeDefinitionAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      definitions.push(this._parseKeyframeDefinition(delimiters));\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssBlockAst(span, definitions);\n  }\n\n  /** @internal */\n  _parseKeyframeDefinition(delimiters: number): CssKeyframeDefinitionAst {\n    const start = this._getScannerIndex();\n    const stepTokens: CssToken[] = [];\n    delimiters |= LBRACE_DELIM_FLAG;\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      stepTokens.push(this._parseKeyframeLabel(delimiters | COMMA_DELIM_FLAG));\n      if (this._scanner.peek != chars.$LBRACE) {\n        this._consume(CssTokenType.Character, ',');\n      }\n    }\n    const stylesBlock = this._parseStyleBlock(delimiters | RBRACE_DELIM_FLAG);\n    const span = this._generateSourceSpan(stepTokens[0], stylesBlock);\n    const ast = new CssKeyframeDefinitionAst(span, stepTokens, stylesBlock !);\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    return ast;\n  }\n\n  /** @internal */\n  _parseKeyframeLabel(delimiters: number): CssToken {\n    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n    return mergeTokens(this._collectUntilDelim(delimiters));\n  }\n\n  /** @internal */\n  _parsePseudoSelector(delimiters: number): CssPseudoSelectorAst {\n    const start = this._getScannerIndex();\n\n    delimiters &= ~COMMA_DELIM_FLAG;\n\n    // we keep the original value since we may use it to recurse when :not, :host are used\n    const startingDelims = delimiters;\n\n    const startToken = this._consume(CssTokenType.Character, ':');\n    const tokens = [startToken];\n\n    if (this._scanner.peek == chars.$COLON) {  // ::something\n      tokens.push(this._consume(CssTokenType.Character, ':'));\n    }\n\n    const innerSelectors: CssSelectorAst[] = [];\n\n    this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR);\n\n    // host, host-context, lang, not, nth-child are all identifiers\n    const pseudoSelectorToken = this._consume(CssTokenType.Identifier);\n    const pseudoSelectorName = pseudoSelectorToken.strValue;\n    tokens.push(pseudoSelectorToken);\n\n    // host(), lang(), nth-child(), etc...\n    if (this._scanner.peek == chars.$LPAREN) {\n      this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS);\n\n      const openParenToken = this._consume(CssTokenType.Character, '(');\n      tokens.push(openParenToken);\n\n      // :host(innerSelector(s)), :not(selector), etc...\n      if (_pseudoSelectorSupportsInnerSelectors(pseudoSelectorName)) {\n        let innerDelims = startingDelims | LPAREN_DELIM_FLAG | RPAREN_DELIM_FLAG;\n        if (pseudoSelectorName == 'not') {\n          // the inner selector inside of :not(...) can only be one\n          // CSS selector (no commas allowed) ... This is according\n          // to the CSS specification\n          innerDelims |= COMMA_DELIM_FLAG;\n        }\n\n        // :host(a, b, c) {\n        this._parseSelectors(innerDelims).forEach((selector, index) => {\n          innerSelectors.push(selector);\n        });\n      } else {\n        // this branch is for things like \"en-us, 2k + 1, etc...\"\n        // which all end up in pseudoSelectors like :lang, :nth-child, etc..\n        const innerValueDelims = delimiters | LBRACE_DELIM_FLAG | COLON_DELIM_FLAG |\n            RPAREN_DELIM_FLAG | LPAREN_DELIM_FLAG;\n        while (!characterContainsDelimiter(this._scanner.peek, innerValueDelims)) {\n          const token = this._scan();\n          tokens.push(token);\n        }\n      }\n\n      const closeParenToken = this._consume(CssTokenType.Character, ')');\n      tokens.push(closeParenToken);\n    }\n\n    const end = this._getScannerIndex() - 1;\n    const strValue = this._extractSourceContent(start, end);\n\n    const endToken = tokens[tokens.length - 1];\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssPseudoSelectorAst(span, strValue, pseudoSelectorName, tokens, innerSelectors);\n  }\n\n  /** @internal */\n  _parseSimpleSelector(delimiters: number): CssSimpleSelectorAst {\n    const start = this._getScannerIndex();\n\n    delimiters |= COMMA_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.SELECTOR);\n    const selectorCssTokens: CssToken[] = [];\n    const pseudoSelectors: CssPseudoSelectorAst[] = [];\n\n    let previousToken: CssToken = undefined !;\n\n    const selectorPartDelimiters = delimiters | SPACE_DELIM_FLAG;\n    let loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n\n    let hasAttributeError = false;\n    while (loopOverSelector) {\n      const peek = this._scanner.peek;\n\n      switch (peek) {\n        case chars.$COLON:\n          let innerPseudo = this._parsePseudoSelector(delimiters);\n          pseudoSelectors.push(innerPseudo);\n          this._scanner.setMode(CssLexerMode.SELECTOR);\n          break;\n\n        case chars.$LBRACKET:\n          // we set the mode after the scan because attribute mode does not\n          // allow attribute [] values. And this also will catch any errors\n          // if an extra \"[\" is used inside.\n          selectorCssTokens.push(this._scan());\n          this._scanner.setMode(CssLexerMode.ATTRIBUTE_SELECTOR);\n          break;\n\n        case chars.$RBRACKET:\n          if (this._scanner.getMode() != CssLexerMode.ATTRIBUTE_SELECTOR) {\n            hasAttributeError = true;\n          }\n          // we set the mode early because attribute mode does not\n          // allow attribute [] values\n          this._scanner.setMode(CssLexerMode.SELECTOR);\n          selectorCssTokens.push(this._scan());\n          break;\n\n        default:\n          if (isSelectorOperatorCharacter(peek)) {\n            loopOverSelector = false;\n            continue;\n          }\n\n          let token = this._scan();\n          previousToken = token;\n          selectorCssTokens.push(token);\n          break;\n      }\n\n      loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n    }\n\n    hasAttributeError =\n        hasAttributeError || this._scanner.getMode() == CssLexerMode.ATTRIBUTE_SELECTOR;\n    if (hasAttributeError) {\n      this._error(\n          `Unbalanced CSS attribute selector at column ${previousToken.line}:${previousToken.column}`,\n          previousToken);\n    }\n\n    let end = this._getScannerIndex() - 1;\n\n    // this happens if the selector is not directly followed by\n    // a comma or curly brace without a space in between\n    let operator: CssToken|null = null;\n    let operatorScanCount = 0;\n    let lastOperatorToken: CssToken|null = null;\n    if (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      while (operator == null && !characterContainsDelimiter(this._scanner.peek, delimiters) &&\n             isSelectorOperatorCharacter(this._scanner.peek)) {\n        let token = this._scan();\n        const tokenOperator = token.strValue;\n        operatorScanCount++;\n        lastOperatorToken = token;\n        if (tokenOperator != SPACE_OPERATOR) {\n          switch (tokenOperator) {\n            case SLASH_CHARACTER:\n              // /deep/ operator\n              let deepToken = this._consume(CssTokenType.Identifier);\n              let deepSlash = this._consume(CssTokenType.Character);\n              let index = lastOperatorToken.index;\n              let line = lastOperatorToken.line;\n              let column = lastOperatorToken.column;\n              if (deepToken != null && deepToken.strValue.toLowerCase() == 'deep' &&\n                  deepSlash.strValue == SLASH_CHARACTER) {\n                token = new CssToken(\n                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n                    CssTokenType.Identifier, DEEP_OPERATOR_STR);\n              } else {\n                const text = SLASH_CHARACTER + deepToken.strValue + deepSlash.strValue;\n                this._error(\n                    generateErrorMessage(\n                        this._getSourceContent(), `${text} is an invalid CSS operator`, text, index,\n                        line, column),\n                    lastOperatorToken);\n                token = new CssToken(index, column, line, CssTokenType.Invalid, text);\n              }\n              break;\n\n            case GT_CHARACTER:\n              // >>> operator\n              if (this._scanner.peek == chars.$GT && this._scanner.peekPeek == chars.$GT) {\n                this._consume(CssTokenType.Character, GT_CHARACTER);\n                this._consume(CssTokenType.Character, GT_CHARACTER);\n                token = new CssToken(\n                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n                    CssTokenType.Identifier, TRIPLE_GT_OPERATOR_STR);\n              }\n              break;\n          }\n\n          operator = token;\n        }\n      }\n\n      // so long as there is an operator then we can have an\n      // ending value that is beyond the selector value ...\n      // otherwise it's just a bunch of trailing whitespace\n      if (operator != null) {\n        end = operator.index;\n      }\n    }\n\n    this._scanner.consumeWhitespace();\n\n    const strValue = this._extractSourceContent(start, end);\n\n    // if we do come across one or more spaces inside of\n    // the operators loop then an empty space is still a\n    // valid operator to use if something else was not found\n    if (operator == null && operatorScanCount > 0 && this._scanner.peek != chars.$LBRACE) {\n      operator = lastOperatorToken;\n    }\n\n    // please note that `endToken` is reassigned multiple times below\n    // so please do not optimize the if statements into if/elseif\n    let startTokenOrAst: CssToken|CssAst|null = null;\n    let endTokenOrAst: CssToken|CssAst|null = null;\n    if (selectorCssTokens.length > 0) {\n      startTokenOrAst = startTokenOrAst || selectorCssTokens[0];\n      endTokenOrAst = selectorCssTokens[selectorCssTokens.length - 1];\n    }\n    if (pseudoSelectors.length > 0) {\n      startTokenOrAst = startTokenOrAst || pseudoSelectors[0];\n      endTokenOrAst = pseudoSelectors[pseudoSelectors.length - 1];\n    }\n    if (operator != null) {\n      startTokenOrAst = startTokenOrAst || operator;\n      endTokenOrAst = operator;\n    }\n\n    const span = this._generateSourceSpan(startTokenOrAst !, endTokenOrAst);\n    return new CssSimpleSelectorAst(span, selectorCssTokens, strValue, pseudoSelectors, operator !);\n  }\n\n  /** @internal */\n  _parseSelector(delimiters: number): CssSelectorAst {\n    delimiters |= COMMA_DELIM_FLAG;\n    this._scanner.setMode(CssLexerMode.SELECTOR);\n\n    const simpleSelectors: CssSimpleSelectorAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      simpleSelectors.push(this._parseSimpleSelector(delimiters));\n      this._scanner.consumeWhitespace();\n    }\n\n    const firstSelector = simpleSelectors[0];\n    const lastSelector = simpleSelectors[simpleSelectors.length - 1];\n    const span = this._generateSourceSpan(firstSelector, lastSelector);\n    return new CssSelectorAst(span, simpleSelectors);\n  }\n\n  /** @internal */\n  _parseValue(delimiters: number): CssStyleValueAst {\n    delimiters |= RBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG | NEWLINE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n    const start = this._getScannerIndex();\n\n    const tokens: CssToken[] = [];\n    let wsStr = '';\n    let previous: CssToken = undefined !;\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      let token: CssToken;\n      if (previous != null && previous.type == CssTokenType.Identifier &&\n          this._scanner.peek == chars.$LPAREN) {\n        token = this._consume(CssTokenType.Character, '(');\n        tokens.push(token);\n\n        this._scanner.setMode(CssLexerMode.STYLE_VALUE_FUNCTION);\n\n        token = this._scan();\n        tokens.push(token);\n\n        this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n\n        token = this._consume(CssTokenType.Character, ')');\n        tokens.push(token);\n      } else {\n        token = this._scan();\n        if (token.type == CssTokenType.Whitespace) {\n          wsStr += token.strValue;\n        } else {\n          wsStr = '';\n          tokens.push(token);\n        }\n      }\n      previous = token;\n    }\n\n    const end = this._getScannerIndex() - 1;\n    this._scanner.consumeWhitespace();\n\n    const code = this._scanner.peek;\n    if (code == chars.$SEMICOLON) {\n      this._consume(CssTokenType.Character, ';');\n    } else if (code != chars.$RBRACE) {\n      this._error(\n          generateErrorMessage(\n              this._getSourceContent(), `The CSS key/value definition did not end with a semicolon`,\n              previous.strValue, previous.index, previous.line, previous.column),\n          previous);\n    }\n\n    const strValue = this._extractSourceContent(start, end);\n    const startToken = tokens[0];\n    const endToken = tokens[tokens.length - 1];\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssStyleValueAst(span, tokens, strValue);\n  }\n\n  /** @internal */\n  _collectUntilDelim(delimiters: number, assertType: CssTokenType|null = null): CssToken[] {\n    const tokens: CssToken[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      const val = assertType != null ? this._consume(assertType) : this._scan();\n      tokens.push(val);\n    }\n    return tokens;\n  }\n\n  /** @internal */\n  _parseBlock(delimiters: number): CssBlockAst {\n    delimiters |= RBRACE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n    this._scanner.consumeEmptyStatements();\n\n    const results: CssRuleAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      results.push(this._parseRule(delimiters));\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    this._scanner.consumeEmptyStatements();\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssBlockAst(span, results);\n  }\n\n  /** @internal */\n  _parseStyleBlock(delimiters: number): CssStylesBlockAst|null {\n    delimiters |= RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n    if (startToken.numValue != chars.$LBRACE) {\n      return null;\n    }\n\n    const definitions: CssDefinitionAst[] = [];\n    this._scanner.consumeEmptyStatements();\n\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      definitions.push(this._parseDefinition(delimiters));\n      this._scanner.consumeEmptyStatements();\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n    this._scanner.consumeEmptyStatements();\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssStylesBlockAst(span, definitions);\n  }\n\n  /** @internal */\n  _parseDefinition(delimiters: number): CssDefinitionAst {\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n\n    let prop = this._consume(CssTokenType.Identifier);\n    let parseValue: boolean = false;\n    let value: CssStyleValueAst|null = null;\n    let endToken: CssToken|CssStyleValueAst = prop;\n\n    // the colon value separates the prop from the style.\n    // there are a few cases as to what could happen if it\n    // is missing\n    switch (this._scanner.peek) {\n      case chars.$SEMICOLON:\n      case chars.$RBRACE:\n      case chars.$EOF:\n        parseValue = false;\n        break;\n\n      default:\n        let propStr = [prop.strValue];\n        if (this._scanner.peek != chars.$COLON) {\n          // this will throw the error\n          const nextValue = this._consume(CssTokenType.Character, ':');\n          propStr.push(nextValue.strValue);\n\n          const remainingTokens = this._collectUntilDelim(\n              delimiters | COLON_DELIM_FLAG | SEMICOLON_DELIM_FLAG, CssTokenType.Identifier);\n          if (remainingTokens.length > 0) {\n            remainingTokens.forEach((token) => { propStr.push(token.strValue); });\n          }\n\n          endToken = prop =\n              new CssToken(prop.index, prop.column, prop.line, prop.type, propStr.join(' '));\n        }\n\n        // this means we've reached the end of the definition and/or block\n        if (this._scanner.peek == chars.$COLON) {\n          this._consume(CssTokenType.Character, ':');\n          parseValue = true;\n        }\n        break;\n    }\n\n    if (parseValue) {\n      value = this._parseValue(delimiters);\n      endToken = value;\n    } else {\n      this._error(\n          generateErrorMessage(\n              this._getSourceContent(), `The CSS property was not paired with a style value`,\n              prop.strValue, prop.index, prop.line, prop.column),\n          prop);\n    }\n\n    const span = this._generateSourceSpan(prop, endToken);\n    return new CssDefinitionAst(span, prop, value !);\n  }\n\n  /** @internal */\n  _assertCondition(status: boolean, errorMessage: string, problemToken: CssToken): boolean {\n    if (!status) {\n      this._error(errorMessage, problemToken);\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal */\n  _error(message: string, problemToken: CssToken) {\n    const length = problemToken.strValue.length;\n    const error = CssParseError.create(\n        this._file, 0, problemToken.line, problemToken.column, length, message);\n    this._errors.push(error);\n  }\n}\n\nexport class CssParseError extends ParseError {\n  static create(\n      file: ParseSourceFile, offset: number, line: number, col: number, length: number,\n      errMsg: string): CssParseError {\n    const start = new ParseLocation(file, offset, line, col);\n    const end = new ParseLocation(file, offset, line, col + length);\n    const span = new ParseSourceSpan(start, end);\n    return new CssParseError(span, 'CSS Parse Error: ' + errMsg);\n  }\n\n  constructor(span: ParseSourceSpan, message: string) { super(span, message); }\n}\n"],"sourceRoot":""}