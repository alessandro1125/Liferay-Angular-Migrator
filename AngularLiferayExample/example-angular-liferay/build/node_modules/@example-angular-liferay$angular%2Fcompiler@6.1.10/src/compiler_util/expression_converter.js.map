{"version":3,"sources":["../../../../../../../packages/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\n\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nexport interface LocalResolver { getLocal(name: string): o.Expression|null; }\n\nexport class ConvertActionBindingResult {\n  /**\n   * Store statements which are render3 compatible.\n   */\n  render3Stmts: o.Statement[];\n  constructor(\n      /**\n       * Render2 compatible statements,\n       */\n      public stmts: o.Statement[],\n      /**\n       * Variable name used with render2 compatible statements.\n       */\n      public allowDefault: o.ReadVarExpr) {\n    /**\n     * This is bit of a hack. It converts statements which render2 expects to statements which are\n     * expected by render3.\n     *\n     * Example: `<div click=\"doSomething($event)\">` will generate:\n     *\n     * Render3:\n     * ```\n     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n     * return pd_b;\n     * ```\n     *\n     * but render2 expects:\n     * ```\n     * return ctx.doSomething($event);\n     * ```\n     */\n    // TODO(misko): remove this hack once we no longer support ViewEngine.\n    this.render3Stmts = stmts.map((statement: o.Statement) => {\n      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n          statement.value instanceof o.BinaryOperatorExpr) {\n        const lhs = statement.value.lhs as o.CastExpr;\n        return new o.ReturnStatement(lhs.value);\n      }\n      return statement;\n    });\n  }\n}\n\nexport type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, interpolationFunction?: InterpolationFunction): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const lastIndex = actionStmts.length - 1;\n  let preventDefaultVar: o.ReadVarExpr = null !;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    const returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\nexport enum BindingForm {\n  // The general form of binding expression, supports all expressions.\n  General,\n\n  // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n  TrySimple,\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm,\n    interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const currValExpr = createCurrValueExpr(bindingId);\n  const stmts: o.Statement[] = [];\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n\n  if (visitor.temporaryCount) {\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  } else if (form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n  visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private interpolationFunction: InterpolationFunction|undefined) {}\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode, value.conditional(\n                  this._visit(ast.trueExp, _Mode.Expression),\n                  this._visit(ast.falseExp, _Mode.Expression)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit(ast.target !, _Mode.Expression).callFn(convertedArgs);\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    if (this.interpolationFunction) {\n      return this.interpolationFunction(args);\n    }\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1))]);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(mode, o.literal(ast.value, type));\n  }\n\n  private _getLocal(name: string): o.Expression|null { return this._localResolver.getLocal(name); }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    if (ast.receiver instanceof cdAst.ImplicitReceiver && ast.name == '$any') {\n      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n      if (args.length != 1) {\n        throw new Error(\n            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n      }\n      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE);\n    }\n\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      const varExpr = this._getLocal(ast.name);\n      if (varExpr) {\n        throw new Error('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this._visit(ast, mode)); }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr = undefined !;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n\n  // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs be transform initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary) { return null; },\n      visitChain(ast: cdAst.Chain) { return null; },\n      visitConditional(ast: cdAst.Conditional) { return null; },\n      visitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n      visitInterpolation(ast: cdAst.Interpolation) { return null; },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n      visitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n      visitPipe(ast: cdAst.BindingPipe) { return null; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) { return null; },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n      visitQuote(ast: cdAst.Quote) { return null; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporary(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n      visitChain(ast: cdAst.Chain) { return false; },\n      visitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n      visitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n      visitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n      visitMethodCall(ast: cdAst.MethodCall) { return true; },\n      visitPipe(ast: cdAst.BindingPipe) { return true; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitNonNullAssert(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n      visitQuote(ast: cdAst.Quote) { return false; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n\nexport class BuiltinFunctionCall extends cdAst.FunctionCall {\n  constructor(span: cdAst.ParseSpan, public args: cdAst.AST[], public converter: BuiltinConverter) {\n    super(span, null, args);\n  }\n}\n"],"sourceRoot":""}