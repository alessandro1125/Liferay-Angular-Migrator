{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {CompileInjectableMetadata, CompileNgModuleMetadata, CompileProviderMetadata, identifierName} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {InjectFlags, NodeFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {convertValueToOutputAst} from './output/value_util';\nimport {typeSourceSpan} from './parse_util';\nimport {NgModuleProviderAnalyzer} from './provider_analyzer';\nimport {OutputContext} from './util';\nimport {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n\ntype MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\ntype MapLiteral = MapEntry[];\n\nfunction mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport class InjectableCompiler {\n  private tokenInjector: StaticSymbol;\n  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n  }\n\n  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n    return deps.map(dep => {\n      let token = dep;\n      let args = [token];\n      let flags: InjectFlags = InjectFlags.Default;\n      if (Array.isArray(dep)) {\n        for (let i = 0; i < dep.length; i++) {\n          const v = dep[i];\n          if (v) {\n            if (v.ngMetadataName === 'Optional') {\n              flags |= InjectFlags.Optional;\n            } else if (v.ngMetadataName === 'SkipSelf') {\n              flags |= InjectFlags.SkipSelf;\n            } else if (v.ngMetadataName === 'Self') {\n              flags |= InjectFlags.Self;\n            } else if (v.ngMetadataName === 'Inject') {\n              token = v.token;\n            } else {\n              token = v;\n            }\n          }\n        }\n      }\n\n      let tokenExpr: o.Expression;\n      if (typeof token === 'string') {\n        tokenExpr = o.literal(token);\n      } else if (token === this.tokenInjector) {\n        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n      } else {\n        tokenExpr = ctx.importExpr(token);\n      }\n\n      if (flags !== InjectFlags.Default) {\n        args = [tokenExpr, o.literal(flags)];\n      } else {\n        args = [tokenExpr];\n      }\n      return o.importExpr(Identifiers.inject).callFn(args);\n    });\n  }\n\n  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let retValue: o.Expression;\n    if (injectable.useExisting) {\n      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n    } else if (injectable.useFactory) {\n      const deps = injectable.deps || [];\n      if (deps.length > 0) {\n        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n      } else {\n        return ctx.importExpr(injectable.useFactory);\n      }\n    } else if (injectable.useValue) {\n      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n    } else {\n      const clazz = injectable.useClass || injectable.symbol;\n      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n    }\n    return o.fn(\n        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n        injectable.symbol.name + '_Factory');\n  }\n\n  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let providedIn: o.Expression = o.NULL_EXPR;\n    if (injectable.providedIn !== undefined) {\n      if (injectable.providedIn === null) {\n        providedIn = o.NULL_EXPR;\n      } else if (typeof injectable.providedIn === 'string') {\n        providedIn = o.literal(injectable.providedIn);\n      } else {\n        providedIn = ctx.importExpr(injectable.providedIn);\n      }\n    }\n    const def: MapLiteral = [\n      mapEntry('factory', this.factoryFor(injectable, ctx)),\n      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n      mapEntry('providedIn', providedIn),\n    ];\n    return o.importExpr(Identifiers.defineInjectable).callFn([o.literalMap(def)]);\n  }\n\n  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n      const className = identifierName(injectable.type) !;\n      const clazz = new o.ClassStmt(\n          className, null,\n          [\n            new o.ClassField(\n                'ngInjectableDef', o.INFERRED_TYPE, [o.StmtModifier.Static],\n                this.injectableDef(injectable, ctx)),\n          ],\n          [], new o.ClassMethod(null, [], []), []);\n      ctx.statements.push(clazz);\n    }\n  }\n}\n"],"sourceRoot":""}