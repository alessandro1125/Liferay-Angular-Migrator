{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {escapeRegExp} from '../util';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new _ParseAST(\n                    input, location, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n\n  private _parseQuote(input: string|null, location: any): AST|null {\n    if (input == null) return null;\n    const prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(tplKey: string, tplValue: string, location: any):\n      TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(tplValue);\n    return new _ParseAST(tplValue, location, tokens, tplValue.length, false, this.errors, 0)\n        .parseTemplateBindings(tplKey);\n  }\n\n  parseInterpolation(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split == null) return null;\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new _ParseAST(\n                      input, location, tokens, sourceToLex.length, false, this.errors,\n                      split.offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n        new Interpolation(\n            new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions),\n        input, location, this.errors);\n  }\n\n  splitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation\n      |null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n            'Blank expressions are not allowed in interpolated strings', input,\n            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n            location);\n        expressions.push('$implict');\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: any): ASTWithSource {\n    return new ASTWithSource(\n        new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input,\n        location, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(\n      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n          `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n          location);\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n    let errLocation = '';\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ?\n          parts[j] :\n          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: any, public tokens: Token[],\n      public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token { return this.peek(0); }\n\n  get inputIndex(): number {\n    return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                                               this.inputLength + this.offset;\n  }\n\n  span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n  advance() { this.index++; }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n  peekKeywordAs(): boolean { return this.next.isKeywordAs(); }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) return new EmptyExpr(this.span(start));\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST { return this.parseConditional(); }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator('&&')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), '-', result, new LiteralPrimitive(new ParseSpan(start, start), 0));\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n              result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n\n      } else if (this.optionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator('=')) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n\n      } else if (this.optionalOperator('!')) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                      new MethodCall(span, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` in between.\n   */\n  expectTemplateBindingKey(): string {\n    let result = '';\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  // Parses the AST for `<some-tag *tplKey=AST>`\n  parseTemplateBindings(tplKey: string): TemplateBindingParseResult {\n    let firstBinding = true;\n    const bindings: TemplateBinding[] = [];\n    const warnings: string[] = [];\n    do {\n      const start = this.inputIndex;\n      let rawKey: string;\n      let key: string;\n      let isVar: boolean = false;\n      if (firstBinding) {\n        rawKey = key = tplKey;\n        firstBinding = false;\n      } else {\n        isVar = this.peekKeywordLet();\n        if (isVar) this.advance();\n        rawKey = this.expectTemplateBindingKey();\n        key = isVar ? rawKey : tplKey + rawKey[0].toUpperCase() + rawKey.substring(1);\n        this.optionalCharacter(chars.$COLON);\n      }\n\n      let name: string = null !;\n      let expression: ASTWithSource|null = null;\n      if (isVar) {\n        if (this.optionalOperator('=')) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = '\\$implicit';\n        }\n      } else if (this.peekKeywordAs()) {\n        this.advance();  // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey();  // read local var name\n        isVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const start = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n\n      bindings.push(new TemplateBinding(this.span(start), key, isVar, name, expression));\n      if (this.peekKeywordAs() && !isVar) {\n        const letStart = this.inputIndex;\n        this.advance();                                   // consume `as`\n        const letName = this.expectTemplateBindingKey();  // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null !));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    } while (this.index < this.tokens.length);\n\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(\n            this.next.toString() !, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n  visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n"],"sourceRoot":""}