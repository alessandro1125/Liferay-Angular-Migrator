{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean { return this.type == TokenType.Number; }\n\n  isString(): boolean { return this.type == TokenType.String; }\n\n  isOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n\n  isIdentifier(): boolean { return this.type == TokenType.Identifier; }\n\n  isKeyword(): boolean { return this.type == TokenType.Keyword; }\n\n  isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n\n  isKeywordAs(): boolean { return this.type == TokenType.Keyword && this.strValue == 'as'; }\n\n  isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n\n  isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n\n  isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n\n  isError(): boolean { return this.type == TokenType.Error; }\n\n  toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n                                        newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"],"sourceRoot":""}