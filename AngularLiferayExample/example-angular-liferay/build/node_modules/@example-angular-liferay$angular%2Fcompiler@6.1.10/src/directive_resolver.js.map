{"version":3,"sources":["../../../../../../packages/compiler/src/directive_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from './compile_reflector';\nimport {Component, Directive, Type, createComponent, createContentChild, createContentChildren, createDirective, createHostBinding, createHostListener, createInput, createOutput, createViewChild, createViewChildren} from './core';\nimport {resolveForwardRef, splitAtColon, stringify} from './util';\n\nconst QUERY_METADATA_IDENTIFIERS = [\n  createViewChild,\n  createViewChildren,\n  createContentChild,\n  createContentChildren,\n];\n\n/*\n * Resolve a `Type` for {@link Directive}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nexport class DirectiveResolver {\n  constructor(private _reflector: CompileReflector) {}\n\n  isDirective(type: Type) {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n  }\n\n  /**\n   * Return {@link Directive} for a given `Type`.\n   */\n  resolve(type: Type): Directive;\n  resolve(type: Type, throwIfNotFound: true): Directive;\n  resolve(type: Type, throwIfNotFound: boolean): Directive|null;\n  resolve(type: Type, throwIfNotFound = true): Directive|null {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    if (typeMetadata) {\n      const metadata = findLast(typeMetadata, isDirectiveMetadata);\n      if (metadata) {\n        const propertyMetadata = this._reflector.propMetadata(type);\n        const guards = this._reflector.guards(type);\n        return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n      }\n    }\n\n    if (throwIfNotFound) {\n      throw new Error(`No Directive annotation found on ${stringify(type)}`);\n    }\n\n    return null;\n  }\n\n  private _mergeWithPropertyMetadata(\n      dm: Directive, propertyMetadata: {[key: string]: any[]}, guards: {[key: string]: any},\n      directiveType: Type): Directive {\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n    const host: {[key: string]: string} = {};\n    const queries: {[key: string]: any} = {};\n    Object.keys(propertyMetadata).forEach((propName: string) => {\n      const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\n      if (input) {\n        if (input.bindingPropertyName) {\n          inputs.push(`${propName}: ${input.bindingPropertyName}`);\n        } else {\n          inputs.push(propName);\n        }\n      }\n      const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\n      if (output) {\n        if (output.bindingPropertyName) {\n          outputs.push(`${propName}: ${output.bindingPropertyName}`);\n        } else {\n          outputs.push(propName);\n        }\n      }\n      const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\n      hostBindings.forEach(hostBinding => {\n        if (hostBinding.hostPropertyName) {\n          const startWith = hostBinding.hostPropertyName[0];\n          if (startWith === '(') {\n            throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\n          } else if (startWith === '[') {\n            throw new Error(\n                `@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n          }\n          host[`[${hostBinding.hostPropertyName}]`] = propName;\n        } else {\n          host[`[${propName}]`] = propName;\n        }\n      });\n      const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\n      hostListeners.forEach(hostListener => {\n        const args = hostListener.args || [];\n        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n      });\n      const query = findLast(\n          propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\n      if (query) {\n        queries[propName] = query;\n      }\n    });\n    return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n  }\n\n  private _extractPublicName(def: string) { return splitAtColon(def, [null !, def])[1].trim(); }\n\n  private _dedupeBindings(bindings: string[]): string[] {\n    const names = new Set<string>();\n    const publicNames = new Set<string>();\n    const reversedResult: string[] = [];\n    // go last to first to allow later entries to overwrite previous entries\n    for (let i = bindings.length - 1; i >= 0; i--) {\n      const binding = bindings[i];\n      const name = this._extractPublicName(binding);\n      publicNames.add(name);\n      if (!names.has(name)) {\n        names.add(name);\n        reversedResult.push(binding);\n      }\n    }\n    return reversedResult.reverse();\n  }\n\n  private _merge(\n      directive: Directive, inputs: string[], outputs: string[], host: {[key: string]: string},\n      queries: {[key: string]: any}, guards: {[key: string]: any}, directiveType: Type): Directive {\n    const mergedInputs =\n        this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n    const mergedOutputs =\n        this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n    const mergedHost = directive.host ? {...directive.host, ...host} : host;\n    const mergedQueries = directive.queries ? {...directive.queries, ...queries} : queries;\n    if (createComponent.isTypeOf(directive)) {\n      const comp = directive as Component;\n      return createComponent({\n        selector: comp.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: comp.exportAs,\n        moduleId: comp.moduleId,\n        queries: mergedQueries,\n        changeDetection: comp.changeDetection,\n        providers: comp.providers,\n        viewProviders: comp.viewProviders,\n        entryComponents: comp.entryComponents,\n        template: comp.template,\n        templateUrl: comp.templateUrl,\n        styles: comp.styles,\n        styleUrls: comp.styleUrls,\n        encapsulation: comp.encapsulation,\n        animations: comp.animations,\n        interpolation: comp.interpolation,\n        preserveWhitespaces: directive.preserveWhitespaces,\n      });\n    } else {\n      return createDirective({\n        selector: directive.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: directive.exportAs,\n        queries: mergedQueries,\n        providers: directive.providers, guards\n      });\n    }\n  }\n}\n\nfunction isDirectiveMetadata(type: any): type is Directive {\n  return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\n\nexport function findLast<T>(arr: T[], condition: (value: T) => boolean): T|null {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (condition(arr[i])) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n"],"sourceRoot":""}