{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompilePipeMetadata, identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DefinitionKind} from '../constant_pool';\nimport * as o from '../output/output_ast';\nimport {OutputContext, error} from '../util';\n\nimport {R3DependencyMetadata, compileFactoryFunction, dependenciesFromGlobalMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\n\nexport interface R3PipeMetadata {\n  name: string;\n  type: o.Expression;\n  pipeName: string;\n  deps: R3DependencyMetadata[];\n  pure: boolean;\n}\n\nexport interface R3PipeDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata) {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type, quoted: false});\n\n  const templateFactory = compileFactoryFunction({\n    name: metadata.name,\n    fnOrClass: metadata.type,\n    deps: metadata.deps,\n    useNew: true,\n    injectFn: R3.directiveInject,\n  });\n  definitionMapValues.push({key: 'factory', value: templateFactory, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  const expression = o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)]);\n  const type = new o.ExpressionType(o.importExpr(R3.PipeDef, [\n    new o.ExpressionType(metadata.type),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n  ]));\n  return {expression, type};\n}\n\n/**\n * Write a pipe definition to the output context.\n */\nexport function compilePipeFromRender2(\n    outputCtx: OutputContext, pipe: CompilePipeMetadata, reflector: CompileReflector) {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  const name = identifierName(pipe.type);\n  if (!name) {\n    return error(`Cannot resolve the name of ${pipe.type}`);\n  }\n\n  const metadata: R3PipeMetadata = {\n    name,\n    pipeName: pipe.name,\n    type: outputCtx.importExpr(pipe.type.reference),\n    deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n    pure: pipe.pure,\n  };\n\n  const res = compilePipeFromMetadata(metadata);\n\n  const definitionField = outputCtx.constantPool.propertyNameOf(DefinitionKind.Pipe);\n\n  outputCtx.statements.push(new o.ClassStmt(\n      /* name */ name,\n      /* parent */ null,\n      /* fields */[new o.ClassField(\n          /* name */ definitionField,\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ res.expression)],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]));\n}\n"],"sourceRoot":""}