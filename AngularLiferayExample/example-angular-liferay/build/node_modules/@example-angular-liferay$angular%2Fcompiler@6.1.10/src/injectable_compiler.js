Liferay.Loader.define("@example-angular-liferay$angular/compiler@6.1.10/src/injectable_compiler", ['module', 'exports', 'require', '@example-angular-liferay$angular/compiler/src/compile_metadata', '@example-angular-liferay$angular/compiler/src/identifiers', '@example-angular-liferay$angular/compiler/src/output/output_ast', '@example-angular-liferay$angular/compiler/src/output/value_util'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    (function (factory) {
        if (typeof module === "object" && typeof module.exports === "object") {
            var v = factory(require, exports);
            if (v !== undefined) module.exports = v;
        } else if (typeof define === "function" && define.amd) {
            define("@angular/compiler/src/injectable_compiler", ["require", "exports", "@angular/compiler/src/compile_metadata", "@angular/compiler/src/identifiers", "@angular/compiler/src/output/output_ast", "@angular/compiler/src/output/value_util"], factory);
        }
    })(function (require, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", { value: true });
        var compile_metadata_1 = require("@example-angular-liferay$angular/compiler/src/compile_metadata");
        var identifiers_1 = require("@example-angular-liferay$angular/compiler/src/identifiers");
        var o = require("@example-angular-liferay$angular/compiler/src/output/output_ast");
        var value_util_1 = require("@example-angular-liferay$angular/compiler/src/output/value_util");
        function mapEntry(key, value) {
            return { key: key, value: value, quoted: false };
        }
        var InjectableCompiler = /** @class */function () {
            function InjectableCompiler(reflector, alwaysGenerateDef) {
                this.reflector = reflector;
                this.alwaysGenerateDef = alwaysGenerateDef;
                this.tokenInjector = reflector.resolveExternalReference(identifiers_1.Identifiers.Injector);
            }
            InjectableCompiler.prototype.depsArray = function (deps, ctx) {
                var _this = this;
                return deps.map(function (dep) {
                    var token = dep;
                    var args = [token];
                    var flags = 0 /* Default */;
                    if (Array.isArray(dep)) {
                        for (var i = 0; i < dep.length; i++) {
                            var v = dep[i];
                            if (v) {
                                if (v.ngMetadataName === 'Optional') {
                                    flags |= 8 /* Optional */;
                                } else if (v.ngMetadataName === 'SkipSelf') {
                                    flags |= 4 /* SkipSelf */;
                                } else if (v.ngMetadataName === 'Self') {
                                    flags |= 2 /* Self */;
                                } else if (v.ngMetadataName === 'Inject') {
                                    token = v.token;
                                } else {
                                    token = v;
                                }
                            }
                        }
                    }
                    var tokenExpr;
                    if (typeof token === 'string') {
                        tokenExpr = o.literal(token);
                    } else if (token === _this.tokenInjector) {
                        tokenExpr = o.importExpr(identifiers_1.Identifiers.INJECTOR);
                    } else {
                        tokenExpr = ctx.importExpr(token);
                    }
                    if (flags !== 0 /* Default */) {
                            args = [tokenExpr, o.literal(flags)];
                        } else {
                        args = [tokenExpr];
                    }
                    return o.importExpr(identifiers_1.Identifiers.inject).callFn(args);
                });
            };
            InjectableCompiler.prototype.factoryFor = function (injectable, ctx) {
                var retValue;
                if (injectable.useExisting) {
                    retValue = o.importExpr(identifiers_1.Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);
                } else if (injectable.useFactory) {
                    var deps = injectable.deps || [];
                    if (deps.length > 0) {
                        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));
                    } else {
                        return ctx.importExpr(injectable.useFactory);
                    }
                } else if (injectable.useValue) {
                    retValue = value_util_1.convertValueToOutputAst(ctx, injectable.useValue);
                } else {
                    var clazz = injectable.useClass || injectable.symbol;
                    var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);
                    retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);
                }
                return o.fn([], [new o.ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');
            };
            InjectableCompiler.prototype.injectableDef = function (injectable, ctx) {
                var providedIn = o.NULL_EXPR;
                if (injectable.providedIn !== undefined) {
                    if (injectable.providedIn === null) {
                        providedIn = o.NULL_EXPR;
                    } else if (typeof injectable.providedIn === 'string') {
                        providedIn = o.literal(injectable.providedIn);
                    } else {
                        providedIn = ctx.importExpr(injectable.providedIn);
                    }
                }
                var def = [mapEntry('factory', this.factoryFor(injectable, ctx)), mapEntry('token', ctx.importExpr(injectable.type.reference)), mapEntry('providedIn', providedIn)];
                return o.importExpr(identifiers_1.Identifiers.defineInjectable).callFn([o.literalMap(def)]);
            };
            InjectableCompiler.prototype.compile = function (injectable, ctx) {
                if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {
                    var className = compile_metadata_1.identifierName(injectable.type);
                    var clazz = new o.ClassStmt(className, null, [new o.ClassField('ngInjectableDef', o.INFERRED_TYPE, [o.StmtModifier.Static], this.injectableDef(injectable, ctx))], [], new o.ClassMethod(null, [], []), []);
                    ctx.statements.push(clazz);
                }
            };
            return InjectableCompiler;
        }();
        exports.InjectableCompiler = InjectableCompiler;
    });
});
//# sourceMappingURL=injectable_compiler.js.map