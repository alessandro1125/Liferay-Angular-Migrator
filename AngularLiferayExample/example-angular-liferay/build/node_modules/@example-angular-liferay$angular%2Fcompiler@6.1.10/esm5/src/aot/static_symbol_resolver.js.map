{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\n\nconst TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\nexport class ResolvedStaticSymbol {\n  constructor(public symbol: StaticSymbol, public metadata: any) {}\n}\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n\n  /**\n   * Get a file suitable for display to the user that should be relative to the project directory\n   * or the current directory.\n   */\n  getOutputName(filePath: string): string;\n}\n\nconst SUPPORTED_SCHEMA_VERSION = 4;\n\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\n  private metadataCache = new Map<string, {[key: string]: any}>();\n  // Note: this will only contain StaticSymbols without members!\n  private resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\n  private resolvedFilePaths = new Set<string>();\n  // Note: this will only contain StaticSymbols without members!\n  private importAs = new Map<StaticSymbol, StaticSymbol>();\n  private symbolResourcePaths = new Map<StaticSymbol, string>();\n  private symbolFromFile = new Map<string, StaticSymbol[]>();\n  private knownFileNameToModuleNames = new Map<string, string>();\n\n  constructor(\n      private host: StaticSymbolResolverHost, private staticSymbolCache: StaticSymbolCache,\n      private summaryResolver: SummaryResolver<StaticSymbol>,\n      private errorRecorder?: (error: any, fileName?: string) => void) {}\n\n  resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol) !;\n    }\n    // Note: always ask for a summary first,\n    // as we might have read shallow metadata via a .d.ts file\n    // for the symbol.\n    const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol) !;\n    if (resultFromSummary) {\n      return resultFromSummary;\n    }\n    const resultFromCache = this.resolvedSymbols.get(staticSymbol);\n    if (resultFromCache) {\n      return resultFromCache;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    return this.resolvedSymbols.get(staticSymbol) !;\n  }\n\n  /**\n   * getImportAs produces a symbol that can be used to import the given symbol.\n   * The import might be different than the symbol if the symbol is exported from\n   * a library with a summary; in which case we want to import the symbol from the\n   * ngfactory re-export instead of directly to avoid introducing a direct dependency\n   * on an otherwise indirect dependency.\n   *\n   * @param staticSymbol the symbol for which to generate a import symbol\n   */\n  getImportAs(staticSymbol: StaticSymbol, useSummaries: boolean = true): StaticSymbol|null {\n    if (staticSymbol.members.length) {\n      const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n    if (summarizedFileName !== staticSymbol.filePath) {\n      const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n      const baseSymbol =\n          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(\n              summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name),\n              baseSymbol.members) :\n          null;\n    }\n    let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n    if (!result) {\n      result = this.importAs.get(staticSymbol) !;\n    }\n    return result;\n  }\n\n  /**\n   * getResourcePath produces the path to the original location of the symbol and should\n   * be used to determine the relative location of resource references recorded in\n   * symbol metadata.\n   */\n  getResourcePath(staticSymbol: StaticSymbol): string {\n    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n  }\n\n  /**\n   * getTypeArity returns the number of generic type parameters the given symbol\n   * has. If the symbol is not a type the result is null.\n   */\n  getTypeArity(staticSymbol: StaticSymbol): number|null {\n    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isGeneratedFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n\n  getKnownModuleName(filePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(filePath) || null;\n  }\n\n  recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n\n  recordModuleNameForFileName(fileName: string, moduleName: string) {\n    this.knownFileNameToModuleNames.set(fileName, moduleName);\n  }\n\n  /**\n   * Invalidate all information derived from the given file.\n   *\n   * @param fileName the file to invalidate\n   */\n  invalidateFile(fileName: string) {\n    this.metadataCache.delete(fileName);\n    this.resolvedFilePaths.delete(fileName);\n    const symbols = this.symbolFromFile.get(fileName);\n    if (symbols) {\n      this.symbolFromFile.delete(fileName);\n      for (const symbol of symbols) {\n        this.resolvedSymbols.delete(symbol);\n        this.importAs.delete(symbol);\n        this.symbolResourcePaths.delete(symbol);\n      }\n    }\n  }\n\n  /** @internal */\n  ignoreErrorsFor<T>(cb: () => T) {\n    const recorder = this.errorRecorder;\n    this.errorRecorder = () => {};\n    try {\n      return cb();\n    } finally {\n      this.errorRecorder = recorder;\n    }\n  }\n\n  private _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const members = staticSymbol.members;\n    const baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let value = baseMetadata;\n      for (let i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n\n  private _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n\n  /**\n   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n   *\n   * @param declarationFile the absolute path of the file where the symbol is declared\n   * @param name the name of the type.\n   * @param members a symbol for a static member of the named type\n   */\n  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n\n  /**\n   * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n   * metadata.\n   *\n   * @param filePath the absolute path to examine for decorators.\n   * @returns true if any class in the file has a decorator.\n   */\n  hasDecorators(filePath: string): boolean {\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      return Object.keys(metadata['metadata']).some((metadataKey) => {\n        const entry = metadata['metadata'][metadataKey];\n        return entry && entry.__symbolic === 'class' && entry.decorators;\n      });\n    }\n    return false;\n  }\n\n  getSymbolsOf(filePath: string): StaticSymbol[] {\n    const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n    if (summarySymbols) {\n      return summarySymbols;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n    this._createSymbolsOf(filePath);\n    const metadataSymbols: StaticSymbol[] = [];\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        metadataSymbols.push(resolvedSymbol.symbol);\n      }\n    });\n    return metadataSymbols;\n  }\n\n  private _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['importAs']) {\n      // Index bundle indices should use the importAs module name defined\n      // in the bundle.\n      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n    }\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n\n    // handle the actual metadata. Has to be after the exports\n    // as there might be collisions in the names, and we want the symbols\n    // of the current module to win ofter reexports.\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      const origins: {[index: string]: string} = metadata['origins'] || {};\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const symbolMeta = metadata['metadata'][metadataKey];\n        const name = unescapeIdentifier(metadataKey);\n\n        const symbol = this.getStaticSymbol(filePath, name);\n\n        const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n        if (origin) {\n          // If the symbol is from a bundled index, use the declaration location of the\n          // symbol so relative references (such as './my.html') will be calculated\n          // correctly.\n          const originFilePath = this.resolveModule(origin, filePath);\n          if (!originFilePath) {\n            this.reportError(\n                new Error(`Couldn't resolve original symbol for ${origin} from ${filePath}`));\n          } else {\n            this.symbolResourcePaths.set(symbol, originFilePath);\n          }\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n      });\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n    this.symbolFromFile.set(filePath, resolvedSymbols.map(resolvedSymbol => resolvedSymbol.symbol));\n  }\n\n  private createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    // For classes that don't have Angular summaries / metadata,\n    // we only keep their arity, but nothing else\n    // (e.g. their constructor parameters).\n    // We do this to prevent introducing deep imports\n    // as we didn't generate .ngfactory.ts files with proper reexports.\n    const isTsFile = TS.test(sourceSymbol.filePath);\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n        metadata['__symbolic'] === 'class') {\n      const transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n\n    let _originalFileMemo: string|undefined;\n    const getOriginalName: () => string = () => {\n      if (!_originalFileMemo) {\n        // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n        // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n        // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n        // location as it is not important to finding the file.\n        _originalFileMemo =\n            this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                                        .replace(/^.*node_modules[/\\\\]/, ''));\n      }\n      return _originalFileMemo;\n    };\n\n    const self = this;\n\n    class ReferenceTransformer extends ValueTransformer {\n      visitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const module = map['module'];\n          const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath) !;\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`,\n                line: map.line,\n                character: map.character,\n                fileName: getOriginalName()\n              };\n            }\n            return {\n              __symbolic: 'resolved',\n              symbol: self.getStaticSymbol(filePath, name),\n              line: map.line,\n              character: map.character,\n              fileName: getOriginalName()\n            };\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(topLevelPath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else if (symbolic === 'error') {\n          return {...map, fileName: getOriginalName()};\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n    if (unwrappedTransformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n\n  private createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n        this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n\n  private reportError(error: Error, context?: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n\n  /**\n   * @param module an absolute path to a module file.\n   */\n  private getModuleMetadata(module: string): {[key: string]: any} {\n    let moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md && md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage));\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n\n\n  getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' +\n            containingFile : ''}`));\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n\n  private resolveModule(module: string, containingFile?: string): string|null {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch (e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, undefined, containingFile);\n    }\n    return null;\n  }\n}\n\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n\nexport function unwrapResolvedMetadata(metadata: any): any {\n  if (metadata && metadata.__symbolic === 'resolved') {\n    return metadata.symbol;\n  }\n  return metadata;\n}\n"],"sourceRoot":""}