{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/aot/lazy_routes.ts"],"names":[],"mappings":";;;;;;;;;;AAQA,aAAiC,cAAjC,QAAsD,qBAAtD;AAcA,WAAM,SAAA,cAAA,CACF,UADE,EACmC,SADnC,EAC6D;;AACjE,YAAM,gBAA6B,EAAnC;;AACA,iBAAiC,IAAA,KAAA,QAAA,QAAA,CAAA,WAAW,gBAAX,CAA4B,SAA5B,CAAA,EAAqC,KAAA,GAAA,IAAA,EAAtE,EAAsE,CAAA,GAAA,IAAtE,EAAsE,KAAA,GAAA,IAAA,EAAtE,EAAwE;AAA7D,oBAAA,KAAA,GAAA,KAAA;AAAA,oBAAC,WAAA,GAAA,QAAD;AAAA,oBAAW,SAAA,GAAA,MAAX;AACT,oBAAI,eAAe,SAAS,KAAxB,MAAmC,UAAU,MAAjD,EAAyD;AACvD,wBAAM,eAAe,qBAAqB,SAAS,QAA9B,CAArB;;AACA,6BAAoB,IAAA,iBAAA,QAAA,QAAA,CAAA,YAAA,CAAA,EAAY,mBAAA,eAAA,IAAA,EAAhC,EAAgC,CAAA,iBAAA,IAAhC,EAAgC,mBAAA,eAAA,IAAA,EAAhC,EAAkC;AAA7B,gCAAM,QAAK,iBAAA,KAAX;AACH,0CAAc,IAAd,CAAmB,eAAe,KAAf,EAAsB,SAAtB,EAAiC,OAAO,SAAxC,CAAnB;AACD;;;;;;;;;;AACF;AACF;;;;;;;;;;AACD,eAAO,aAAP;AACD;AAED,aAAA,oBAAA,CAA8B,MAA9B,EAAgE,MAAhE,EAAqF;AAArB,YAAA,WAAA,KAAA,CAAA,EAAA;AAAA,qBAAA,EAAA;AAAqB;;AACnF,YAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,mBAAO,IAAP,CAAY,MAAZ;AACD,SAFD,MAEO,IAAI,MAAM,OAAN,CAAc,MAAd,CAAJ,EAA2B;;AAChC,qBAAoB,IAAA,WAAA,QAAA,QAAA,CAAA,MAAA,CAAA,EAAM,aAAA,SAAA,IAAA,EAA1B,EAA0B,CAAA,WAAA,IAA1B,EAA0B,aAAA,SAAA,IAAA,EAA1B,EAA4B;AAAvB,wBAAM,QAAK,WAAA,KAAX;AACH,yCAAqB,KAArB,EAA4B,MAA5B;AACD;;;;;;;;;;AACF,SAJM,MAIA,IAAI,OAAO,YAAX,EAAyB;AAC9B,iCAAqB,OAAO,YAA5B,EAA0C,MAA1C;AACD,SAFM,MAEA,IAAI,OAAO,QAAX,EAAqB;AAC1B,iCAAqB,OAAO,QAA5B,EAAsC,MAAtC;AACD;AACD,eAAO,MAAP;AACD;AAED,WAAM,SAAA,cAAA,CACF,KADE,EACa,SADb,EACyC,MADzC,EAC8D;AAC5D,YAAA,KAAA,QAAA,MAAA,CAAA,MAAA,KAAA,CAAA,GAAA,CAAA,EAAA,CAAA,CAAA;AAAA,YAAC,YAAA,GAAA,CAAA,CAAD;AAAA,YAAY,YAAA,GAAA,CAAA,CAAZ;AACN,YAAM,mBAAmB,UAAU,wBAAV,CACrB;AACE,wBAAY,SADd;AAEE,kBAAM;AAFR,SADqB,EAKrB,SAAS,OAAO,QAAhB,GAA2B,SALN,CAAzB;AAMA,eAAO,EAAC,OAAO,KAAR,EAAe,QAAQ,UAAU,gBAAjC,EAAmD,kBAAgB,gBAAnE,EAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileNgModuleMetadata, tokenReference} from '../compile_metadata';\nimport {Route} from '../core';\nimport {CompileMetadataResolver} from '../metadata_resolver';\n\nimport {AotCompilerHost} from './compiler_host';\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\n\nexport interface LazyRoute {\n  module: StaticSymbol;\n  route: string;\n  referencedModule: StaticSymbol;\n}\n\nexport function listLazyRoutes(\n    moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[] {\n  const allLazyRoutes: LazyRoute[] = [];\n  for (const {provider, module} of moduleMeta.transitiveModule.providers) {\n    if (tokenReference(provider.token) === reflector.ROUTES) {\n      const loadChildren = _collectLoadChildren(provider.useValue);\n      for (const route of loadChildren) {\n        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n      }\n    }\n  }\n  return allLazyRoutes;\n}\n\nfunction _collectLoadChildren(routes: string | Route | Route[], target: string[] = []): string[] {\n  if (typeof routes === 'string') {\n    target.push(routes);\n  } else if (Array.isArray(routes)) {\n    for (const route of routes) {\n      _collectLoadChildren(route, target);\n    }\n  } else if (routes.loadChildren) {\n    _collectLoadChildren(routes.loadChildren, target);\n  } else if (routes.children) {\n    _collectLoadChildren(routes.children, target);\n  }\n  return target;\n}\n\nexport function parseLazyRoute(\n    route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute {\n  const [routePath, routeName] = route.split('#');\n  const referencedModule = reflector.resolveExternalReference(\n      {\n        moduleName: routePath,\n        name: routeName,\n      },\n      module ? module.filePath : undefined);\n  return {route: route, module: module || referencedModule, referencedModule};\n}\n"],"sourceRoot":""}