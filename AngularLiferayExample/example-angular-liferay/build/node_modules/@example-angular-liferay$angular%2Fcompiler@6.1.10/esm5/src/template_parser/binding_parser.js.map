{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\n\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  getUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEvents);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig) !;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  // Parse an inline template binding. ie `<tag *tplKey=\"<tplValue>\">`\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[],\n      targetVars: ParsedVariable[]) {\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);\n\n    for (let i = 0; i < bindings.length; i++) {\n      const binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n\n  private _parseTemplateBindings(tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]): boolean {\n    const expr = this.parseInterpolation(value, sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(expression || 'undefined', false, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan));\n  }\n\n  private _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  createBoundElementProperty(elementSelector: string, boundProp: ParsedProperty):\n      BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined !;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined !;\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = BindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan);\n  }\n\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, targetEvents: ParsedEvent[]) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(\n              new ParsedEvent(eventName, phase, ParsedEventType.Animation, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null !, name]);\n    const ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([name !, ast.source !]);\n    targetEvents.push(new ParsedEvent(eventName, target, ParsedEventType.Regular, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n\n    try {\n      const ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName !.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg !, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n"],"sourceRoot":""}