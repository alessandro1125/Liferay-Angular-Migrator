{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, BuiltinConverter, EventHandlerVars, LocalResolver, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder | null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName | StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {context: this.component, value: input.value} as Expression\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null !;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter:\n                (keys: {key: string, quoted: boolean}[]) => (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"],"sourceRoot":""}