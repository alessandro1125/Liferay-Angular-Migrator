{"version":3,"sources":["../../../../../../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n// Closure variables holding messages must be named `MSG_[A-Z0-9]+`\nconst TRANSLATION_PREFIX = 'MSG_';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Closure uses `goog.getMsg(message)` to lookup translations\n */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared !: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private translations = new Map<string, o.Expression>();\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  // Generates closure specific code for translation.\n  //\n  // ```\n  // /**\n  //  * @desc description?\n  //  * @meaning meaning?\n  //  */\n  // const MSG_XYZ = goog.getMsg('message');\n  // ```\n  getTranslation(message: string, meta: {description?: string, meaning?: string}): o.Expression {\n    // The identity of an i18n message depends on the message and its meaning\n    const key = meta.meaning ? `${message}\\u0000\\u0000${meta.meaning}` : message;\n\n    const exp = this.translations.get(key);\n\n    if (exp) {\n      return exp;\n    }\n\n    const docStmt = i18nMetaToDocStmt(meta);\n    if (docStmt) {\n      this.statements.push(docStmt);\n    }\n\n    // Call closure to get the translation\n    const variable = o.variable(this.freshTranslationName());\n    const fnCall = o.variable(GOOG_GET_MSG).callFn([o.literal(message)]);\n    const msgStmt = variable.set(fnCall).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]);\n    this.statements.push(msgStmt);\n\n    this.translations.set(key, variable);\n    return variable;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private freshTranslationName(): string {\n    return this.uniqueName(TRANSLATION_PREFIX).toUpperCase();\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) { return `VAR:${node.name}`; }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\n// Converts i18n meta informations for a message (description, meaning) to a JsDoc statement\n// formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta: {description?: string, id?: string, meaning?: string}):\n    o.JSDocCommentStmt|null {\n  const tags: o.JSDocTag[] = [];\n\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  }\n\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n\n  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n}\n"],"sourceRoot":""}