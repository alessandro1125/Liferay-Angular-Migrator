{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/output/abstract_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext { return new EmitterVisitorContext(0); }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) { this._lines = [new _EmittedLine(_indent)]; }\n\n  private get _currentLine(): _EmittedLine { return this._lines[this._lines.length - 1]; }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean { return this._currentLine.parts.length === 0; }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) { this._classes.push(clazz); }\n\n  popClass(): o.ClassStmt { return this._classes.pop() !; }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx] !;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) { return this._preambleLineCount = count; }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.multiline) {\n      ctx.println(stmt, `/* ${stmt.comment} */`);\n    } else {\n      stmt.comment.split('\\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });\n    }\n    return null;\n  }\n  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n    ctx.println(stmt, `/*${stmt.toString()}*/`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name !;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name !;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name !;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase !.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n"],"sourceRoot":""}