{"version":3,"sources":["../../../../../../../../../../packages/compiler/src/ml_parser/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from './tags';\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(public type: TokenType, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    tokenizeExpansionForms: boolean = false,\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): TokenizeResult {\n  return new _Tokenizer(\n             new ParseSourceFile(source, url), getTagDefinition, tokenizeExpansionForms,\n             interpolationConfig)\n      .tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass _Tokenizer {\n  private _input: string;\n  private _length: number;\n  // Note: this is always lowercase!\n  private _peek: number = -1;\n  private _nextPeek: number = -1;\n  private _index: number = -1;\n  private _line: number = 0;\n  private _column: number = -1;\n  // TODO(issue/24571): remove '!'.\n  private _currentTokenStart !: ParseLocation;\n  // TODO(issue/24571): remove '!'.\n  private _currentTokenType !: TokenType;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source\n   * @param _getTagDefinition\n   * @param _tokenizeIcu Whether to tokenize ICU messages (considered as text nodes when false)\n   * @param _interpolationConfig\n   */\n  constructor(\n      private _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      private _tokenizeIcu: boolean,\n      private _interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\n    this._input = _file.content;\n    this._length = _file.content.length;\n    this._advance();\n  }\n\n  private _processCarriageReturns(content: string): string {\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._peek !== chars.$EOF) {\n      const start = this._getLocation();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        if (e instanceof _ControlFlowError) {\n          this.errors.push(e.error);\n        } else {\n          throw e;\n        }\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._peek) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._peek === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getLocation(): ParseLocation {\n    return new ParseLocation(this._file, this._index, this._line, this._column);\n  }\n\n  private _getSpan(\n      start: ParseLocation = this._getLocation(),\n      end: ParseLocation = this._getLocation()): ParseSourceSpan {\n    return new ParseSourceSpan(start, end);\n  }\n\n  private _beginToken(type: TokenType, start: ParseLocation = this._getLocation()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end: ParseLocation = this._getLocation()): Token {\n    const token =\n        new Token(this._currentTokenType, parts, new ParseSourceSpan(this._currentTokenStart, end));\n    this.tokens.push(token);\n    this._currentTokenStart = null !;\n    this._currentTokenType = null !;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null !;\n    this._currentTokenType = null !;\n    return new _ControlFlowError(error);\n  }\n\n  private _advance() {\n    if (this._index >= this._length) {\n      throw this._createError(_unexpectedCharacterErrorMsg(chars.$EOF), this._getSpan());\n    }\n    if (this._peek === chars.$LF) {\n      this._line++;\n      this._column = 0;\n    } else if (this._peek !== chars.$LF && this._peek !== chars.$CR) {\n      this._column++;\n    }\n    this._index++;\n    this._peek = this._index >= this._length ? chars.$EOF : this._input.charCodeAt(this._index);\n    this._nextPeek =\n        this._index + 1 >= this._length ? chars.$EOF : this._input.charCodeAt(this._index + 1);\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._peek === charCode) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._peek, charCode)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._getLocation();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._peek), this._getSpan(location, location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._index + len > this._length) {\n      return false;\n    }\n    const initialPosition = this._savePosition();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._restorePosition(initialPosition);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._getLocation();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._peek)) {\n      this._advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._getLocation();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._index - start.offset < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._peek), this._getSpan(start, start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._peek !== char) {\n      this._advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._peek === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      const index = this._index;\n      this._advance();\n      return this._input[index];\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._getLocation();\n    this._advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const numberStart = this._getLocation().offset;\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._peek != chars.$SEMICOLON) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      this._advance();\n      const strNum = this._input.substring(numberStart, this._index - 1);\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch (e) {\n        const entity = this._input.substring(start.offset + 1, this._index - 1);\n        throw this._createError(_unknownEntityErrorMsg(entity), this._getSpan(start));\n      }\n    } else {\n      const startPosition = this._savePosition();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._peek != chars.$SEMICOLON) {\n        this._restorePosition(startPosition);\n        return '&';\n      }\n      this._advance();\n      const name = this._input.substring(start.offset + 1, this._index - 1);\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(\n      decodeEntities: boolean, firstCharOfEnd: number, attemptEndRest: () => boolean): Token {\n    let tagCloseStart: ParseLocation;\n    const textStart = this._getLocation();\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT, textStart);\n    const parts: string[] = [];\n    while (true) {\n      tagCloseStart = this._getLocation();\n      if (this._attemptCharCode(firstCharOfEnd) && attemptEndRest()) {\n        break;\n      }\n      if (this._index > tagCloseStart.offset) {\n        // add the characters consumed by the previous if statement to the output\n        parts.push(this._input.substring(tagCloseStart.offset, this._index));\n      }\n      while (this._peek !== firstCharOfEnd) {\n        parts.push(this._readChar(decodeEntities));\n      }\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(''))], tagCloseStart);\n  }\n\n  private _consumeComment(start: ParseLocation) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$MINUS, () => this._attemptStr('->'));\n    this._beginToken(TokenType.COMMENT_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: ParseLocation) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    const textToken = this._consumeRawText(false, chars.$RBRACKET, () => this._attemptStr(']>'));\n    this._beginToken(TokenType.CDATA_END, textToken.sourceSpan.end);\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: ParseLocation) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    this._attemptUntilChar(chars.$GT);\n    this._advance();\n    this._endToken([this._input.substring(start.offset + 2, this._index - 1)]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._index;\n    let prefix: string = null !;\n    while (this._peek !== chars.$COLON && !isPrefixEnd(this._peek)) {\n      this._advance();\n    }\n    let nameStart: number;\n    if (this._peek === chars.$COLON) {\n      this._advance();\n      prefix = this._input.substring(nameOrPrefixStart, this._index - 1);\n      nameStart = this._index;\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, this._index === nameStart ? 1 : 0);\n    const name = this._input.substring(nameStart, this._index);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: ParseLocation) {\n    const savedPos = this._savePosition();\n    let tagName: string;\n    let lowercaseTagName: string;\n    try {\n      if (!chars.isAsciiLetter(this._peek)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._peek), this._getSpan());\n      }\n      const nameStart = this._index;\n      this._consumeTagOpenStart(start);\n      tagName = this._input.substring(nameStart, this._index);\n      lowercaseTagName = tagName.toLowerCase();\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._peek !== chars.$SLASH && this._peek !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        // When the start tag is invalid, assume we want a \"<\"\n        this._restorePosition(savedPos);\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken(['<']);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(lowercaseTagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(lowercaseTagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, chars.$LT, () => {\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(lowercaseTagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE, textToken.sourceSpan.end);\n    this._endToken([null !, lowercaseTagName]);\n  }\n\n  private _consumeTagOpenStart(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    this._beginToken(TokenType.ATTR_VALUE);\n    let value: string;\n    if (this._peek === chars.$SQ || this._peek === chars.$DQ) {\n      const quoteChar = this._peek;\n      this._advance();\n      const parts: string[] = [];\n      while (this._peek !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join('');\n      this._advance();\n    } else {\n      const valueStart = this._index;\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._input.substring(valueStart, this._index);\n    }\n    this._endToken([this._processCarriageReturns(value)]);\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: ParseLocation) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT, this._getLocation());\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type], this._getLocation());\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE, this._getLocation());\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START, this._getLocation());\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([], this._getLocation());\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END, this._getLocation());\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._getLocation();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n          this._interpolationConfig && this._inInterpolation &&\n          this._attemptStr(this._interpolationConfig.end)) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._peek === chars.$LT || this._peek === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (isExpansionFormStart(this._input, this._index, this._interpolationConfig)) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._peek === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _savePosition(): [number, number, number, number, number] {\n    return [this._peek, this._index, this._column, this._line, this.tokens.length];\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._index;\n    this._attemptUntilChar(char);\n    return this._input.substring(start, this._index);\n  }\n\n  private _restorePosition(position: [number, number, number, number, number]): void {\n    this._peek = position[0];\n    this._index = position[1];\n    this._column = position[2];\n    this._line = position[3];\n    const nbTokens = position[4];\n    if (nbTokens < this.tokens.length) {\n      // remove any extra tokens\n      this.tokens = this.tokens.slice(0, nbTokens);\n    }\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH ||\n      code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionFormStart(\n    input: string, offset: number, interpolationConfig: InterpolationConfig): boolean {\n  const isInterpolationStart =\n      interpolationConfig ? input.indexOf(interpolationConfig.start, offset) == offset : false;\n\n  return input.charCodeAt(offset) == chars.$LBRACE && !isInterpolationStart;\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n"],"sourceRoot":""}