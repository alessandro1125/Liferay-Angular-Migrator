{"version":3,"sources":["../../../../../../packages/compiler/src/ast_path.ts"],"names":[],"mappings":";;;;;;;;;AAQA;;;;;;;;;;;;;;;;;AAiBA,WAAM,MAAA,OAAA,CAAA;AACJ,oBAAoB,IAApB,EAAsC,WAAmB,CAAC,CAA1D,EAA2D;AAAvC,iBAAA,IAAA,GAAA,IAAA;AAAkB,iBAAA,QAAA,GAAA,QAAA;AAAyB;AAE/D,YAAI,KAAJ,GAAS;AAAc,mBAAO,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,IAAL,CAAU,MAAhC;AAAyC;AAChE,YAAI,IAAJ,GAAQ;AAAkB,mBAAO,KAAK,IAAL,CAAU,CAAV,CAAP;AAAsB;AAChD,YAAI,IAAJ,GAAQ;AAAkB,mBAAO,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAP;AAAyC;AAEnE,iBAAS,IAAT,EAA0B;AACxB,mBAAO,QAAQ,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,IAA0B,CAApC,CAAf;AACD;AACD,gBAAQ,IAAR,EAAe;AAAiB,mBAAO,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,IAA0B,CAApC,CAAP;AAAgD;AAEhF,cAAmB,IAAnB,EAAkD;AAChD,iBAAK,IAAI,IAAI,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAhC,EAAmC,KAAK,CAAxC,EAA2C,GAA3C,EAAgD;AAC9C,oBAAI,OAAO,KAAK,IAAL,CAAU,CAAV,CAAX;AACA,oBAAI,gBAAgB,IAApB,EAA0B,OAAU,IAAV;AAC3B;AACF;AAED,aAAK,IAAL,EAAY;AAAI,iBAAK,IAAL,CAAU,IAAV,CAAe,IAAf;AAAuB;AAEvC,cAAG;AAAQ,mBAAO,KAAK,IAAL,CAAU,GAAV,EAAP;AAA2B;AArBlC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nexport class AstPath<T> {\n  constructor(private path: T[], public position: number = -1) {}\n\n  get empty(): boolean { return !this.path || !this.path.length; }\n  get head(): T|undefined { return this.path[0]; }\n  get tail(): T|undefined { return this.path[this.path.length - 1]; }\n\n  parentOf(node: T|undefined): T|undefined {\n    return node && this.path[this.path.indexOf(node) - 1];\n  }\n  childOf(node: T): T|undefined { return this.path[this.path.indexOf(node) + 1]; }\n\n  first<N extends T>(ctor: {new (...args: any[]): N}): N|undefined {\n    for (let i = this.path.length - 1; i >= 0; i--) {\n      let item = this.path[i];\n      if (item instanceof ctor) return <N>item;\n    }\n  }\n\n  push(node: T) { this.path.push(node); }\n\n  pop(): T { return this.path.pop() !; }\n}\n"],"sourceRoot":""}