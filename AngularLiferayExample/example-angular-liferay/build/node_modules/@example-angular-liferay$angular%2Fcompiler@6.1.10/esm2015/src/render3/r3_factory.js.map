{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {unsupported} from './view/util';\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3FactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the function (or constructor) which will instantiate the requested\n   * type.\n   *\n   * This could be a reference to a constructor type, or to a user-defined factory function. The\n   * `useNew` property determines whether it will be called as a constructor or not.\n   */\n  fnOrClass: o.Expression;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters.\n   */\n  deps: R3DependencyMetadata[];\n\n  /**\n   * Whether to interpret `fnOrClass` as a constructor function (`useNew: true`) or as a factory\n   * (`useNew: false`).\n   */\n  useNew: boolean;\n\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n}\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n\n  /**\n   * The dependency is for the `Injector` type itself.\n   */\n  Injector = 2,\n\n  /**\n   * The dependency is for `ElementRef`.\n   */\n  ElementRef = 3,\n\n  /**\n   * The dependency is for `TemplateRef`.\n   */\n  TemplateRef = 4,\n\n  /**\n   * The dependency is for `ViewContainerRef`.\n   */\n  ViewContainerRef = 5,\n\n  /**\n   * The dependency is for `ChangeDetectorRef`.\n   */\n  ChangeDetectorRef = 6,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): o.Expression {\n  // Each dependency becomes an invocation of an inject*() function.\n  const args = meta.deps.map(dep => compileInjectDependency(dep, meta.injectFn));\n\n  // The overall result depends on whether this is construction or function invocation.\n  const expr = meta.useNew ? new o.InstantiateExpr(meta.fnOrClass, args) :\n                             new o.InvokeFunctionExpr(meta.fnOrClass, args);\n\n  return o.fn(\n      [], [new o.ReturnStatement(expr)], o.INFERRED_TYPE, undefined, `${meta.name}_Factory`);\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.Injector: {\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n      // Determine the token used for injection. In almost all cases this is the given token, but\n      // if the dependency is resolved to the `Injector` then the special `INJECTOR` token is used\n      // instead.\n      let token: o.Expression = dep.token;\n      if (dep.resolved === R3ResolvedDependencyType.Injector) {\n        token = o.importExpr(Identifiers.INJECTOR);\n      }\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [token];\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      if (flags !== InjectFlags.Default || dep.optional) {\n        injectArgs.push(o.literal(flags));\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    }\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    case R3ResolvedDependencyType.ElementRef:\n      return o.importExpr(R3.injectElementRef).callFn([]);\n    case R3ResolvedDependencyType.TemplateRef:\n      return o.importExpr(R3.injectTemplateRef).callFn([]);\n    case R3ResolvedDependencyType.ViewContainerRef:\n      return o.importExpr(R3.injectViewContainerRef).callFn([]);\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      return o.importExpr(R3.injectChangeDetectorRef).callFn([]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const elementRef = reflector.resolveExternalReference(Identifiers.ElementRef);\n  const templateRef = reflector.resolveExternalReference(Identifiers.TemplateRef);\n  const viewContainerRef = reflector.resolveExternalReference(Identifiers.ViewContainerRef);\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = R3ResolvedDependencyType.Token;\n      if (tokenRef === elementRef) {\n        resolved = R3ResolvedDependencyType.ElementRef;\n      } else if (tokenRef === templateRef) {\n        resolved = R3ResolvedDependencyType.TemplateRef;\n      } else if (tokenRef === viewContainerRef) {\n        resolved = R3ResolvedDependencyType.ViewContainerRef;\n      } else if (tokenRef === injectorRef) {\n        resolved = R3ResolvedDependencyType.Injector;\n      } else if (dependency.isAttribute) {\n        resolved = R3ResolvedDependencyType.Attribute;\n      }\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n"],"sourceRoot":""}