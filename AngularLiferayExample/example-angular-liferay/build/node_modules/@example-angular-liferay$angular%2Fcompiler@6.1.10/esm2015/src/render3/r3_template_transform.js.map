{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_template_transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParsedEvent, ParsedProperty, ParsedVariable, ParserError} from '../expression_parser/ast';\nimport * as html from '../ml_parser/ast';\nimport {replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {isNgTemplate} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {PreparsedElementType, preparseElement} from '../template_parser/template_preparser';\nimport {syntaxError} from '../util';\nimport * as t from './r3_ast';\n\n\nconst BIND_NAME_REGEXP =\n    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst IDENT_EVENT_IDX = 10;\n\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst CLASS_ATTR = 'class';\n// Default selector used by `<ng-content>` if none specified\nconst DEFAULT_CONTENT_SELECTOR = '*';\n\n// Result of the html AST to Ivy AST transformation\nexport type Render3ParseResult = {\n  nodes: t.Node[]; errors: ParseError[];\n  // Any non default (empty or '*') selector found in the template\n  ngContentSelectors: string[];\n  // Wether the template contains any `<ng-content>`\n  hasNgContent: boolean;\n};\n\nexport function htmlAstToRender3Ast(\n    htmlNodes: html.Node[], bindingParser: BindingParser): Render3ParseResult {\n  const transformer = new HtmlAstToIvyAst(bindingParser);\n  const ivyNodes = html.visitAll(transformer, htmlNodes);\n\n  // Errors might originate in either the binding parser or the html to ivy transformer\n  const allErrors = bindingParser.errors.concat(transformer.errors);\n  const errors: ParseError[] = allErrors.filter(e => e.level === ParseErrorLevel.ERROR);\n\n  if (errors.length > 0) {\n    const errorString = errors.join('\\n');\n    throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\n  }\n\n  return {\n    nodes: ivyNodes,\n    errors: allErrors,\n    ngContentSelectors: transformer.ngContentSelectors,\n    hasNgContent: transformer.hasNgContent,\n  };\n}\n\nclass HtmlAstToIvyAst implements html.Visitor {\n  errors: ParseError[] = [];\n  // Selectors for the `ng-content` tags. Only non `*` selectors are recorded here\n  ngContentSelectors: string[] = [];\n  // Any `<ng-content>` in the template ?\n  hasNgContent = false;\n\n  constructor(private bindingParser: BindingParser) {}\n\n  // HTML visitor\n  visitElement(element: html.Element): t.Node|null {\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE) {\n      // Skipping <script> for security reasons\n      // Skipping <style> as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n    if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      // Skipping stylesheets with either relative urls or package scheme as we already processed\n      // them in the StyleCompiler\n      return null;\n    }\n\n    // Whether the element is a `<ng-template>`\n    const isTemplateElement = isNgTemplate(element.name);\n\n    const matchableAttributes: [string, string][] = [];\n    const parsedProperties: ParsedProperty[] = [];\n    const boundEvents: t.BoundEvent[] = [];\n    const variables: t.Variable[] = [];\n    const references: t.Reference[] = [];\n    const attributes: t.TextAttribute[] = [];\n\n    const templateMatchableAttributes: [string, string][] = [];\n    let inlineTemplateSourceSpan: ParseSourceSpan;\n    const templateParsedProperties: ParsedProperty[] = [];\n    const templateVariables: t.Variable[] = [];\n\n    // Whether the element has any *-attribute\n    let elementHasInlineTemplate = false;\n\n    for (const attribute of element.attrs) {\n      let hasBinding = false;\n      const normalizedName = normalizeAttributeName(attribute.name);\n\n      // `*attr` defines template bindings\n      let isTemplateBinding = false;\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        if (elementHasInlineTemplate) {\n          this.reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attribute.sourceSpan);\n        }\n        isTemplateBinding = true;\n        elementHasInlineTemplate = true;\n        const templateValue = attribute.value;\n        const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n\n        inlineTemplateSourceSpan = attribute.valueSpan || attribute.sourceSpan;\n\n        const parsedVariables: ParsedVariable[] = [];\n        this.bindingParser.parseInlineTemplateBinding(\n            templateKey, templateValue, attribute.sourceSpan, templateMatchableAttributes,\n            templateParsedProperties, parsedVariables);\n        templateVariables.push(\n            ...parsedVariables.map(v => new t.Variable(v.name, v.value, v.sourceSpan)));\n      } else {\n        // Check for variables, events, property bindings, interpolation\n        hasBinding = this.parseAttribute(\n            isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents,\n            variables, references);\n      }\n\n      if (!hasBinding && !isTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attributes.push(this.visitAttribute(attribute) as t.TextAttribute);\n        matchableAttributes.push([attribute.name, attribute.value]);\n      }\n    }\n\n    const children: t.Node[] =\n        html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children);\n\n    let parsedElement: t.Node|undefined;\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>`\n      this.hasNgContent = true;\n\n      if (element.children && !element.children.every(isEmptyTextNode)) {\n        this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n      }\n\n      const selector = preparsedElement.selectAttr;\n\n      let attributes: t.TextAttribute[] = element.attrs.map(attribute => {\n        return new t.TextAttribute(\n            attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan);\n      });\n\n      const selectorIndex =\n          selector === DEFAULT_CONTENT_SELECTOR ? 0 : this.ngContentSelectors.push(selector);\n      parsedElement = new t.Content(selectorIndex, attributes, element.sourceSpan);\n    } else if (isTemplateElement) {\n      // `<ng-template>`\n      const boundAttributes = this.createBoundAttributes(element.name, parsedProperties);\n      parsedElement = new t.Template(\n          attributes, boundAttributes, children, references, variables, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan);\n    } else {\n      const boundAttributes = this.createBoundAttributes(element.name, parsedProperties);\n\n      parsedElement = new t.Element(\n          element.name, attributes, boundAttributes, boundEvents, children, references,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n\n    if (elementHasInlineTemplate) {\n      const attributes: t.TextAttribute[] = [];\n\n      templateMatchableAttributes.forEach(\n          ([name, value]) =>\n              attributes.push(new t.TextAttribute(name, value, inlineTemplateSourceSpan)));\n\n      const boundAttributes = this.createBoundAttributes('ng-template', templateParsedProperties);\n      parsedElement = new t.Template(\n          attributes, boundAttributes, [parsedElement], [], templateVariables, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan);\n    }\n    return parsedElement;\n  }\n\n  visitAttribute(attribute: html.Attribute): t.Node {\n    return new t.TextAttribute(\n        attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan);\n  }\n\n  visitText(text: html.Text): t.Node {\n    const valueNoNgsp = replaceNgsp(text.value);\n    const expr = this.bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n    return expr ? new t.BoundText(expr, text.sourceSpan) : new t.Text(valueNoNgsp, text.sourceSpan);\n  }\n\n  visitComment(comment: html.Comment): null { return null; }\n\n  visitExpansion(expansion: html.Expansion): null { return null; }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): null { return null; }\n\n  private createBoundAttributes(elementName: string, properties: ParsedProperty[]):\n      t.BoundAttribute[] {\n    return properties.filter(prop => !prop.isLiteral)\n        .map(prop => this.bindingParser.createBoundElementProperty(elementName, prop))\n        .map(prop => t.BoundAttribute.fromBoundElementProperty(prop));\n  }\n\n  private parseAttribute(\n      isTemplateElement: boolean, attribute: html.Attribute, matchableAttributes: string[][],\n      parsedProperties: ParsedProperty[], boundEvents: t.BoundEvent[], variables: t.Variable[],\n      references: t.Reference[]) {\n    const name = normalizeAttributeName(attribute.name);\n    const value = attribute.value;\n    const srcSpan = attribute.sourceSpan;\n\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    let hasBinding = false;\n\n    if (bindParts) {\n      hasBinding = true;\n      if (bindParts[KW_BIND_IDX] != null) {\n        this.bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          this.parseVariable(identifier, value, srcSpan, variables);\n        } else {\n          this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        this.parseReference(identifier, value, srcSpan, references);\n\n      } else if (bindParts[KW_ON_IDX]) {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, matchableAttributes, events);\n        addEvents(events, boundEvents);\n      } else if (bindParts[KW_BINDON_IDX]) {\n        this.bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, matchableAttributes, parsedProperties);\n        this.parseAssignmentEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, matchableAttributes, boundEvents);\n      } else if (bindParts[KW_AT_IDX]) {\n        this.bindingParser.parseLiteralAttr(\n            name, value, srcSpan, matchableAttributes, parsedProperties);\n\n      } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n        this.bindingParser.parsePropertyBinding(\n            bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, matchableAttributes,\n            parsedProperties);\n        this.parseAssignmentEvent(\n            bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, matchableAttributes, boundEvents);\n\n      } else if (bindParts[IDENT_PROPERTY_IDX]) {\n        this.bindingParser.parsePropertyBinding(\n            bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, matchableAttributes,\n            parsedProperties);\n\n      } else if (bindParts[IDENT_EVENT_IDX]) {\n        const events: ParsedEvent[] = [];\n        this.bindingParser.parseEvent(\n            bindParts[IDENT_EVENT_IDX], value, srcSpan, matchableAttributes, events);\n        addEvents(events, boundEvents);\n      }\n    } else {\n      hasBinding = this.bindingParser.parsePropertyInterpolation(\n          name, value, srcSpan, matchableAttributes, parsedProperties);\n    }\n\n    return hasBinding;\n  }\n\n  private parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, variables: t.Variable[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    }\n    variables.push(new t.Variable(identifier, value, sourceSpan));\n  }\n\n  private parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, references: t.Reference[]) {\n    if (identifier.indexOf('-') > -1) {\n      this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    }\n\n    references.push(new t.Reference(identifier, value, sourceSpan));\n  }\n\n  private parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], boundEvents: t.BoundEvent[]) {\n    const events: ParsedEvent[] = [];\n    this.bindingParser.parseEvent(\n        `${name}Change`, `${expression}=$event`, sourceSpan, targetMatchableAttrs, events);\n    addEvents(events, boundEvents);\n  }\n\n  private reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element): t.Element|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const children: t.Node[] = html.visitAll(this, ast.children, null);\n    return new t.Element(\n        ast.name, html.visitAll(this, ast.attrs) as t.TextAttribute[],\n        /* inputs */[], /* outputs */[], children,  /* references */[], ast.sourceSpan,\n        ast.startSourceSpan, ast.endSourceSpan);\n  }\n\n  visitComment(comment: html.Comment): any { return null; }\n\n  visitAttribute(attribute: html.Attribute): t.TextAttribute {\n    return new t.TextAttribute(attribute.name, attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text): t.Text { return new t.Text(text.value, text.sourceSpan); }\n\n  visitExpansion(expansion: html.Expansion): any { return null; }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase): any { return null; }\n}\n\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction normalizeAttributeName(attrName: string): string {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events: ParsedEvent[], boundEvents: t.BoundEvent[]) {\n  boundEvents.push(...events.map(e => t.BoundEvent.fromParsedEvent(e)));\n}\n\nfunction isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n"],"sourceRoot":""}