{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_module_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileShallowModuleMetadata, identifierName} from '../compile_metadata';\nimport {InjectableCompiler} from '../injectable_compiler';\nimport {mapLiteral} from '../output/map_util';\nimport * as o from '../output/output_ast';\nimport {OutputContext} from '../util';\n\nimport {R3DependencyMetadata, compileFactoryFunction} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {convertMetaToOutput, mapToMapExpression} from './util';\n\nexport interface R3NgModuleDef {\n  expression: o.Expression;\n  type: o.Type;\n  additionalStatements: o.Statement[];\n}\n\n/**\n * Metadata required by the module compiler to generate a `ngModuleDef` for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: o.Expression[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: o.Expression[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: o.Expression[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: o.Expression[];\n\n  /**\n   * Whether to emit the selector scope values (declarations, imports, exports) inline into the\n   * module definition, or to generate additional statements which patch them on. Inline emission\n   * does not allow components to be tree-shaken, but is useful for JIT mode.\n   */\n  emitInline: boolean;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n  const {type: moduleType, bootstrap, declarations, imports, exports} = meta;\n  const expression = o.importExpr(R3.defineNgModule).callFn([mapToMapExpression({\n    type: moduleType,\n    bootstrap: o.literalArr(bootstrap),\n    declarations: o.literalArr(declarations),\n    imports: o.literalArr(imports),\n    exports: o.literalArr(exports),\n  })]);\n\n  const type = new o.ExpressionType(o.importExpr(R3.NgModuleDef, [\n    new o.ExpressionType(moduleType), tupleTypeOf(declarations), tupleTypeOf(imports),\n    tupleTypeOf(exports)\n  ]));\n\n  const additionalStatements: o.Statement[] = [];\n  return {expression, type, additionalStatements};\n}\n\nexport interface R3InjectorDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: o.Expression;\n  deps: R3DependencyMetadata[];\n  providers: o.Expression;\n  imports: o.Expression;\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n  const expression = o.importExpr(R3.defineInjector).callFn([mapToMapExpression({\n    factory: compileFactoryFunction({\n      name: meta.name,\n      fnOrClass: meta.type,\n      deps: meta.deps,\n      useNew: true,\n      injectFn: R3.inject,\n    }),\n    providers: meta.providers,\n    imports: meta.imports,\n  })]);\n  const type =\n      new o.ExpressionType(o.importExpr(R3.InjectorDef, [new o.ExpressionType(meta.type)]));\n  return {expression, type};\n}\n\n// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\nexport function compileNgModuleFromRender2(\n    ctx: OutputContext, ngModule: CompileShallowModuleMetadata,\n    injectableCompiler: InjectableCompiler): void {\n  const className = identifierName(ngModule.type) !;\n\n  const rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n  const rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n\n  const injectorDefArg = mapLiteral({\n    'factory':\n        injectableCompiler.factoryFor({type: ngModule.type, symbol: ngModule.type.reference}, ctx),\n    'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n    'imports': convertMetaToOutput([...rawImports, ...rawExports], ctx),\n  });\n\n  const injectorDef = o.importExpr(R3.defineInjector).callFn([injectorDefArg]);\n\n  ctx.statements.push(new o.ClassStmt(\n      /* name */ className,\n      /* parent */ null,\n      /* fields */[new o.ClassField(\n          /* name */ 'ngInjectorDef',\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ injectorDef, )],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]));\n}\n\nfunction accessExportScope(module: o.Expression): o.Expression {\n  const selectorScope = new o.ReadPropExpr(module, 'ngModuleDef');\n  return new o.ReadPropExpr(selectorScope, 'exported');\n}\n\nfunction tupleTypeOf(exp: o.Expression[]): o.Type {\n  const types = exp.map(type => o.typeofExpr(type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}"],"sourceRoot":""}