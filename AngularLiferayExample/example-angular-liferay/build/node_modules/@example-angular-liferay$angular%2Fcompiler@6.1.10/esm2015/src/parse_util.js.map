{"version":3,"sources":["../../../../../../packages/compiler/src/parse_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {CompileIdentifierMetadata, identifierModuleUrl, identifierName} from './compile_metadata';\nimport {error} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  constructor(\n      public start: ParseLocation, public end: ParseLocation, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\nexport function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan {\n  const moduleUrl = identifierModuleUrl(type);\n  const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\n                                             `in ${kind} ${identifierName(type)}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n"],"sourceRoot":""}