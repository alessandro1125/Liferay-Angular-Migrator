{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler.ts"],"names":[],"mappings":";;;;;;;;;AASA,aAAqF,cAArF,QAA0G,oBAA1G;AAGA,aAAQ,WAAR,QAA0B,eAA1B;AACA,WAAO,KAAK,CAAZ,MAAmB,qBAAnB;AACA,aAAQ,uBAAR,QAAsC,qBAAtC;AAaA,aAAA,QAAA,CAAkB,GAAlB,EAA+B,KAA/B,EAAkD;AAChD,eAAO,EAAC,GAAD,EAAM,KAAN,EAAa,QAAQ,KAArB,EAAP;AACD;AAED,WAAM,MAAA,kBAAA,CAAA;AAEJ,oBAAoB,SAApB,EAAyD,iBAAzD,EAAmF;AAA/D,iBAAA,SAAA,GAAA,SAAA;AAAqC,iBAAA,iBAAA,GAAA,iBAAA;AACvD,iBAAK,aAAL,GAAqB,UAAU,wBAAV,CAAmC,YAAY,QAA/C,CAArB;AACD;AAEO,kBAAU,IAAV,EAAuB,GAAvB,EAAyC;AAC/C,mBAAO,KAAK,GAAL,CAAS,OAAM;AACpB,oBAAI,QAAQ,GAAZ;AACA,oBAAI,OAAO,CAAC,KAAD,CAAX;AACA,oBAAI,QAAK,CAAT,CAAS,aAAT;AACA,oBAAI,MAAM,OAAN,CAAc,GAAd,CAAJ,EAAwB;AACtB,yBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,IAAI,MAAxB,EAAgC,GAAhC,EAAqC;AACnC,8BAAM,IAAI,IAAI,CAAJ,CAAV;AACA,4BAAI,CAAJ,EAAO;AACL,gCAAI,EAAE,cAAF,KAAqB,UAAzB,EAAqC;AACnC,yCAAK,CAAL,CAAK,cAAL;AACD,6BAFD,MAEO,IAAI,EAAE,cAAF,KAAqB,UAAzB,EAAqC;AAC1C,yCAAK,CAAL,CAAK,cAAL;AACD,6BAFM,MAEA,IAAI,EAAE,cAAF,KAAqB,MAAzB,EAAiC;AACtC,yCAAK,CAAL,CAAK,UAAL;AACD,6BAFM,MAEA,IAAI,EAAE,cAAF,KAAqB,QAAzB,EAAmC;AACxC,wCAAQ,EAAE,KAAV;AACD,6BAFM,MAEA;AACL,wCAAQ,CAAR;AACD;AACF;AACF;AACF;AAED,oBAAI,SAAJ;AACA,oBAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,gCAAY,EAAE,OAAF,CAAU,KAAV,CAAZ;AACD,iBAFD,MAEO,IAAI,UAAU,KAAK,aAAnB,EAAkC;AACvC,gCAAY,EAAE,UAAF,CAAa,YAAY,QAAzB,CAAZ;AACD,iBAFM,MAEA;AACL,gCAAY,IAAI,UAAJ,CAAe,KAAf,CAAZ;AACD;AAED,oBAAI,UAAK,CAAT,CAAS,aAAT,EAAmC;AACjC,+BAAO,CAAC,SAAD,EAAY,EAAE,OAAF,CAAU,KAAV,CAAZ,CAAP;AACD,qBAFD,MAEO;AACL,2BAAO,CAAC,SAAD,CAAP;AACD;AACD,uBAAO,EAAE,UAAF,CAAa,YAAY,MAAzB,EAAiC,MAAjC,CAAwC,IAAxC,CAAP;AACD,aAtCM,CAAP;AAuCD;AAED,mBAAW,UAAX,EAAkD,GAAlD,EAAoE;AAClE,gBAAI,QAAJ;AACA,gBAAI,WAAW,WAAf,EAA4B;AAC1B,2BAAW,EAAE,UAAF,CAAa,YAAY,MAAzB,EAAiC,MAAjC,CAAwC,CAAC,IAAI,UAAJ,CAAe,WAAW,WAA1B,CAAD,CAAxC,CAAX;AACD,aAFD,MAEO,IAAI,WAAW,UAAf,EAA2B;AAChC,sBAAM,OAAO,WAAW,IAAX,IAAmB,EAAhC;AACA,oBAAI,KAAK,MAAL,GAAc,CAAlB,EAAqB;AACnB,+BAAW,IAAI,UAAJ,CAAe,WAAW,UAA1B,EAAsC,MAAtC,CAA6C,KAAK,SAAL,CAAe,IAAf,EAAqB,GAArB,CAA7C,CAAX;AACD,iBAFD,MAEO;AACL,2BAAO,IAAI,UAAJ,CAAe,WAAW,UAA1B,CAAP;AACD;AACF,aAPM,MAOA,IAAI,WAAW,QAAf,EAAyB;AAC9B,2BAAW,wBAAwB,GAAxB,EAA6B,WAAW,QAAxC,CAAX;AACD,aAFM,MAEA;AACL,sBAAM,QAAQ,WAAW,QAAX,IAAuB,WAAW,MAAhD;AACA,sBAAM,UAAU,KAAK,SAAL,CAAe,KAAK,SAAL,CAAe,UAAf,CAA0B,KAA1B,CAAf,EAAiD,GAAjD,CAAhB;AACA,2BAAW,IAAI,EAAE,eAAN,CAAsB,IAAI,UAAJ,CAAe,KAAf,CAAtB,EAA6C,OAA7C,CAAX;AACD;AACD,mBAAO,EAAE,EAAF,CACH,EADG,EACC,CAAC,IAAI,EAAE,eAAN,CAAsB,QAAtB,CAAD,CADD,EACoC,SADpC,EAC+C,SAD/C,EAEH,WAAW,MAAX,CAAkB,IAAlB,GAAyB,UAFtB,CAAP;AAGD;AAED,sBAAc,UAAd,EAAqD,GAArD,EAAuE;AACrE,gBAAI,aAA2B,EAAE,SAAjC;AACA,gBAAI,WAAW,UAAX,KAA0B,SAA9B,EAAyC;AACvC,oBAAI,WAAW,UAAX,KAA0B,IAA9B,EAAoC;AAClC,iCAAa,EAAE,SAAf;AACD,iBAFD,MAEO,IAAI,OAAO,WAAW,UAAlB,KAAiC,QAArC,EAA+C;AACpD,iCAAa,EAAE,OAAF,CAAU,WAAW,UAArB,CAAb;AACD,iBAFM,MAEA;AACL,iCAAa,IAAI,UAAJ,CAAe,WAAW,UAA1B,CAAb;AACD;AACF;AACD,kBAAM,MAAkB,CACtB,SAAS,SAAT,EAAoB,KAAK,UAAL,CAAgB,UAAhB,EAA4B,GAA5B,CAApB,CADsB,EAEtB,SAAS,OAAT,EAAkB,IAAI,UAAJ,CAAe,WAAW,IAAX,CAAgB,SAA/B,CAAlB,CAFsB,EAGtB,SAAS,YAAT,EAAuB,UAAvB,CAHsB,CAAxB;AAKA,mBAAO,EAAE,UAAF,CAAa,YAAY,gBAAzB,EAA2C,MAA3C,CAAkD,CAAC,EAAE,UAAF,CAAa,GAAb,CAAD,CAAlD,CAAP;AACD;AAED,gBAAQ,UAAR,EAA+C,GAA/C,EAAiE;AAC/D,gBAAI,KAAK,iBAAL,IAA0B,WAAW,UAAX,KAA0B,SAAxD,EAAmE;AACjE,sBAAM,YAAY,eAAe,WAAW,IAA1B,CAAlB;AACA,sBAAM,QAAQ,IAAI,EAAE,SAAN,CACV,SADU,EACC,IADD,EAEV,CACE,IAAI,EAAE,UAAN,CACI,iBADJ,EACuB,EAAE,aADzB,EACwC,CAAC,EAAE,YAAF,CAAe,MAAhB,CADxC,EAEI,KAAK,aAAL,CAAmB,UAAnB,EAA+B,GAA/B,CAFJ,CADF,CAFU,EAOV,EAPU,EAON,IAAI,EAAE,WAAN,CAAkB,IAAlB,EAAwB,EAAxB,EAA4B,EAA5B,CAPM,EAO2B,EAP3B,CAAd;AAQA,oBAAI,UAAJ,CAAe,IAAf,CAAoB,KAApB;AACD;AACF;AAvGG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {CompileInjectableMetadata, CompileNgModuleMetadata, CompileProviderMetadata, identifierName} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {InjectFlags, NodeFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {convertValueToOutputAst} from './output/value_util';\nimport {typeSourceSpan} from './parse_util';\nimport {NgModuleProviderAnalyzer} from './provider_analyzer';\nimport {OutputContext} from './util';\nimport {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n\ntype MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\ntype MapLiteral = MapEntry[];\n\nfunction mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport class InjectableCompiler {\n  private tokenInjector: StaticSymbol;\n  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n  }\n\n  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n    return deps.map(dep => {\n      let token = dep;\n      let args = [token];\n      let flags: InjectFlags = InjectFlags.Default;\n      if (Array.isArray(dep)) {\n        for (let i = 0; i < dep.length; i++) {\n          const v = dep[i];\n          if (v) {\n            if (v.ngMetadataName === 'Optional') {\n              flags |= InjectFlags.Optional;\n            } else if (v.ngMetadataName === 'SkipSelf') {\n              flags |= InjectFlags.SkipSelf;\n            } else if (v.ngMetadataName === 'Self') {\n              flags |= InjectFlags.Self;\n            } else if (v.ngMetadataName === 'Inject') {\n              token = v.token;\n            } else {\n              token = v;\n            }\n          }\n        }\n      }\n\n      let tokenExpr: o.Expression;\n      if (typeof token === 'string') {\n        tokenExpr = o.literal(token);\n      } else if (token === this.tokenInjector) {\n        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n      } else {\n        tokenExpr = ctx.importExpr(token);\n      }\n\n      if (flags !== InjectFlags.Default) {\n        args = [tokenExpr, o.literal(flags)];\n      } else {\n        args = [tokenExpr];\n      }\n      return o.importExpr(Identifiers.inject).callFn(args);\n    });\n  }\n\n  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let retValue: o.Expression;\n    if (injectable.useExisting) {\n      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n    } else if (injectable.useFactory) {\n      const deps = injectable.deps || [];\n      if (deps.length > 0) {\n        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n      } else {\n        return ctx.importExpr(injectable.useFactory);\n      }\n    } else if (injectable.useValue) {\n      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n    } else {\n      const clazz = injectable.useClass || injectable.symbol;\n      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n    }\n    return o.fn(\n        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n        injectable.symbol.name + '_Factory');\n  }\n\n  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let providedIn: o.Expression = o.NULL_EXPR;\n    if (injectable.providedIn !== undefined) {\n      if (injectable.providedIn === null) {\n        providedIn = o.NULL_EXPR;\n      } else if (typeof injectable.providedIn === 'string') {\n        providedIn = o.literal(injectable.providedIn);\n      } else {\n        providedIn = ctx.importExpr(injectable.providedIn);\n      }\n    }\n    const def: MapLiteral = [\n      mapEntry('factory', this.factoryFor(injectable, ctx)),\n      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n      mapEntry('providedIn', providedIn),\n    ];\n    return o.importExpr(Identifiers.defineInjectable).callFn([o.literalMap(def)]);\n  }\n\n  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n      const className = identifierName(injectable.type) !;\n      const clazz = new o.ClassStmt(\n          className, null,\n          [\n            new o.ClassField(\n                'ngInjectableDef', o.INFERRED_TYPE, [o.StmtModifier.Static],\n                this.injectableDef(injectable, ctx)),\n          ],\n          [], new o.ClassMethod(null, [], []), []);\n      ctx.statements.push(clazz);\n    }\n  }\n}\n"],"sourceRoot":""}