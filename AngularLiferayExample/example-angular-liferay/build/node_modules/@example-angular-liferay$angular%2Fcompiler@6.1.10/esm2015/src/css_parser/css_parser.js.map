{"version":3,"sources":["../../../../../../../packages/compiler/src/css_parser/css_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {BlockType, CssAst, CssAtRulePredicateAst, CssBlockAst, CssBlockDefinitionRuleAst, CssBlockRuleAst, CssDefinitionAst, CssInlineRuleAst, CssKeyframeDefinitionAst, CssKeyframeRuleAst, CssMediaQueryRuleAst, CssPseudoSelectorAst, CssRuleAst, CssSelectorAst, CssSelectorRuleAst, CssSimpleSelectorAst, CssStyleSheetAst, CssStyleValueAst, CssStylesBlockAst, CssUnknownRuleAst, CssUnknownTokenListAst, mergeTokens} from './css_ast';\nimport {CssLexer, CssLexerMode, CssScanner, CssToken, CssTokenType, generateErrorMessage, getRawMessage, isNewline} from './css_lexer';\n\nconst SPACE_OPERATOR = ' ';\n\nexport {CssToken} from './css_lexer';\nexport {BlockType} from './css_ast';\n\nconst SLASH_CHARACTER = '/';\nconst GT_CHARACTER = '>';\nconst TRIPLE_GT_OPERATOR_STR = '>>>';\nconst DEEP_OPERATOR_STR = '/deep/';\n\nconst EOF_DELIM_FLAG = 1;\nconst RBRACE_DELIM_FLAG = 2;\nconst LBRACE_DELIM_FLAG = 4;\nconst COMMA_DELIM_FLAG = 8;\nconst COLON_DELIM_FLAG = 16;\nconst SEMICOLON_DELIM_FLAG = 32;\nconst NEWLINE_DELIM_FLAG = 64;\nconst RPAREN_DELIM_FLAG = 128;\nconst LPAREN_DELIM_FLAG = 256;\nconst SPACE_DELIM_FLAG = 512;\n\nfunction _pseudoSelectorSupportsInnerSelectors(name: string): boolean {\n  return ['not', 'host', 'host-context'].indexOf(name) >= 0;\n}\n\nfunction isSelectorOperatorCharacter(code: number): boolean {\n  switch (code) {\n    case chars.$SLASH:\n    case chars.$TILDA:\n    case chars.$PLUS:\n    case chars.$GT:\n      return true;\n    default:\n      return chars.isWhitespace(code);\n  }\n}\n\nfunction getDelimFromCharacter(code: number): number {\n  switch (code) {\n    case chars.$EOF:\n      return EOF_DELIM_FLAG;\n    case chars.$COMMA:\n      return COMMA_DELIM_FLAG;\n    case chars.$COLON:\n      return COLON_DELIM_FLAG;\n    case chars.$SEMICOLON:\n      return SEMICOLON_DELIM_FLAG;\n    case chars.$RBRACE:\n      return RBRACE_DELIM_FLAG;\n    case chars.$LBRACE:\n      return LBRACE_DELIM_FLAG;\n    case chars.$RPAREN:\n      return RPAREN_DELIM_FLAG;\n    case chars.$SPACE:\n    case chars.$TAB:\n      return SPACE_DELIM_FLAG;\n    default:\n      return isNewline(code) ? NEWLINE_DELIM_FLAG : 0;\n  }\n}\n\nfunction characterContainsDelimiter(code: number, delimiters: number): boolean {\n  return (getDelimFromCharacter(code) & delimiters) > 0;\n}\n\nexport class ParsedCssResult {\n  constructor(public errors: CssParseError[], public ast: CssStyleSheetAst) {}\n}\n\nexport class CssParser {\n  private _errors: CssParseError[] = [];\n  // TODO(issue/24571): remove '!'.\n  private _file !: ParseSourceFile;\n  // TODO(issue/24571): remove '!'.\n  private _scanner !: CssScanner;\n  // TODO(issue/24571): remove '!'.\n  private _lastToken !: CssToken;\n\n  /**\n   * @param css the CSS code that will be parsed\n   * @param url the name of the CSS file containing the CSS source code\n   */\n  parse(css: string, url: string): ParsedCssResult {\n    const lexer = new CssLexer();\n    this._file = new ParseSourceFile(css, url);\n    this._scanner = lexer.scan(css, false);\n\n    const ast = this._parseStyleSheet(EOF_DELIM_FLAG);\n\n    const errors = this._errors;\n    this._errors = [];\n\n    const result = new ParsedCssResult(errors, ast);\n    this._file = null as any;\n    this._scanner = null as any;\n    return result;\n  }\n\n  /** @internal */\n  _parseStyleSheet(delimiters: number): CssStyleSheetAst {\n    const results: CssRuleAst[] = [];\n    this._scanner.consumeEmptyStatements();\n    while (this._scanner.peek != chars.$EOF) {\n      this._scanner.setMode(CssLexerMode.BLOCK);\n      results.push(this._parseRule(delimiters));\n    }\n    let span: ParseSourceSpan|null = null;\n    if (results.length > 0) {\n      const firstRule = results[0];\n      // we collect the last token like so incase there was an\n      // EOF token that was emitted sometime during the lexing\n      span = this._generateSourceSpan(firstRule, this._lastToken);\n    }\n    return new CssStyleSheetAst(span !, results);\n  }\n\n  /** @internal */\n  _getSourceContent(): string { return this._scanner != null ? this._scanner.input : ''; }\n\n  /** @internal */\n  _extractSourceContent(start: number, end: number): string {\n    return this._getSourceContent().substring(start, end + 1);\n  }\n\n  /** @internal */\n  _generateSourceSpan(start: CssToken|CssAst, end: CssToken|CssAst|null = null): ParseSourceSpan {\n    let startLoc: ParseLocation;\n    if (start instanceof CssAst) {\n      startLoc = start.location.start;\n    } else {\n      let token = start;\n      if (token == null) {\n        // the data here is invalid, however, if and when this does\n        // occur, any other errors associated with this will be collected\n        token = this._lastToken;\n      }\n      startLoc = new ParseLocation(this._file, token.index, token.line, token.column);\n    }\n\n    if (end == null) {\n      end = this._lastToken;\n    }\n\n    let endLine: number = -1;\n    let endColumn: number = -1;\n    let endIndex: number = -1;\n    if (end instanceof CssAst) {\n      endLine = end.location.end.line !;\n      endColumn = end.location.end.col !;\n      endIndex = end.location.end.offset !;\n    } else if (end instanceof CssToken) {\n      endLine = end.line;\n      endColumn = end.column;\n      endIndex = end.index;\n    }\n\n    const endLoc = new ParseLocation(this._file, endIndex, endLine, endColumn);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n\n  /** @internal */\n  _resolveBlockType(token: CssToken): BlockType {\n    switch (token.strValue) {\n      case '@-o-keyframes':\n      case '@-moz-keyframes':\n      case '@-webkit-keyframes':\n      case '@keyframes':\n        return BlockType.Keyframes;\n\n      case '@charset':\n        return BlockType.Charset;\n\n      case '@import':\n        return BlockType.Import;\n\n      case '@namespace':\n        return BlockType.Namespace;\n\n      case '@page':\n        return BlockType.Page;\n\n      case '@document':\n        return BlockType.Document;\n\n      case '@media':\n        return BlockType.MediaQuery;\n\n      case '@font-face':\n        return BlockType.FontFace;\n\n      case '@viewport':\n        return BlockType.Viewport;\n\n      case '@supports':\n        return BlockType.Supports;\n\n      default:\n        return BlockType.Unsupported;\n    }\n  }\n\n  /** @internal */\n  _parseRule(delimiters: number): CssRuleAst {\n    if (this._scanner.peek == chars.$AT) {\n      return this._parseAtRule(delimiters);\n    }\n    return this._parseSelectorRule(delimiters);\n  }\n\n  /** @internal */\n  _parseAtRule(delimiters: number): CssRuleAst {\n    const start = this._getScannerIndex();\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    const token = this._scan();\n    const startToken = token;\n\n    this._assertCondition(\n        token.type == CssTokenType.AtKeyword,\n        `The CSS Rule ${token.strValue} is not a valid [@] rule.`, token);\n\n    let block: CssBlockAst;\n    const type = this._resolveBlockType(token);\n    let span: ParseSourceSpan;\n    let tokens: CssToken[];\n    let endToken: CssToken;\n    let end: number;\n    let strValue: string;\n    let query: CssAtRulePredicateAst;\n    switch (type) {\n      case BlockType.Charset:\n      case BlockType.Namespace:\n      case BlockType.Import:\n        let value = this._parseValue(delimiters);\n        this._scanner.setMode(CssLexerMode.BLOCK);\n        this._scanner.consumeEmptyStatements();\n        span = this._generateSourceSpan(startToken, value);\n        return new CssInlineRuleAst(span, type, value);\n\n      case BlockType.Viewport:\n      case BlockType.FontFace:\n        block = this._parseStyleBlock(delimiters) !;\n        span = this._generateSourceSpan(startToken, block);\n        return new CssBlockRuleAst(span, type, block);\n\n      case BlockType.Keyframes:\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        // keyframes only have one identifier name\n        let name = tokens[0];\n        block = this._parseKeyframeBlock(delimiters);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssKeyframeRuleAst(span, name, block);\n\n      case BlockType.MediaQuery:\n        this._scanner.setMode(CssLexerMode.MEDIA_QUERY);\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        endToken = tokens[tokens.length - 1];\n        // we do not track the whitespace after the mediaQuery predicate ends\n        // so we have to calculate the end string value on our own\n        end = endToken.index + endToken.strValue.length - 1;\n        strValue = this._extractSourceContent(start, end);\n        span = this._generateSourceSpan(startToken, endToken);\n        query = new CssAtRulePredicateAst(span, strValue, tokens);\n        block = this._parseBlock(delimiters);\n        strValue = this._extractSourceContent(start, this._getScannerIndex() - 1);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssMediaQueryRuleAst(span, strValue, query, block);\n\n      case BlockType.Document:\n      case BlockType.Supports:\n      case BlockType.Page:\n        this._scanner.setMode(CssLexerMode.AT_RULE_QUERY);\n        tokens = this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG);\n        endToken = tokens[tokens.length - 1];\n        // we do not track the whitespace after this block rule predicate ends\n        // so we have to calculate the end string value on our own\n        end = endToken.index + endToken.strValue.length - 1;\n        strValue = this._extractSourceContent(start, end);\n        span = this._generateSourceSpan(startToken, tokens[tokens.length - 1]);\n        query = new CssAtRulePredicateAst(span, strValue, tokens);\n        block = this._parseBlock(delimiters);\n        strValue = this._extractSourceContent(start, block.end.offset !);\n        span = this._generateSourceSpan(startToken, block);\n        return new CssBlockDefinitionRuleAst(span, strValue, type, query, block);\n\n      // if a custom @rule { ... } is used it should still tokenize the insides\n      default:\n        let listOfTokens: CssToken[] = [];\n        let tokenName = token.strValue;\n        this._scanner.setMode(CssLexerMode.ALL);\n        this._error(\n            generateErrorMessage(\n                this._getSourceContent(),\n                `The CSS \"at\" rule \"${tokenName}\" is not allowed to used here`, token.strValue,\n                token.index, token.line, token.column),\n            token);\n\n        this._collectUntilDelim(delimiters | LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG)\n            .forEach((token) => { listOfTokens.push(token); });\n        if (this._scanner.peek == chars.$LBRACE) {\n          listOfTokens.push(this._consume(CssTokenType.Character, '{'));\n          this._collectUntilDelim(delimiters | RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG)\n              .forEach((token) => { listOfTokens.push(token); });\n          listOfTokens.push(this._consume(CssTokenType.Character, '}'));\n        }\n        endToken = listOfTokens[listOfTokens.length - 1];\n        span = this._generateSourceSpan(startToken, endToken);\n        return new CssUnknownRuleAst(span, tokenName, listOfTokens);\n    }\n  }\n\n  /** @internal */\n  _parseSelectorRule(delimiters: number): CssRuleAst {\n    const start = this._getScannerIndex();\n    const selectors = this._parseSelectors(delimiters);\n    const block = this._parseStyleBlock(delimiters);\n    let ruleAst: CssRuleAst;\n    let span: ParseSourceSpan;\n    const startSelector = selectors[0];\n    if (block != null) {\n      span = this._generateSourceSpan(startSelector, block);\n      ruleAst = new CssSelectorRuleAst(span, selectors, block);\n    } else {\n      const name = this._extractSourceContent(start, this._getScannerIndex() - 1);\n      const innerTokens: CssToken[] = [];\n      selectors.forEach((selector: CssSelectorAst) => {\n        selector.selectorParts.forEach((part: CssSimpleSelectorAst) => {\n          part.tokens.forEach((token: CssToken) => { innerTokens.push(token); });\n        });\n      });\n      const endToken = innerTokens[innerTokens.length - 1];\n      span = this._generateSourceSpan(startSelector, endToken);\n      ruleAst = new CssUnknownTokenListAst(span, name, innerTokens);\n    }\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    this._scanner.consumeEmptyStatements();\n    return ruleAst;\n  }\n\n  /** @internal */\n  _parseSelectors(delimiters: number): CssSelectorAst[] {\n    delimiters |= LBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG;\n\n    const selectors: CssSelectorAst[] = [];\n    let isParsingSelectors = true;\n    while (isParsingSelectors) {\n      selectors.push(this._parseSelector(delimiters));\n\n      isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n\n      if (isParsingSelectors) {\n        this._consume(CssTokenType.Character, ',');\n        isParsingSelectors = !characterContainsDelimiter(this._scanner.peek, delimiters);\n        if (isParsingSelectors) {\n          this._scanner.consumeWhitespace();\n        }\n      }\n    }\n\n    return selectors;\n  }\n\n  /** @internal */\n  _scan(): CssToken {\n    const output = this._scanner.scan() !;\n    const token = output.token;\n    const error = output.error;\n    if (error != null) {\n      this._error(getRawMessage(error), token);\n    }\n    this._lastToken = token;\n    return token;\n  }\n\n  /** @internal */\n  _getScannerIndex(): number { return this._scanner.index; }\n\n  /** @internal */\n  _consume(type: CssTokenType, value: string|null = null): CssToken {\n    const output = this._scanner.consume(type, value);\n    const token = output.token;\n    const error = output.error;\n    if (error != null) {\n      this._error(getRawMessage(error), token);\n    }\n    this._lastToken = token;\n    return token;\n  }\n\n  /** @internal */\n  _parseKeyframeBlock(delimiters: number): CssBlockAst {\n    delimiters |= RBRACE_DELIM_FLAG;\n    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n\n    const definitions: CssKeyframeDefinitionAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      definitions.push(this._parseKeyframeDefinition(delimiters));\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssBlockAst(span, definitions);\n  }\n\n  /** @internal */\n  _parseKeyframeDefinition(delimiters: number): CssKeyframeDefinitionAst {\n    const start = this._getScannerIndex();\n    const stepTokens: CssToken[] = [];\n    delimiters |= LBRACE_DELIM_FLAG;\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      stepTokens.push(this._parseKeyframeLabel(delimiters | COMMA_DELIM_FLAG));\n      if (this._scanner.peek != chars.$LBRACE) {\n        this._consume(CssTokenType.Character, ',');\n      }\n    }\n    const stylesBlock = this._parseStyleBlock(delimiters | RBRACE_DELIM_FLAG);\n    const span = this._generateSourceSpan(stepTokens[0], stylesBlock);\n    const ast = new CssKeyframeDefinitionAst(span, stepTokens, stylesBlock !);\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    return ast;\n  }\n\n  /** @internal */\n  _parseKeyframeLabel(delimiters: number): CssToken {\n    this._scanner.setMode(CssLexerMode.KEYFRAME_BLOCK);\n    return mergeTokens(this._collectUntilDelim(delimiters));\n  }\n\n  /** @internal */\n  _parsePseudoSelector(delimiters: number): CssPseudoSelectorAst {\n    const start = this._getScannerIndex();\n\n    delimiters &= ~COMMA_DELIM_FLAG;\n\n    // we keep the original value since we may use it to recurse when :not, :host are used\n    const startingDelims = delimiters;\n\n    const startToken = this._consume(CssTokenType.Character, ':');\n    const tokens = [startToken];\n\n    if (this._scanner.peek == chars.$COLON) {  // ::something\n      tokens.push(this._consume(CssTokenType.Character, ':'));\n    }\n\n    const innerSelectors: CssSelectorAst[] = [];\n\n    this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR);\n\n    // host, host-context, lang, not, nth-child are all identifiers\n    const pseudoSelectorToken = this._consume(CssTokenType.Identifier);\n    const pseudoSelectorName = pseudoSelectorToken.strValue;\n    tokens.push(pseudoSelectorToken);\n\n    // host(), lang(), nth-child(), etc...\n    if (this._scanner.peek == chars.$LPAREN) {\n      this._scanner.setMode(CssLexerMode.PSEUDO_SELECTOR_WITH_ARGUMENTS);\n\n      const openParenToken = this._consume(CssTokenType.Character, '(');\n      tokens.push(openParenToken);\n\n      // :host(innerSelector(s)), :not(selector), etc...\n      if (_pseudoSelectorSupportsInnerSelectors(pseudoSelectorName)) {\n        let innerDelims = startingDelims | LPAREN_DELIM_FLAG | RPAREN_DELIM_FLAG;\n        if (pseudoSelectorName == 'not') {\n          // the inner selector inside of :not(...) can only be one\n          // CSS selector (no commas allowed) ... This is according\n          // to the CSS specification\n          innerDelims |= COMMA_DELIM_FLAG;\n        }\n\n        // :host(a, b, c) {\n        this._parseSelectors(innerDelims).forEach((selector, index) => {\n          innerSelectors.push(selector);\n        });\n      } else {\n        // this branch is for things like \"en-us, 2k + 1, etc...\"\n        // which all end up in pseudoSelectors like :lang, :nth-child, etc..\n        const innerValueDelims = delimiters | LBRACE_DELIM_FLAG | COLON_DELIM_FLAG |\n            RPAREN_DELIM_FLAG | LPAREN_DELIM_FLAG;\n        while (!characterContainsDelimiter(this._scanner.peek, innerValueDelims)) {\n          const token = this._scan();\n          tokens.push(token);\n        }\n      }\n\n      const closeParenToken = this._consume(CssTokenType.Character, ')');\n      tokens.push(closeParenToken);\n    }\n\n    const end = this._getScannerIndex() - 1;\n    const strValue = this._extractSourceContent(start, end);\n\n    const endToken = tokens[tokens.length - 1];\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssPseudoSelectorAst(span, strValue, pseudoSelectorName, tokens, innerSelectors);\n  }\n\n  /** @internal */\n  _parseSimpleSelector(delimiters: number): CssSimpleSelectorAst {\n    const start = this._getScannerIndex();\n\n    delimiters |= COMMA_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.SELECTOR);\n    const selectorCssTokens: CssToken[] = [];\n    const pseudoSelectors: CssPseudoSelectorAst[] = [];\n\n    let previousToken: CssToken = undefined !;\n\n    const selectorPartDelimiters = delimiters | SPACE_DELIM_FLAG;\n    let loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n\n    let hasAttributeError = false;\n    while (loopOverSelector) {\n      const peek = this._scanner.peek;\n\n      switch (peek) {\n        case chars.$COLON:\n          let innerPseudo = this._parsePseudoSelector(delimiters);\n          pseudoSelectors.push(innerPseudo);\n          this._scanner.setMode(CssLexerMode.SELECTOR);\n          break;\n\n        case chars.$LBRACKET:\n          // we set the mode after the scan because attribute mode does not\n          // allow attribute [] values. And this also will catch any errors\n          // if an extra \"[\" is used inside.\n          selectorCssTokens.push(this._scan());\n          this._scanner.setMode(CssLexerMode.ATTRIBUTE_SELECTOR);\n          break;\n\n        case chars.$RBRACKET:\n          if (this._scanner.getMode() != CssLexerMode.ATTRIBUTE_SELECTOR) {\n            hasAttributeError = true;\n          }\n          // we set the mode early because attribute mode does not\n          // allow attribute [] values\n          this._scanner.setMode(CssLexerMode.SELECTOR);\n          selectorCssTokens.push(this._scan());\n          break;\n\n        default:\n          if (isSelectorOperatorCharacter(peek)) {\n            loopOverSelector = false;\n            continue;\n          }\n\n          let token = this._scan();\n          previousToken = token;\n          selectorCssTokens.push(token);\n          break;\n      }\n\n      loopOverSelector = !characterContainsDelimiter(this._scanner.peek, selectorPartDelimiters);\n    }\n\n    hasAttributeError =\n        hasAttributeError || this._scanner.getMode() == CssLexerMode.ATTRIBUTE_SELECTOR;\n    if (hasAttributeError) {\n      this._error(\n          `Unbalanced CSS attribute selector at column ${previousToken.line}:${previousToken.column}`,\n          previousToken);\n    }\n\n    let end = this._getScannerIndex() - 1;\n\n    // this happens if the selector is not directly followed by\n    // a comma or curly brace without a space in between\n    let operator: CssToken|null = null;\n    let operatorScanCount = 0;\n    let lastOperatorToken: CssToken|null = null;\n    if (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      while (operator == null && !characterContainsDelimiter(this._scanner.peek, delimiters) &&\n             isSelectorOperatorCharacter(this._scanner.peek)) {\n        let token = this._scan();\n        const tokenOperator = token.strValue;\n        operatorScanCount++;\n        lastOperatorToken = token;\n        if (tokenOperator != SPACE_OPERATOR) {\n          switch (tokenOperator) {\n            case SLASH_CHARACTER:\n              // /deep/ operator\n              let deepToken = this._consume(CssTokenType.Identifier);\n              let deepSlash = this._consume(CssTokenType.Character);\n              let index = lastOperatorToken.index;\n              let line = lastOperatorToken.line;\n              let column = lastOperatorToken.column;\n              if (deepToken != null && deepToken.strValue.toLowerCase() == 'deep' &&\n                  deepSlash.strValue == SLASH_CHARACTER) {\n                token = new CssToken(\n                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n                    CssTokenType.Identifier, DEEP_OPERATOR_STR);\n              } else {\n                const text = SLASH_CHARACTER + deepToken.strValue + deepSlash.strValue;\n                this._error(\n                    generateErrorMessage(\n                        this._getSourceContent(), `${text} is an invalid CSS operator`, text, index,\n                        line, column),\n                    lastOperatorToken);\n                token = new CssToken(index, column, line, CssTokenType.Invalid, text);\n              }\n              break;\n\n            case GT_CHARACTER:\n              // >>> operator\n              if (this._scanner.peek == chars.$GT && this._scanner.peekPeek == chars.$GT) {\n                this._consume(CssTokenType.Character, GT_CHARACTER);\n                this._consume(CssTokenType.Character, GT_CHARACTER);\n                token = new CssToken(\n                    lastOperatorToken.index, lastOperatorToken.column, lastOperatorToken.line,\n                    CssTokenType.Identifier, TRIPLE_GT_OPERATOR_STR);\n              }\n              break;\n          }\n\n          operator = token;\n        }\n      }\n\n      // so long as there is an operator then we can have an\n      // ending value that is beyond the selector value ...\n      // otherwise it's just a bunch of trailing whitespace\n      if (operator != null) {\n        end = operator.index;\n      }\n    }\n\n    this._scanner.consumeWhitespace();\n\n    const strValue = this._extractSourceContent(start, end);\n\n    // if we do come across one or more spaces inside of\n    // the operators loop then an empty space is still a\n    // valid operator to use if something else was not found\n    if (operator == null && operatorScanCount > 0 && this._scanner.peek != chars.$LBRACE) {\n      operator = lastOperatorToken;\n    }\n\n    // please note that `endToken` is reassigned multiple times below\n    // so please do not optimize the if statements into if/elseif\n    let startTokenOrAst: CssToken|CssAst|null = null;\n    let endTokenOrAst: CssToken|CssAst|null = null;\n    if (selectorCssTokens.length > 0) {\n      startTokenOrAst = startTokenOrAst || selectorCssTokens[0];\n      endTokenOrAst = selectorCssTokens[selectorCssTokens.length - 1];\n    }\n    if (pseudoSelectors.length > 0) {\n      startTokenOrAst = startTokenOrAst || pseudoSelectors[0];\n      endTokenOrAst = pseudoSelectors[pseudoSelectors.length - 1];\n    }\n    if (operator != null) {\n      startTokenOrAst = startTokenOrAst || operator;\n      endTokenOrAst = operator;\n    }\n\n    const span = this._generateSourceSpan(startTokenOrAst !, endTokenOrAst);\n    return new CssSimpleSelectorAst(span, selectorCssTokens, strValue, pseudoSelectors, operator !);\n  }\n\n  /** @internal */\n  _parseSelector(delimiters: number): CssSelectorAst {\n    delimiters |= COMMA_DELIM_FLAG;\n    this._scanner.setMode(CssLexerMode.SELECTOR);\n\n    const simpleSelectors: CssSimpleSelectorAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      simpleSelectors.push(this._parseSimpleSelector(delimiters));\n      this._scanner.consumeWhitespace();\n    }\n\n    const firstSelector = simpleSelectors[0];\n    const lastSelector = simpleSelectors[simpleSelectors.length - 1];\n    const span = this._generateSourceSpan(firstSelector, lastSelector);\n    return new CssSelectorAst(span, simpleSelectors);\n  }\n\n  /** @internal */\n  _parseValue(delimiters: number): CssStyleValueAst {\n    delimiters |= RBRACE_DELIM_FLAG | SEMICOLON_DELIM_FLAG | NEWLINE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n    const start = this._getScannerIndex();\n\n    const tokens: CssToken[] = [];\n    let wsStr = '';\n    let previous: CssToken = undefined !;\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      let token: CssToken;\n      if (previous != null && previous.type == CssTokenType.Identifier &&\n          this._scanner.peek == chars.$LPAREN) {\n        token = this._consume(CssTokenType.Character, '(');\n        tokens.push(token);\n\n        this._scanner.setMode(CssLexerMode.STYLE_VALUE_FUNCTION);\n\n        token = this._scan();\n        tokens.push(token);\n\n        this._scanner.setMode(CssLexerMode.STYLE_VALUE);\n\n        token = this._consume(CssTokenType.Character, ')');\n        tokens.push(token);\n      } else {\n        token = this._scan();\n        if (token.type == CssTokenType.Whitespace) {\n          wsStr += token.strValue;\n        } else {\n          wsStr = '';\n          tokens.push(token);\n        }\n      }\n      previous = token;\n    }\n\n    const end = this._getScannerIndex() - 1;\n    this._scanner.consumeWhitespace();\n\n    const code = this._scanner.peek;\n    if (code == chars.$SEMICOLON) {\n      this._consume(CssTokenType.Character, ';');\n    } else if (code != chars.$RBRACE) {\n      this._error(\n          generateErrorMessage(\n              this._getSourceContent(), `The CSS key/value definition did not end with a semicolon`,\n              previous.strValue, previous.index, previous.line, previous.column),\n          previous);\n    }\n\n    const strValue = this._extractSourceContent(start, end);\n    const startToken = tokens[0];\n    const endToken = tokens[tokens.length - 1];\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssStyleValueAst(span, tokens, strValue);\n  }\n\n  /** @internal */\n  _collectUntilDelim(delimiters: number, assertType: CssTokenType|null = null): CssToken[] {\n    const tokens: CssToken[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      const val = assertType != null ? this._consume(assertType) : this._scan();\n      tokens.push(val);\n    }\n    return tokens;\n  }\n\n  /** @internal */\n  _parseBlock(delimiters: number): CssBlockAst {\n    delimiters |= RBRACE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n    this._scanner.consumeEmptyStatements();\n\n    const results: CssRuleAst[] = [];\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      results.push(this._parseRule(delimiters));\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    this._scanner.setMode(CssLexerMode.BLOCK);\n    this._scanner.consumeEmptyStatements();\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssBlockAst(span, results);\n  }\n\n  /** @internal */\n  _parseStyleBlock(delimiters: number): CssStylesBlockAst|null {\n    delimiters |= RBRACE_DELIM_FLAG | LBRACE_DELIM_FLAG;\n\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n\n    const startToken = this._consume(CssTokenType.Character, '{');\n    if (startToken.numValue != chars.$LBRACE) {\n      return null;\n    }\n\n    const definitions: CssDefinitionAst[] = [];\n    this._scanner.consumeEmptyStatements();\n\n    while (!characterContainsDelimiter(this._scanner.peek, delimiters)) {\n      definitions.push(this._parseDefinition(delimiters));\n      this._scanner.consumeEmptyStatements();\n    }\n\n    const endToken = this._consume(CssTokenType.Character, '}');\n\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n    this._scanner.consumeEmptyStatements();\n\n    const span = this._generateSourceSpan(startToken, endToken);\n    return new CssStylesBlockAst(span, definitions);\n  }\n\n  /** @internal */\n  _parseDefinition(delimiters: number): CssDefinitionAst {\n    this._scanner.setMode(CssLexerMode.STYLE_BLOCK);\n\n    let prop = this._consume(CssTokenType.Identifier);\n    let parseValue: boolean = false;\n    let value: CssStyleValueAst|null = null;\n    let endToken: CssToken|CssStyleValueAst = prop;\n\n    // the colon value separates the prop from the style.\n    // there are a few cases as to what could happen if it\n    // is missing\n    switch (this._scanner.peek) {\n      case chars.$SEMICOLON:\n      case chars.$RBRACE:\n      case chars.$EOF:\n        parseValue = false;\n        break;\n\n      default:\n        let propStr = [prop.strValue];\n        if (this._scanner.peek != chars.$COLON) {\n          // this will throw the error\n          const nextValue = this._consume(CssTokenType.Character, ':');\n          propStr.push(nextValue.strValue);\n\n          const remainingTokens = this._collectUntilDelim(\n              delimiters | COLON_DELIM_FLAG | SEMICOLON_DELIM_FLAG, CssTokenType.Identifier);\n          if (remainingTokens.length > 0) {\n            remainingTokens.forEach((token) => { propStr.push(token.strValue); });\n          }\n\n          endToken = prop =\n              new CssToken(prop.index, prop.column, prop.line, prop.type, propStr.join(' '));\n        }\n\n        // this means we've reached the end of the definition and/or block\n        if (this._scanner.peek == chars.$COLON) {\n          this._consume(CssTokenType.Character, ':');\n          parseValue = true;\n        }\n        break;\n    }\n\n    if (parseValue) {\n      value = this._parseValue(delimiters);\n      endToken = value;\n    } else {\n      this._error(\n          generateErrorMessage(\n              this._getSourceContent(), `The CSS property was not paired with a style value`,\n              prop.strValue, prop.index, prop.line, prop.column),\n          prop);\n    }\n\n    const span = this._generateSourceSpan(prop, endToken);\n    return new CssDefinitionAst(span, prop, value !);\n  }\n\n  /** @internal */\n  _assertCondition(status: boolean, errorMessage: string, problemToken: CssToken): boolean {\n    if (!status) {\n      this._error(errorMessage, problemToken);\n      return true;\n    }\n    return false;\n  }\n\n  /** @internal */\n  _error(message: string, problemToken: CssToken) {\n    const length = problemToken.strValue.length;\n    const error = CssParseError.create(\n        this._file, 0, problemToken.line, problemToken.column, length, message);\n    this._errors.push(error);\n  }\n}\n\nexport class CssParseError extends ParseError {\n  static create(\n      file: ParseSourceFile, offset: number, line: number, col: number, length: number,\n      errMsg: string): CssParseError {\n    const start = new ParseLocation(file, offset, line, col);\n    const end = new ParseLocation(file, offset, line, col + length);\n    const span = new ParseSourceSpan(start, end);\n    return new CssParseError(span, 'CSS Parse Error: ' + errMsg);\n  }\n\n  constructor(span: ParseSourceSpan, message: string) { super(span, message); }\n}\n"],"sourceRoot":""}