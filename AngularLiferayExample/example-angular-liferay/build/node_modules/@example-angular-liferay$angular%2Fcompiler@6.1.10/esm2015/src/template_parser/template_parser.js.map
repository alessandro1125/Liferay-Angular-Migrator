{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/template_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTokenMetadata, CompileTypeMetadata, identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {CompilerConfig} from '../config';\nimport {SchemaMetadata} from '../core';\nimport {AST, ASTWithSource, EmptyExpr, ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {Identifiers, createTokenForExternalReference, createTokenForReference} from '../identifiers';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser, ParseTreeResult} from '../ml_parser/html_parser';\nimport {removeWhitespaces, replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {expandNodes} from '../ml_parser/icu_ast_expander';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {isNgTemplate, splitNsName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ProviderElementContext, ProviderViewContext} from '../provider_analyzer';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector, SelectorMatcher} from '../selector';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {Console, syntaxError} from '../util';\n\nimport {BindingParser} from './binding_parser';\nimport * as t from './template_ast';\nimport {PreparsedElementType, preparseElement} from './template_preparser';\n\nconst BIND_NAME_REGEXP =\n    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.+))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst IDENT_EVENT_IDX = 10;\n\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst CLASS_ATTR = 'class';\n\nlet _TEXT_CSS_SELECTOR !: CssSelector;\nfunction TEXT_CSS_SELECTOR(): CssSelector {\n  if (!_TEXT_CSS_SELECTOR) {\n    _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n  }\n  return _TEXT_CSS_SELECTOR;\n}\n\nexport class TemplateParseError extends ParseError {\n  constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel) {\n    super(span, message, level);\n  }\n}\n\nexport class TemplateParseResult {\n  constructor(\n      public templateAst?: t.TemplateAst[], public usedPipes?: CompilePipeSummary[],\n      public errors?: ParseError[]) {}\n}\n\nexport class TemplateParser {\n  constructor(\n      private _config: CompilerConfig, private _reflector: CompileReflector,\n      private _exprParser: Parser, private _schemaRegistry: ElementSchemaRegistry,\n      private _htmlParser: HtmlParser, private _console: Console,\n      public transforms: t.TemplateAstVisitor[]) {}\n\n  public get expressionParser() { return this._exprParser; }\n\n  parse(\n      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n      templateUrl: string,\n      preserveWhitespaces: boolean): {template: t.TemplateAst[], pipes: CompilePipeSummary[]} {\n    const result = this.tryParse(\n        component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n    const warnings = result.errors !.filter(error => error.level === ParseErrorLevel.WARNING);\n\n    const errors = result.errors !.filter(error => error.level === ParseErrorLevel.ERROR);\n\n    if (warnings.length > 0) {\n      this._console.warn(`Template parse warnings:\\n${warnings.join('\\n')}`);\n    }\n\n    if (errors.length > 0) {\n      const errorString = errors.join('\\n');\n      throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\n    }\n\n    return {template: result.templateAst !, pipes: result.usedPipes !};\n  }\n\n  tryParse(\n      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n      templateUrl: string, preserveWhitespaces: boolean): TemplateParseResult {\n    let htmlParseResult = typeof template === 'string' ?\n        this._htmlParser !.parse(\n            template, templateUrl, true, this.getInterpolationConfig(component)) :\n        template;\n\n    if (!preserveWhitespaces) {\n      htmlParseResult = removeWhitespaces(htmlParseResult);\n    }\n\n    return this.tryParseHtml(\n        this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n  }\n\n  tryParseHtml(\n      htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[],\n      schemas: SchemaMetadata[]): TemplateParseResult {\n    let result: t.TemplateAst[];\n    const errors = htmlAstWithErrors.errors;\n    const usedPipes: CompilePipeSummary[] = [];\n    if (htmlAstWithErrors.rootNodes.length > 0) {\n      const uniqDirectives = removeSummaryDuplicates(directives);\n      const uniqPipes = removeSummaryDuplicates(pipes);\n      const providerViewContext = new ProviderViewContext(this._reflector, component);\n      let interpolationConfig: InterpolationConfig = undefined !;\n      if (component.template && component.template.interpolation) {\n        interpolationConfig = {\n          start: component.template.interpolation[0],\n          end: component.template.interpolation[1]\n        };\n      }\n      const bindingParser = new BindingParser(\n          this._exprParser, interpolationConfig !, this._schemaRegistry, uniqPipes, errors);\n      const parseVisitor = new TemplateParseVisitor(\n          this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser,\n          this._schemaRegistry, schemas, errors);\n      result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n      errors.push(...providerViewContext.errors);\n      usedPipes.push(...bindingParser.getUsedPipes());\n    } else {\n      result = [];\n    }\n    this._assertNoReferenceDuplicationOnTemplate(result, errors);\n\n    if (errors.length > 0) {\n      return new TemplateParseResult(result, usedPipes, errors);\n    }\n\n    if (this.transforms) {\n      this.transforms.forEach(\n          (transform: t.TemplateAstVisitor) => { result = t.templateVisitAll(transform, result); });\n    }\n\n    return new TemplateParseResult(result, usedPipes, errors);\n  }\n\n  expandHtml(htmlAstWithErrors: ParseTreeResult, forced: boolean = false): ParseTreeResult {\n    const errors: ParseError[] = htmlAstWithErrors.errors;\n\n    if (errors.length == 0 || forced) {\n      // Transform ICU messages to angular directives\n      const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n      errors.push(...expandedHtmlAst.errors);\n      htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n    }\n    return htmlAstWithErrors;\n  }\n\n  getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig|undefined {\n    if (component.template) {\n      return InterpolationConfig.fromArray(component.template.interpolation);\n    }\n    return undefined;\n  }\n\n  /** @internal */\n  _assertNoReferenceDuplicationOnTemplate(result: t.TemplateAst[], errors: TemplateParseError[]):\n      void {\n    const existingReferences: string[] = [];\n\n    result.filter(element => !!(<any>element).references)\n        .forEach(element => (<any>element).references.forEach((reference: t.ReferenceAst) => {\n          const name = reference.name;\n          if (existingReferences.indexOf(name) < 0) {\n            existingReferences.push(name);\n          } else {\n            const error = new TemplateParseError(\n                `Reference \"#${name}\" is defined several times`, reference.sourceSpan,\n                ParseErrorLevel.ERROR);\n            errors.push(error);\n          }\n        }));\n  }\n}\n\nclass TemplateParseVisitor implements html.Visitor {\n  selectorMatcher = new SelectorMatcher();\n  directivesIndex = new Map<CompileDirectiveSummary, number>();\n  ngContentCount = 0;\n  contentQueryStartId: number;\n\n  constructor(\n      private reflector: CompileReflector, private config: CompilerConfig,\n      public providerViewContext: ProviderViewContext, directives: CompileDirectiveSummary[],\n      private _bindingParser: BindingParser, private _schemaRegistry: ElementSchemaRegistry,\n      private _schemas: SchemaMetadata[], private _targetErrors: TemplateParseError[]) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n    directives.forEach((directive, index) => {\n      const selector = CssSelector.parse(directive.selector !);\n      this.selectorMatcher.addSelectables(selector, directive);\n      this.directivesIndex.set(directive, index);\n    });\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any { return null; }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any { return null; }\n\n  visitText(text: html.Text, parent: ElementContext): any {\n    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR()) !;\n    const valueNoNgsp = replaceNgsp(text.value);\n    const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan !);\n    return expr ? new t.BoundTextAst(expr, ngContentIndex, text.sourceSpan !) :\n                  new t.TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan !);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n  }\n\n  visitComment(comment: html.Comment, context: any): any { return null; }\n\n  visitElement(element: html.Element, parent: ElementContext): any {\n    const queryStartIndex = this.contentQueryStartId;\n    const elName = element.name;\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE) {\n      // Skipping <script> for security reasons\n      // Skipping <style> as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n    if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      // Skipping stylesheets with either relative urls or package scheme as we already processed\n      // them in the StyleCompiler\n      return null;\n    }\n\n    const matchableAttrs: [string, string][] = [];\n    const elementOrDirectiveProps: ParsedProperty[] = [];\n    const elementOrDirectiveRefs: ElementOrDirectiveRef[] = [];\n    const elementVars: t.VariableAst[] = [];\n    const events: t.BoundEventAst[] = [];\n\n    const templateElementOrDirectiveProps: ParsedProperty[] = [];\n    const templateMatchableAttrs: [string, string][] = [];\n    const templateElementVars: t.VariableAst[] = [];\n\n    let hasInlineTemplates = false;\n    const attrs: t.AttrAst[] = [];\n    const isTemplateElement = isNgTemplate(element.name);\n\n    element.attrs.forEach(attr => {\n      const parsedVariables: ParsedVariable[] = [];\n      const hasBinding = this._parseAttr(\n          isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events,\n          elementOrDirectiveRefs, elementVars);\n      elementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n\n      let templateValue: string|undefined;\n      let templateKey: string|undefined;\n      const normalizedName = this._normalizeAttributeName(attr.name);\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        templateValue = attr.value;\n        templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n      }\n\n      const hasTemplateBinding = templateValue != null;\n      if (hasTemplateBinding) {\n        if (hasInlineTemplates) {\n          this._reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attr.sourceSpan);\n        }\n        hasInlineTemplates = true;\n        const parsedVariables: ParsedVariable[] = [];\n        this._bindingParser.parseInlineTemplateBinding(\n            templateKey !, templateValue !, attr.sourceSpan, templateMatchableAttrs,\n            templateElementOrDirectiveProps, parsedVariables);\n        templateElementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n      }\n\n      if (!hasBinding && !hasTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attrs.push(this.visitAttribute(attr, null));\n        matchableAttrs.push([attr.name, attr.value]);\n      }\n    });\n\n    const elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n    const {directives: directiveMetas, matchElement} =\n        this._parseDirectives(this.selectorMatcher, elementCssSelector);\n    const references: t.ReferenceAst[] = [];\n    const boundDirectivePropNames = new Set<string>();\n    const directiveAsts = this._createDirectiveAsts(\n        isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps,\n        elementOrDirectiveRefs, element.sourceSpan !, references, boundDirectivePropNames);\n    const elementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n        element.name, elementOrDirectiveProps, boundDirectivePropNames);\n    const isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n\n    const providerContext = new ProviderElementContext(\n        this.providerViewContext, parent.providerContext !, isViewRoot, directiveAsts, attrs,\n        references, isTemplateElement, queryStartIndex, element.sourceSpan !);\n\n    const children: t.TemplateAst[] = html.visitAll(\n        preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children,\n        ElementContext.create(\n            isTemplateElement, directiveAsts,\n            isTemplateElement ? parent.providerContext ! : providerContext));\n    providerContext.afterElement();\n    // Override the actual selector when the `ngProjectAs` attribute is provided\n    const projectionSelector = preparsedElement.projectAs != '' ?\n        CssSelector.parse(preparsedElement.projectAs)[0] :\n        elementCssSelector;\n    const ngContentIndex = parent.findNgContentIndex(projectionSelector) !;\n    let parsedElement: t.TemplateAst;\n\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>` element\n      if (element.children && !element.children.every(_isEmptyTextNode)) {\n        this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan !);\n      }\n\n      parsedElement = new t.NgContentAst(\n          this.ngContentCount++, hasInlineTemplates ? null ! : ngContentIndex,\n          element.sourceSpan !);\n    } else if (isTemplateElement) {\n      // `<ng-template>` element\n      this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n      this._assertNoComponentsNorElementBindingsOnTemplate(\n          directiveAsts, elementProps, element.sourceSpan !);\n\n      parsedElement = new t.EmbeddedTemplateAst(\n          attrs, events, references, elementVars, providerContext.transformedDirectiveAsts,\n          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n          providerContext.queryMatches, children, hasInlineTemplates ? null ! : ngContentIndex,\n          element.sourceSpan !);\n    } else {\n      // element other than `<ng-content>` and `<ng-template>`\n      this._assertElementExists(matchElement, element);\n      this._assertOnlyOneComponent(directiveAsts, element.sourceSpan !);\n\n      const ngContentIndex =\n          hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n      parsedElement = new t.ElementAst(\n          elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts,\n          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n          providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex,\n          element.sourceSpan, element.endSourceSpan || null);\n    }\n\n    if (hasInlineTemplates) {\n      // The element as a *-attribute\n      const templateQueryStartIndex = this.contentQueryStartId;\n      const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n      const {directives} = this._parseDirectives(this.selectorMatcher, templateSelector);\n      const templateBoundDirectivePropNames = new Set<string>();\n      const templateDirectiveAsts = this._createDirectiveAsts(\n          true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan !, [],\n          templateBoundDirectivePropNames);\n      const templateElementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n          elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n      this._assertNoComponentsNorElementBindingsOnTemplate(\n          templateDirectiveAsts, templateElementProps, element.sourceSpan !);\n      const templateProviderContext = new ProviderElementContext(\n          this.providerViewContext, parent.providerContext !, parent.isTemplateElement,\n          templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan !);\n      templateProviderContext.afterElement();\n\n      parsedElement = new t.EmbeddedTemplateAst(\n          [], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts,\n          templateProviderContext.transformProviders,\n          templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches,\n          [parsedElement], ngContentIndex, element.sourceSpan !);\n    }\n\n    return parsedElement;\n  }\n\n  private _parseAttr(\n      isTemplateElement: boolean, attr: html.Attribute, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], targetEvents: t.BoundEventAst[],\n      targetRefs: ElementOrDirectiveRef[], targetVars: t.VariableAst[]): boolean {\n    const name = this._normalizeAttributeName(attr.name);\n    const value = attr.value;\n    const srcSpan = attr.sourceSpan;\n\n    const boundEvents: ParsedEvent[] = [];\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    let hasBinding = false;\n\n    if (bindParts !== null) {\n      hasBinding = true;\n      if (bindParts[KW_BIND_IDX] != null) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          this._parseVariable(identifier, value, srcSpan, targetVars);\n        } else {\n          this._reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        this._parseReference(identifier, value, srcSpan, targetRefs);\n\n      } else if (bindParts[KW_ON_IDX]) {\n        this._bindingParser.parseEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[KW_BINDON_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, targetMatchableAttrs, targetProps);\n        this._parseAssignmentEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[KW_AT_IDX]) {\n        this._bindingParser.parseLiteralAttr(\n            name, value, srcSpan, targetMatchableAttrs, targetProps);\n\n      } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, targetMatchableAttrs,\n            targetProps);\n        this._parseAssignmentEvent(\n            bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[IDENT_PROPERTY_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, targetMatchableAttrs,\n            targetProps);\n\n      } else if (bindParts[IDENT_EVENT_IDX]) {\n        this._bindingParser.parseEvent(\n            bindParts[IDENT_EVENT_IDX], value, srcSpan, targetMatchableAttrs, boundEvents);\n      }\n    } else {\n      hasBinding = this._bindingParser.parsePropertyInterpolation(\n          name, value, srcSpan, targetMatchableAttrs, targetProps);\n    }\n\n    if (!hasBinding) {\n      this._bindingParser.parseLiteralAttr(name, value, srcSpan, targetMatchableAttrs, targetProps);\n    }\n\n    targetEvents.push(...boundEvents.map(e => t.BoundEventAst.fromParsedEvent(e)));\n\n    return hasBinding;\n  }\n\n  private _normalizeAttributeName(attrName: string): string {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n  }\n\n  private _parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, targetVars: t.VariableAst[]) {\n    if (identifier.indexOf('-') > -1) {\n      this._reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    }\n\n    targetVars.push(new t.VariableAst(identifier, value, sourceSpan));\n  }\n\n  private _parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan,\n      targetRefs: ElementOrDirectiveRef[]) {\n    if (identifier.indexOf('-') > -1) {\n      this._reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    }\n\n    targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n  }\n\n  private _parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    this._bindingParser.parseEvent(\n        `${name}Change`, `${expression}=$event`, sourceSpan, targetMatchableAttrs, targetEvents);\n  }\n\n  private _parseDirectives(selectorMatcher: SelectorMatcher, elementCssSelector: CssSelector):\n      {directives: CompileDirectiveSummary[], matchElement: boolean} {\n    // Need to sort the directives so that we get consistent results throughout,\n    // as selectorMatcher uses Maps inside.\n    // Also deduplicate directives as they might match more than one time!\n    const directives = new Array(this.directivesIndex.size);\n    // Whether any directive selector matches on the element name\n    let matchElement = false;\n\n    selectorMatcher.match(elementCssSelector, (selector, directive) => {\n      directives[this.directivesIndex.get(directive) !] = directive;\n      matchElement = matchElement || selector.hasElementSelector();\n    });\n\n    return {\n      directives: directives.filter(dir => !!dir),\n      matchElement,\n    };\n  }\n\n  private _createDirectiveAsts(\n      isTemplateElement: boolean, elementName: string, directives: CompileDirectiveSummary[],\n      props: ParsedProperty[], elementOrDirectiveRefs: ElementOrDirectiveRef[],\n      elementSourceSpan: ParseSourceSpan, targetReferences: t.ReferenceAst[],\n      targetBoundDirectivePropNames: Set<string>): t.DirectiveAst[] {\n    const matchedReferences = new Set<string>();\n    let component: CompileDirectiveSummary = null !;\n\n    const directiveAsts = directives.map((directive) => {\n      const sourceSpan = new ParseSourceSpan(\n          elementSourceSpan.start, elementSourceSpan.end,\n          `Directive ${identifierName(directive.type)}`);\n\n      if (directive.isComponent) {\n        component = directive;\n      }\n      const directiveProperties: t.BoundDirectivePropertyAst[] = [];\n      const boundProperties =\n          this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan) !;\n\n      let hostProperties =\n          boundProperties.map(prop => t.BoundElementPropertyAst.fromBoundProperty(prop));\n      // Note: We need to check the host properties here as well,\n      // as we don't know the element name in the DirectiveWrapperCompiler yet.\n      hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);\n      const parsedEvents =\n          this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan) !;\n      this._createDirectivePropertyAsts(\n          directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n      elementOrDirectiveRefs.forEach((elOrDirRef) => {\n        if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n            (elOrDirRef.isReferenceToDirective(directive))) {\n          targetReferences.push(new t.ReferenceAst(\n              elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value,\n              elOrDirRef.sourceSpan));\n          matchedReferences.add(elOrDirRef.name);\n        }\n      });\n      const hostEvents = parsedEvents.map(e => t.BoundEventAst.fromParsedEvent(e));\n      const contentQueryStartId = this.contentQueryStartId;\n      this.contentQueryStartId += directive.queries.length;\n      return new t.DirectiveAst(\n          directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId,\n          sourceSpan);\n    });\n\n    elementOrDirectiveRefs.forEach((elOrDirRef) => {\n      if (elOrDirRef.value.length > 0) {\n        if (!matchedReferences.has(elOrDirRef.name)) {\n          this._reportError(\n              `There is no directive with \"exportAs\" set to \"${elOrDirRef.value}\"`,\n              elOrDirRef.sourceSpan);\n        }\n      } else if (!component) {\n        let refToken: CompileTokenMetadata = null !;\n        if (isTemplateElement) {\n          refToken = createTokenForExternalReference(this.reflector, Identifiers.TemplateRef);\n        }\n        targetReferences.push(\n            new t.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n      }\n    });\n    return directiveAsts;\n  }\n\n  private _createDirectivePropertyAsts(\n      directiveProperties: {[key: string]: string}, boundProps: ParsedProperty[],\n      targetBoundDirectiveProps: t.BoundDirectivePropertyAst[],\n      targetBoundDirectivePropNames: Set<string>) {\n    if (directiveProperties) {\n      const boundPropsByName = new Map<string, ParsedProperty>();\n      boundProps.forEach(boundProp => {\n        const prevValue = boundPropsByName.get(boundProp.name);\n        if (!prevValue || prevValue.isLiteral) {\n          // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n          boundPropsByName.set(boundProp.name, boundProp);\n        }\n      });\n\n      Object.keys(directiveProperties).forEach(dirProp => {\n        const elProp = directiveProperties[dirProp];\n        const boundProp = boundPropsByName.get(elProp);\n\n        // Bindings are optional, so this binding only needs to be set up if an expression is given.\n        if (boundProp) {\n          targetBoundDirectivePropNames.add(boundProp.name);\n          if (!isEmptyExpression(boundProp.expression)) {\n            targetBoundDirectiveProps.push(new t.BoundDirectivePropertyAst(\n                dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n          }\n        }\n      });\n    }\n  }\n\n  private _createElementPropertyAsts(\n      elementName: string, props: ParsedProperty[],\n      boundDirectivePropNames: Set<string>): t.BoundElementPropertyAst[] {\n    const boundElementProps: t.BoundElementPropertyAst[] = [];\n\n    props.forEach((prop: ParsedProperty) => {\n      if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n        const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);\n        boundElementProps.push(t.BoundElementPropertyAst.fromBoundProperty(boundProp));\n      }\n    });\n    return this._checkPropertiesInSchema(elementName, boundElementProps);\n  }\n\n  private _findComponentDirectives(directives: t.DirectiveAst[]): t.DirectiveAst[] {\n    return directives.filter(directive => directive.directive.isComponent);\n  }\n\n  private _findComponentDirectiveNames(directives: t.DirectiveAst[]): string[] {\n    return this._findComponentDirectives(directives)\n        .map(directive => identifierName(directive.directive.type) !);\n  }\n\n  private _assertOnlyOneComponent(directives: t.DirectiveAst[], sourceSpan: ParseSourceSpan) {\n    const componentTypeNames = this._findComponentDirectiveNames(directives);\n    if (componentTypeNames.length > 1) {\n      this._reportError(\n          `More than one component matched on this element.\\n` +\n              `Make sure that only one component's selector can match a given element.\\n` +\n              `Conflicting components: ${componentTypeNames.join(',')}`,\n          sourceSpan);\n    }\n  }\n\n  /**\n   * Make sure that non-angular tags conform to the schemas.\n   *\n   * Note: An element is considered an angular tag when at least one directive selector matches the\n   * tag name.\n   *\n   * @param matchElement Whether any directive has matched on the tag name\n   * @param element the html element\n   */\n  private _assertElementExists(matchElement: boolean, element: html.Element) {\n    const elName = element.name.replace(/^:xhtml:/, '');\n\n    if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n      let errorMsg = `'${elName}' is not a known element:\\n`;\n      errorMsg +=\n          `1. If '${elName}' is an Angular component, then verify that it is part of this module.\\n`;\n      if (elName.indexOf('-') > -1) {\n        errorMsg +=\n            `2. If '${elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n      } else {\n        errorMsg +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n      this._reportError(errorMsg, element.sourceSpan !);\n    }\n  }\n\n  private _assertNoComponentsNorElementBindingsOnTemplate(\n      directives: t.DirectiveAst[], elementProps: t.BoundElementPropertyAst[],\n      sourceSpan: ParseSourceSpan) {\n    const componentTypeNames: string[] = this._findComponentDirectiveNames(directives);\n    if (componentTypeNames.length > 0) {\n      this._reportError(\n          `Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);\n    }\n    elementProps.forEach(prop => {\n      this._reportError(\n          `Property binding ${prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n          sourceSpan);\n    });\n  }\n\n  private _assertAllEventsPublishedByDirectives(\n      directives: t.DirectiveAst[], events: t.BoundEventAst[]) {\n    const allDirectiveEvents = new Set<string>();\n\n    directives.forEach(directive => {\n      Object.keys(directive.directive.outputs).forEach(k => {\n        const eventName = directive.directive.outputs[k];\n        allDirectiveEvents.add(eventName);\n      });\n    });\n\n    events.forEach(event => {\n      if (event.target != null || !allDirectiveEvents.has(event.name)) {\n        this._reportError(\n            `Event binding ${event.fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n            event.sourceSpan);\n      }\n    });\n  }\n\n  private _checkPropertiesInSchema(elementName: string, boundProps: t.BoundElementPropertyAst[]):\n      t.BoundElementPropertyAst[] {\n    // Note: We can't filter out empty expressions before this method,\n    // as we still want to validate them!\n    return boundProps.filter((boundProp) => {\n      if (boundProp.type === t.PropertyBindingType.Property &&\n          !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {\n        let errorMsg =\n            `Can't bind to '${boundProp.name}' since it isn't a known property of '${elementName}'.`;\n        if (elementName.startsWith('ng-')) {\n          errorMsg +=\n              `\\n1. If '${boundProp.name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\n              `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n        } else if (elementName.indexOf('-') > -1) {\n          errorMsg +=\n              `\\n1. If '${elementName}' is an Angular component and it has '${boundProp.name}' input, then verify that it is part of this module.` +\n              `\\n2. If '${elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\n              `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n        }\n        this._reportError(errorMsg, boundProp.sourceSpan);\n      }\n      return !isEmptyExpression(boundProp.value);\n    });\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this._targetErrors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element, parent: ElementContext): t.ElementAst|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const attrNameAndValues = ast.attrs.map((attr): [string, string] => [attr.name, attr.value]);\n    const selector = createElementCssSelector(ast.name, attrNameAndValues);\n    const ngContentIndex = parent.findNgContentIndex(selector);\n    const children: t.TemplateAst[] = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n    return new t.ElementAst(\n        ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, [], children,\n        ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n  }\n  visitComment(comment: html.Comment, context: any): any { return null; }\n\n  visitAttribute(attribute: html.Attribute, context: any): t.AttrAst {\n    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, parent: ElementContext): t.TextAst {\n    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR()) !;\n    return new t.TextAst(text.value, ngContentIndex, text.sourceSpan !);\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any { return expansion; }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any { return expansionCase; }\n}\n\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\nclass ElementOrDirectiveRef {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  /** Gets whether this is a reference to the given directive. */\n  isReferenceToDirective(directive: CompileDirectiveSummary) {\n    return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n  }\n}\n\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\nfunction splitExportAs(exportAs: string | null): string[] {\n  return exportAs ? exportAs.split(',').map(e => e.trim()) : [];\n}\n\nexport function splitClasses(classAttrValue: string): string[] {\n  return classAttrValue.trim().split(/\\s+/g);\n}\n\nclass ElementContext {\n  static create(\n      isTemplateElement: boolean, directives: t.DirectiveAst[],\n      providerContext: ProviderElementContext): ElementContext {\n    const matcher = new SelectorMatcher();\n    let wildcardNgContentIndex: number = null !;\n    const component = directives.find(directive => directive.directive.isComponent);\n    if (component) {\n      const ngContentSelectors = component.directive.template !.ngContentSelectors;\n      for (let i = 0; i < ngContentSelectors.length; i++) {\n        const selector = ngContentSelectors[i];\n        if (selector === '*') {\n          wildcardNgContentIndex = i;\n        } else {\n          matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n        }\n      }\n    }\n    return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n  }\n  constructor(\n      public isTemplateElement: boolean, private _ngContentIndexMatcher: SelectorMatcher,\n      private _wildcardNgContentIndex: number|null,\n      public providerContext: ProviderElementContext|null) {}\n\n  findNgContentIndex(selector: CssSelector): number|null {\n    const ngContentIndices: number[] = [];\n    this._ngContentIndexMatcher.match(\n        selector, (selector, ngContentIndex) => { ngContentIndices.push(ngContentIndex); });\n    ngContentIndices.sort();\n    if (this._wildcardNgContentIndex != null) {\n      ngContentIndices.push(this._wildcardNgContentIndex);\n    }\n    return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n  }\n}\n\nexport function createElementCssSelector(\n    elementName: string, attributes: [string, string][]): CssSelector {\n  const cssSelector = new CssSelector();\n  const elNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elNameNoNs);\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attrName = attributes[i][0];\n    const attrNameNoNs = splitNsName(attrName)[1];\n    const attrValue = attributes[i][1];\n\n    cssSelector.addAttribute(attrNameNoNs, attrValue);\n    if (attrName.toLowerCase() == CLASS_ATTR) {\n      const classes = splitClasses(attrValue);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  }\n  return cssSelector;\n}\n\nconst EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction _isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n\nexport function removeSummaryDuplicates<T extends{type: CompileTypeMetadata}>(items: T[]): T[] {\n  const map = new Map<any, T>();\n\n  items.forEach((item) => {\n    if (!map.get(item.type.reference)) {\n      map.set(item.type.reference, item);\n    }\n  });\n\n  return Array.from(map.values());\n}\n\nfunction isEmptyExpression(ast: AST): boolean {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n  return ast instanceof EmptyExpr;\n}"],"sourceRoot":""}