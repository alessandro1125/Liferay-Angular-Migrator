{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\n\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  getUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEvents);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig) !;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  // Parse an inline template binding. ie `<tag *tplKey=\"<tplValue>\">`\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[],\n      targetVars: ParsedVariable[]) {\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan);\n\n    for (let i = 0; i < bindings.length; i++) {\n      const binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n\n  private _parseTemplateBindings(tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), ParsedPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]): boolean {\n    const expr = this.parseInterpolation(value, sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(expression || 'undefined', false, sourceSpan);\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan));\n  }\n\n  private _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  createBoundElementProperty(elementSelector: string, boundProp: ParsedProperty):\n      BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined !;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined !;\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = BindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan);\n  }\n\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseRegularEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, targetEvents: ParsedEvent[]) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(\n              new ParsedEvent(eventName, phase, ParsedEventType.Animation, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null !, name]);\n    const ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([name !, ast.source !]);\n    targetEvents.push(new ParsedEvent(eventName, target, ParsedEventType.Regular, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n\n    try {\n      const ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName !.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg !, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n"],"sourceRoot":""}