{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {R3DependencyMetadata, compileFactoryFunction} from './render3/r3_factory';\nimport {mapToMapExpression} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: o.Expression;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let factory: o.Expression = o.NULL_EXPR;\n\n  function makeFn(ret: o.Expression): o.Expression {\n    return o.fn([], [new o.ReturnStatement(ret)], undefined, undefined, `${meta.name}_Factory`);\n  }\n\n  if (meta.useClass !== undefined || meta.useFactory !== undefined) {\n    // First, handle useClass and useFactory together, since both involve a similar call to\n    // `compileFactoryFunction`. Either dependencies are explicitly specified, in which case\n    // a factory function call is generated, or they're not specified and the calls are special-\n    // cased.\n    if (meta.deps !== undefined) {\n      // Either call `new meta.useClass(...)` or `meta.useFactory(...)`.\n      const fnOrClass: o.Expression = meta.useClass || meta.useFactory !;\n\n      // useNew: true if meta.useClass, false for meta.useFactory.\n      const useNew = meta.useClass !== undefined;\n\n      factory = compileFactoryFunction({\n        name: meta.name,\n        fnOrClass,\n        useNew,\n        injectFn: Identifiers.inject,\n        deps: meta.deps,\n      });\n    } else if (meta.useClass !== undefined) {\n      // Special case for useClass where the factory from the class's ngInjectableDef is used.\n      if (meta.useClass.isEquivalent(meta.type)) {\n        // For the injectable compiler, useClass represents a foreign type that should be\n        // instantiated to satisfy construction of the given type. It's not valid to specify\n        // useClass === type, since the useClass type is expected to already be compiled.\n        throw new Error(\n            `useClass is the same as the type, but no deps specified, which is invalid.`);\n      }\n      factory =\n          makeFn(new o.ReadPropExpr(new o.ReadPropExpr(meta.useClass, 'ngInjectableDef'), 'factory')\n                     .callFn([]));\n    } else if (meta.useFactory !== undefined) {\n      // Special case for useFactory where no arguments are passed.\n      factory = meta.useFactory.callFn([]);\n    } else {\n      // Can't happen - outer conditional guards against both useClass and useFactory being\n      // undefined.\n      throw new Error('Reached unreachable block in injectable compiler.');\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    factory = makeFn(meta.useValue);\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    factory = makeFn(o.importExpr(Identifiers.inject).callFn([meta.useExisting]));\n  } else {\n    // A strict type is compiled according to useClass semantics, except the dependencies are\n    // required.\n    if (meta.deps === undefined) {\n      throw new Error(`Type compilation of an injectable requires dependencies.`);\n    }\n    factory = compileFactoryFunction({\n      name: meta.name,\n      fnOrClass: meta.type,\n      useNew: true,\n      injectFn: Identifiers.inject,\n      deps: meta.deps,\n    });\n  }\n\n  const token = meta.type;\n  const providedIn = meta.providedIn;\n\n  const expression = o.importExpr(Identifiers.defineInjectable).callFn([mapToMapExpression(\n      {token, factory, providedIn})]);\n  const type = new o.ExpressionType(\n      o.importExpr(Identifiers.InjectableDef, [new o.ExpressionType(meta.type)]));\n\n  return {\n      expression, type,\n  };\n}\n"],"sourceRoot":""}