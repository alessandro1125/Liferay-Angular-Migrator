{"version":3,"sources":["../../../../../../../packages/compiler/src/output/abstract_emitter.ts"],"names":[],"mappings":";;;;;;;;;AAUA,WAAO,KAAK,CAAZ,MAAmB,cAAnB;AACA,aAAQ,kBAAR,QAAiC,cAAjC;AAEA,UAAM,iCAAiC,gBAAvC;AACA,UAAM,uBAAuB,uBAA7B;AACA,UAAM,eAAe,IAArB;AACA,WAAO,MAAM,kBAAkB,EAAE,QAAF,CAAW,OAAX,EAAoB,IAApB,EAA0B,IAA1B,CAAxB;AACP,WAAO,MAAM,kBAAkB,EAAE,QAAF,CAAW,OAAX,EAAoB,IAApB,EAA0B,IAA1B,CAAxB;AAMP,UAAA,YAAA,CAAA;AAIE,oBAAmB,MAAnB,EAAiC;AAAd,iBAAA,MAAA,GAAA,MAAA;AAHnB,iBAAA,WAAA,GAAc,CAAd;AACA,iBAAA,KAAA,GAAkB,EAAlB;AACA,iBAAA,QAAA,GAAqC,EAArC;AACqC;AAJvC;AAOA,WAAM,MAAA,qBAAA,CAAA;AAOJ,oBAAoB,OAApB,EAAmC;AAAf,iBAAA,OAAA,GAAA,OAAA;AAHZ,iBAAA,QAAA,GAA0B,EAA1B;AACA,iBAAA,kBAAA,GAAqB,CAArB;AAE+B,iBAAK,MAAL,GAAc,CAAC,IAAI,YAAJ,CAAiB,OAAjB,CAAD,CAAd;AAA4C;AANnF,eAAO,UAAP,GAAiB;AAA4B,mBAAO,IAAI,qBAAJ,CAA0B,CAA1B,CAAP;AAAsC;AAQnF,YAAY,YAAZ,GAAwB;AAAmB,mBAAO,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,CAAP;AAA6C;AAExF,gBAAQ,IAAR,EAA0D,WAAmB,EAA7E,EAA+E;AAC7E,iBAAK,KAAL,CAAW,QAAQ,IAAnB,EAAyB,QAAzB,EAAmC,IAAnC;AACD;AAED,sBAAW;AAAc,mBAAO,KAAK,YAAL,CAAkB,KAAlB,CAAwB,MAAxB,KAAmC,CAA1C;AAA8C;AAEvE,qBAAU;AACR,mBAAO,KAAK,YAAL,CAAkB,MAAlB,GAA2B,aAAa,MAAxC,GAAiD,KAAK,YAAL,CAAkB,WAA1E;AACD;AAED,cAAM,IAAN,EAAuD,IAAvD,EAAqE,UAAmB,KAAxF,EAA6F;AAC3F,gBAAI,KAAK,MAAL,GAAc,CAAlB,EAAqB;AACnB,qBAAK,YAAL,CAAkB,KAAlB,CAAwB,IAAxB,CAA6B,IAA7B;AACA,qBAAK,YAAL,CAAkB,WAAlB,IAAiC,KAAK,MAAtC;AACA,qBAAK,YAAL,CAAkB,QAAlB,CAA2B,IAA3B,CAAgC,QAAQ,KAAK,UAAb,IAA2B,IAA3D;AACD;AACD,gBAAI,OAAJ,EAAa;AACX,qBAAK,MAAL,CAAY,IAAZ,CAAiB,IAAI,YAAJ,CAAiB,KAAK,OAAtB,CAAjB;AACD;AACF;AAED,8BAAmB;AACjB,gBAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,qBAAK,MAAL,CAAY,GAAZ;AACD;AACF;AAED,oBAAS;AACP,iBAAK,OAAL;AACA,gBAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,qBAAK,YAAL,CAAkB,MAAlB,GAA2B,KAAK,OAAhC;AACD;AACF;AAED,oBAAS;AACP,iBAAK,OAAL;AACA,gBAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,qBAAK,YAAL,CAAkB,MAAlB,GAA2B,KAAK,OAAhC;AACD;AACF;AAED,kBAAU,KAAV,EAA4B;AAAI,iBAAK,QAAL,CAAc,IAAd,CAAmB,KAAnB;AAA4B;AAE5D,mBAAQ;AAAkB,mBAAO,KAAK,QAAL,CAAc,GAAd,EAAP;AAA+B;AAEzD,YAAI,YAAJ,GAAgB;AACd,mBAAO,KAAK,QAAL,CAAc,MAAd,GAAuB,CAAvB,GAA2B,KAAK,QAAL,CAAc,KAAK,QAAL,CAAc,MAAd,GAAuB,CAArC,CAA3B,GAAqE,IAA5E;AACD;AAED,mBAAQ;AACN,mBAAO,KAAK,WAAL,CACF,GADE,CACE,KAAK,EAAE,KAAF,CAAQ,MAAR,GAAiB,CAAjB,GAAqB,cAAc,EAAE,MAAhB,IAA0B,EAAE,KAAF,CAAQ,IAAR,CAAa,EAAb,CAA/C,GAAkE,EADzE,EAEF,IAFE,CAEG,IAFH,CAAP;AAGD;AAED,6BAAqB,WAArB,EAA0C,eAAuB,CAAjE,EAAkE;AAChE,kBAAM,MAAM,IAAI,kBAAJ,CAAuB,WAAvB,CAAZ;AAEA,gBAAI,oBAAoB,KAAxB;AACA,kBAAM,yBAAyB,MAAK;AAClC,oBAAI,CAAC,iBAAL,EAAwB;AACtB;AACA;AACA;AACA,wBAAI,SAAJ,CAAc,WAAd,EAA2B,GAA3B,EAAgC,UAAhC,CAA2C,CAA3C,EAA8C,WAA9C,EAA2D,CAA3D,EAA8D,CAA9D;AACA,wCAAoB,IAApB;AACD;AACF,aARD;AAUA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,YAApB,EAAkC,GAAlC,EAAuC;AACrC,oBAAI,OAAJ;AACA;AACD;AAED,iBAAK,WAAL,CAAiB,OAAjB,CAAyB,CAAC,IAAD,EAAO,OAAP,KAAkB;AACzC,oBAAI,OAAJ;AAEA,sBAAM,QAAQ,KAAK,QAAnB;AACA,sBAAM,QAAQ,KAAK,KAAnB;AACA,oBAAI,OAAO,KAAK,MAAL,GAAc,aAAa,MAAtC;AACA,oBAAI,UAAU,CAAd;AACA;AACA,uBAAO,UAAU,MAAM,MAAhB,IAA0B,CAAC,MAAM,OAAN,CAAlC,EAAkD;AAChD,4BAAQ,MAAM,OAAN,EAAe,MAAvB;AACA;AACD;AACD,oBAAI,UAAU,MAAM,MAAhB,IAA0B,YAAY,CAAtC,IAA2C,SAAS,CAAxD,EAA2D;AACzD,wCAAoB,IAApB;AACD,iBAFD,MAEO;AACL;AACD;AAED,uBAAO,UAAU,MAAM,MAAvB,EAA+B;AAC7B,0BAAM,OAAO,MAAM,OAAN,CAAb;AACA,0BAAM,SAAS,KAAK,KAAL,CAAW,IAA1B;AACA,0BAAM,aAAa,KAAK,KAAL,CAAW,IAA9B;AACA,0BAAM,YAAY,KAAK,KAAL,CAAW,GAA7B;AACA,wBAAI,SAAJ,CAAc,OAAO,GAArB,EAA0B,OAAO,OAAjC,EACK,UADL,CACgB,IADhB,EACsB,OAAO,GAD7B,EACkC,UADlC,EAC8C,SAD9C;AAGA,4BAAQ,MAAM,OAAN,EAAe,MAAvB;AACA;AAEA;AACA,2BAAO,UAAU,MAAM,MAAhB,KAA2B,SAAS,MAAM,OAAN,CAAT,IAA2B,CAAC,MAAM,OAAN,CAAvD,CAAP,EAA+E;AAC7E,gCAAQ,MAAM,OAAN,EAAe,MAAvB;AACA;AACD;AACF;AACF,aAnCD;AAqCA,mBAAO,GAAP;AACD;AAED,6BAAqB,KAArB,EAAkC;AAAI,mBAAO,KAAK,kBAAL,GAA0B,KAAjC;AAAyC;AAE/E,eAAO,IAAP,EAAqB,MAArB,EAAmC;AACjC,kBAAM,cAAc,KAAK,MAAL,CAAY,OAAO,KAAK,kBAAxB,CAApB;AACA,gBAAI,WAAJ,EAAiB;AACf,oBAAI,cAAc,SAAS,cAAc,YAAY,MAA1B,EAAkC,MAA7D;AACA,qBAAK,IAAI,YAAY,CAArB,EAAwB,YAAY,YAAY,KAAZ,CAAkB,MAAtD,EAA8D,WAA9D,EAA2E;AACzE,0BAAM,OAAO,YAAY,KAAZ,CAAkB,SAAlB,CAAb;AACA,wBAAI,KAAK,MAAL,GAAc,WAAlB,EAA+B;AAC7B,+BAAO,YAAY,QAAZ,CAAqB,SAArB,CAAP;AACD;AACD,mCAAe,KAAK,MAApB;AACD;AACF;AACD,mBAAO,IAAP;AACD;AAED,YAAY,WAAZ,GAAuB;AACrB,gBAAI,KAAK,MAAL,CAAY,MAAZ,IAAsB,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,EAAoC,KAApC,CAA0C,MAA1C,KAAqD,CAA/E,EAAkF;AAChF,uBAAO,KAAK,MAAL,CAAY,KAAZ,CAAkB,CAAlB,EAAqB,CAAC,CAAtB,CAAP;AACD;AACD,mBAAO,KAAK,MAAZ;AACD;AAnJG;AAsJN,WAAM,MAAA,sBAAA,CAAA;AACJ,oBAAoB,sBAApB,EAAmD;AAA/B,iBAAA,sBAAA,GAAA,sBAAA;AAAmC;AAEvD,4BAAoB,IAApB,EAAiD,GAAjD,EAA2E;AACzE,iBAAK,IAAL,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACA,gBAAI,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,mBAAO,IAAP;AACD;AAED,wBAAgB,IAAhB,EAAyC,GAAzC,EAAmE;AACjE,gBAAI,KAAJ,CAAU,IAAV,EAAgB,SAAhB;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,mBAAO,IAAP;AACD;AAMD,oBAAY,IAAZ,EAA4B,GAA5B,EAAsD;AACpD,gBAAI,KAAJ,CAAU,IAAV,EAAgB,MAAhB;AACA,iBAAK,SAAL,CAAe,eAAf,CAA+B,IAA/B,EAAqC,GAArC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,KAAhB;AACA,kBAAM,cAAc,KAAK,SAAL,IAAkB,IAAlB,IAA0B,KAAK,SAAL,CAAe,MAAf,GAAwB,CAAtE;AACA,gBAAI,KAAK,QAAL,CAAc,MAAd,IAAwB,CAAxB,IAA6B,CAAC,WAAlC,EAA+C;AAC7C,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,qBAAK,kBAAL,CAAwB,KAAK,QAA7B,EAAuC,GAAvC;AACA,oBAAI,mBAAJ;AACA,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD,aALD,MAKO;AACL,oBAAI,OAAJ;AACA,oBAAI,SAAJ;AACA,qBAAK,kBAAL,CAAwB,KAAK,QAA7B,EAAuC,GAAvC;AACA,oBAAI,SAAJ;AACA,oBAAI,WAAJ,EAAiB;AACf,wBAAI,OAAJ,CAAY,IAAZ,EAAkB,UAAlB;AACA,wBAAI,SAAJ;AACA,yBAAK,kBAAL,CAAwB,KAAK,SAA7B,EAAwC,GAAxC;AACA,wBAAI,SAAJ;AACD;AACF;AACD,gBAAI,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,mBAAO,IAAP;AACD;AAID,uBAAe,IAAf,EAAkC,GAAlC,EAA4D;AAC1D,gBAAI,KAAJ,CAAU,IAAV,EAAgB,QAAhB;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,mBAAO,IAAP;AACD;AACD,yBAAiB,IAAjB,EAAsC,GAAtC,EAAgE;AAC9D,gBAAI,KAAK,SAAT,EAAoB;AAClB,oBAAI,OAAJ,CAAY,IAAZ,EAAkB,MAAM,KAAK,OAAO,KAApC;AACD,aAFD,MAEO;AACL,qBAAK,OAAL,CAAa,KAAb,CAAmB,IAAnB,EAAyB,OAAzB,CAAkC,IAAD,IAAS;AAAG,wBAAI,OAAJ,CAAY,IAAZ,EAAkB,MAAM,IAAI,EAA5B;AAAkC,iBAA/E;AACD;AACD,mBAAO,IAAP;AACD;AACD,8BAAsB,IAAtB,EAAgD,GAAhD,EAA0E;AACxE,gBAAI,OAAJ,CAAY,IAAZ,EAAkB,KAAK,KAAK,QAAL,EAAe,IAAtC;AACA,mBAAO,IAAP;AACD;AAID,0BAAkB,IAAlB,EAAwC,GAAxC,EAAkE;AAChE,kBAAM,eAAe,IAAI,WAAJ,EAArB;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,gBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAG,KAAK,IAAI,KAA5B;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,mBAAO,IAAP;AACD;AACD,0BAAkB,IAAlB,EAAwC,GAAxC,EAAkE;AAChE,kBAAM,eAAe,IAAI,WAAJ,EAArB;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,iBAAK,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,MAAhB;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,mBAAO,IAAP;AACD;AACD,2BAAmB,IAAnB,EAA0C,GAA1C,EAAoE;AAClE,kBAAM,eAAe,IAAI,WAAJ,EAArB;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,iBAAK,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,IAAI,KAAK,IAAI,KAA7B;AACA,iBAAK,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,gBAAI,CAAC,YAAL,EAAmB;AACjB,oBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;AACD,mBAAO,IAAP;AACD;AACD,8BAAsB,IAAtB,EAAgD,GAAhD,EAA0E;AACxE,iBAAK,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,gBAAI,OAAO,KAAK,IAAhB;AACA,gBAAI,KAAK,OAAL,IAAgB,IAApB,EAA0B;AACxB,uBAAO,KAAK,oBAAL,CAA0B,KAAK,OAA/B,CAAP;AACA,oBAAI,QAAQ,IAAZ,EAAkB;AAChB;AACA,2BAAO,IAAP;AACD;AACF;AACD,gBAAI,KAAJ,CAAU,IAAV,EAAgB,IAAI,IAAI,GAAxB;AACA,iBAAK,mBAAL,CAAyB,KAAK,IAA9B,EAAoC,GAApC,EAAyC,GAAzC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,mBAAO,IAAP;AACD;AAID,gCAAwB,IAAxB,EAAoD,GAApD,EAA8E;AAC5E,iBAAK,EAAL,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,iBAAK,mBAAL,CAAyB,KAAK,IAA9B,EAAoC,GAApC,EAAyC,GAAzC;AACA,gBAAI,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,mBAAO,IAAP;AACD;AACD,6BAAqB,GAArB,EAAkD,GAAlD,EAA4E;AAC1E,kBAAM,IAAI,KAAJ,CAAU,gDAAV,CAAN;AACD;AACD,wBAAgB,IAAhB,EAAoC,GAApC,EAA8D;AAC5D,gBAAI,KAAJ,CAAU,IAAV,EAAgB,SAAhB;AACA,iBAAK,IAAL,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACD;AACD,yBAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,gBAAI,UAAU,IAAI,IAAlB;AACA,gBAAI,IAAI,OAAJ,IAAe,IAAnB,EAAyB;AACvB,wBAAQ,IAAI,OAAZ;AACE,yBAAK,EAAE,UAAF,CAAa,KAAlB;AACE,kCAAU,OAAV;AACA;AACF,yBAAK,EAAE,UAAF,CAAa,IAAlB;AACE,kCAAU,MAAV;AACA;AACF,yBAAK,EAAE,UAAF,CAAa,UAAlB;AACE,kCAAU,gBAAgB,IAA1B;AACA;AACF,yBAAK,EAAE,UAAF,CAAa,UAAlB;AACE,kCAAU,gBAAgB,IAA1B;AACA;AACF;AACE,8BAAM,IAAI,KAAJ,CAAU,4BAA4B,IAAI,OAAO,EAAjD,CAAN;AAdJ;AAgBD;AACD,gBAAI,KAAJ,CAAU,GAAV,EAAe,OAAf;AACA,mBAAO,IAAP;AACD;AACD,6BAAqB,GAArB,EAA6C,GAA7C,EAAuE;AACrE,gBAAI,KAAJ,CAAU,GAAV,EAAe,MAAf;AACA,gBAAI,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,iBAAK,mBAAL,CAAyB,IAAI,IAA7B,EAAmC,GAAnC,EAAwC,GAAxC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AAED,yBAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,kBAAM,QAAQ,IAAI,KAAlB;AACA,gBAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,oBAAI,KAAJ,CAAU,GAAV,EAAe,iBAAiB,KAAjB,EAAwB,KAAK,sBAA7B,CAAf;AACD,aAFD,MAEO;AACL,oBAAI,KAAJ,CAAU,GAAV,EAAe,GAAG,KAAK,EAAvB;AACD;AACD,mBAAO,IAAP;AACD;AAID,6BAAqB,GAArB,EAA6C,GAA7C,EAAuE;AACrE,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,gBAAI,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,IAAf;AACA,gBAAI,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,IAAf;AACA,gBAAI,SAAJ,CAAgB,eAAhB,CAAgC,IAAhC,EAAsC,GAAtC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AACD,qBAAa,GAAb,EAA6B,GAA7B,EAAuD;AACrD,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,gBAAI,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,mBAAO,IAAP;AACD;AACD,+BAAuB,GAAvB,EAA6C,GAA7C,EAAuE;AACrE,gBAAI,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,mBAAO,IAAP;AACD;AAID,gCAAwB,GAAxB,EAAmD,GAAnD,EAA6E;AAC3E,gBAAI,KAAJ;AACA,oBAAQ,IAAI,QAAZ;AACE,qBAAK,EAAE,cAAF,CAAiB,MAAtB;AACE,4BAAQ,IAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,SAAtB;AACE,4BAAQ,KAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,SAAtB;AACE,4BAAQ,IAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,YAAtB;AACE,4BAAQ,KAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,GAAtB;AACE,4BAAQ,IAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,UAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,EAAtB;AACE,4BAAQ,IAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,IAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,KAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,MAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,QAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,MAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,KAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,WAAtB;AACE,4BAAQ,IAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,MAAtB;AACE,4BAAQ,GAAR;AACA;AACF,qBAAK,EAAE,cAAF,CAAiB,YAAtB;AACE,4BAAQ,IAAR;AACA;AACF;AACE,0BAAM,IAAI,KAAJ,CAAU,oBAAoB,IAAI,QAAQ,EAA1C,CAAN;AAlDJ;AAoDA,gBAAI,IAAI,MAAR,EAAgB,IAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,gBAAI,GAAJ,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,IAAI,KAAK,GAAxB;AACA,gBAAI,GAAJ,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,gBAAI,IAAI,MAAR,EAAgB,IAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,mBAAO,IAAP;AACD;AAED,0BAAkB,GAAlB,EAAuC,GAAvC,EAAiE;AAC/D,gBAAI,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,IAAI,IAAnB;AACA,mBAAO,IAAP;AACD;AACD,yBAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,gBAAI,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,gBAAI,KAAJ,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AACD,8BAAsB,GAAtB,EAA+C,GAA/C,EAAyE;AACvE,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,iBAAK,mBAAL,CAAyB,IAAI,OAA7B,EAAsC,GAAtC,EAA2C,GAA3C;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AACD,4BAAoB,GAApB,EAA2C,GAA3C,EAAqE;AACnE,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,iBAAK,eAAL,CAAqB,SAAQ;AAC3B,oBAAI,KAAJ,CAAU,GAAV,EAAe,GAAG,iBAAiB,MAAM,GAAvB,EAA4B,KAAK,sBAAjC,EAAyD,MAAM,MAA/D,CAAsE,GAAxF;AACA,sBAAM,KAAN,CAAY,eAAZ,CAA4B,IAA5B,EAAkC,GAAlC;AACD,aAHD,EAGG,IAAI,OAHP,EAGgB,GAHhB,EAGqB,GAHrB;AAIA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AACD,uBAAe,GAAf,EAAiC,GAAjC,EAA2D;AACzD,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,iBAAK,mBAAL,CAAyB,IAAI,KAA7B,EAAoC,GAApC,EAAyC,GAAzC;AACA,gBAAI,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,mBAAO,IAAP;AACD;AACD,4BAAoB,WAApB,EAAiD,GAAjD,EAA6E,SAA7E,EAA8F;AAE5F,iBAAK,eAAL,CAAqB,QAAQ,KAAK,eAAL,CAAqB,IAArB,EAA2B,GAA3B,CAA7B,EAA8D,WAA9D,EAA2E,GAA3E,EAAgF,SAAhF;AACD;AAED,wBACI,OADJ,EAC6B,WAD7B,EAC+C,GAD/C,EAEI,SAFJ,EAEqB;AACnB,gBAAI,oBAAoB,KAAxB;AACA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,YAAY,MAAhC,EAAwC,GAAxC,EAA6C;AAC3C,oBAAI,IAAI,CAAR,EAAW;AACT,wBAAI,IAAI,UAAJ,KAAmB,EAAvB,EAA2B;AACzB,4BAAI,KAAJ,CAAU,IAAV,EAAgB,SAAhB,EAA2B,IAA3B;AACA,4BAAI,CAAC,iBAAL,EAAwB;AACtB;AACA,gCAAI,SAAJ;AACA,gCAAI,SAAJ;AACA,gDAAoB,IAApB;AACD;AACF,qBARD,MAQO;AACL,4BAAI,KAAJ,CAAU,IAAV,EAAgB,SAAhB,EAA2B,KAA3B;AACD;AACF;AACD,wBAAQ,YAAY,CAAZ,CAAR;AACD;AACD,gBAAI,iBAAJ,EAAuB;AACrB;AACA,oBAAI,SAAJ;AACA,oBAAI,SAAJ;AACD;AACF;AAED,2BAAmB,UAAnB,EAA8C,GAA9C,EAAwE;AACtE,uBAAW,OAAX,CAAoB,IAAD,IAAU,KAAK,cAAL,CAAoB,IAApB,EAA0B,GAA1B,CAA7B;AACD;AAjVG;AAoVN,WAAM,SAAA,gBAAA,CACF,KADE,EACa,YADb,EACoC,cAAuB,IAD3D,EAC+D;AACnE,YAAI,SAAS,IAAb,EAAmB;AACjB,mBAAO,IAAP;AACD;AACD,cAAM,OAAO,MAAM,OAAN,CAAc,8BAAd,EAA8C,CAAC,GAAG,KAAJ,KAAuB;AAChF,gBAAI,MAAM,CAAN,KAAY,GAAhB,EAAqB;AACnB,uBAAO,eAAe,KAAf,GAAuB,GAA9B;AACD,aAFD,MAEO,IAAI,MAAM,CAAN,KAAY,IAAhB,EAAsB;AAC3B,uBAAO,KAAP;AACD,aAFM,MAEA,IAAI,MAAM,CAAN,KAAY,IAAhB,EAAsB;AAC3B,uBAAO,KAAP;AACD,aAFM,MAEA;AACL,uBAAO,KAAK,MAAM,CAAN,CAAQ,EAApB;AACD;AACF,SAVY,CAAb;AAWA,cAAM,iBAAiB,eAAe,CAAC,qBAAqB,IAArB,CAA0B,IAA1B,CAAvC;AACA,eAAO,iBAAiB,IAAI,IAAI,GAAzB,GAA+B,IAAtC;AACD;AAED,aAAA,aAAA,CAAuB,KAAvB,EAAoC;AAClC,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAApB,EAA2B,GAA3B,EAAgC;AAC9B,mBAAO,YAAP;AACD;AACD,eAAO,GAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext { return new EmitterVisitorContext(0); }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) { this._lines = [new _EmittedLine(_indent)]; }\n\n  private get _currentLine(): _EmittedLine { return this._lines[this._lines.length - 1]; }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean { return this._currentLine.parts.length === 0; }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) { this._classes.push(clazz); }\n\n  popClass(): o.ClassStmt { return this._classes.pop() !; }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx] !;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) { return this._preambleLineCount = count; }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.multiline) {\n      ctx.println(stmt, `/* ${stmt.comment} */`);\n    } else {\n      stmt.comment.split('\\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });\n    }\n    return null;\n  }\n  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n    ctx.println(stmt, `/*${stmt.toString()}*/`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name !;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name !;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name !;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase !.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n"],"sourceRoot":""}