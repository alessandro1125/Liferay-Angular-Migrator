Liferay.Loader.define('@example-angular-liferay$angular/compiler@6.1.10/esm2015/src/output/js_emitter', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { EmitterVisitorContext } from './abstract_emitter';
    import { AbstractJsEmitterVisitor } from './abstract_js_emitter';
    import * as o from './output_ast';
    export class JavaScriptEmitter {
        emitStatements(genFilePath, stmts, preamble = '') {
            const converter = new JsEmitterVisitor();
            const ctx = EmitterVisitorContext.createRoot();
            converter.visitAllStatements(stmts, ctx);
            const preambleLines = preamble ? preamble.split('\n') : [];
            converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {
                // Note: can't write the real word for import as it screws up system.js auto detection...
                preambleLines.push(`var ${prefix} = req` + `uire('${importedModuleName}');`);
            });
            const sm = ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment();
            const lines = [...preambleLines, ctx.toSource(), sm];
            if (sm) {
                // always add a newline at the end, as some tools have bugs without it.
                lines.push('');
            }
            return lines.join('\n');
        }
    }
    class JsEmitterVisitor extends AbstractJsEmitterVisitor {
        constructor() {
            super(...arguments);
            this.importsWithPrefixes = new Map();
        }
        visitExternalExpr(ast, ctx) {
            const { name, moduleName } = ast.value;
            if (moduleName) {
                let prefix = this.importsWithPrefixes.get(moduleName);
                if (prefix == null) {
                    prefix = `i${this.importsWithPrefixes.size}`;
                    this.importsWithPrefixes.set(moduleName, prefix);
                }
                ctx.print(ast, `${prefix}.`);
            }
            ctx.print(ast, name);
            return null;
        }
        visitDeclareVarStmt(stmt, ctx) {
            super.visitDeclareVarStmt(stmt, ctx);
            if (stmt.hasModifier(o.StmtModifier.Exported)) {
                ctx.println(stmt, exportVar(stmt.name));
            }
            return null;
        }
        visitDeclareFunctionStmt(stmt, ctx) {
            super.visitDeclareFunctionStmt(stmt, ctx);
            if (stmt.hasModifier(o.StmtModifier.Exported)) {
                ctx.println(stmt, exportVar(stmt.name));
            }
            return null;
        }
        visitDeclareClassStmt(stmt, ctx) {
            super.visitDeclareClassStmt(stmt, ctx);
            if (stmt.hasModifier(o.StmtModifier.Exported)) {
                ctx.println(stmt, exportVar(stmt.name));
            }
            return null;
        }
    }
    function exportVar(varName) {
        return `Object.defineProperty(exports, '${varName}', { get: function() { return ${varName}; }});`;
    }
});
//# sourceMappingURL=js_emitter.js.map