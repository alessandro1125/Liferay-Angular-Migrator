{"version":3,"sources":["../../../../../../../packages/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\n\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nexport interface LocalResolver { getLocal(name: string): o.Expression|null; }\n\nexport class ConvertActionBindingResult {\n  /**\n   * Store statements which are render3 compatible.\n   */\n  render3Stmts: o.Statement[];\n  constructor(\n      /**\n       * Render2 compatible statements,\n       */\n      public stmts: o.Statement[],\n      /**\n       * Variable name used with render2 compatible statements.\n       */\n      public allowDefault: o.ReadVarExpr) {\n    /**\n     * This is bit of a hack. It converts statements which render2 expects to statements which are\n     * expected by render3.\n     *\n     * Example: `<div click=\"doSomething($event)\">` will generate:\n     *\n     * Render3:\n     * ```\n     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n     * return pd_b;\n     * ```\n     *\n     * but render2 expects:\n     * ```\n     * return ctx.doSomething($event);\n     * ```\n     */\n    // TODO(misko): remove this hack once we no longer support ViewEngine.\n    this.render3Stmts = stmts.map((statement: o.Statement) => {\n      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n          statement.value instanceof o.BinaryOperatorExpr) {\n        const lhs = statement.value.lhs as o.CastExpr;\n        return new o.ReturnStatement(lhs.value);\n      }\n      return statement;\n    });\n  }\n}\n\nexport type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, interpolationFunction?: InterpolationFunction): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const lastIndex = actionStmts.length - 1;\n  let preventDefaultVar: o.ReadVarExpr = null !;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    const returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\nexport enum BindingForm {\n  // The general form of binding expression, supports all expressions.\n  General,\n\n  // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n  TrySimple,\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm,\n    interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const currValExpr = createCurrValueExpr(bindingId);\n  const stmts: o.Statement[] = [];\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n\n  if (visitor.temporaryCount) {\n    for (let i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  } else if (form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n  visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private interpolationFunction: InterpolationFunction|undefined) {}\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode, value.conditional(\n                  this._visit(ast.trueExp, _Mode.Expression),\n                  this._visit(ast.falseExp, _Mode.Expression)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit(ast.target !, _Mode.Expression).callFn(convertedArgs);\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    if (this.interpolationFunction) {\n      return this.interpolationFunction(args);\n    }\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1))]);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(mode, o.literal(ast.value, type));\n  }\n\n  private _getLocal(name: string): o.Expression|null { return this._localResolver.getLocal(name); }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    if (ast.receiver instanceof cdAst.ImplicitReceiver && ast.name == '$any') {\n      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n      if (args.length != 1) {\n        throw new Error(\n            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n      }\n      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE);\n    }\n\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      const varExpr = this._getLocal(ast.name);\n      if (varExpr) {\n        throw new Error('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this._visit(ast, mode)); }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr = undefined !;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n\n  // Given a expression of the form a?.b.c?.d.e the the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs be transform initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary) { return null; },\n      visitChain(ast: cdAst.Chain) { return null; },\n      visitConditional(ast: cdAst.Conditional) { return null; },\n      visitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n      visitInterpolation(ast: cdAst.Interpolation) { return null; },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n      visitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n      visitPipe(ast: cdAst.BindingPipe) { return null; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) { return null; },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n      visitQuote(ast: cdAst.Quote) { return null; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporary(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n      visitChain(ast: cdAst.Chain) { return false; },\n      visitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n      visitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n      visitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n      visitMethodCall(ast: cdAst.MethodCall) { return true; },\n      visitPipe(ast: cdAst.BindingPipe) { return true; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitNonNullAssert(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n      visitQuote(ast: cdAst.Quote) { return false; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n\nexport class BuiltinFunctionCall extends cdAst.FunctionCall {\n  constructor(span: cdAst.ParseSpan, public args: cdAst.AST[], public converter: BuiltinConverter) {\n    super(span, null, args);\n  }\n}\n"],"sourceRoot":""}