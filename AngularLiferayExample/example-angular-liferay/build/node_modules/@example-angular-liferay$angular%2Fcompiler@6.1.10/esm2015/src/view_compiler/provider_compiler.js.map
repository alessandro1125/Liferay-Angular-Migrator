{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DepFlags, NodeFlags} from '../core';\nimport {Identifiers, createTokenForExternalReference} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nexport function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  let flags = NodeFlags.None;\n  if (!providerAst.eager) {\n    flags |= NodeFlags.LazyProvider;\n  }\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= NodeFlags.PrivateProvider;\n  }\n  if (providerAst.isModule) {\n    flags |= NodeFlags.TypeModuleProvider;\n  }\n  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n        providerAst.providerType === ProviderAstType.Directive ||\n        providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n      multiProviderDef(ctx, flags, providerAst.providers) :\n      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n  return {\n    providerExpr,\n    flags: providerFlags, depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token),\n  };\n}\n\nfunction multiProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  const allDepDefs: o.Expression[] = [];\n  const allParams: o.FnParam[] = [];\n  const exprs = providers.map((provider, providerIndex) => {\n    let expr: o.Expression;\n    if (provider.useClass) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n    } else if (provider.useExisting) {\n      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n      expr = depExprs[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n    return expr;\n  });\n  const providerExpr =\n      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n  return {\n    providerExpr,\n    flags: flags | NodeFlags.TypeFactoryProvider,\n    depsExpr: o.literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n    return deps.map((dep, depIndex) => {\n      const paramName = `p${providerIndex}_${depIndex}`;\n      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return o.variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n    providerMeta: CompileProviderMetadata):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  let providerExpr: o.Expression;\n  let deps: CompileDiDependencyMetadata[];\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass !.reference);\n    flags |= NodeFlags.TypeDirective;\n    deps = providerMeta.deps || providerMeta.useClass !.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= NodeFlags.TypeClassProvider;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= NodeFlags.TypeFactoryProvider;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = o.NULL_EXPR;\n      flags |= NodeFlags.TypeUseExistingProvider;\n      deps = [{token: providerMeta.useExisting}];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= NodeFlags.TypeValueProvider;\n      deps = [];\n    }\n  }\n  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n  return {providerExpr, flags, depsExpr};\n}\n\nfunction tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n                                o.literal(tokenMeta.value);\n}\n\nexport function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token !);\n  let flags = DepFlags.None;\n  if (dep.isSkipSelf) {\n    flags |= DepFlags.SkipSelf;\n  }\n  if (dep.isOptional) {\n    flags |= DepFlags.Optional;\n  }\n  if (dep.isSelf) {\n    flags |= DepFlags.Self;\n  }\n  if (dep.isValue) {\n    flags |= DepFlags.Value;\n  }\n  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n}\n\nexport function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n  let nodeFlag = NodeFlags.None;\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = NodeFlags.AfterContentChecked;\n      break;\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = NodeFlags.AfterContentInit;\n      break;\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = NodeFlags.AfterViewChecked;\n      break;\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = NodeFlags.AfterViewInit;\n      break;\n    case LifecycleHooks.DoCheck:\n      nodeFlag = NodeFlags.DoCheck;\n      break;\n    case LifecycleHooks.OnChanges:\n      nodeFlag = NodeFlags.OnChanges;\n      break;\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = NodeFlags.OnDestroy;\n      break;\n    case LifecycleHooks.OnInit:\n      nodeFlag = NodeFlags.OnInit;\n      break;\n  }\n  return nodeFlag;\n}\n\nexport function componentFactoryResolverProviderDef(\n    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n    entryComponents: CompileEntryComponentMetadata[]): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  const entryComponentFactories =\n      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n  const classMeta = {\n    diDeps: [\n      {isValue: true, value: o.literalArr(entryComponentFactories)},\n      {token: token, isSkipSelf: true, isOptional: true},\n      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n    ],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n  };\n  const {providerExpr, flags: providerFlags, depsExpr} =\n      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n      });\n  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n}\n"],"sourceRoot":""}