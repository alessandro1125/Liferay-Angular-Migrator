{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, BuiltinConverter, EventHandlerVars, LocalResolver, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, TextAst, VariableAst, templateVisitAll} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder | null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName | StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {context: this.component, value: input.value} as Expression\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => { this.visitDirective(dirAst); });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null !;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter:\n                (keys: {key: string, quoted: boolean}[]) => (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"],"sourceRoot":""}