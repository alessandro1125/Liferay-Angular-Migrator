{"version":3,"sources":["../../../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n// Closure variables holding messages must be named `MSG_[A-Z0-9]+`\nconst TRANSLATION_PREFIX = 'MSG_';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Closure uses `goog.getMsg(message)` to lookup translations\n */\nconst GOOG_GET_MSG = 'goog.getMsg';\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared !: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private translations = new Map<string, o.Expression>();\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  // Generates closure specific code for translation.\n  //\n  // ```\n  // /**\n  //  * @desc description?\n  //  * @meaning meaning?\n  //  */\n  // const MSG_XYZ = goog.getMsg('message');\n  // ```\n  getTranslation(message: string, meta: {description?: string, meaning?: string}): o.Expression {\n    // The identity of an i18n message depends on the message and its meaning\n    const key = meta.meaning ? `${message}\\u0000\\u0000${meta.meaning}` : message;\n\n    const exp = this.translations.get(key);\n\n    if (exp) {\n      return exp;\n    }\n\n    const docStmt = i18nMetaToDocStmt(meta);\n    if (docStmt) {\n      this.statements.push(docStmt);\n    }\n\n    // Call closure to get the translation\n    const variable = o.variable(this.freshTranslationName());\n    const fnCall = o.variable(GOOG_GET_MSG).callFn([o.literal(message)]);\n    const msgStmt = variable.set(fnCall).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]);\n    this.statements.push(msgStmt);\n\n    this.translations.set(key, variable);\n    return variable;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ngComponentDef';\n      case DefinitionKind.Directive:\n        return 'ngDirectiveDef';\n      case DefinitionKind.Injector:\n        return 'ngInjectorDef';\n      case DefinitionKind.Pipe:\n        return 'ngPipeDef';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private freshTranslationName(): string {\n    return this.uniqueName(TRANSLATION_PREFIX).toUpperCase();\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) { return `VAR:${node.name}`; }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n}\n\nfunction invalid<T>(arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\n// Converts i18n meta informations for a message (description, meaning) to a JsDoc statement\n// formatted as expected by the Closure compiler.\nfunction i18nMetaToDocStmt(meta: {description?: string, id?: string, meaning?: string}):\n    o.JSDocCommentStmt|null {\n  const tags: o.JSDocTag[] = [];\n\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  }\n\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n\n  return tags.length == 0 ? null : new o.JSDocCommentStmt(tags);\n}\n"],"sourceRoot":""}