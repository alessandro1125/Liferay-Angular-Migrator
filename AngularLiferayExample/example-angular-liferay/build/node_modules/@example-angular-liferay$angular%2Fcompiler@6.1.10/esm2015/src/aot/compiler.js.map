{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileIdentifierMetadata, CompileInjectableMetadata, CompileNgModuleMetadata, CompilePipeMetadata, CompilePipeSummary, CompileProviderMetadata, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileTypeMetadata, CompileTypeSummary, componentFactoryName, flatten, identifierName, templateSourceUrl} from '../compile_metadata';\nimport {CompilerConfig} from '../config';\nimport {ConstantPool} from '../constant_pool';\nimport {ViewEncapsulation} from '../core';\nimport {MessageBundle} from '../i18n/message_bundle';\nimport {Identifiers, createTokenForExternalReference} from '../identifiers';\nimport {InjectableCompiler} from '../injectable_compiler';\nimport {CompileMetadataResolver} from '../metadata_resolver';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {removeWhitespaces} from '../ml_parser/html_whitespaces';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {NgModuleCompiler} from '../ng_module_compiler';\nimport {OutputEmitter} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\nimport {ParseError} from '../parse_util';\nimport {compileNgModuleFromRender2 as compileR3Module} from '../render3/r3_module_compiler';\nimport {compilePipeFromRender2 as compileR3Pipe} from '../render3/r3_pipe_compiler';\nimport {htmlAstToRender3Ast} from '../render3/r3_template_transform';\nimport {compileComponentFromRender2 as compileR3Component, compileDirectiveFromRender2 as compileR3Directive} from '../render3/view/compiler';\nimport {DomElementSchemaRegistry} from '../schema/dom_element_schema_registry';\nimport {CompiledStylesheet, StyleCompiler} from '../style_compiler';\nimport {SummaryResolver} from '../summary_resolver';\nimport {BindingParser} from '../template_parser/binding_parser';\nimport {TemplateAst} from '../template_parser/template_ast';\nimport {TemplateParser} from '../template_parser/template_parser';\nimport {OutputContext, ValueVisitor, error, syntaxError, visitValue} from '../util';\nimport {TypeCheckCompiler} from '../view_compiler/type_check_compiler';\nimport {ViewCompileResult, ViewCompiler} from '../view_compiler/view_compiler';\n\nimport {AotCompilerHost} from './compiler_host';\nimport {AotCompilerOptions} from './compiler_options';\nimport {GeneratedFile} from './generated_file';\nimport {LazyRoute, listLazyRoutes, parseLazyRoute} from './lazy_routes';\nimport {PartialModule} from './partial_module';\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\nimport {StaticSymbolResolver} from './static_symbol_resolver';\nimport {createForJitStub, serializeSummaries} from './summary_serializer';\nimport {ngfactoryFilePath, normalizeGenFileSuffix, splitTypescriptSuffix, summaryFileName, summaryForJitFileName} from './util';\n\nconst enum StubEmitFlags { Basic = 1 << 0, TypeCheck = 1 << 1, All = TypeCheck | Basic }\n\nexport class AotCompiler {\n  private _templateAstCache =\n      new Map<StaticSymbol, {template: TemplateAst[], pipes: CompilePipeSummary[]}>();\n  private _analyzedFiles = new Map<string, NgAnalyzedFile>();\n  private _analyzedFilesForInjectables = new Map<string, NgAnalyzedFileWithInjectables>();\n\n  constructor(\n      private _config: CompilerConfig, private _options: AotCompilerOptions,\n      private _host: AotCompilerHost, readonly reflector: StaticReflector,\n      private _metadataResolver: CompileMetadataResolver, private _templateParser: TemplateParser,\n      private _styleCompiler: StyleCompiler, private _viewCompiler: ViewCompiler,\n      private _typeCheckCompiler: TypeCheckCompiler, private _ngModuleCompiler: NgModuleCompiler,\n      private _injectableCompiler: InjectableCompiler, private _outputEmitter: OutputEmitter,\n      private _summaryResolver: SummaryResolver<StaticSymbol>,\n      private _symbolResolver: StaticSymbolResolver) {}\n\n  clearCache() { this._metadataResolver.clearCache(); }\n\n  analyzeModulesSync(rootFiles: string[]): NgAnalyzedModules {\n    const analyzeResult = analyzeAndValidateNgModules(\n        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n    analyzeResult.ngModules.forEach(\n        ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n            ngModule.type.reference, true));\n    return analyzeResult;\n  }\n\n  analyzeModulesAsync(rootFiles: string[]): Promise<NgAnalyzedModules> {\n    const analyzeResult = analyzeAndValidateNgModules(\n        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n    return Promise\n        .all(analyzeResult.ngModules.map(\n            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                ngModule.type.reference, false)))\n        .then(() => analyzeResult);\n  }\n\n  private _analyzeFile(fileName: string): NgAnalyzedFile {\n    let analyzedFile = this._analyzedFiles.get(fileName);\n    if (!analyzedFile) {\n      analyzedFile =\n          analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n      this._analyzedFiles.set(fileName, analyzedFile);\n    }\n    return analyzedFile;\n  }\n\n  private _analyzeFileForInjectables(fileName: string): NgAnalyzedFileWithInjectables {\n    let analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n    if (!analyzedFile) {\n      analyzedFile = analyzeFileForInjectables(\n          this._host, this._symbolResolver, this._metadataResolver, fileName);\n      this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n    }\n    return analyzedFile;\n  }\n\n  findGeneratedFileNames(fileName: string): string[] {\n    const genFileNames: string[] = [];\n    const file = this._analyzeFile(fileName);\n    // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n    // or a reference to a non source file.\n    // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n    // Only do this for StubEmitFlags.Basic, as adding a type check block\n    // does not change this file (as we generate type check blocks based on NgModules).\n    if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n        file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n      genFileNames.push(ngfactoryFilePath(file.fileName, true));\n      if (this._options.enableSummariesForJit) {\n        genFileNames.push(summaryForJitFileName(file.fileName, true));\n      }\n    }\n    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n    file.directives.forEach((dirSymbol) => {\n      const compMeta =\n          this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol) !.metadata;\n      if (!compMeta.isComponent) {\n        return;\n      }\n      // Note: compMeta is a component and therefore template is non null.\n      compMeta.template !.styleUrls.forEach((styleUrl) => {\n        const normalizedUrl = this._host.resourceNameToFileName(styleUrl, file.fileName);\n        if (!normalizedUrl) {\n          throw syntaxError(`Couldn't resolve resource ${styleUrl} relative to ${file.fileName}`);\n        }\n        const needsShim = (compMeta.template !.encapsulation ||\n                           this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n        genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n        if (this._options.allowEmptyCodegenFiles) {\n          genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n        }\n      });\n    });\n    return genFileNames;\n  }\n\n  emitBasicStub(genFileName: string, originalFileName?: string): GeneratedFile {\n    const outputCtx = this._createOutputContext(genFileName);\n    if (genFileName.endsWith('.ngfactory.ts')) {\n      if (!originalFileName) {\n        throw new Error(\n            `Assertion error: require the original file for .ngfactory.ts stubs. File: ${genFileName}`);\n      }\n      const originalFile = this._analyzeFile(originalFileName);\n      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.Basic);\n    } else if (genFileName.endsWith('.ngsummary.ts')) {\n      if (this._options.enableSummariesForJit) {\n        if (!originalFileName) {\n          throw new Error(\n              `Assertion error: require the original file for .ngsummary.ts stubs. File: ${genFileName}`);\n        }\n        const originalFile = this._analyzeFile(originalFileName);\n        _createEmptyStub(outputCtx);\n        originalFile.ngModules.forEach(ngModule => {\n          // create exports that user code can reference\n          createForJitStub(outputCtx, ngModule.type.reference);\n        });\n      }\n    } else if (genFileName.endsWith('.ngstyle.ts')) {\n      _createEmptyStub(outputCtx);\n    }\n    // Note: for the stubs, we don't need a property srcFileUrl,\n    // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n    // correct srcFileUrl.\n    // This is good as e.g. for .ngstyle.ts files we can't derive\n    // the url of components based on the genFileUrl.\n    return this._codegenSourceModule('unknown', outputCtx);\n  }\n\n  emitTypeCheckStub(genFileName: string, originalFileName: string): GeneratedFile|null {\n    const originalFile = this._analyzeFile(originalFileName);\n    const outputCtx = this._createOutputContext(genFileName);\n    if (genFileName.endsWith('.ngfactory.ts')) {\n      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.TypeCheck);\n    }\n    return outputCtx.statements.length > 0 ?\n        this._codegenSourceModule(originalFile.fileName, outputCtx) :\n        null;\n  }\n\n  loadFilesAsync(fileNames: string[], tsFiles: string[]): Promise<\n      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]}> {\n    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n    const loadingPromises: Promise<NgAnalyzedModules>[] = [];\n    files.forEach(\n        file => file.ngModules.forEach(\n            ngModule =>\n                loadingPromises.push(this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                    ngModule.type.reference, false))));\n    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n    return Promise.all(loadingPromises).then(_ => ({\n                                               analyzedModules: mergeAndValidateNgFiles(files),\n                                               analyzedInjectables: analyzedInjectables,\n                                             }));\n  }\n\n  loadFilesSync(fileNames: string[], tsFiles: string[]):\n      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]} {\n    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n    files.forEach(\n        file => file.ngModules.forEach(\n            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                ngModule.type.reference, true)));\n    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n    return {\n      analyzedModules: mergeAndValidateNgFiles(files),\n      analyzedInjectables: analyzedInjectables,\n    };\n  }\n\n  private _createNgFactoryStub(\n      outputCtx: OutputContext, file: NgAnalyzedFile, emitFlags: StubEmitFlags) {\n    let componentId = 0;\n    file.ngModules.forEach((ngModuleMeta, ngModuleIndex) => {\n      // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n      // so we don't change the .ngfactory file too much when adding the type-check block.\n\n      // create exports that user code can reference\n      this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n\n      // add references to the symbols from the metadata.\n      // These can be used by the type check block for components,\n      // and they also cause TypeScript to include these files into the program too,\n      // which will make them part of the analyzedFiles.\n      const externalReferences: StaticSymbol[] = [\n        // Add references that are available from all the modules and imports.\n        ...ngModuleMeta.transitiveModule.directives.map(d => d.reference),\n        ...ngModuleMeta.transitiveModule.pipes.map(d => d.reference),\n        ...ngModuleMeta.importedModules.map(m => m.type.reference),\n        ...ngModuleMeta.exportedModules.map(m => m.type.reference),\n\n        // Add references that might be inserted by the template compiler.\n        ...this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]),\n      ];\n\n      const externalReferenceVars = new Map<any, string>();\n      externalReferences.forEach((ref, typeIndex) => {\n        externalReferenceVars.set(ref, `_decl${ngModuleIndex}_${typeIndex}`);\n      });\n      externalReferenceVars.forEach((varName, reference) => {\n        outputCtx.statements.push(\n            o.variable(varName)\n                .set(o.NULL_EXPR.cast(o.DYNAMIC_TYPE))\n                .toDeclStmt(o.expressionType(outputCtx.importExpr(\n                    reference, /* typeParams */ null, /* useSummaries */ false))));\n      });\n\n      if (emitFlags & StubEmitFlags.TypeCheck) {\n        // add the type-check block for all components of the NgModule\n        ngModuleMeta.declaredDirectives.forEach((dirId) => {\n          const compMeta = this._metadataResolver.getDirectiveMetadata(dirId.reference);\n          if (!compMeta.isComponent) {\n            return;\n          }\n          componentId++;\n          this._createTypeCheckBlock(\n              outputCtx, `${compMeta.type.reference.name}_Host_${componentId}`, ngModuleMeta,\n              this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type],\n              externalReferenceVars);\n          this._createTypeCheckBlock(\n              outputCtx, `${compMeta.type.reference.name}_${componentId}`, ngModuleMeta, compMeta,\n              ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n        });\n      }\n    });\n\n    if (outputCtx.statements.length === 0) {\n      _createEmptyStub(outputCtx);\n    }\n  }\n\n  private _externalIdentifierReferences(references: o.ExternalReference[]): StaticSymbol[] {\n    const result: StaticSymbol[] = [];\n    for (let reference of references) {\n      const token = createTokenForExternalReference(this.reflector, reference);\n      if (token.identifier) {\n        result.push(token.identifier.reference);\n      }\n    }\n    return result;\n  }\n\n  private _createTypeCheckBlock(\n      ctx: OutputContext, componentId: string, moduleMeta: CompileNgModuleMetadata,\n      compMeta: CompileDirectiveMetadata, directives: CompileIdentifierMetadata[],\n      externalReferenceVars: Map<any, string>) {\n    const {template: parsedTemplate, pipes: usedPipes} =\n        this._parseTemplate(compMeta, moduleMeta, directives);\n    ctx.statements.push(...this._typeCheckCompiler.compileComponent(\n        componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx));\n  }\n\n  emitMessageBundle(analyzeResult: NgAnalyzedModules, locale: string|null): MessageBundle {\n    const errors: ParseError[] = [];\n    const htmlParser = new HtmlParser();\n\n    // TODO(vicb): implicit tags & attributes\n    const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n\n    analyzeResult.files.forEach(file => {\n      const compMetas: CompileDirectiveMetadata[] = [];\n      file.directives.forEach(directiveType => {\n        const dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\n        if (dirMeta && dirMeta.isComponent) {\n          compMetas.push(dirMeta);\n        }\n      });\n      compMetas.forEach(compMeta => {\n        const html = compMeta.template !.template !;\n        // Template URL points to either an HTML or TS file depending on whether\n        // the file is used with `templateUrl:` or `template:`, respectively.\n        const templateUrl = compMeta.template !.templateUrl !;\n        const interpolationConfig =\n            InterpolationConfig.fromArray(compMeta.template !.interpolation);\n        errors.push(...messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig) !);\n      });\n    });\n\n    if (errors.length) {\n      throw new Error(errors.map(e => e.toString()).join('\\n'));\n    }\n\n    return messageBundle;\n  }\n\n  emitAllPartialModules(\n      {ngModuleByPipeOrDirective, files}: NgAnalyzedModules,\n      r3Files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n    const contextMap = new Map<string, OutputContext>();\n\n    const getContext = (fileName: string): OutputContext => {\n      if (!contextMap.has(fileName)) {\n        contextMap.set(fileName, this._createOutputContext(fileName));\n      }\n      return contextMap.get(fileName) !;\n    };\n\n    files.forEach(\n        file => this._compilePartialModule(\n            file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules,\n            file.injectables, getContext(file.fileName)));\n    r3Files.forEach(\n        file => this._compileShallowModules(\n            file.fileName, file.shallowModules, getContext(file.fileName)));\n\n    return Array.from(contextMap.values())\n        .map(context => ({\n               fileName: context.genFilePath,\n               statements: [...context.constantPool.statements, ...context.statements],\n             }));\n  }\n\n  private _compileShallowModules(\n      fileName: string, shallowModules: CompileShallowModuleMetadata[],\n      context: OutputContext): void {\n    shallowModules.forEach(module => compileR3Module(context, module, this._injectableCompiler));\n  }\n\n  private _compilePartialModule(\n      fileName: string, ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>,\n      directives: StaticSymbol[], pipes: StaticSymbol[], ngModules: CompileNgModuleMetadata[],\n      injectables: CompileInjectableMetadata[], context: OutputContext): void {\n    const errors: ParseError[] = [];\n\n    const schemaRegistry = new DomElementSchemaRegistry();\n    const hostBindingParser = new BindingParser(\n        this._templateParser.expressionParser, DEFAULT_INTERPOLATION_CONFIG, schemaRegistry, [],\n        errors);\n\n    // Process all components and directives\n    directives.forEach(directiveType => {\n      const directiveMetadata = this._metadataResolver.getDirectiveMetadata(directiveType);\n      if (directiveMetadata.isComponent) {\n        const module = ngModuleByPipeOrDirective.get(directiveType) !;\n        module ||\n            error(\n                `Cannot determine the module for component '${identifierName(directiveMetadata.type)}'`);\n\n        let htmlAst = directiveMetadata.template !.htmlAst !;\n        const preserveWhitespaces = directiveMetadata !.template !.preserveWhitespaces;\n\n        if (!preserveWhitespaces) {\n          htmlAst = removeWhitespaces(htmlAst);\n        }\n        const render3Ast = htmlAstToRender3Ast(htmlAst.rootNodes, hostBindingParser);\n\n        // Map of StaticType by directive selectors\n        const directiveTypeBySel = new Map<string, any>();\n\n        const directives = module.transitiveModule.directives.map(\n            dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n\n        directives.forEach(directive => {\n          if (directive.selector) {\n            directiveTypeBySel.set(directive.selector, directive.type.reference);\n          }\n        });\n\n        // Map of StaticType by pipe names\n        const pipeTypeByName = new Map<string, any>();\n\n        const pipes = module.transitiveModule.pipes.map(\n            pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n\n        pipes.forEach(pipe => { pipeTypeByName.set(pipe.name, pipe.type.reference); });\n\n        compileR3Component(\n            context, directiveMetadata, render3Ast, this.reflector, hostBindingParser,\n            directiveTypeBySel, pipeTypeByName);\n      } else {\n        compileR3Directive(context, directiveMetadata, this.reflector, hostBindingParser);\n      }\n    });\n\n    pipes.forEach(pipeType => {\n      const pipeMetadata = this._metadataResolver.getPipeMetadata(pipeType);\n      if (pipeMetadata) {\n        compileR3Pipe(context, pipeMetadata, this.reflector);\n      }\n    });\n\n    injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\n  }\n\n  emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n    // Using reduce like this is a select many pattern (where map is a select pattern)\n    return files.reduce<PartialModule[]>((r, file) => {\n      r.push(...this._emitPartialModule2(file.fileName, file.injectables));\n      return r;\n    }, []);\n  }\n\n  private _emitPartialModule2(fileName: string, injectables: CompileInjectableMetadata[]):\n      PartialModule[] {\n    const context = this._createOutputContext(fileName);\n\n    injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\n\n    if (context.statements && context.statements.length > 0) {\n      return [{fileName, statements: [...context.constantPool.statements, ...context.statements]}];\n    }\n    return [];\n  }\n\n  emitAllImpls(analyzeResult: NgAnalyzedModules): GeneratedFile[] {\n    const {ngModuleByPipeOrDirective, files} = analyzeResult;\n    const sourceModules = files.map(\n        file => this._compileImplFile(\n            file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules,\n            file.injectables));\n    return flatten(sourceModules);\n  }\n\n  private _compileImplFile(\n      srcFileUrl: string, ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>,\n      directives: StaticSymbol[], pipes: StaticSymbol[], ngModules: CompileNgModuleMetadata[],\n      injectables: CompileInjectableMetadata[]): GeneratedFile[] {\n    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n    const generatedFiles: GeneratedFile[] = [];\n\n    const outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n\n    generatedFiles.push(\n        ...this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\n\n    // compile all ng modules\n    ngModules.forEach((ngModuleMeta) => this._compileModule(outputCtx, ngModuleMeta));\n\n    // compile components\n    directives.forEach((dirType) => {\n      const compMeta = this._metadataResolver.getDirectiveMetadata(<any>dirType);\n      if (!compMeta.isComponent) {\n        return;\n      }\n      const ngModule = ngModuleByPipeOrDirective.get(dirType);\n      if (!ngModule) {\n        throw new Error(\n            `Internal Error: cannot determine the module for component ${identifierName(compMeta.type)}!`);\n      }\n\n      // compile styles\n      const componentStylesheet = this._styleCompiler.compileComponent(outputCtx, compMeta);\n      // Note: compMeta is a component and therefore template is non null.\n      compMeta.template !.externalStylesheets.forEach((stylesheetMeta) => {\n        // Note: fill non shim and shim style files as they might\n        // be shared by component with and without ViewEncapsulation.\n        const shim = this._styleCompiler.needsStyleShim(compMeta);\n        generatedFiles.push(\n            this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n        if (this._options.allowEmptyCodegenFiles) {\n          generatedFiles.push(\n              this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n        }\n      });\n\n      // compile components\n      const compViewVars = this._compileComponent(\n          outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet,\n          fileSuffix);\n      this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n    });\n    if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n      const srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n      generatedFiles.unshift(srcModule);\n    }\n    return generatedFiles;\n  }\n\n  private _createSummary(\n      srcFileName: string, directives: StaticSymbol[], pipes: StaticSymbol[],\n      ngModules: CompileNgModuleMetadata[], injectables: CompileInjectableMetadata[],\n      ngFactoryCtx: OutputContext): GeneratedFile[] {\n    const symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n                                .map(symbol => this._symbolResolver.resolveSymbol(symbol));\n    const typeData: {\n      summary: CompileTypeSummary,\n      metadata: CompileNgModuleMetadata | CompileDirectiveMetadata | CompilePipeMetadata |\n          CompileTypeMetadata\n    }[] =\n        [\n          ...ngModules.map(\n              meta => ({\n                summary: this._metadataResolver.getNgModuleSummary(meta.type.reference) !,\n                metadata: this._metadataResolver.getNgModuleMetadata(meta.type.reference) !\n              })),\n          ...directives.map(ref => ({\n                              summary: this._metadataResolver.getDirectiveSummary(ref) !,\n                              metadata: this._metadataResolver.getDirectiveMetadata(ref) !\n                            })),\n          ...pipes.map(ref => ({\n                         summary: this._metadataResolver.getPipeSummary(ref) !,\n                         metadata: this._metadataResolver.getPipeMetadata(ref) !\n                       })),\n          ...injectables.map(\n              ref => ({\n                summary: this._metadataResolver.getInjectableSummary(ref.symbol) !,\n                metadata: this._metadataResolver.getInjectableSummary(ref.symbol) !.type\n              }))\n        ];\n    const forJitOutputCtx = this._options.enableSummariesForJit ?\n        this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n        null;\n    const {json, exportAs} = serializeSummaries(\n        srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries,\n        typeData);\n    exportAs.forEach((entry) => {\n      ngFactoryCtx.statements.push(\n          o.variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n            o.StmtModifier.Exported\n          ]));\n    });\n    const summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n    const result = [summaryJson];\n    if (forJitOutputCtx) {\n      result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n    }\n    return result;\n  }\n\n  private _compileModule(outputCtx: OutputContext, ngModule: CompileNgModuleMetadata): void {\n    const providers: CompileProviderMetadata[] = [];\n\n    if (this._options.locale) {\n      const normalizedLocale = this._options.locale.replace(/_/g, '-');\n      providers.push({\n        token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),\n        useValue: normalizedLocale,\n      });\n    }\n\n    if (this._options.i18nFormat) {\n      providers.push({\n        token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),\n        useValue: this._options.i18nFormat\n      });\n    }\n\n    this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n  }\n\n  private _compileComponentFactory(\n      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n      ngModule: CompileNgModuleMetadata, fileSuffix: string): void {\n    const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n    const hostViewFactoryVar =\n        this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n    const compFactoryVar = componentFactoryName(compMeta.type.reference);\n    const inputsExprs: o.LiteralMapEntry[] = [];\n    for (let propName in compMeta.inputs) {\n      const templateName = compMeta.inputs[propName];\n      // Don't quote so that the key gets minified...\n      inputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n    }\n    const outputsExprs: o.LiteralMapEntry[] = [];\n    for (let propName in compMeta.outputs) {\n      const templateName = compMeta.outputs[propName];\n      // Don't quote so that the key gets minified...\n      outputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n    }\n\n    outputCtx.statements.push(\n        o.variable(compFactoryVar)\n            .set(o.importExpr(Identifiers.createComponentFactory).callFn([\n              o.literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n              o.variable(hostViewFactoryVar), new o.LiteralMapExpr(inputsExprs),\n              new o.LiteralMapExpr(outputsExprs),\n              o.literalArr(\n                  compMeta.template !.ngContentSelectors.map(selector => o.literal(selector)))\n            ]))\n            .toDeclStmt(\n                o.importType(\n                    Identifiers.ComponentFactory,\n                    [o.expressionType(outputCtx.importExpr(compMeta.type.reference)) !],\n                    [o.TypeModifier.Const]),\n                [o.StmtModifier.Final, o.StmtModifier.Exported]));\n  }\n\n  private _compileComponent(\n      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n      ngModule: CompileNgModuleMetadata, directiveIdentifiers: CompileIdentifierMetadata[],\n      componentStyles: CompiledStylesheet|null, fileSuffix: string): ViewCompileResult {\n    const {template: parsedTemplate, pipes: usedPipes} =\n        this._parseTemplate(compMeta, ngModule, directiveIdentifiers);\n    const stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);\n    const viewResult = this._viewCompiler.compileComponent(\n        outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n    if (componentStyles) {\n      _resolveStyleStatements(\n          this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta),\n          fileSuffix);\n    }\n    return viewResult;\n  }\n\n  private _parseTemplate(\n      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata,\n      directiveIdentifiers: CompileIdentifierMetadata[]):\n      {template: TemplateAst[], pipes: CompilePipeSummary[]} {\n    if (this._templateAstCache.has(compMeta.type.reference)) {\n      return this._templateAstCache.get(compMeta.type.reference) !;\n    }\n    const preserveWhitespaces = compMeta !.template !.preserveWhitespaces;\n    const directives =\n        directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n    const pipes = ngModule.transitiveModule.pipes.map(\n        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n    const result = this._templateParser.parse(\n        compMeta, compMeta.template !.htmlAst !, directives, pipes, ngModule.schemas,\n        templateSourceUrl(ngModule.type, compMeta, compMeta.template !), preserveWhitespaces);\n    this._templateAstCache.set(compMeta.type.reference, result);\n    return result;\n  }\n\n  private _createOutputContext(genFilePath: string): OutputContext {\n    const importExpr =\n        (symbol: StaticSymbol, typeParams: o.Type[] | null = null,\n         useSummaries: boolean = true) => {\n          if (!(symbol instanceof StaticSymbol)) {\n            throw new Error(`Internal error: unknown identifier ${JSON.stringify(symbol)}`);\n          }\n          const arity = this._symbolResolver.getTypeArity(symbol) || 0;\n          const {filePath, name, members} =\n              this._symbolResolver.getImportAs(symbol, useSummaries) || symbol;\n          const importModule = this._fileNameToModuleName(filePath, genFilePath);\n\n          // It should be good enough to compare filePath to genFilePath and if they are equal\n          // there is a self reference. However, ngfactory files generate to .ts but their\n          // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n          // and is tracked by #17705.\n          const selfReference = this._fileNameToModuleName(genFilePath, genFilePath);\n          const moduleName = importModule === selfReference ? null : importModule;\n\n          // If we are in a type expression that refers to a generic type then supply\n          // the required type parameters. If there were not enough type parameters\n          // supplied, supply any as the type. Outside a type expression the reference\n          // should not supply type parameters and be treated as a simple value reference\n          // to the constructor function itself.\n          const suppliedTypeParams = typeParams || [];\n          const missingTypeParamsCount = arity - suppliedTypeParams.length;\n          const allTypeParams =\n              suppliedTypeParams.concat(new Array(missingTypeParamsCount).fill(o.DYNAMIC_TYPE));\n          return members.reduce(\n              (expr, memberName) => expr.prop(memberName),\n              <o.Expression>o.importExpr(\n                  new o.ExternalReference(moduleName, name, null), allTypeParams));\n        };\n\n    return {statements: [], genFilePath, importExpr, constantPool: new ConstantPool()};\n  }\n\n  private _fileNameToModuleName(importedFilePath: string, containingFilePath: string): string {\n    return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n        this._symbolResolver.getKnownModuleName(importedFilePath) ||\n        this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n  }\n\n  private _codegenStyles(\n      srcFileUrl: string, compMeta: CompileDirectiveMetadata,\n      stylesheetMetadata: CompileStylesheetMetadata, isShimmed: boolean,\n      fileSuffix: string): GeneratedFile {\n    const outputCtx = this._createOutputContext(\n        _stylesModuleUrl(stylesheetMetadata.moduleUrl !, isShimmed, fileSuffix));\n    const compiledStylesheet =\n        this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n    _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n    return this._codegenSourceModule(srcFileUrl, outputCtx);\n  }\n\n  private _codegenSourceModule(srcFileUrl: string, ctx: OutputContext): GeneratedFile {\n    return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n  }\n\n  listLazyRoutes(entryRoute?: string, analyzedModules?: NgAnalyzedModules): LazyRoute[] {\n    const self = this;\n    if (entryRoute) {\n      const symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n      return visitLazyRoute(symbol);\n    } else if (analyzedModules) {\n      const allLazyRoutes: LazyRoute[] = [];\n      for (const ngModule of analyzedModules.ngModules) {\n        const lazyRoutes = listLazyRoutes(ngModule, this.reflector);\n        for (const lazyRoute of lazyRoutes) {\n          allLazyRoutes.push(lazyRoute);\n        }\n      }\n      return allLazyRoutes;\n    } else {\n      throw new Error(`Either route or analyzedModules has to be specified!`);\n    }\n\n    function visitLazyRoute(\n        symbol: StaticSymbol, seenRoutes = new Set<StaticSymbol>(),\n        allLazyRoutes: LazyRoute[] = []): LazyRoute[] {\n      // Support pointing to default exports, but stop recursing there,\n      // as the StaticReflector does not yet support default exports.\n      if (seenRoutes.has(symbol) || !symbol.name) {\n        return allLazyRoutes;\n      }\n      seenRoutes.add(symbol);\n      const lazyRoutes = listLazyRoutes(\n          self._metadataResolver.getNgModuleMetadata(symbol, true) !, self.reflector);\n      for (const lazyRoute of lazyRoutes) {\n        allLazyRoutes.push(lazyRoute);\n        visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n      }\n      return allLazyRoutes;\n    }\n  }\n}\n\nfunction _createEmptyStub(outputCtx: OutputContext) {\n  // Note: We need to produce at least one import statement so that\n  // TypeScript knows that the file is an es6 module. Otherwise our generated\n  // exports / imports won't be emitted properly by TypeScript.\n  outputCtx.statements.push(o.importExpr(Identifiers.ComponentFactory).toStmt());\n}\n\n\nfunction _resolveStyleStatements(\n    symbolResolver: StaticSymbolResolver, compileResult: CompiledStylesheet, needsShim: boolean,\n    fileSuffix: string): void {\n  compileResult.dependencies.forEach((dep) => {\n    dep.setValue(symbolResolver.getStaticSymbol(\n        _stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n  });\n}\n\nfunction _stylesModuleUrl(stylesheetUrl: string, shim: boolean, suffix: string): string {\n  return `${stylesheetUrl}${shim ? '.shim' : ''}.ngstyle${suffix}`;\n}\n\nexport interface NgAnalyzedModules {\n  ngModules: CompileNgModuleMetadata[];\n  ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;\n  files: NgAnalyzedFile[];\n  symbolsMissingModule?: StaticSymbol[];\n}\n\nexport interface NgAnalyzedFileWithInjectables {\n  fileName: string;\n  injectables: CompileInjectableMetadata[];\n  shallowModules: CompileShallowModuleMetadata[];\n}\n\nexport interface NgAnalyzedFile {\n  fileName: string;\n  directives: StaticSymbol[];\n  pipes: StaticSymbol[];\n  ngModules: CompileNgModuleMetadata[];\n  injectables: CompileInjectableMetadata[];\n  exportsNonSourceFiles: boolean;\n}\n\nexport interface NgAnalyzeModulesHost { isSourceFile(filePath: string): boolean; }\n\nexport function analyzeNgModules(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n  const files = _analyzeFilesIncludingNonProgramFiles(\n      fileNames, host, staticSymbolResolver, metadataResolver);\n  return mergeAnalyzedFiles(files);\n}\n\nexport function analyzeAndValidateNgModules(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n  return validateAnalyzedModules(\n      analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\n\nfunction validateAnalyzedModules(analyzedModules: NgAnalyzedModules): NgAnalyzedModules {\n  if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n    const messages = analyzedModules.symbolsMissingModule.map(\n        s =>\n            `Cannot determine the module for class ${s.name} in ${s.filePath}! Add ${s.name} to the NgModule to fix it.`);\n    throw syntaxError(messages.join('\\n'));\n  }\n  return analyzedModules;\n}\n\n// Analyzes all of the program files,\n// including files that are not part of the program\n// but are referenced by an NgModule.\nfunction _analyzeFilesIncludingNonProgramFiles(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedFile[] {\n  const seenFiles = new Set<string>();\n  const files: NgAnalyzedFile[] = [];\n\n  const visitFile = (fileName: string) => {\n    if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n      return false;\n    }\n    seenFiles.add(fileName);\n    const analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n    files.push(analyzedFile);\n    analyzedFile.ngModules.forEach(ngModule => {\n      ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));\n    });\n  };\n  fileNames.forEach((fileName) => visitFile(fileName));\n  return files;\n}\n\nexport function analyzeFile(\n    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFile {\n  const directives: StaticSymbol[] = [];\n  const pipes: StaticSymbol[] = [];\n  const injectables: CompileInjectableMetadata[] = [];\n  const ngModules: CompileNgModuleMetadata[] = [];\n  const hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n  let exportsNonSourceFiles = false;\n  // Don't analyze .d.ts files that have no decorators as a shortcut\n  // to speed up the analysis. This prevents us from\n  // resolving the references in these files.\n  // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n  // which is not the case when .d.ts files are treated as input files.\n  if (!fileName.endsWith('.d.ts') || hasDecorators) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      const symbolMeta = resolvedSymbol.metadata;\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n      let isNgSymbol = false;\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isDirective(symbol)) {\n          isNgSymbol = true;\n          directives.push(symbol);\n        } else if (metadataResolver.isPipe(symbol)) {\n          isNgSymbol = true;\n          pipes.push(symbol);\n        } else if (metadataResolver.isNgModule(symbol)) {\n          const ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n          if (ngModule) {\n            isNgSymbol = true;\n            ngModules.push(ngModule);\n          }\n        } else if (metadataResolver.isInjectable(symbol)) {\n          isNgSymbol = true;\n          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        }\n      }\n      if (!isNgSymbol) {\n        exportsNonSourceFiles =\n            exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n      }\n    });\n  }\n  return {\n      fileName, directives, pipes, ngModules, injectables, exportsNonSourceFiles,\n  };\n}\n\nexport function analyzeFileForInjectables(\n    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFileWithInjectables {\n  const injectables: CompileInjectableMetadata[] = [];\n  const shallowModules: CompileShallowModuleMetadata[] = [];\n  if (staticSymbolResolver.hasDecorators(fileName)) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      const symbolMeta = resolvedSymbol.metadata;\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isInjectable(symbol)) {\n          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        } else if (metadataResolver.isNgModule(symbol)) {\n          const module = metadataResolver.getShallowModuleMetadata(symbol);\n          if (module) {\n            shallowModules.push(module);\n          }\n        }\n      }\n    });\n  }\n  return {fileName, injectables, shallowModules};\n}\n\nfunction isValueExportingNonSourceFile(host: NgAnalyzeModulesHost, metadata: any): boolean {\n  let exportsNonSourceFiles = false;\n\n  class Visitor implements ValueVisitor {\n    visitArray(arr: any[], context: any): any { arr.forEach(v => visitValue(v, this, context)); }\n    visitStringMap(map: {[key: string]: any}, context: any): any {\n      Object.keys(map).forEach((key) => visitValue(map[key], this, context));\n    }\n    visitPrimitive(value: any, context: any): any {}\n    visitOther(value: any, context: any): any {\n      if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n        exportsNonSourceFiles = true;\n      }\n    }\n  }\n\n  visitValue(metadata, new Visitor(), null);\n  return exportsNonSourceFiles;\n}\n\nexport function mergeAnalyzedFiles(analyzedFiles: NgAnalyzedFile[]): NgAnalyzedModules {\n  const allNgModules: CompileNgModuleMetadata[] = [];\n  const ngModuleByPipeOrDirective = new Map<StaticSymbol, CompileNgModuleMetadata>();\n  const allPipesAndDirectives = new Set<StaticSymbol>();\n\n  analyzedFiles.forEach(af => {\n    af.ngModules.forEach(ngModule => {\n      allNgModules.push(ngModule);\n      ngModule.declaredDirectives.forEach(\n          d => ngModuleByPipeOrDirective.set(d.reference, ngModule));\n      ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));\n    });\n    af.directives.forEach(d => allPipesAndDirectives.add(d));\n    af.pipes.forEach(p => allPipesAndDirectives.add(p));\n  });\n\n  const symbolsMissingModule: StaticSymbol[] = [];\n  allPipesAndDirectives.forEach(ref => {\n    if (!ngModuleByPipeOrDirective.has(ref)) {\n      symbolsMissingModule.push(ref);\n    }\n  });\n  return {\n    ngModules: allNgModules,\n    ngModuleByPipeOrDirective,\n    symbolsMissingModule,\n    files: analyzedFiles\n  };\n}\n\nfunction mergeAndValidateNgFiles(files: NgAnalyzedFile[]): NgAnalyzedModules {\n  return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n"],"sourceRoot":""}