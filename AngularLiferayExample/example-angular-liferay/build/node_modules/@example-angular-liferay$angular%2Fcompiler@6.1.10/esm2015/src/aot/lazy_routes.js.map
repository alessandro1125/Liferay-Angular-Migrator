{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/lazy_routes.ts"],"names":[],"mappings":";;;;;;;;;AAQA,aAAiC,cAAjC,QAAsD,qBAAtD;AAcA,WAAM,SAAA,cAAA,CACF,UADE,EACmC,SADnC,EAC6D;AACjE,cAAM,gBAA6B,EAAnC;AACA,aAAK,MAAM,EAAC,QAAD,EAAW,MAAX,EAAX,IAAiC,WAAW,gBAAX,CAA4B,SAA7D,EAAwE;AACtE,gBAAI,eAAe,SAAS,KAAxB,MAAmC,UAAU,MAAjD,EAAyD;AACvD,sBAAM,eAAe,qBAAqB,SAAS,QAA9B,CAArB;AACA,qBAAK,MAAM,KAAX,IAAoB,YAApB,EAAkC;AAChC,kCAAc,IAAd,CAAmB,eAAe,KAAf,EAAsB,SAAtB,EAAiC,OAAO,SAAxC,CAAnB;AACD;AACF;AACF;AACD,eAAO,aAAP;AACD;AAED,aAAA,oBAAA,CAA8B,MAA9B,EAAgE,SAAmB,EAAnF,EAAqF;AACnF,YAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,mBAAO,IAAP,CAAY,MAAZ;AACD,SAFD,MAEO,IAAI,MAAM,OAAN,CAAc,MAAd,CAAJ,EAA2B;AAChC,iBAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AAC1B,qCAAqB,KAArB,EAA4B,MAA5B;AACD;AACF,SAJM,MAIA,IAAI,OAAO,YAAX,EAAyB;AAC9B,iCAAqB,OAAO,YAA5B,EAA0C,MAA1C;AACD,SAFM,MAEA,IAAI,OAAO,QAAX,EAAqB;AAC1B,iCAAqB,OAAO,QAA5B,EAAsC,MAAtC;AACD;AACD,eAAO,MAAP;AACD;AAED,WAAM,SAAA,cAAA,CACF,KADE,EACa,SADb,EACyC,MADzC,EAC8D;AAClE,cAAM,CAAC,SAAD,EAAY,SAAZ,IAAyB,MAAM,KAAN,CAAY,GAAZ,CAA/B;AACA,cAAM,mBAAmB,UAAU,wBAAV,CACrB;AACE,wBAAY,SADd;AAEE,kBAAM;AAFR,SADqB,EAKrB,SAAS,OAAO,QAAhB,GAA2B,SALN,CAAzB;AAMA,eAAO,EAAC,OAAO,KAAR,EAAe,QAAQ,UAAU,gBAAjC,EAAmD,gBAAnD,EAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileNgModuleMetadata, tokenReference} from '../compile_metadata';\nimport {Route} from '../core';\nimport {CompileMetadataResolver} from '../metadata_resolver';\n\nimport {AotCompilerHost} from './compiler_host';\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\n\nexport interface LazyRoute {\n  module: StaticSymbol;\n  route: string;\n  referencedModule: StaticSymbol;\n}\n\nexport function listLazyRoutes(\n    moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[] {\n  const allLazyRoutes: LazyRoute[] = [];\n  for (const {provider, module} of moduleMeta.transitiveModule.providers) {\n    if (tokenReference(provider.token) === reflector.ROUTES) {\n      const loadChildren = _collectLoadChildren(provider.useValue);\n      for (const route of loadChildren) {\n        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n      }\n    }\n  }\n  return allLazyRoutes;\n}\n\nfunction _collectLoadChildren(routes: string | Route | Route[], target: string[] = []): string[] {\n  if (typeof routes === 'string') {\n    target.push(routes);\n  } else if (Array.isArray(routes)) {\n    for (const route of routes) {\n      _collectLoadChildren(route, target);\n    }\n  } else if (routes.loadChildren) {\n    _collectLoadChildren(routes.loadChildren, target);\n  } else if (routes.children) {\n    _collectLoadChildren(routes.children, target);\n  }\n  return target;\n}\n\nexport function parseLazyRoute(\n    route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute {\n  const [routePath, routeName] = route.split('#');\n  const referencedModule = reflector.resolveExternalReference(\n      {\n        moduleName: routePath,\n        name: routeName,\n      },\n      module ? module.filePath : undefined);\n  return {route: route, module: module || referencedModule, referencedModule};\n}\n"],"sourceRoot":""}