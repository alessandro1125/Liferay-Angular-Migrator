{"version":3,"sources":["../../../../../../packages/compiler/src/directive_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from './compile_reflector';\nimport {Component, Directive, Type, createComponent, createContentChild, createContentChildren, createDirective, createHostBinding, createHostListener, createInput, createOutput, createViewChild, createViewChildren} from './core';\nimport {resolveForwardRef, splitAtColon, stringify} from './util';\n\nconst QUERY_METADATA_IDENTIFIERS = [\n  createViewChild,\n  createViewChildren,\n  createContentChild,\n  createContentChildren,\n];\n\n/*\n * Resolve a `Type` for {@link Directive}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nexport class DirectiveResolver {\n  constructor(private _reflector: CompileReflector) {}\n\n  isDirective(type: Type) {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n  }\n\n  /**\n   * Return {@link Directive} for a given `Type`.\n   */\n  resolve(type: Type): Directive;\n  resolve(type: Type, throwIfNotFound: true): Directive;\n  resolve(type: Type, throwIfNotFound: boolean): Directive|null;\n  resolve(type: Type, throwIfNotFound = true): Directive|null {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    if (typeMetadata) {\n      const metadata = findLast(typeMetadata, isDirectiveMetadata);\n      if (metadata) {\n        const propertyMetadata = this._reflector.propMetadata(type);\n        const guards = this._reflector.guards(type);\n        return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n      }\n    }\n\n    if (throwIfNotFound) {\n      throw new Error(`No Directive annotation found on ${stringify(type)}`);\n    }\n\n    return null;\n  }\n\n  private _mergeWithPropertyMetadata(\n      dm: Directive, propertyMetadata: {[key: string]: any[]}, guards: {[key: string]: any},\n      directiveType: Type): Directive {\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n    const host: {[key: string]: string} = {};\n    const queries: {[key: string]: any} = {};\n    Object.keys(propertyMetadata).forEach((propName: string) => {\n      const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\n      if (input) {\n        if (input.bindingPropertyName) {\n          inputs.push(`${propName}: ${input.bindingPropertyName}`);\n        } else {\n          inputs.push(propName);\n        }\n      }\n      const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\n      if (output) {\n        if (output.bindingPropertyName) {\n          outputs.push(`${propName}: ${output.bindingPropertyName}`);\n        } else {\n          outputs.push(propName);\n        }\n      }\n      const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\n      hostBindings.forEach(hostBinding => {\n        if (hostBinding.hostPropertyName) {\n          const startWith = hostBinding.hostPropertyName[0];\n          if (startWith === '(') {\n            throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\n          } else if (startWith === '[') {\n            throw new Error(\n                `@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n          }\n          host[`[${hostBinding.hostPropertyName}]`] = propName;\n        } else {\n          host[`[${propName}]`] = propName;\n        }\n      });\n      const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\n      hostListeners.forEach(hostListener => {\n        const args = hostListener.args || [];\n        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n      });\n      const query = findLast(\n          propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\n      if (query) {\n        queries[propName] = query;\n      }\n    });\n    return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n  }\n\n  private _extractPublicName(def: string) { return splitAtColon(def, [null !, def])[1].trim(); }\n\n  private _dedupeBindings(bindings: string[]): string[] {\n    const names = new Set<string>();\n    const publicNames = new Set<string>();\n    const reversedResult: string[] = [];\n    // go last to first to allow later entries to overwrite previous entries\n    for (let i = bindings.length - 1; i >= 0; i--) {\n      const binding = bindings[i];\n      const name = this._extractPublicName(binding);\n      publicNames.add(name);\n      if (!names.has(name)) {\n        names.add(name);\n        reversedResult.push(binding);\n      }\n    }\n    return reversedResult.reverse();\n  }\n\n  private _merge(\n      directive: Directive, inputs: string[], outputs: string[], host: {[key: string]: string},\n      queries: {[key: string]: any}, guards: {[key: string]: any}, directiveType: Type): Directive {\n    const mergedInputs =\n        this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n    const mergedOutputs =\n        this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n    const mergedHost = directive.host ? {...directive.host, ...host} : host;\n    const mergedQueries = directive.queries ? {...directive.queries, ...queries} : queries;\n    if (createComponent.isTypeOf(directive)) {\n      const comp = directive as Component;\n      return createComponent({\n        selector: comp.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: comp.exportAs,\n        moduleId: comp.moduleId,\n        queries: mergedQueries,\n        changeDetection: comp.changeDetection,\n        providers: comp.providers,\n        viewProviders: comp.viewProviders,\n        entryComponents: comp.entryComponents,\n        template: comp.template,\n        templateUrl: comp.templateUrl,\n        styles: comp.styles,\n        styleUrls: comp.styleUrls,\n        encapsulation: comp.encapsulation,\n        animations: comp.animations,\n        interpolation: comp.interpolation,\n        preserveWhitespaces: directive.preserveWhitespaces,\n      });\n    } else {\n      return createDirective({\n        selector: directive.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: directive.exportAs,\n        queries: mergedQueries,\n        providers: directive.providers, guards\n      });\n    }\n  }\n}\n\nfunction isDirectiveMetadata(type: any): type is Directive {\n  return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\n\nexport function findLast<T>(arr: T[], condition: (value: T) => boolean): T|null {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (condition(arr[i])) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n"],"sourceRoot":""}