{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {escapeRegExp} from '../util';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\n\nexport class SplitInterpolation {\n  constructor(public strings: string[], public expressions: string[], public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  parseAction(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new _ParseAST(\n                    input, location, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  parseSimpleBinding(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, interpolationConfig);\n    const errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n\n  private _parseQuote(input: string|null, location: any): AST|null {\n    if (input == null) return null;\n    const prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n\n  parseTemplateBindings(tplKey: string, tplValue: string, location: any):\n      TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(tplValue);\n    return new _ParseAST(tplValue, location, tokens, tplValue.length, false, this.errors, 0)\n        .parseTemplateBindings(tplKey);\n  }\n\n  parseInterpolation(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split == null) return null;\n\n    const expressions: AST[] = [];\n\n    for (let i = 0; i < split.expressions.length; ++i) {\n      const expressionText = split.expressions[i];\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new _ParseAST(\n                      input, location, tokens, sourceToLex.length, false, this.errors,\n                      split.offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n        new Interpolation(\n            new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions),\n        input, location, this.errors);\n  }\n\n  splitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation\n      |null {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const strings: string[] = [];\n    const expressions: string[] = [];\n    const offsets: number[] = [];\n    let offset = 0;\n    for (let i = 0; i < parts.length; i++) {\n      const part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n            'Blank expressions are not allowed in interpolated strings', input,\n            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n            location);\n        expressions.push('$implict');\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: any): ASTWithSource {\n    return new ASTWithSource(\n        new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input,\n        location, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(\n      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const regexp = _createInterpolateRegExp(interpolationConfig);\n    const parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n          `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n          location);\n    }\n  }\n\n  private _findInterpolationErrorColumn(\n      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n    let errLocation = '';\n    for (let j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ?\n          parts[j] :\n          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: any, public tokens: Token[],\n      public inputLength: number, public parseAction: boolean, private errors: ParserError[],\n      private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token { return this.peek(0); }\n\n  get inputIndex(): number {\n    return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                                               this.inputLength + this.offset;\n  }\n\n  span(start: number) { return new ParseSpan(start, this.inputIndex); }\n\n  advance() { this.index++; }\n\n  optionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n  peekKeywordAs(): boolean { return this.next.isKeywordAs(); }\n\n  expectCharacter(code: number) {\n    if (this.optionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  optionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.optionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  expectIdentifierOrKeyword(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) return new EmptyExpr(this.span(start));\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), exprs);\n  }\n\n  parsePipe(): AST {\n    let result = this.parseExpression();\n    if (this.optionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const name = this.expectIdentifierOrKeyword();\n        const args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST { return this.parseConditional(); }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.optionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    let result = this.parseLogicalAnd();\n    while (this.optionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    let result = this.parseEquality();\n    while (this.optionalOperator('&&')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), '-', result, new LiteralPrimitive(new ParseSpan(start, start), 0));\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n              result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n\n      } else if (this.optionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator('=')) {\n          const value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n\n      } else if (this.optionalOperator('!')) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n    const start = receiver.span.start;\n    const id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                      new MethodCall(span, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * An identifier, a keyword, a string with an optional `-` in between.\n   */\n  expectTemplateBindingKey(): string {\n    let result = '';\n    let operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n\n  // Parses the AST for `<some-tag *tplKey=AST>`\n  parseTemplateBindings(tplKey: string): TemplateBindingParseResult {\n    let firstBinding = true;\n    const bindings: TemplateBinding[] = [];\n    const warnings: string[] = [];\n    do {\n      const start = this.inputIndex;\n      let rawKey: string;\n      let key: string;\n      let isVar: boolean = false;\n      if (firstBinding) {\n        rawKey = key = tplKey;\n        firstBinding = false;\n      } else {\n        isVar = this.peekKeywordLet();\n        if (isVar) this.advance();\n        rawKey = this.expectTemplateBindingKey();\n        key = isVar ? rawKey : tplKey + rawKey[0].toUpperCase() + rawKey.substring(1);\n        this.optionalCharacter(chars.$COLON);\n      }\n\n      let name: string = null !;\n      let expression: ASTWithSource|null = null;\n      if (isVar) {\n        if (this.optionalOperator('=')) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = '\\$implicit';\n        }\n      } else if (this.peekKeywordAs()) {\n        this.advance();  // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey();  // read local var name\n        isVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const start = this.inputIndex;\n        const ast = this.parsePipe();\n        const source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n\n      bindings.push(new TemplateBinding(this.span(start), key, isVar, name, expression));\n      if (this.peekKeywordAs() && !isVar) {\n        const letStart = this.inputIndex;\n        this.advance();                                   // consume `as`\n        const letName = this.expectTemplateBindingKey();  // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, null !));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    } while (this.index < this.tokens.length);\n\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n  // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n  // '}' and ']' as conditional recovery points if one of calling productions is expecting\n  // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n  // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n  // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n  // must be conditional as they must be skipped if none of the calling productions are not\n  // expecting the closing token else we will never make progress in the case of an\n  // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n  // parseChain() is always the root production and it expects a ';'.\n\n  // If a production expects one of these token it increments the corresponding nesting count,\n  // and then decrements it just prior to checking if the token is in the input.\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError(\n            this.next.toString() !, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  static check(ast: AST): string[] {\n    const s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n\n  visitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n"],"sourceRoot":""}