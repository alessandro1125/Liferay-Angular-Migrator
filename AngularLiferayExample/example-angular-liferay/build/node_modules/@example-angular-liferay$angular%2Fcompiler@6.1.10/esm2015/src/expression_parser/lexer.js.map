{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean { return this.type == TokenType.Number; }\n\n  isString(): boolean { return this.type == TokenType.String; }\n\n  isOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n\n  isIdentifier(): boolean { return this.type == TokenType.Identifier; }\n\n  isKeyword(): boolean { return this.type == TokenType.Keyword; }\n\n  isKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n\n  isKeywordAs(): boolean { return this.type == TokenType.Keyword && this.strValue == 'as'; }\n\n  isKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n\n  isKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n\n  isKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n\n  isError(): boolean { return this.type == TokenType.Error; }\n\n  toNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n                                        newIdentifierToken(start, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"],"sourceRoot":""}