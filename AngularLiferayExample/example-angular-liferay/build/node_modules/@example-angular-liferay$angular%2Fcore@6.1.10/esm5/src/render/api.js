Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render/api', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  /**
   * @license
   * Copyright Google Inc. All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   */
  import { InjectionToken } from '../di';
  /**
   * @deprecated Use `RendererType2` (and `Renderer2`) instead.
   */
  var RenderComponentType = /** @class */function () {
    function RenderComponentType(id, templateUrl, slotCount, encapsulation, styles, animations) {
      this.id = id;
      this.templateUrl = templateUrl;
      this.slotCount = slotCount;
      this.encapsulation = encapsulation;
      this.styles = styles;
      this.animations = animations;
    }
    return RenderComponentType;
  }();
  export { RenderComponentType };
  /**
   * @deprecated Debug info is handeled internally in the view engine now.
   */
  var RenderDebugInfo = /** @class */function () {
    function RenderDebugInfo() {}
    return RenderDebugInfo;
  }();
  export { RenderDebugInfo };
  /**
   * @deprecated Use the `Renderer2` instead.
   */
  var Renderer = /** @class */function () {
    function Renderer() {}
    return Renderer;
  }();
  export { Renderer };
  export var Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
  /**
   * Injectable service that provides a low-level interface for modifying the UI.
   *
   * Use this service to bypass Angular's templating and make custom UI changes that can't be
   * expressed declaratively. For example if you need to set a property or an attribute whose name is
   * not statically known, use {@link Renderer#setElementProperty setElementProperty} or
   * {@link Renderer#setElementAttribute setElementAttribute} respectively.
   *
   * If you are implementing a custom renderer, you must implement this interface.
   *
   * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
   *
   * @deprecated Use `RendererFactory2` instead.
   */
  var RootRenderer = /** @class */function () {
    function RootRenderer() {}
    return RootRenderer;
  }();
  export { RootRenderer };
  /**
   * Creates and initializes a custom renderer that implements the `Renderer2` base class.
   *
   * @experimental
   */
  var RendererFactory2 = /** @class */function () {
    function RendererFactory2() {}
    return RendererFactory2;
  }();
  export { RendererFactory2 };
  /**
   * Flags for renderer-specific style modifiers.
   * @experimental
   */
  export var RendererStyleFlags2;
  (function (RendererStyleFlags2) {
    /**
     * Marks a style as important.
     */
    RendererStyleFlags2[RendererStyleFlags2["Important"] = 1] = "Important";
    /**
     * Marks a style as using dash case naming (this-is-dash-case).
     */
    RendererStyleFlags2[RendererStyleFlags2["DashCase"] = 2] = "DashCase";
  })(RendererStyleFlags2 || (RendererStyleFlags2 = {}));
  /**
   * Extend this base class to implement custom rendering. By default, Angular
   * renders a template into DOM. You can use custom rendering to intercept
   * rendering calls, or to render to something other than DOM.
   *
   * Create your custom renderer using `RendererFactory2`.
   *
   * Use a custom renderer to bypass Angular's templating and
   * make custom UI changes that can't be expressed declaratively.
   * For example if you need to set a property or an attribute whose name is
   * not statically known, use the `setProperty()` or
   * `setAttribute()` method.
   *
   * @experimental
   */
  var Renderer2 = /** @class */function () {
    function Renderer2() {}
    return Renderer2;
  }();
  export { Renderer2 };
});
//# sourceMappingURL=api.js.map