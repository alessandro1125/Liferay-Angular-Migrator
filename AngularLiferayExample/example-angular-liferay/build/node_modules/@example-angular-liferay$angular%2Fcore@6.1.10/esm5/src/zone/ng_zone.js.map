{"version":3,"sources":["../../../../../../../../../../packages/core/src/zone/ng_zone.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter} from '../event_emitter';\n\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n *\n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {@link #run}.\n *\n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * import {Component, NgZone} from '@angular/core';\n * import {NgIf} from '@angular/common';\n *\n * @Component({\n *   selector: 'ng-zone-demo',\n *   template: `\n *     <h2>Demo: NgZone</h2>\n *\n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n *\n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n *\n *   constructor(private _ngZone: NgZone) {}\n *\n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n *\n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *         // reenter the Angular zone and display done\n *         this._ngZone.run(() => { console.log('Outside Done!'); });\n *       });\n *     });\n *   }\n *\n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n *\n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n *\n * @experimental\n */\nexport class NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  readonly isStable: boolean = true;\n\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  readonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  readonly onStable: EventEmitter<any> = new EventEmitter(false);\n\n  /**\n   * Notifies that an error has been delivered.\n   */\n  readonly onError: EventEmitter<any> = new EventEmitter(false);\n\n  constructor({enableLongStackTrace = false}) {\n    if (typeof Zone == 'undefined') {\n      throw new Error(`In this configuration Angular requires Zone.js`);\n    }\n\n    Zone.assertZonePatched();\n    const self = this as any as NgZonePrivate;\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    if ((Zone as any)['wtfZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['wtfZoneSpec']);\n    }\n\n    if ((Zone as any)['TaskTrackingZoneSpec']) {\n      self._inner = self._inner.fork(new ((Zone as any)['TaskTrackingZoneSpec'] as any));\n    }\n\n    if (enableLongStackTrace && (Zone as any)['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork((Zone as any)['longStackTraceZoneSpec']);\n    }\n\n    forkInnerZoneWithAngularBehavior(self);\n  }\n\n  static isInAngularZone(): boolean { return Zone.current.get('isAngularZone') === true; }\n\n  static assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n\n  static assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.run(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const zone = (this as any as NgZonePrivate)._inner;\n    const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return zone.runTask(task, applyThis, applyArgs) as T;\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return (this as any as NgZonePrivate)._inner.runGuarded(fn, applyThis, applyArgs) as T;\n  }\n\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return (this as any as NgZonePrivate)._outer.run(fn) as T;\n  }\n}\n\nfunction noop() {}\nconst EMPTY_PAYLOAD = {};\n\n\ninterface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n\n  hasPendingMicrotasks: boolean;\n  hasPendingMacrotasks: boolean;\n  isStable: boolean;\n}\n\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: <any>{'isAngularZone': true},\n    onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n                   applyArgs: any): any => {\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n\n    onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,\n               applyThis: any, applyArgs: any[], source: string): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n    onHasTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n          delegate.hasTask(target, hasTaskState);\n          if (current === target) {\n            // We are only interested in hasTask events which originate from our zone\n            // (A child hasTask event is not interesting to us)\n            if (hasTaskState.change == 'microTask') {\n              zone.hasPendingMicrotasks = hasTaskState.microTask;\n              checkStable(zone);\n            } else if (hasTaskState.change == 'macroTask') {\n              zone.hasPendingMacrotasks = hasTaskState.macroTask;\n            }\n          }\n        },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\n\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n\n/**\n * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls\n * to framework to perform rendering.\n */\nexport class NoopNgZone implements NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n  readonly isStable: boolean = true;\n  readonly onUnstable: EventEmitter<any> = new EventEmitter();\n  readonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter();\n  readonly onStable: EventEmitter<any> = new EventEmitter();\n  readonly onError: EventEmitter<any> = new EventEmitter();\n\n  run(fn: () => any): any { return fn(); }\n\n  runGuarded(fn: () => any): any { return fn(); }\n\n  runOutsideAngular(fn: () => any): any { return fn(); }\n\n  runTask<T>(fn: () => any): any { return fn(); }\n}\n"],"sourceRoot":""}