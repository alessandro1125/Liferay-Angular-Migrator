{"version":3,"sources":["../../../../../../../../../../packages/core/src/metadata/resource_loading.ts"],"names":[],"mappings":";;;;;;;;;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCA,WAAM,SAAA,yBAAA,CACF,gBADE,EAC4E;AAChF;AACA,YAAM,aAAgC,EAAtC;AAEA;AACA,YAAM,SAAS,IAAI,GAAJ,EAAf;AACA,iBAAA,qBAAA,CAA+B,GAA/B,EAA0C;AACxC,gBAAI,UAAU,OAAO,GAAP,CAAW,GAAX,CAAd;AACA,gBAAI,CAAC,OAAL,EAAc;AACZ,oBAAM,OAAO,iBAAiB,GAAjB,CAAb;AACA,uBAAO,GAAP,CAAW,GAAX,EAAgB,UAAU,KAAK,IAAL,CAAU,cAAV,CAA1B;AACA,2BAAW,IAAX,CAAgB,OAAhB;AACD;AACD,mBAAO,OAAP;AACD;AAED,yCAAiC,OAAjC,CAAyC,UAAC,SAAD,EAAqB;AAC5D,gBAAI,UAAU,WAAd,EAA2B;AACzB,sCAAsB,UAAU,WAAhC,EAA6C,IAA7C,CAAkD,UAAC,QAAD,EAAS;AACzD,8BAAU,QAAV,GAAqB,QAArB;AACA,8BAAU,WAAV,GAAwB,SAAxB;AACD,iBAHD;AAID;AACD,gBAAM,YAAY,UAAU,SAA5B;AACA,gBAAM,SAAS,UAAU,MAAV,KAAqB,UAAU,MAAV,GAAmB,EAAxC,CAAf;AACA,gBAAM,cAAc,UAAU,MAAV,CAAiB,MAArC;AACA,yBAAa,UAAU,OAAV,CAAkB,UAAC,QAAD,EAAW,KAAX,EAAgB;AAC7C,uBAAO,IAAP,CAAY,EAAZ,EAD6C,CAC3B;AAClB,sCAAsB,QAAtB,EAAgC,IAAhC,CAAqC,UAAC,KAAD,EAAM;AACzC,2BAAO,cAAc,KAArB,IAA8B,KAA9B;AACA,8BAAU,MAAV,CAAiB,UAAU,OAAV,CAAkB,QAAlB,CAAjB,EAA8C,CAA9C;AACA,wBAAI,UAAU,MAAV,IAAoB,CAAxB,EAA2B;AACzB,kCAAU,SAAV,GAAsB,SAAtB;AACD;AACF,iBAND;AAOD,aATY,CAAb;AAUD,SApBD;AAqBA,yCAAiC,KAAjC;AACA,eAAO,QAAQ,GAAR,CAAY,UAAZ,EAAwB,IAAxB,CAA6B,YAAA;AAAM,mBAAA,IAAA;AAAI,SAAvC,CAAP;AACD;AAED,QAAM,mCAAmD,IAAI,GAAJ,EAAzD;AAEA,WAAM,SAAA,wCAAA,CAAmD,QAAnD,EAAsE;AAC1E,YAAI,yBAAyB,QAAzB,CAAJ,EAAwC;AACtC,6CAAiC,GAAjC,CAAqC,QAArC;AACD;AACF;AAED,WAAM,SAAA,wBAAA,CAAmC,SAAnC,EAAuD;AAC3D,eAAO,UAAU,WAAV,IAAyB,UAAU,SAAV,IAAuB,UAAU,SAAV,CAAoB,MAA3E;AACD;AACD,WAAM,SAAA,wCAAA,GAAA;AACJ,yCAAiC,KAAjC;AACD;AAED,aAAA,cAAA,CAAwB,QAAxB,EAAoE;AAClE,eAAO,OAAO,QAAP,IAAmB,QAAnB,GAA8B,QAA9B,GAAyC,SAAS,IAAT,EAAhD;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Component} from './directives';\n\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponnent{\n * }\n *\n * // Calling `renderComponent` will fail because `MyComponent`'s `@Compenent.templateUrl`\n * // needs to be resolved because `renderComponent` is synchronous process.\n * // renderComponent(MyComponent);\n *\n * // Calling `resolveComponentResources` will resolve `@Compenent.templateUrl` into\n * // `@Compenent.template`, which would allow `renderComponent` to proceed in synchronous manner.\n * // Use browser's `fetch` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible to returning a `Promise` of the resolved\n * URL. Browser's `fetch` method is a good default implementation.\n */\nexport function resolveComponentResources(\n    resourceResolver: (url: string) => (Promise<string|{text(): Promise<string>}>)): Promise<null> {\n  // Store all promises which are fetching the resources.\n  const urlFetches: Promise<string>[] = [];\n\n  // Cache so that we don't fetch the same resource more than once.\n  const urlMap = new Map<string, Promise<string>>();\n  function cachedResourceResolve(url: string): Promise<string> {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n      urlFetches.push(promise);\n    }\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component: Component) => {\n    if (component.templateUrl) {\n      cachedResourceResolve(component.templateUrl).then((template) => {\n        component.template = template;\n        component.templateUrl = undefined;\n      });\n    }\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push('');  // pre-allocate array.\n      cachedResourceResolve(styleUrl).then((style) => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      });\n    });\n  });\n  componentResourceResolutionQueue.clear();\n  return Promise.all(urlFetches).then(() => null);\n}\n\nconst componentResourceResolutionQueue: Set<Component> = new Set();\n\nexport function maybeQueueResolutionOfComponentResources(metadata: Component) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.add(metadata);\n  }\n}\n\nexport function componentNeedsResolution(component: Component) {\n  return component.templateUrl || component.styleUrls && component.styleUrls.length;\n}\nexport function clearResolutionOfComponentResourcesQueue() {\n  componentResourceResolutionQueue.clear();\n}\n\nfunction unwrapResponse(response: string | {text(): Promise<string>}): string|Promise<string> {\n  return typeof response == 'string' ? response : response.text();\n}"],"sourceRoot":""}