{"version":3,"sources":["../../../../../../../../../../packages/core/src/di/reflective_errors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {wrappedError} from '../error_handler';\nimport {ERROR_ORIGINAL_ERROR, getOriginalError} from '../errors';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {ReflectiveInjector} from './reflective_injector';\nimport {ReflectiveKey} from './reflective_key';\n\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const res: any[] = [];\n  for (let i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const reversed = findFirstClosedCycle(keys.slice().reverse());\n    const tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n\nexport interface InjectionError extends Error {\n  keys: ReflectiveKey[];\n  injectors: ReflectiveInjector[];\n  constructResolvingMessage: (keys: ReflectiveKey[]) => string;\n  addKey(injector: ReflectiveInjector, key: ReflectiveKey): void;\n}\n\nfunction injectionError(\n    injector: ReflectiveInjector, key: ReflectiveKey,\n    constructResolvingMessage: (keys: ReflectiveKey[]) => string,\n    originalError?: Error): InjectionError {\n  const keys = [key];\n  const errMsg = constructResolvingMessage(keys);\n  const error =\n      (originalError ? wrappedError(errMsg, originalError) : Error(errMsg)) as InjectionError;\n  error.addKey = addKey;\n  error.keys = keys;\n  error.injectors = [injector];\n  error.constructResolvingMessage = constructResolvingMessage;\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n\nfunction addKey(this: InjectionError, injector: ReflectiveInjector, key: ReflectiveKey): void {\n  this.injectors.push(injector);\n  this.keys.push(key);\n  // Note: This updated message won't be reflected in the `.stack` property\n  this.message = this.constructResolvingMessage(this.keys);\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {@link Injector}, but the\n * {@link Injector} does not have a {@link Provider} for the given key.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n */\nexport function noProviderError(injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `No provider for ${first}!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when dependencies form a cycle.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n *\n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n *\n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n */\nexport function cyclicDependencyError(\n    injector: ReflectiveInjector, key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n  });\n}\n\n/**\n * Thrown when a constructing type returns with an Error.\n *\n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n *\n * var injector = Injector.resolveAndCreate([A]);\n\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n */\nexport function instantiationError(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey): InjectionError {\n  return injectionError(injector, key, function(keys: ReflectiveKey[]) {\n    const first = stringify(keys[0].token);\n    return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`;\n  }, originalException);\n}\n\n/**\n * Thrown when an object other then {@link Provider} (or `Type`) is passed to {@link Injector}\n * creation.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n */\nexport function invalidProviderError(provider: any) {\n  return Error(\n      `Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n}\n\n/**\n * Thrown when the class has no annotation information.\n *\n * Lack of annotation information prevents the {@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n *\n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n *\n * This error is also thrown when the class not marked with {@link Injectable} has parameter types.\n *\n * ```typescript\n * class B {}\n *\n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n *\n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n *\n */\nexport function noAnnotationError(typeOrFunc: Type<any>| Function, params: any[][]): Error {\n  const signature: string[] = [];\n  for (let i = 0, ii = params.length; i < ii; i++) {\n    const parameter = params[i];\n    if (!parameter || parameter.length == 0) {\n      signature.push('?');\n    } else {\n      signature.push(parameter.map(stringify).join(' '));\n    }\n  }\n  return Error(\n      'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \\'' +\n      stringify(typeOrFunc) + '\\' is decorated with Injectable.');\n}\n\n/**\n * Thrown when getting an object by index.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * class A {}\n *\n * var injector = Injector.resolveAndCreate([A]);\n *\n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n *\n */\nexport function outOfBoundsError(index: number) {\n  return Error(`Index ${index} is out-of-bounds.`);\n}\n\n// TODO: add a working example after alpha38 is released\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n *\n * @usageNotes\n * ### Example\n *\n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport function mixingMultiProvidersWithRegularProvidersError(\n    provider1: any, provider2: any): Error {\n  return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`);\n}\n"],"sourceRoot":""}