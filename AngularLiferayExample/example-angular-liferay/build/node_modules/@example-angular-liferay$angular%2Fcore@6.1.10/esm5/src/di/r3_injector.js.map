{"version":3,"sources":["../../../../../../../../../../packages/core/src/di/r3_injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy} from '../metadata/lifecycle_hooks';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, InjectableType, InjectorDef, InjectorType, InjectorTypeWithProviders} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectableDefToken, InjectionToken} from './injection_token';\nimport {INJECTOR, InjectFlags, Injector, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, inject, injectArgs, setCurrentInjector} from './injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, Provider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider} from './provider';\nimport {APP_ROOT} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @experimental\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector | null = null,\n    additionalProviders: StaticProvider[] | null = null): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, additionalProviders, parent);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly isRootInjector: boolean;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  private destroyed = false;\n\n  constructor(\n      def: InjectorType<any>, additionalProviders: StaticProvider[]|null,\n      readonly parent: Injector) {\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in `def`.\n    deepForEach(\n        [def], injectorDef => this.processInjectorType(injectorDef, new Set<InjectorType<any>>()));\n\n    additionalProviders &&\n        deepForEach(additionalProviders, provider => this.processProvider(provider));\n\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    this.isRootInjector = this.records.has(APP_ROOT);\n\n    // Eagerly instantiate the InjectorType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this.destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\n          // with a scope matching this injector.\n          const def = couldBeInjectableType(token) &&\n                  (token as InjectableType<any>| InjectableDefToken<any>).ngInjectableDef ||\n              undefined;\n          if (def !== undefined && this.injectableDefInScope(def)) {\n            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = injectableDefRecord(token);\n            this.records.set(token, record);\n          }\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record !== undefined) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      let next = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      return this.parent.get(token, notFoundValue);\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  private assertNotDestroyed(): void {\n    if (this.destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: Set<InjectorType<any>>) {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n\n    // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the ngInjectorDef.\n    let def = (defOrWrappedDef as InjectorType<any>).ngInjectorDef as(InjectorDef<any>| undefined);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\n    // extra providers.\n    const providers =\n        (ngModule !== undefined) && (defOrWrappedDef as InjectorTypeWithProviders<any>).providers ||\n        EMPTY_ARRAY;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = ngModule.ngInjectorDef;\n    }\n\n    // If no definition was found, it might be from exports. Remove it.\n    if (def == null) {\n      return;\n    }\n\n    // Check for circular dependencies.\n    if (parents.has(defType)) {\n      throw new Error(`Circular dependency: type ${stringify(defType)} ends up importing itself.`);\n    }\n\n    // Track the InjectorType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      parents.add(defType);\n      try {\n        deepForEach(def.imports, imported => this.processInjectorType(imported, parents));\n      } finally {\n        // Remove it from the parents set when finished.\n        parents.delete(defType);\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    if (def.providers != null) {\n      deepForEach(def.providers, provider => this.processProvider(provider));\n    }\n\n    // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\n    deepForEach(providers, provider => this.processProvider(provider));\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throw new Error(`Mixed multi-provider for ${token}.`);\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (existing && existing.multi !== undefined) {\n        throw new Error(`Mixed multi-provider for ${stringify(token)}`);\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throw new Error(`Circular dep for ${stringify(token)}`);\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: InjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefRecord(token: Type<any>| InjectionToken<any>): Record<any> {\n  const def = (token as InjectableType<any>).ngInjectableDef as InjectableDef<any>;\n  if (def === undefined) {\n    if (token instanceof InjectionToken) {\n      throw new Error(`Token ${stringify(token)} is missing an ngInjectableDef definition.`);\n    }\n    // TODO(alxhub): there should probably be a strict mode which throws here instead of assuming a\n    // no-args constructor.\n    return makeRecord(() => new (token as Type<any>)());\n  }\n  return makeRecord(def.factory);\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  let token = resolveForwardRef(provider);\n  let value: any = NOT_YET;\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefRecord(provider);\n  } else {\n    token = resolveForwardRef(provider.provide);\n    if (isValueProvider(provider)) {\n      value = provider.useValue;\n    } else if (isExistingProvider(provider)) {\n      factory = () => inject(provider.useExisting);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = (provider as StaticClassProvider | ClassProvider).useClass || token;\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefRecord(classRef);\n      }\n    }\n  }\n  return makeRecord(factory, value);\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {} = NOT_YET, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value as ExistingProvider).useExisting;\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value as FactoryProvider).useFactory;\n}\n\nfunction isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as ClassProvider).useClass;\n}\n\nfunction isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return typeof value === 'object' && value != null && (value as OnDestroy).ngOnDestroy &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n"],"sourceRoot":""}