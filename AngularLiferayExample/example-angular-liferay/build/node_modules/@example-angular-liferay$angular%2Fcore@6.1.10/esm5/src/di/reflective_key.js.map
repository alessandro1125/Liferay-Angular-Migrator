{"version":3,"sources":["../../../../../../../../../../packages/core/src/di/reflective_key.ts"],"names":[],"mappings":";;;;;;;;;AAQA,aAAQ,SAAR,QAAwB,SAAxB;AACA,aAAQ,iBAAR,QAAgC,eAAhC;AAGA;;;;;;;;;;;;;;;;AAgBA,QAAA,gBAAA,aAAA,YAAA;AAEE;;;AAGA,iBAAA,aAAA,CAAmB,KAAnB,EAAyC,EAAzC,EAAmD;AAAhC,iBAAA,KAAA,GAAA,KAAA;AAAsB,iBAAA,EAAA,GAAA,EAAA;AACvC,gBAAI,CAAC,KAAL,EAAY;AACV,sBAAM,IAAI,KAAJ,CAAU,wBAAV,CAAN;AACD;AACD,iBAAK,WAAL,GAAmB,UAAU,KAAK,KAAf,CAAnB;AACD;AAED;;;AAGO,sBAAA,GAAA,GAAP,UAAW,KAAX,EAAwB;AACtB,mBAAO,mBAAmB,GAAnB,CAAuB,kBAAkB,KAAlB,CAAvB,CAAP;AACD,SAFM;AAOP,eAAA,cAAA,CAAW,aAAX,EAAW,cAAX,EAAuB;AAHvB;;;iBAGA,YAAA;AAAoC,uBAAO,mBAAmB,YAA1B;AAAyC,aAAtD;4BAAA;;AAAA,SAAvB;AACF,eAAA,aAAA;AAAC,KAvBD,EAAA;;AAyBA,QAAA,cAAA,aAAA,YAAA;AAAA,iBAAA,WAAA,GAAA;AACU,iBAAA,QAAA,GAAW,IAAI,GAAJ,EAAX;AAeT;AAbC,oBAAA,SAAA,CAAA,GAAA,GAAA,UAAI,KAAJ,EAAiB;AACf,gBAAI,iBAAiB,aAArB,EAAoC,OAAO,KAAP;AAEpC,gBAAI,KAAK,QAAL,CAAc,GAAd,CAAkB,KAAlB,CAAJ,EAA8B;AAC5B,uBAAO,KAAK,QAAL,CAAc,GAAd,CAAkB,KAAlB,CAAP;AACD;AAED,gBAAM,SAAS,IAAI,aAAJ,CAAkB,KAAlB,EAAyB,cAAc,YAAvC,CAAf;AACA,iBAAK,QAAL,CAAc,GAAd,CAAkB,KAAlB,EAAyB,MAAzB;AACA,mBAAO,MAAP;AACD,SAVD;AAYA,eAAA,cAAA,CAAI,YAAA,SAAJ,EAAI,cAAJ,EAAgB;iBAAhB,YAAA;AAA6B,uBAAO,KAAK,QAAL,CAAc,IAArB;AAA4B,aAAzC;4BAAA;;AAAA,SAAhB;AACF,eAAA,WAAA;AAAC,KAhBD,EAAA;;AAkBA,QAAM,qBAAqB,IAAI,WAAJ,EAA3B","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {stringify} from '../util';\nimport {resolveForwardRef} from './forward_ref';\n\n\n/**\n * A unique object used for retrieving items from the {@link ReflectiveInjector}.\n *\n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n *\n * `Key` is used internally by {@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n *\n * `Key` should not be created directly. {@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n * @deprecated No replacement\n */\nexport class ReflectiveKey {\n  public readonly displayName: string;\n  /**\n   * Private\n   */\n  constructor(public token: Object, public id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n    this.displayName = stringify(this.token);\n  }\n\n  /**\n   * Retrieves a `Key` for a token.\n   */\n  static get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n\n  /**\n   * @returns the number of keys registered in the system.\n   */\n  static get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nexport class KeyRegistry {\n  private _allKeys = new Map<Object, ReflectiveKey>();\n\n  get(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token) !;\n    }\n\n    const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n\n  get numberOfKeys(): number { return this._allKeys.size; }\n}\n\nconst _globalKeyRegistry = new KeyRegistry();\n"],"sourceRoot":""}