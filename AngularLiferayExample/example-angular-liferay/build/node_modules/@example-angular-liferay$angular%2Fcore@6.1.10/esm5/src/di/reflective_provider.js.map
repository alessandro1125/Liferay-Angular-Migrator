{"version":3,"sources":["../../../../../../../../../../packages/core/src/di/reflective_provider.ts"],"names":[],"mappings":";;;;;;;;;AAQA,aAAQ,SAAR,QAAwB,0BAAxB;AACA,aAAQ,IAAR,QAAmB,SAAnB;AAEA,aAAQ,iBAAR,QAAgC,eAAhC;AACA,aAAQ,cAAR,QAA6B,mBAA7B;AACA,aAAQ,MAAR,EAAgB,QAAhB,EAA0B,IAA1B,EAAgC,QAAhC,QAA+C,YAA/C;AAEA,aAAQ,oBAAR,EAA8B,6CAA9B,EAA6E,iBAA7E,QAAqG,qBAArG;AACA,aAAQ,aAAR,QAA4B,kBAA5B;AAMA;;;;AAIA,QAAA,uBAAA,aAAA,YAAA;AACE,iBAAA,oBAAA,CACW,GADX,EACsC,QADtC,EACgE,UADhE,EAC8F;AAAnF,iBAAA,GAAA,GAAA,GAAA;AAA2B,iBAAA,QAAA,GAAA,QAAA;AAA0B,iBAAA,UAAA,GAAA,UAAA;AAAkC;AAE3F,6BAAA,OAAA,GAAP,UAAe,GAAf,EAAiC;AAC/B,mBAAO,IAAI,oBAAJ,CAAyB,GAAzB,EAA8B,KAA9B,EAAqC,IAArC,CAAP;AACD,SAFM;AAGT,eAAA,oBAAA;AAAC,KAPD,EAAA;;AASA,QAAM,cAAqB,EAA3B;AAsCA,QAAA,8BAAA,aAAA,YAAA;AAGE,iBAAA,2BAAA,CACW,GADX,EACsC,iBADtC,EAEW,aAFX,EAEiC;AADtB,iBAAA,GAAA,GAAA,GAAA;AAA2B,iBAAA,iBAAA,GAAA,iBAAA;AAC3B,iBAAA,aAAA,GAAA,aAAA;AACT,iBAAK,eAAL,GAAuB,KAAK,iBAAL,CAAuB,CAAvB,CAAvB;AACD;AACH,eAAA,2BAAA;AAAC,KARD,EAAA;;AAUA;;;;AAIA,QAAA,4BAAA,aAAA,YAAA;AACE,iBAAA,yBAAA;AACI;;;AAGO,eAJX;AAMI;;;AAGO,oBATX,EAS+C;AALpC,iBAAA,OAAA,GAAA,OAAA;AAKA,iBAAA,YAAA,GAAA,YAAA;AAAwC;AACrD,eAAA,yBAAA;AAAC,KAXD,EAAA;;AAcA;;;AAGA,aAAA,wBAAA,CAAkC,QAAlC,EAA8D;AAC5D,YAAI,SAAJ;AACA,YAAI,YAAJ;AACA,YAAI,SAAS,QAAb,EAAuB;AACrB,gBAAM,WAAW,kBAAkB,SAAS,QAA3B,CAAjB;AACA,wBAAY,UAAU,OAAV,CAAkB,QAAlB,CAAZ;AACA,2BAAe,iBAAiB,QAAjB,CAAf;AACD,SAJD,MAIO,IAAI,SAAS,WAAb,EAA0B;AAC/B,wBAAY,UAAC,aAAD,EAAmB;AAAK,uBAAA,aAAA;AAAa,aAAjD;AACA,2BAAe,CAAC,qBAAqB,OAArB,CAA6B,cAAc,GAAd,CAAkB,SAAS,WAA3B,CAA7B,CAAD,CAAf;AACD,SAHM,MAGA,IAAI,SAAS,UAAb,EAAyB;AAC9B,wBAAY,SAAS,UAArB;AACA,2BAAe,sBAAsB,SAAS,UAA/B,EAA2C,SAAS,IAApD,CAAf;AACD,SAHM,MAGA;AACL,wBAAY,YAAA;AAAM,uBAAA,SAAA,QAAA;AAAiB,aAAnC;AACA,2BAAe,WAAf;AACD;AACD,eAAO,IAAI,yBAAJ,CAA8B,SAA9B,EAAyC,YAAzC,CAAP;AACD;AAED;;;;;;AAMA,aAAA,yBAAA,CAAmC,QAAnC,EAA+D;AAC7D,eAAO,IAAI,2BAAJ,CACH,cAAc,GAAd,CAAkB,SAAS,OAA3B,CADG,EACkC,CAAC,yBAAyB,QAAzB,CAAD,CADlC,EAEH,SAAS,KAAT,IAAkB,KAFf,CAAP;AAGD;AAED;;;AAGA,WAAM,SAAA,0BAAA,CAAqC,SAArC,EAA0D;AAC9D,YAAM,aAAa,oBAAoB,SAApB,EAA+B,EAA/B,CAAnB;AACA,YAAM,WAAW,WAAW,GAAX,CAAe,yBAAf,CAAjB;AACA,YAAM,sBAAsB,iCAAiC,QAAjC,EAA2C,IAAI,GAAJ,EAA3C,CAA5B;AACA,eAAO,MAAM,IAAN,CAAW,oBAAoB,MAApB,EAAX,CAAP;AACD;AAED;;;;AAIA,WAAM,SAAA,gCAAA,CACF,SADE,EAEF,sBAFE,EAE6D;AAEjE,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAAU,MAA9B,EAAsC,GAAtC,EAA2C;AACzC,gBAAM,WAAW,UAAU,CAAV,CAAjB;AACA,gBAAM,WAAW,uBAAuB,GAAvB,CAA2B,SAAS,GAAT,CAAa,EAAxC,CAAjB;AACA,gBAAI,QAAJ,EAAc;AACZ,oBAAI,SAAS,aAAT,KAA2B,SAAS,aAAxC,EAAuD;AACrD,0BAAM,8CAA8C,QAA9C,EAAwD,QAAxD,CAAN;AACD;AACD,oBAAI,SAAS,aAAb,EAA4B;AAC1B,yBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,SAAS,iBAAT,CAA2B,MAA/C,EAAuD,GAAvD,EAA4D;AAC1D,iCAAS,iBAAT,CAA2B,IAA3B,CAAgC,SAAS,iBAAT,CAA2B,CAA3B,CAAhC;AACD;AACF,iBAJD,MAIO;AACL,2CAAuB,GAAvB,CAA2B,SAAS,GAAT,CAAa,EAAxC,EAA4C,QAA5C;AACD;AACF,aAXD,MAWO;AACL,oBAAI,mBAAgB,KAAA,CAApB;AACA,oBAAI,SAAS,aAAb,EAA4B;AAC1B,uCAAmB,IAAI,2BAAJ,CACf,SAAS,GADM,EACD,SAAS,iBAAT,CAA2B,KAA3B,EADC,EACmC,SAAS,aAD5C,CAAnB;AAED,iBAHD,MAGO;AACL,uCAAmB,QAAnB;AACD;AACD,uCAAuB,GAAvB,CAA2B,SAAS,GAAT,CAAa,EAAxC,EAA4C,gBAA5C;AACD;AACF;AACD,eAAO,sBAAP;AACD;AAED,aAAA,mBAAA,CAA6B,SAA7B,EAAoD,GAApD,EAAmE;AACjE,kBAAU,OAAV,CAAkB,UAAA,CAAA,EAAC;AACjB,gBAAI,aAAa,IAAjB,EAAuB;AACrB,oBAAI,IAAJ,CAAS,EAAC,SAAS,CAAV,EAAa,UAAU,CAAvB,EAAT;AAED,aAHD,MAGO,IAAI,KAAK,OAAO,CAAP,IAAY,QAAjB,IAA8B,EAAU,OAAV,KAAsB,SAAxD,EAAmE;AACxE,oBAAI,IAAJ,CAAS,CAAT;AAED,aAHM,MAGA,IAAI,aAAa,KAAjB,EAAwB;AAC7B,oCAAoB,CAApB,EAAuB,GAAvB;AAED,aAHM,MAGA;AACL,sBAAM,qBAAqB,CAArB,CAAN;AACD;AACF,SAbD;AAeA,eAAO,GAAP;AACD;AAED,WAAM,SAAA,qBAAA,CACF,UADE,EACe,YADf,EACmC;AACvC,YAAI,CAAC,YAAL,EAAmB;AACjB,mBAAO,iBAAiB,UAAjB,CAAP;AACD,SAFD,MAEO;AACL,gBAAM,WAAkB,aAAa,GAAb,CAAiB,UAAA,CAAA,EAAC;AAAI,uBAAA,CAAA,CAAA,CAAA;AAAG,aAAzB,CAAxB;AACA,mBAAO,aAAa,GAAb,CAAiB,UAAA,CAAA,EAAC;AAAI,uBAAA,cAAc,UAAd,EAA0B,CAA1B,EAAA,QAAA,CAAA;AAAoC,aAA1D,CAAP;AACD;AACF;AAED,aAAA,gBAAA,CAA0B,UAA1B,EAAyC;AACvC,YAAM,SAAS,UAAU,UAAV,CAAqB,UAArB,CAAf;AAEA,YAAI,CAAC,MAAL,EAAa,OAAO,EAAP;AACb,YAAI,OAAO,IAAP,CAAY,UAAA,CAAA,EAAC;AAAI,mBAAA,KAAA,IAAA;AAAS,SAA1B,CAAJ,EAAiC;AAC/B,kBAAM,kBAAkB,UAAlB,EAA8B,MAA9B,CAAN;AACD;AACD,eAAO,OAAO,GAAP,CAAW,UAAA,CAAA,EAAC;AAAI,mBAAA,cAAc,UAAd,EAA0B,CAA1B,EAAA,MAAA,CAAA;AAAoC,SAApD,CAAP;AACD;AAED,aAAA,aAAA,CACI,UADJ,EACqB,QADrB,EAC4C,MAD5C,EAC2D;AACzD,YAAI,QAAa,IAAjB;AACA,YAAI,WAAW,KAAf;AAEA,YAAI,CAAC,MAAM,OAAN,CAAc,QAAd,CAAL,EAA8B;AAC5B,gBAAI,oBAAoB,MAAxB,EAAgC;AAC9B,uBAAO,kBAAkB,SAAS,KAA3B,EAAkC,QAAlC,EAA4C,IAA5C,CAAP;AACD,aAFD,MAEO;AACL,uBAAO,kBAAkB,QAAlB,EAA4B,QAA5B,EAAsC,IAAtC,CAAP;AACD;AACF;AAED,YAAI,aAAiC,IAArC;AAEA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,SAAS,MAA7B,EAAqC,EAAE,CAAvC,EAA0C;AACxC,gBAAM,gBAAgB,SAAS,CAAT,CAAtB;AAEA,gBAAI,yBAAyB,IAA7B,EAAmC;AACjC,wBAAQ,aAAR;AAED,aAHD,MAGO,IAAI,yBAAyB,MAA7B,EAAqC;AAC1C,wBAAQ,cAAc,KAAtB;AAED,aAHM,MAGA,IAAI,yBAAyB,QAA7B,EAAuC;AAC5C,2BAAW,IAAX;AAED,aAHM,MAGA,IAAI,yBAAyB,IAAzB,IAAiC,yBAAyB,QAA9D,EAAwE;AAC7E,6BAAa,aAAb;AACD,aAFM,MAEA,IAAI,yBAAyB,cAA7B,EAA6C;AAClD,wBAAQ,aAAR;AACD;AACF;AAED,gBAAQ,kBAAkB,KAAlB,CAAR;AAEA,YAAI,SAAS,IAAb,EAAmB;AACjB,mBAAO,kBAAkB,KAAlB,EAAyB,QAAzB,EAAmC,UAAnC,CAAP;AACD,SAFD,MAEO;AACL,kBAAM,kBAAkB,UAAlB,EAA8B,MAA9B,CAAN;AACD;AACF;AAED,aAAA,iBAAA,CACI,KADJ,EACgB,QADhB,EACmC,UADnC,EACqE;AACnE,eAAO,IAAI,oBAAJ,CAAyB,cAAc,GAAd,CAAkB,KAAlB,CAAzB,EAAmD,QAAnD,EAA6D,UAA7D,CAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {reflector} from '../reflection/reflection';\nimport {Type} from '../type';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider} from './provider';\nimport {invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\n\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n    FactoryProvider {}\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n  constructor(\n      public key: ReflectiveKey, public optional: boolean, public visibility: Self|SkipSelf|null) {}\n\n  static fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nconst _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a `Provider` used by the `Injector`.\n *\n * @usageNotes\n * This is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\n\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n  readonly resolvedFactory: ResolvedReflectiveFactory;\n\n  constructor(\n      public key: ReflectiveKey, public resolvedFactories: ResolvedReflectiveFactory[],\n      public multiProvider: boolean) {\n    this.resolvedFactory = this.resolvedFactories[0];\n  }\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving `Provider`.\n * @experimental\n */\nexport class ResolvedReflectiveFactory {\n  constructor(\n      /**\n       * Factory function which can return an instance of an object represented by a key.\n       */\n      public factory: Function,\n\n      /**\n       * Arguments (dependencies) to the `factory` function.\n       */\n      public dependencies: ReflectiveDependency[]) {}\n}\n\n\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let factoryFn: Function;\n  let resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n\n/**\n * Converts the `Provider` into `ResolvedProvider`.\n *\n * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider\n * syntax.\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n      ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],\n      provider.multi || false);\n}\n\n/**\n * Resolve a list of Providers.\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const normalized = _normalizeProviders(providers, []);\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n\n/**\n * Merges a list of ResolvedProviders into a list where each key is contained exactly once and\n * multi providers have been merged.\n */\nexport function mergeResolvedReflectiveProviders(\n    providers: ResolvedReflectiveProvider[],\n    normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n    Map<number, ResolvedReflectiveProvider> {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n            provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({provide: b, useClass: b});\n\n    } else if (b && typeof b == 'object' && (b as any).provide !== undefined) {\n      res.push(b as NormalizedProvider);\n\n    } else if (b instanceof Array) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n\nexport function constructDependencies(\n    typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(\n    typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let token: any = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility: Self|SkipSelf|null = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(\n    token: any, optional: boolean, visibility: Self | SkipSelf | null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n"],"sourceRoot":""}