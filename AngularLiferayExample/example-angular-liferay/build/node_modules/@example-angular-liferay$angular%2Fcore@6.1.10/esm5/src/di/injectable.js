Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/di/injectable', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { R3_COMPILE_INJECTABLE } from '../ivy_switch';
    import { ReflectionCapabilities } from '../reflection/reflection_capabilities';
    import { makeDecorator } from '../util/decorators';
    import { getClosureSafeProperty } from '../util/property';
    import { defineInjectable } from './defs';
    import { inject, injectArgs } from './injector';
    var GET_PROPERTY_NAME = {};
    var ɵ0 = GET_PROPERTY_NAME;
    var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 }, GET_PROPERTY_NAME);
    var EMPTY_ARRAY = [];
    export function convertInjectableProviderToFactory(type, provider) {
        if (!provider) {
            var reflectionCapabilities = new ReflectionCapabilities();
            var deps_1 = reflectionCapabilities.parameters(type);
            // TODO - convert to flags.
            return function () {
                return new (type.bind.apply(type, tslib_1.__spread([void 0], injectArgs(deps_1))))();
            };
        }
        if (USE_VALUE in provider) {
            var valueProvider_1 = provider;
            return function () {
                return valueProvider_1.useValue;
            };
        } else if (provider.useExisting) {
            var existingProvider_1 = provider;
            return function () {
                return inject(existingProvider_1.useExisting);
            };
        } else if (provider.useFactory) {
            var factoryProvider_1 = provider;
            return function () {
                return factoryProvider_1.useFactory.apply(factoryProvider_1, tslib_1.__spread(injectArgs(factoryProvider_1.deps || EMPTY_ARRAY)));
            };
        } else if (provider.useClass) {
            var classProvider_1 = provider;
            var deps_2 = provider.deps;
            if (!deps_2) {
                var reflectionCapabilities = new ReflectionCapabilities();
                deps_2 = reflectionCapabilities.parameters(type);
            }
            return function () {
                var _a;
                return new ((_a = classProvider_1.useClass).bind.apply(_a, tslib_1.__spread([void 0], injectArgs(deps_2))))();
            };
        } else {
            var deps_3 = provider.deps;
            if (!deps_3) {
                var reflectionCapabilities = new ReflectionCapabilities();
                deps_3 = reflectionCapabilities.parameters(type);
            }
            return function () {
                return new (type.bind.apply(type, tslib_1.__spread([void 0], injectArgs(deps_3))))();
            };
        }
    }
    /**
     * Supports @Injectable() in JIT mode for Render2.
     */
    function preR3InjectableCompile(injectableType, options) {
        if (options && options.providedIn !== undefined && injectableType.ngInjectableDef === undefined) {
            injectableType.ngInjectableDef = defineInjectable({
                providedIn: options.providedIn,
                factory: convertInjectableProviderToFactory(injectableType, options)
            });
        }
    }
    /**
    * Injectable decorator and metadata.
    *
    * @Annotation
    */
    export var Injectable = makeDecorator('Injectable', undefined, undefined, undefined, function (type, meta) {
        return (R3_COMPILE_INJECTABLE || preR3InjectableCompile)(type, meta);
    });
    export { ɵ0 };
});
//# sourceMappingURL=injectable.js.map