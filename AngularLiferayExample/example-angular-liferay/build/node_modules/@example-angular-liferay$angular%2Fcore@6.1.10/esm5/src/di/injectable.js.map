{"version":3,"sources":["../../../../../../../../../../packages/core/src/di/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3_COMPILE_INJECTABLE} from '../ivy_switch';\nimport {ReflectionCapabilities} from '../reflection/reflection_capabilities';\nimport {Type} from '../type';\nimport {makeDecorator, makeParamDecorator} from '../util/decorators';\nimport {getClosureSafeProperty} from '../util/property';\n\nimport {InjectableDef, InjectableType, defineInjectable} from './defs';\nimport {inject, injectArgs} from './injector';\nimport {ClassSansProvider, ConstructorProvider, ConstructorSansProvider, ExistingProvider, ExistingSansProvider, FactoryProvider, FactorySansProvider, StaticClassProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from './provider';\n\nconst GET_PROPERTY_NAME = {} as any;\nconst USE_VALUE = getClosureSafeProperty<ValueProvider>(\n    {provide: String, useValue: GET_PROPERTY_NAME}, GET_PROPERTY_NAME);\n\n/**\n * Injectable providers used in `@Injectable` decorator.\n *\n * @experimental\n */\nexport type InjectableProvider = ValueSansProvider | ExistingSansProvider |\n    StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;\n\n/**\n * Type of the Injectable decorator / constructor function.\n */\nexport interface InjectableDecorator {\n  /**\n   * A marker metadata that marks a class as available to `Injector` for creation.\n   *\n   * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/metadata_spec.ts region='Injectable'}\n   *\n   * `Injector` will throw an error when trying to instantiate a class that\n   * does not have `@Injectable` marker, as shown in the example below.\n   *\n   * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\n   *\n   */\n  (): any;\n  (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): any;\n  new (): Injectable;\n  new (options?: {providedIn: Type<any>| 'root' | null}&InjectableProvider): Injectable;\n}\n\n/**\n * Type of the Injectable metadata.\n *\n * @experimental\n */\nexport interface Injectable { providedIn?: Type<any>|'root'|null; }\n\nconst EMPTY_ARRAY: any[] = [];\n\nexport function convertInjectableProviderToFactory(\n    type: Type<any>, provider?: InjectableProvider): () => any {\n  if (!provider) {\n    const reflectionCapabilities = new ReflectionCapabilities();\n    const deps = reflectionCapabilities.parameters(type);\n    // TODO - convert to flags.\n    return () => new type(...injectArgs(deps as any[]));\n  }\n\n  if (USE_VALUE in provider) {\n    const valueProvider = (provider as ValueSansProvider);\n    return () => valueProvider.useValue;\n  } else if ((provider as ExistingSansProvider).useExisting) {\n    const existingProvider = (provider as ExistingSansProvider);\n    return () => inject(existingProvider.useExisting);\n  } else if ((provider as FactorySansProvider).useFactory) {\n    const factoryProvider = (provider as FactorySansProvider);\n    return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY));\n  } else if ((provider as StaticClassSansProvider | ClassSansProvider).useClass) {\n    const classProvider = (provider as StaticClassSansProvider | ClassSansProvider);\n    let deps = (provider as StaticClassSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new classProvider.useClass(...injectArgs(deps));\n  } else {\n    let deps = (provider as ConstructorSansProvider).deps;\n    if (!deps) {\n      const reflectionCapabilities = new ReflectionCapabilities();\n      deps = reflectionCapabilities.parameters(type);\n    }\n    return () => new type(...injectArgs(deps !));\n  }\n}\n\n/**\n * Supports @Injectable() in JIT mode for Render2.\n */\nfunction preR3InjectableCompile(\n    injectableType: InjectableType<any>,\n    options: {providedIn?: Type<any>| 'root' | null} & InjectableProvider): void {\n  if (options && options.providedIn !== undefined && injectableType.ngInjectableDef === undefined) {\n    injectableType.ngInjectableDef = defineInjectable({\n      providedIn: options.providedIn,\n      factory: convertInjectableProviderToFactory(injectableType, options),\n    });\n  }\n}\n\n/**\n* Injectable decorator and metadata.\n*\n* @Annotation\n*/\nexport const Injectable: InjectableDecorator = makeDecorator(\n    'Injectable', undefined, undefined, undefined,\n    (type: Type<any>, meta: Injectable) =>\n        (R3_COMPILE_INJECTABLE || preR3InjectableCompile)(type, meta));\n\n/**\n * Type representing injectable service.\n *\n * @experimental\n */\nexport interface InjectableType<T> extends Type<T> { ngInjectableDef: InjectableDef<T>; }\n"],"sourceRoot":""}