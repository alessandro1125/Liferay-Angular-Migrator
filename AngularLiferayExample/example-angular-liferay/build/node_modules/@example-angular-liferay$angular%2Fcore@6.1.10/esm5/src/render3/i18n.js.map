{"version":3,"sources":["../../../../../../../../../../packages/core/src/render3/i18n.ts"],"names":[],"mappings":";;;;;;;;;AAQA,aAAQ,WAAR,EAAqB,cAArB,QAA0C,UAA1C;AACA,aAAQ,SAAR,EAAmB,cAAnB,EAAmC,eAAnC,EAAoD,eAApD,EAAqE,WAArE,EAAkF,uBAAlF,EAA2G,WAA3G,EAAwH,WAAxH,EAAqI,IAArI,EAA2I,qBAA3I,QAAuK,gBAAvK;AACA,aAAQ,aAAR,QAA4B,wBAA5B;AAEA,aAAQ,aAAR,EAAuB,aAAvB,EAAsC,KAAtC,QAAkD,mBAAlD;AACA,aAAQ,WAAR,EAAqB,cAArB,EAAqC,cAArC,EAAqD,WAArD,QAAuE,qBAAvE;AACA,aAAQ,SAAR,QAAwB,QAAxB;AAoCA,QAAM,eAAe,cAArB;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA,WAAM,SAAA,WAAA,CACF,WADE,EACmB,QADnB,EAEF,WAFE,EAE8C,aAF9C,EAGF,cAHE,EAG4B;AAChC,YAAM,mBAAmB,YAAY,KAAZ,CAAkB,YAAlB,CAAzB;AACA,YAAM,cAAc,gBAAgB,cAAc,MAAd,GAAuB,CAAvC,GAA2C,CAA/D;AACA,YAAM,eAAqC,IAAI,KAAJ,CAAU,WAAV,CAAD,CAAyB,IAAzB,CAA8B,SAA9B,CAA1C;AAEA,oCACI,CADJ,EACO,CADP,EACU,gBADV,EAC4B,YAD5B,EAC0C,QAD1C,EACoD,WADpD,EACiE,aADjE,EACgF,cADhF;AAGA,eAAO,YAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;AAuBA,aAAA,2BAAA,CACI,SADJ,EACuB,SADvB,EAC0C,gBAD1C,EAEI,YAFJ,EAEuC,QAFvC,EAGI,WAHJ,EAGoD,aAHpD,EAII,cAJJ,EAIkC;AAChC,YAAM,mBAAsC,EAA5C;AACA,YAAM,YAAsB,EAA5B;AACA,YAAI,iBAAiB,CAArB;AACA,YAAI,WAAW,CAAf;AACA,YAAI,kBACA,YAAY,SAAS,SAAT,CAAZ,GAAkC,SAAS,SAAT,CAAlC,GAAwD,IAD5D;AAEA,YAAI,qBACA,eAAe,YAAY,SAAZ,CAAf,GAAwC,YAAY,SAAZ,CAAxC,GAAiE,IADrE;AAGA,qBAAa,SAAb,IAA0B,gBAA1B;AAEA,eAAO,YAAY,iBAAiB,MAApC,EAA4C,WAA5C,EAAyD;AACvD;AACA,gBAAM,QAAQ,iBAAiB,SAAjB,CAAd;AAEA;AACA,gBAAI,YAAY,CAAhB,EAAmB;AACjB,oBAAI,UAAO,KAAA,CAAX;AACA,oBAAI,mBAAmB,gBAAgB,KAAhB,MAA2B,SAAlD,EAA6D;AAC3D,8BAAU,gBAAgB,KAAhB,CAAV;AACA;AACA,wBAAI,oBAAoB,gBAAgB,cAAc,OAAd,CAAsB,KAAtB,CAAhB,GAA+C,CAAC,CAAxE;AACA,wBAAI,sBAAsB,CAAC,CAAvB,IAA6B,oBAAoB,CAArB,KAA4B,SAA5D,EAAuE;AACrE;AACA,yCAAiB,IAAjB,CAAsB,UAAO,CAAA,UAA7B,CAA6B,kBAA7B;AACD,qBAHD,MAGO;AACL,yCAAiB,IAAjB,CAAsB,UAAO,UAA7B,CAA6B,aAA7B;AACA;AACD;AACD,8BAAU,IAAV,CAAe,KAAf;AACD,iBAZD,MAYO,IAAI,sBAAsB,mBAAmB,KAAnB,MAA8B,SAAxD,EAAmE;AACxE,8BAAU,mBAAmB,KAAnB,CAAV;AACA;AACA,qCAAiB,IAAjB,CAAsB,UAAO,UAA7B,CAA6B,gBAA7B;AACA,8BAAU,IAAV,CAAe,KAAf;AACD,iBALM,MAKA;AACL;AACA,qCAAiB,IAAjB,CAAqB,CAAA,UAArB,CAAqB,eAArB;AAEA,wBAAI,YAAY,CAAhB,EAAmB;AACjB;AAEA;AACA,4BAAI,mBAAmB,CAAvB,EAA0B;AACxB;AACD;AACF;AACF;AAED,oBAAI,YAAY,SAAZ,IAAyB,UAAU,QAAvC,EAAiD;AAC/C,+BAAW,OAAX;AACD;AAED,oBAAI,aAAJ,EAAmB;AACjB,wBAAM,eAAe,cAAc,OAAd,CAAsB,KAAtB,IAA+B,CAApD;AACA,wBAAI,iBAAiB,CAAjB,IAAsB,iBAAiB,SAA3C,EAAsD;AACpD,oCAAY,4BACR,YADQ,EACM,SADN,EACiB,gBADjB,EACmC,YADnC,EACiD,QADjD,EAC2D,WAD3D,EAER,aAFQ,EAEO,cAFP,CAAZ;AAGD;AACF;AAEF,aA9CD,MA8CO,IAAI,KAAJ,EAAW;AAChB;AACA,iCAAiB,IAAjB,CAAqB,SAArB,CAAqB,UAArB,EAA6C,KAA7C;AACD;AACF;AAED;AACA,YAAI,QAAJ,EAAc;AACZ,gBAAM,eAAe,SAAS,SAAT,CAArB;AAEA,gBAAI,YAAJ,EAAkB;AAChB,oBAAM,SAAS,OAAO,IAAP,CAAY,YAAZ,CAAf;AAEA,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC,wBAAM,KAAK,OAAO,CAAP,CAAX;AAEA,wBAAI,UAAU,OAAV,CAAkB,EAAlB,MAA0B,CAAC,CAA/B,EAAkC;AAChC,4BAAI,QAAQ,aAAa,EAAb,CAAZ;AACA;AACA,yCAAiB,IAAjB,CAAsB,QAAK,CAAA,SAA3B,CAA2B,gBAA3B;AAEA,4BAAI,QAAQ,QAAZ,EAAsB;AACpB,uCAAW,KAAX;AACD;AACF;AACF;AACF;AACF;AAED;AACA,YAAI,WAAJ,EAAiB;AACf,gBAAM,kBAAkB,YAAY,SAAZ,CAAxB;AAEA,gBAAI,eAAJ,EAAqB;AACnB,oBAAM,SAAS,OAAO,IAAP,CAAY,eAAZ,CAAf;AAEA,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC,wBAAM,KAAK,OAAO,CAAP,CAAX;AAEA,wBAAI,UAAU,OAAV,CAAkB,EAAlB,MAA0B,CAAC,CAA/B,EAAkC;AAChC,4BAAI,QAAQ,gBAAgB,EAAhB,CAAZ;AACA,4BAAI,SAAJ,EAAe;AACb,2CACI,MAAM,QAAN,CAAe,CAAf,EAAkB,MADtB,EAC8B,EAD9B,EACkC,WAAS,KAAT,GAAc,+BADhD;AAED;AACD;AACA,yCAAiB,IAAjB,CAAsB,QAAK,CAAA,SAA3B,CAA2B,gBAA3B;AAEA,4BAAI,QAAQ,QAAZ,EAAsB;AACpB,uCAAW,KAAX;AACD;AACF;AACF;AACF;AACF;AAED,YAAI,cAAc,CAAd,IAAmB,OAAO,cAAP,KAA0B,QAAjD,EAA2D;AACzD;AACA;AACA,iBAAK,IAAI,IAAI,WAAW,CAAxB,EAA2B,KAAK,cAAhC,EAAgD,GAAhD,EAAqD;AACnD,oBAAI,SAAJ,EAAe;AACb,mCAAe,EAAE,QAAF,CAAW,CAAX,EAAc,MAA7B,EAAqC,EAArC,EAAyC,WAAS,CAAT,GAAU,+BAAnD;AACD;AACD,iCAAiB,IAAjB,CAAsB,IAAC,CAAA,UAAvB,CAAuB,SAAvB;AACD;AACF;AAED,eAAO,SAAP;AACD;AAED,aAAA,cAAA,CAAwB,IAAxB,EAAqC,UAArC,EAAwD,YAAxD,EAA2E;AACzE,YAAI,SAAJ,EAAe;AACb,sBAAU,gBAAV;AACD;AAED,YAAM,WAAW,aAAjB;AAEA,oBAAY,UAAZ,EAAwB,KAAK,MAAL,IAAe,IAAvC,EAA6C,QAA7C;AAEA;AACA,YAAM,oBAAoB,KAAK,IAAL,CAAU,KAAV,EAAiB,iBAA3C;AACA,YAAI,iBAAJ,EAAuB;AACrB,gBAAI,iBAAiB,UAAjB,IAA+B,KAAK,KAAL,KAAe,WAAW,KAAX,CAAiB,KAAnE,EAA0E;AACxE,qBAAK,KAAL,CAAW,IAAX,GAAkB,WAAW,KAAX,CAAiB,KAAnC;AACA,2BAAW,KAAX,CAAiB,KAAjB,GAAyB,KAAK,KAA9B;AACD,aAHD,MAGO,IAAI,iBAAiB,UAAjB,IAA+B,KAAK,KAAL,KAAe,aAAa,KAAb,CAAmB,IAArE,EAA2E;AAChF,qBAAK,KAAL,CAAW,IAAX,GAAkB,aAAa,KAAb,CAAmB,IAArC;AACA,6BAAa,KAAb,CAAmB,IAAnB,GAA0B,KAAK,KAA/B;AACD,aAHM,MAGA;AACL,qBAAK,KAAL,CAAW,IAAX,GAAkB,IAAlB;AACD;AAED,gBAAI,WAAW,IAAX,KAAoB,KAAK,IAA7B,EAAmC,KAAK,KAAL,CAAW,MAAX,GAAoB,WAAW,KAA/B;AACpC;AAED;AACA,YAAI,KAAK,KAAL,CAAW,IAAX,KAAe,CAAf,CAAe,eAAf,IAA2C,KAAK,qBAApD,EAA2E;AACzE,wBAAY,UAAZ,EAAwB,KAAK,qBAAL,CAA2B,MAA3B,IAAqC,IAA7D,EAAmE,QAAnE;AACA,gBAAI,iBAAJ,EAAuB;AACrB,qBAAK,KAAL,CAAW,oBAAX,GAAkC,KAAK,qBAAL,CAA2B,KAA7D;AACA,qBAAK,qBAAL,CAA2B,KAA3B,CAAiC,MAAjC,GAA0C,KAAK,KAA/C;AACD;AACD,mBAAO,KAAK,qBAAZ;AACD;AAED,eAAO,IAAP;AACD;AAED;;;;;;;AAOA,WAAM,SAAA,SAAA,CAAoB,UAApB,EAAwC,YAAxC,EAAuE;AAC3E,YAAM,WAAW,aAAjB;AACA,YAAI,SAAJ,EAAe;AACb,wBAAY,SAAS,aAAT,CAAZ,EAAqC,CAAC,CAAtC,EAAyC,+CAAzC;AACD;AAED,YAAI,CAAC,YAAL,EAAmB;AACjB;AACD;AAED,YAAM,WAAW,aAAjB;AACA,YAAI,kBAAyB,eAAe,KAAK,UAAL,CAAf,KAAoC,yBAAjE;AACA,YAAI,oBAA2B,eAA/B;AACA,gCAb2E,CAajD;AAE1B,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C,gBAAM,cAAc,aAAa,CAAb,CAApB;AACA,oBAAQ,cAAW,CAAA,SAAnB,CAAmB,qBAAnB,GACE,KAAA,UAAA,CAAA,aAAA;AACE,wBAAM,UAAiB,KAAK,cAAW,SAAhB,CAAgB,eAAhB,CAAvB;AACA,wCAAoB,eAAe,OAAf,EAAwB,eAAxB,EAAyC,iBAAzC,CAApB;AACA,sCAAkB,OAAlB;AACA;AACF,qBAAA,UAAA,CAAA,gBAAA;AACA,qBAAA,CAAA,UAAA,CAAA,kBAAA;AACA,qBAAA,CAAA,UAAA,CAAA,SAAA;AACE,wBAAM,OAAc,KAAK,cAAW,SAAhB,CAAgB,eAAhB,CAApB;AACA,wCAAoB,eAAe,IAAf,EAAqB,eAArB,EAAsC,iBAAtC,CAApB;AACA;AACF,qBAAA,SAAA,CAAA,UAAA;AACE,wBAAI,SAAJ,EAAe;AACb,kCAAU,sBAAV;AACD;AACD,wBAAM,QAAQ,aAAa,EAAE,CAAf,CAAd;AACA,wBAAM,YAAY,eAAe,KAAf,EAAsB,QAAtB,CAAlB;AACA;AACA;AACA;AACA,wBAAM,YACF,YAAY,SAAS,MAAT,GAAkB,aAA9B,EAA2C,CAA3C,CAA2C,aAA3C,EAAgE,SAAhE,EAA2E,IAA3E,EAAiF,IAAjF,CADJ;AAEA,wCAAoB,eAAe,SAAf,EAA0B,eAA1B,EAA2C,iBAA3C,CAApB;AACA;AACA;AACF,qBAAA,CAAA,UAAA,CAAA,eAAA;AACE,wCAAoB,eAApB;AACA,sCAAkB,eAAe,eAAf,CAAlB;AACA;AACF,qBAAA,CAAA,SAAA,CAAA,gBAAA;AACE,wBAAI,SAAJ,EAAe;AACb,kCAAU,kBAAV;AACD;AACD,wBAAM,QAAQ,cAAW,SAAzB,CAAyB,eAAzB;AACA,wBAAM,cAAoC,KAAK,KAAL,CAA1C;AACA,wBAAM,aAAa,eAAe,WAAf,CAAnB;AACA,gCAAY,UAAZ,EAAwB,YAAY,MAAZ,IAAsB,IAA9C,EAAoD,QAApD;AAEA;AACA,wBAAI,YAAY,KAAZ,CAAkB,IAAlB,KAAsB,CAAtB,CAAsB,eAAtB,IAAkD,YAAY,qBAAlE,EAAyF;AACvF,oCAAY,UAAZ,EAAwB,YAAY,qBAAZ,CAAkC,MAAlC,IAA4C,IAApE,EAA0E,QAA1E;AACA,oCAAY,qBAAZ,CAAkC,KAAlC,CAAwC,QAAxC,GAAmD,IAAnD;AACA,oCAAY,qBAAZ,CAAkC,IAAlC,CAAuC,aAAvC,IAAwD,IAAxD;AACD;AACD;AA7CJ;AA+CD;AACF;AAED;;;;;;AAMA,WAAM,SAAA,cAAA,CACF,WADE,EACmB,YADnB,EAC+C;AACnD,YAAM,aAAmC,YAAY,KAAZ,CAAkB,YAAlB,CAAzC;AACA;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,WAAW,MAA/B,EAAuC,KAAK,CAA5C,EAA+C;AAC7C,uBAAW,CAAX,IAAgB,aAAa,WAAW,CAAX,CAAb,CAAhB;AACD;AACD,eAAO,UAAP;AACD;AAED;;;;;;;;;AASA,WAAM,SAAA,kBAAA,CAA6B,YAA7B,EAAiE,EAAjE,EAAwE;AAC5E,YAAM,YAAY,eAAe,EAAf,CAAlB;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT,uBAAO,UAAU,EAAV,CAAP;AACD,aAFD,MAEO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;AAUA,WAAM,SAAA,kBAAA,CAA6B,YAA7B,EAAiE,EAAjE,EAA0E,EAA1E,EAAiF;AAErF,YAAM,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,CAAlB;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAK,EAAL,GAAU,EAAxB;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aARD,MAQO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;AAWA,WAAM,SAAA,kBAAA,CACF,YADE,EACkC,EADlC,EAC2C,EAD3C,EACoD,EADpD,EAC2D;AAC/D,YAAI,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,CAAhB;AACA,oBAAY,eAAe,EAAf,KAAsB,SAAlC;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAK,EAAL,GAAW,KAAK,EAAL,GAAU,EAAnC;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aATD,MASO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;;AAYA,WAAM,SAAA,kBAAA,CACF,YADE,EACkC,EADlC,EAC2C,EAD3C,EACoD,EADpD,EAC6D,EAD7D,EACoE;AACxE,YAAM,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAAlB;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EAA/C;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aATD,MASO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;;;AAaA,WAAM,SAAA,kBAAA,CACF,YADE,EACkC,EADlC,EAC2C,EAD3C,EACoD,EADpD,EAC6D,EAD7D,EACsE,EADtE,EAC6E;AAEjF,YAAI,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAAhB;AACA,oBAAY,eAAe,EAAf,KAAsB,SAAlC;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAK,EAAL,GAAW,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EAA1D;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aAVD,MAUO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;;;OAaI,OAAM,SAAA,kBAAA,CAEN,YAFM,EAE8B,EAF9B,EAEuC,EAFvC,EAEgD,EAFhD,EAEyD,EAFzD,EAEkE,EAFlE,EAE2E,EAF3E,EAEkF;AAE1F,YAAI,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAAhB;AACA,oBAAY,gBAAgB,EAAhB,EAAoB,EAApB,KAA2B,SAAvC;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EAAtE;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aAVD,MAUO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;AAeA,WAAM,SAAA,kBAAA,CACF,YADE,EACkC,EADlC,EAC2C,EAD3C,EACoD,EADpD,EAC6D,EAD7D,EACsE,EADtE,EAC+E,EAD/E,EAEF,EAFE,EAEK;AACT,YAAI,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAAhB;AACA,oBAAY,gBAAgB,EAAhB,EAAoB,EAApB,KAA2B,SAAvC;AACA,oBAAY,eAAe,EAAf,KAAsB,SAAlC;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QAAQ,KAAM,KAAK,EAAL,GAAW,KAAK,EAAL,GAAU,EAA3B,GAAmC,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EAAlF;AAEA,uBAAO,UAAU,KAAV,CAAP;AACD,aAVD,MAUO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;;;;;;;;;AAgBA,WAAM,SAAA,kBAAA,CACF,YADE,EACkC,EADlC,EAC2C,EAD3C,EACoD,EADpD,EAC6D,EAD7D,EACsE,EADtE,EAC+E,EAD/E,EAEF,EAFE,EAEO,EAFP,EAEc;AAClB,YAAI,YAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,CAAhB;AACA,oBAAY,gBAAgB,EAAhB,EAAoB,EAApB,EAAwB,EAAxB,EAA4B,EAA5B,KAAmC,SAA/C;AAEA,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT;AACA,oBAAM,MAAM,aAAa,CAAb,CAAZ;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA,oBAAM,KAAK,MAAM,CAAjB;AACA;AACA,oBAAM,QACF,KAAM,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EAAvC,GAA+C,KAAM,KAAK,EAAL,GAAU,EAAhB,GAAuB,KAAK,EAAL,GAAU,EADpF;AAGA,uBAAO,UAAU,KAAV,CAAP;AACD,aAXD,MAWO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD;AAED;;;;;;;;AAQA,WAAM,SAAA,kBAAA,CAA6B,YAA7B,EAAiE,MAAjE,EAA8E;AAElF,YAAI,YAAY,KAAhB;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;AACtC;AACA,2BAAe,OAAO,CAAP,CAAf,MAA8B,YAAY,IAA1C;AACD;AAED,YAAI,CAAC,SAAL,EAAgB;AACd,mBAAO,SAAP;AACD;AAED,YAAI,MAAM,EAAV;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,MAAjC,EAAyC,GAAzC,EAA8C;AAC5C;AACA,gBAAI,IAAI,CAAR,EAAW;AACT,uBAAO,UAAU,OAAO,aAAa,CAAb,CAAP,CAAV,CAAP;AACD,aAFD,MAEO;AACL,uBAAO,aAAa,CAAb,CAAP;AACD;AACF;AAED,eAAO,GAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThan} from './assert';\nimport {NO_CHANGE, bindingUpdated, bindingUpdated2, bindingUpdated4, createLNode, getPreviousOrParentNode, getRenderer, getViewData, load, resetApplicationState} from './instructions';\nimport {RENDER_PARENT} from './interfaces/container';\nimport {LContainerNode, LNode, TContainerNode, TElementNode, TNodeType} from './interfaces/node';\nimport {BINDING_INDEX, HEADER_OFFSET, TVIEW} from './interfaces/view';\nimport {appendChild, createTextNode, getParentLNode, removeChild} from './node_manipulation';\nimport {stringify} from './util';\n\n/**\n * A list of flags to encode the i18n instructions used to translate the template.\n * We shift the flags by 29 so that 30 & 31 & 32 bits contains the instructions.\n */\nexport const enum I18nInstructions {\n  Text = 1 << 29,\n  Element = 2 << 29,\n  Expression = 3 << 29,\n  TemplateRoot = 4 << 29,\n  Any = 5 << 29,\n  CloseNode = 6 << 29,\n  RemoveNode = 7 << 29,\n  /** Used to decode the number encoded with the instruction. */\n  IndexMask = (1 << 29) - 1,\n  /** Used to test the type of instruction. */\n  InstructionMask = ~((1 << 29) - 1),\n}\n\n/**\n * Represents the instructions used to translate the template.\n * Instructions can be a placeholder index, a static text or a simple bit field (`I18nFlag`).\n * When the instruction is the flag `Text`, it is always followed by its text value.\n */\nexport type I18nInstruction = number | string;\n/**\n * Represents the instructions used to translate attributes containing expressions.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport type I18nExpInstruction = number | string;\n/** Mapping of placeholder names to their absolute indexes in their templates. */\nexport type PlaceholderMap = {\n  [name: string]: number\n};\nconst i18nTagRegex = /{\\$([^}]+)}/g;\n\n/**\n * Takes a translation string, the initial list of placeholders (elements and expressions) and the\n * indexes of their corresponding expression nodes to return a list of instructions for each\n * template function.\n *\n * Because embedded templates have different indexes for each placeholder, each parameter (except\n * the translation) is an array, where each value corresponds to a different template, by order of\n * appearance.\n *\n * @param translation A translation string where placeholders are represented by `{$name}`\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns A list of instructions used to translate each template.\n */\nexport function i18nMapping(\n    translation: string, elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): I18nInstruction[][] {\n  const translationParts = translation.split(i18nTagRegex);\n  const nbTemplates = templateRoots ? templateRoots.length + 1 : 1;\n  const instructions: I18nInstruction[][] = (new Array(nbTemplates)).fill(undefined);\n\n  generateMappingInstructions(\n      0, 0, translationParts, instructions, elements, expressions, templateRoots, lastChildIndex);\n\n  return instructions;\n}\n\n/**\n * Internal function that reads the translation parts and generates a set of instructions for each\n * template.\n *\n * See `i18nMapping()` for more details.\n *\n * @param tmplIndex The order of appearance of the template.\n * 0 for the root template, following indexes match the order in `templateRoots`.\n * @param partIndex The current index in `translationParts`.\n * @param translationParts The translation string split into an array of placeholders and text\n * elements.\n * @param instructions The current list of instructions to update.\n * @param elements An array containing, for each template, the maps of element placeholders and\n * their indexes.\n * @param expressions An array containing, for each template, the maps of expression placeholders\n * and their indexes.\n * @param templateRoots An array of template roots whose content should be ignored when\n * generating the instructions for their parent template.\n * @param lastChildIndex The index of the last child of the i18n node. Used when the i18n block is\n * an ng-container.\n *\n * @returns the current index in `translationParts`\n */\nfunction generateMappingInstructions(\n    tmplIndex: number, partIndex: number, translationParts: string[],\n    instructions: I18nInstruction[][], elements: (PlaceholderMap | null)[] | null,\n    expressions?: (PlaceholderMap | null)[] | null, templateRoots?: string[] | null,\n    lastChildIndex?: number | null): number {\n  const tmplInstructions: I18nInstruction[] = [];\n  const phVisited: string[] = [];\n  let openedTagCount = 0;\n  let maxIndex = 0;\n  let currentElements: PlaceholderMap|null =\n      elements && elements[tmplIndex] ? elements[tmplIndex] : null;\n  let currentExpressions: PlaceholderMap|null =\n      expressions && expressions[tmplIndex] ? expressions[tmplIndex] : null;\n\n  instructions[tmplIndex] = tmplInstructions;\n\n  for (; partIndex < translationParts.length; partIndex++) {\n    // The value can either be text or the name of a placeholder (element/template root/expression)\n    const value = translationParts[partIndex];\n\n    // Odd indexes are placeholders\n    if (partIndex & 1) {\n      let phIndex;\n      if (currentElements && currentElements[value] !== undefined) {\n        phIndex = currentElements[value];\n        // The placeholder represents a DOM element, add an instruction to move it\n        let templateRootIndex = templateRoots ? templateRoots.indexOf(value) : -1;\n        if (templateRootIndex !== -1 && (templateRootIndex + 1) !== tmplIndex) {\n          // This is a template root, it has no closing tag, not treating it as an element\n          tmplInstructions.push(phIndex | I18nInstructions.TemplateRoot);\n        } else {\n          tmplInstructions.push(phIndex | I18nInstructions.Element);\n          openedTagCount++;\n        }\n        phVisited.push(value);\n      } else if (currentExpressions && currentExpressions[value] !== undefined) {\n        phIndex = currentExpressions[value];\n        // The placeholder represents an expression, add an instruction to move it\n        tmplInstructions.push(phIndex | I18nInstructions.Expression);\n        phVisited.push(value);\n      } else {\n        // It is a closing tag\n        tmplInstructions.push(I18nInstructions.CloseNode);\n\n        if (tmplIndex > 0) {\n          openedTagCount--;\n\n          // If we have reached the closing tag for this template, exit the loop\n          if (openedTagCount === 0) {\n            break;\n          }\n        }\n      }\n\n      if (phIndex !== undefined && phIndex > maxIndex) {\n        maxIndex = phIndex;\n      }\n\n      if (templateRoots) {\n        const newTmplIndex = templateRoots.indexOf(value) + 1;\n        if (newTmplIndex !== 0 && newTmplIndex !== tmplIndex) {\n          partIndex = generateMappingInstructions(\n              newTmplIndex, partIndex, translationParts, instructions, elements, expressions,\n              templateRoots, lastChildIndex);\n        }\n      }\n\n    } else if (value) {\n      // It's a non-empty string, create a text node\n      tmplInstructions.push(I18nInstructions.Text, value);\n    }\n  }\n\n  // Add instructions to remove elements that are not used in the translation\n  if (elements) {\n    const tmplElements = elements[tmplIndex];\n\n    if (tmplElements) {\n      const phKeys = Object.keys(tmplElements);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplElements[ph];\n          // Add an instruction to remove the element\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  // Add instructions to remove expressions that are not used in the translation\n  if (expressions) {\n    const tmplExpressions = expressions[tmplIndex];\n\n    if (tmplExpressions) {\n      const phKeys = Object.keys(tmplExpressions);\n\n      for (let i = 0; i < phKeys.length; i++) {\n        const ph = phKeys[i];\n\n        if (phVisited.indexOf(ph) === -1) {\n          let index = tmplExpressions[ph];\n          if (ngDevMode) {\n            assertLessThan(\n                index.toString(2).length, 28, `Index ${index} is too big and will overflow`);\n          }\n          // Add an instruction to remove the expression\n          tmplInstructions.push(index | I18nInstructions.RemoveNode);\n\n          if (index > maxIndex) {\n            maxIndex = index;\n          }\n        }\n      }\n    }\n  }\n\n  if (tmplIndex === 0 && typeof lastChildIndex === 'number') {\n    // The current parent is an ng-container and it has more children after the translation that we\n    // need to append to keep the order of the DOM nodes correct\n    for (let i = maxIndex + 1; i <= lastChildIndex; i++) {\n      if (ngDevMode) {\n        assertLessThan(i.toString(2).length, 28, `Index ${i} is too big and will overflow`);\n      }\n      tmplInstructions.push(i | I18nInstructions.Any);\n    }\n  }\n\n  return partIndex;\n}\n\nfunction appendI18nNode(node: LNode, parentNode: LNode, previousNode: LNode) {\n  if (ngDevMode) {\n    ngDevMode.rendererMoveNode++;\n  }\n\n  const viewData = getViewData();\n\n  appendChild(parentNode, node.native || null, viewData);\n\n  // On first pass, re-organize node tree to put this node in the correct position.\n  const firstTemplatePass = node.view[TVIEW].firstTemplatePass;\n  if (firstTemplatePass) {\n    if (previousNode === parentNode && node.tNode !== parentNode.tNode.child) {\n      node.tNode.next = parentNode.tNode.child;\n      parentNode.tNode.child = node.tNode;\n    } else if (previousNode !== parentNode && node.tNode !== previousNode.tNode.next) {\n      node.tNode.next = previousNode.tNode.next;\n      previousNode.tNode.next = node.tNode;\n    } else {\n      node.tNode.next = null;\n    }\n\n    if (parentNode.view === node.view) node.tNode.parent = parentNode.tNode as TElementNode;\n  }\n\n  // Template containers also have a comment node for the `ViewContainerRef` that should be moved\n  if (node.tNode.type === TNodeType.Container && node.dynamicLContainerNode) {\n    appendChild(parentNode, node.dynamicLContainerNode.native || null, viewData);\n    if (firstTemplatePass) {\n      node.tNode.dynamicContainerNode = node.dynamicLContainerNode.tNode;\n      node.dynamicLContainerNode.tNode.parent = node.tNode as TContainerNode;\n    }\n    return node.dynamicLContainerNode;\n  }\n\n  return node;\n}\n\n/**\n * Takes a list of instructions generated by `i18nMapping()` to transform the template accordingly.\n *\n * @param startIndex Index of the first element to translate (for instance the first child of the\n * element with the i18n attribute).\n * @param instructions The list of instructions to apply on the current view.\n */\nexport function i18nApply(startIndex: number, instructions: I18nInstruction[]): void {\n  const viewData = getViewData();\n  if (ngDevMode) {\n    assertEqual(viewData[BINDING_INDEX], -1, 'i18nApply should be called before any binding');\n  }\n\n  if (!instructions) {\n    return;\n  }\n\n  const renderer = getRenderer();\n  let localParentNode: LNode = getParentLNode(load(startIndex)) || getPreviousOrParentNode();\n  let localPreviousNode: LNode = localParentNode;\n  resetApplicationState();  // We don't want to add to the tree with the wrong previous node\n\n  for (let i = 0; i < instructions.length; i++) {\n    const instruction = instructions[i] as number;\n    switch (instruction & I18nInstructions.InstructionMask) {\n      case I18nInstructions.Element:\n        const element: LNode = load(instruction & I18nInstructions.IndexMask);\n        localPreviousNode = appendI18nNode(element, localParentNode, localPreviousNode);\n        localParentNode = element;\n        break;\n      case I18nInstructions.Expression:\n      case I18nInstructions.TemplateRoot:\n      case I18nInstructions.Any:\n        const node: LNode = load(instruction & I18nInstructions.IndexMask);\n        localPreviousNode = appendI18nNode(node, localParentNode, localPreviousNode);\n        break;\n      case I18nInstructions.Text:\n        if (ngDevMode) {\n          ngDevMode.rendererCreateTextNode++;\n        }\n        const value = instructions[++i];\n        const textRNode = createTextNode(value, renderer);\n        // If we were to only create a `RNode` then projections won't move the text.\n        // Create text node at the current end of viewData. Must subtract header offset because\n        // createLNode takes a raw index (not adjusted by header offset).\n        const textLNode =\n            createLNode(viewData.length - HEADER_OFFSET, TNodeType.Element, textRNode, null, null);\n        localPreviousNode = appendI18nNode(textLNode, localParentNode, localPreviousNode);\n        resetApplicationState();\n        break;\n      case I18nInstructions.CloseNode:\n        localPreviousNode = localParentNode;\n        localParentNode = getParentLNode(localParentNode) !;\n        break;\n      case I18nInstructions.RemoveNode:\n        if (ngDevMode) {\n          ngDevMode.rendererRemoveNode++;\n        }\n        const index = instruction & I18nInstructions.IndexMask;\n        const removedNode: LNode|LContainerNode = load(index);\n        const parentNode = getParentLNode(removedNode) !;\n        removeChild(parentNode, removedNode.native || null, viewData);\n\n        // For template containers we also need to remove their `ViewContainerRef` from the DOM\n        if (removedNode.tNode.type === TNodeType.Container && removedNode.dynamicLContainerNode) {\n          removeChild(parentNode, removedNode.dynamicLContainerNode.native || null, viewData);\n          removedNode.dynamicLContainerNode.tNode.detached = true;\n          removedNode.dynamicLContainerNode.data[RENDER_PARENT] = null;\n        }\n        break;\n    }\n  }\n}\n\n/**\n * Takes a translation string and the initial list of expressions and returns a list of instructions\n * that will be used to translate an attribute.\n * Even indexes contain static strings, while odd indexes contain the index of the expression whose\n * value will be concatenated into the final translation.\n */\nexport function i18nExpMapping(\n    translation: string, placeholders: PlaceholderMap): I18nExpInstruction[] {\n  const staticText: I18nExpInstruction[] = translation.split(i18nTagRegex);\n  // odd indexes are placeholders\n  for (let i = 1; i < staticText.length; i += 2) {\n    staticText[i] = placeholders[staticText[i]];\n  }\n  return staticText;\n}\n\n/**\n * Checks if the value of an expression has changed and replaces it by its value in a translation,\n * or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation1(instructions: I18nExpInstruction[], v0: any): string|NO_CHANGE {\n  const different = bindingUpdated(v0);\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      res += stringify(v0);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 2 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation2(instructions: I18nExpInstruction[], v0: any, v1: any): string|\n    NO_CHANGE {\n  const different = bindingUpdated2(v0, v1);\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b1 ? v1 : v0;\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 3 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation3(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any): string|NO_CHANGE {\n  let different = bindingUpdated2(v0, v1);\n  different = bindingUpdated(v2) || different;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? v2 : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 4 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation4(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any): string|NO_CHANGE {\n  const different = bindingUpdated4(v0, v1, v2, v3);\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0);\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 5 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation5(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated(v4) || different;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? v4 : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 6 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */ export function\ni18nInterpolation6(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any):\n    string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b1 ? v5 : v4) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 7 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation7(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n  different = bindingUpdated(v6) || different;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value = b4 ? (b2 ? v6 : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Checks if the values of up to 8 expressions have changed and replaces them by their values in a\n * translation, or returns NO_CHANGE.\n *\n * @param instructions A list of instructions that will be used to translate an attribute.\n * @param v0 value checked for change.\n * @param v1 value checked for change.\n * @param v2 value checked for change.\n * @param v3 value checked for change.\n * @param v4 value checked for change.\n * @param v5 value checked for change.\n * @param v6 value checked for change.\n * @param v7 value checked for change.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolation8(\n    instructions: I18nExpInstruction[], v0: any, v1: any, v2: any, v3: any, v4: any, v5: any,\n    v6: any, v7: any): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated4(v4, v5, v6, v7) || different;\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are bindings\n    if (i & 1) {\n      // Extract bits\n      const idx = instructions[i] as number;\n      const b4 = idx & 4;\n      const b2 = idx & 2;\n      const b1 = idx & 1;\n      // Get the value from the argument vx where x = idx\n      const value =\n          b4 ? (b2 ? (b1 ? v7 : v6) : (b1 ? v5 : v4)) : (b2 ? (b1 ? v3 : v2) : (b1 ? v1 : v0));\n\n      res += stringify(value);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n\n/**\n * Create a translated interpolation binding with a variable number of expressions.\n *\n * If there are 1 to 8 expressions then `i18nInterpolation()` should be used instead. It is faster\n * because there is no need to create an array of expressions and iterate over it.\n *\n * @returns The concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function i18nInterpolationV(instructions: I18nExpInstruction[], values: any[]): string|\n    NO_CHANGE {\n  let different = false;\n  for (let i = 0; i < values.length; i++) {\n    // Check if bindings have changed\n    bindingUpdated(values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  let res = '';\n  for (let i = 0; i < instructions.length; i++) {\n    // Odd indexes are placeholders\n    if (i & 1) {\n      res += stringify(values[instructions[i] as number]);\n    } else {\n      res += instructions[i];\n    }\n  }\n\n  return res;\n}\n"],"sourceRoot":""}