{"version":3,"sources":["../../../../../../../../../../../packages/core/src/render3/jit/module.ts"],"names":[],"mappings":";;;;;;;;;;AAQA,aAA4D,eAA5D,EAA6E,eAA7E,EAA8F,mBAAmB,iBAAjH,EAAoI,aAApI,QAAwJ,mBAAxJ;AAMA,aAAQ,cAAR,QAA6B,eAA7B;AACA,aAAQ,gBAAR,EAA0B,gBAA1B,EAA4C,eAA5C,EAA6D,aAA7D,EAA4E,WAA5E,QAA8F,UAA9F;AACA,aAAQ,mBAAR,QAAkC,QAAlC;AAEA,QAAM,cAA2B,EAAjC;AAEA,WAAM,SAAA,eAAA,CAA0B,IAA1B,EAA2C,QAA3C,EAA6D;AACjE,YAAM,eAA4B,QAAQ,SAAS,YAAT,IAAyB,WAAjC,CAAlC;AAEA,YAAI,cAAmB,IAAvB;AACA,eAAO,cAAP,CAAsB,IAAtB,EAA4B,aAA5B,EAA2C;AACzC,iBAAK,YAAA;AACH,oBAAI,gBAAgB,IAApB,EAA0B;AACxB,wBAAM,OAA2B;AAC/B,8BAAM,KAAK,IAAL,CADyB;AAE/B,mCAAW,QAAQ,SAAS,SAAT,IAAsB,WAA9B,EAA2C,GAA3C,CAA+C,IAA/C,CAFoB;AAG/B,sCAAc,aAAa,GAAb,CAAiB,IAAjB,CAHiB;AAI/B,iCACI,QAAQ,SAAS,OAAT,IAAoB,WAA5B,EAAyC,GAAzC,CAA6C,yBAA7C,EAAwE,GAAxE,CAA4E,IAA5E,CAL2B;AAM/B,iCACI,QAAQ,SAAS,OAAT,IAAoB,WAA5B,EAAyC,GAAzC,CAA6C,yBAA7C,EAAwE,GAAxE,CAA4E,IAA5E,CAP2B;AAQ/B,oCAAY;AARmB,qBAAjC;AAUA,wBAAM,MAAM,kBAAkB,IAAlB,CAAZ;AACA,kCACI,cAAc,IAAI,UAAlB,EAA8B,cAA9B,EAA8C,UAAQ,KAAK,IAAb,GAAiB,iBAA/D,CADJ;AAED;AACD,uBAAO,WAAP;AACD;AAlBwC,SAA3C;AAqBA,YAAI,gBAAqB,IAAzB;AACA,eAAO,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;AAC3C,iBAAK,YAAA;AACH,oBAAI,kBAAkB,IAAtB,EAA4B;AAC1B,wBAAM,OAA2B;AAC/B,8BAAM,KAAK,IADoB;AAE/B,8BAAM,KAAK,IAAL,CAFyB;AAG/B,8BAAM,oBAAoB,IAApB,CAHyB;AAI/B,mCAAW,IAAI,eAAJ,CAAoB,SAAS,SAAT,IAAsB,WAA1C,CAJoB;AAK/B,iCAAS,IAAI,eAAJ,CAAoB,CAC3B,SAAS,OAAT,IAAoB,WADO,EAE3B,SAAS,OAAT,IAAoB,WAFO,CAApB;AALsB,qBAAjC;AAUA,wBAAM,MAAM,gBAAgB,IAAhB,CAAZ;AACA,oCACI,cAAc,IAAI,UAAlB,EAA8B,cAA9B,EAA8C,UAAQ,KAAK,IAAb,GAAiB,mBAA/D,CADJ;AAED;AACD,uBAAO,aAAP;AACD;AAlB0C,SAA7C;AAqBA,qBAAa,OAAb,CAAqB,UAAA,WAAA,EAAW;AAC9B;AACA;AACA;AACA,gBAAI,YAAY,cAAZ,CAA2B,gBAA3B,CAAJ,EAAkD;AAChD;AACA,2CACK,YAAuE,cAD5E,EAEI,IAFJ;AAGD,aALD,MAKO,IACH,CAAC,YAAY,cAAZ,CAA2B,gBAA3B,CAAD,IAAiD,CAAC,YAAY,cAAZ,CAA2B,WAA3B,CAD/C,EACwF;AAC7F;AACC,4BAAmD,eAAnD,GAAqE,IAArE;AACF;AACF,SAdD;AAeD;AAED;;;;AAIA,WAAM,SAAA,0BAAA,CACF,YADE,EACqC,MADrC,EACoD;AACxD,qBAAa,aAAb,GAA6B,YAAA;AAAM,mBAAA,MAAM,IAAN,CAAW,oBAAoB,MAApB,EAA4B,WAA5B,CAAwC,UAAnD,EACK,GADL,CACS,UAAA,GAAA,EAAG;AAAI,uBAAA,IAAI,cAAJ,IAAsB,IAAtB,cAAA;AAAwC,aADxD,EAEK,MAFL,CAEY,UAAA,GAAA,EAAG;AAAI,uBAAA,CAAC,CAAD,GAAA;AAFnB,aAAA,CAAA;AAEyB,SAF5D;AAGA,qBAAa,QAAb,GAAwB,YAAA;AACpB,mBAAA,MAAM,IAAN,CAAW,oBAAoB,MAApB,EAA4B,WAA5B,CAAwC,KAAnD,EAA0D,GAA1D,CAA8D,UAAA,IAAA,EAAI;AAAI,uBAAA,KAAA,SAAA;AAAc,aAApF,CAAA;AAAqF,SADzF;AAED;AAED;;;;;;;AAOA,WAAM,SAAA,mBAAA,CAAiC,UAAjC,EAAoD;AACxD,YAAI,CAAC,WAAW,UAAX,CAAL,EAA6B;AAC3B,kBAAM,IAAI,KAAJ,CAAa,WAAW,IAAX,GAAe,+BAA5B,CAAN;AACD;AACD,YAAM,MAAM,WAAW,WAAvB;AAEA,YAAI,IAAI,uBAAJ,KAAgC,IAApC,EAA0C;AACxC,mBAAO,IAAI,uBAAX;AACD;AAED,YAAM,SAAmC;AACvC,yBAAa;AACX,4BAAY,IAAI,GAAJ,EADD;AAEX,uBAAO,IAAI,GAAJ;AAFI,aAD0B;AAKvC,sBAAU;AACR,4BAAY,IAAI,GAAJ,EADJ;AAER,uBAAO,IAAI,GAAJ;AAFC;AAL6B,SAAzC;AAWA,YAAI,YAAJ,CAAiB,OAAjB,CAAyB,UAAA,QAAA,EAAQ;AAC/B,gBAAM,mBAAmB,QAAzB;AAEA,gBAAI,iBAAiB,SAAjB,KAA+B,SAAnC,EAA8C;AAC5C,uBAAO,WAAP,CAAmB,KAAnB,CAAyB,GAAzB,CAA6B,QAA7B;AACD,aAFD,MAEO;AACL;AACA;AACA;AACA,uBAAO,WAAP,CAAmB,UAAnB,CAA8B,GAA9B,CAAkC,QAAlC;AACD;AACF,SAXD;AAaA,YAAI,OAAJ,CAAY,OAAZ,CAAoB,UAAI,QAAJ,EAAqB;AACvC,gBAAI,gBAAgB,QAApB;AAKA,gBAAI,CAAC,WAAc,aAAd,CAAL,EAAmC;AACjC,sBAAM,IAAI,KAAJ,CAAU,eAAa,cAAc,IAA3B,GAA+B,qCAAzC,CAAN;AACD;AAED;AACA;AACA,gBAAM,gBAAgB,oBAAoB,aAApB,CAAtB;AACA,0BAAc,QAAd,CAAuB,UAAvB,CAAkC,OAAlC,CAA0C,UAAA,KAAA,EAAK;AAAI,uBAAA,OAAO,WAAP,CAAmB,UAAnB,CAA8B,GAA9B,CAAA,KAAA,CAAA;AAAwC,aAA3F;AACA,0BAAc,QAAd,CAAuB,KAAvB,CAA6B,OAA7B,CAAqC,UAAA,KAAA,EAAK;AAAI,uBAAA,OAAO,WAAP,CAAmB,KAAnB,CAAyB,GAAzB,CAAA,KAAA,CAAA;AAAmC,aAAjF;AACD,SAfD;AAiBA,YAAI,OAAJ,CAAY,OAAZ,CAAoB,UAAI,QAAJ,EAAqB;AACvC,gBAAM,gBAAgB,QAAtB;AAQA;AACA;AACA,gBAAI,WAAW,aAAX,CAAJ,EAA+B;AAC7B;AACA;AACA,oBAAM,gBAAgB,oBAAoB,aAApB,CAAtB;AACA,8BAAc,QAAd,CAAuB,UAAvB,CAAkC,OAAlC,CAA0C,UAAA,KAAA,EAAK;AAC7C,2BAAO,WAAP,CAAmB,UAAnB,CAA8B,GAA9B,CAAkC,KAAlC;AACA,2BAAO,QAAP,CAAgB,UAAhB,CAA2B,GAA3B,CAA+B,KAA/B;AACD,iBAHD;AAIA,8BAAc,QAAd,CAAuB,KAAvB,CAA6B,OAA7B,CAAqC,UAAA,KAAA,EAAK;AACxC,2BAAO,WAAP,CAAmB,KAAnB,CAAyB,GAAzB,CAA6B,KAA7B;AACA,2BAAO,QAAP,CAAgB,KAAhB,CAAsB,GAAtB,CAA0B,KAA1B;AACD,iBAHD;AAID,aAZD,MAYO,IAAI,cAAc,SAAd,KAA4B,SAAhC,EAA2C;AAChD,uBAAO,QAAP,CAAgB,KAAhB,CAAsB,GAAtB,CAA0B,aAA1B;AACD,aAFM,MAEA;AACL,uBAAO,QAAP,CAAgB,UAAhB,CAA2B,GAA3B,CAA+B,aAA/B;AACD;AACF,SA5BD;AA8BA,YAAI,uBAAJ,GAA8B,MAA9B;AACA,eAAO,MAAP;AACD;AAED,aAAA,OAAA,CAAoB,MAApB,EAAiC;AAC/B,YAAM,MAAW,EAAjB;AACA,eAAO,OAAP,CAAe,UAAA,KAAA,EAAK;AAClB,gBAAI,MAAM,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,oBAAI,IAAJ,CAAQ,KAAR,CAAA,GAAA,EAAG,QAAA,QAAA,CAAS,QAAW,KAAX,CAAT,CAAH;AACD,aAFD,MAEO;AACL,oBAAI,IAAJ,CAAS,KAAT;AACD;AACF,SAND;AAOA,eAAO,GAAP;AACD;AAED,aAAA,yBAAA,CAAmC,KAAnC,EAAwE;AACtE,YAAI,sBAAsB,KAAtB,CAAJ,EAAkC;AAChC,mBAAO,MAAM,QAAb;AACD;AACD,eAAO,KAAP;AACD;AAED,aAAA,IAAA,CAAc,KAAd,EAA8B;AAC5B,eAAO,IAAI,eAAJ,CAAoB,KAApB,CAAP;AACD;AAED,aAAA,qBAAA,CAA+B,KAA/B,EAAyC;AACvC,eAAQ,MAA0B,QAA1B,KAAuC,SAA/C;AACD;AAED,aAAA,UAAA,CAAuB,KAAvB,EAAqC;AACnC,eAAQ,MAAgD,WAAhD,KAAgE,SAAxE;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, R3InjectorMetadata, R3NgModuleMetadata, WrappedNodeExpr, compileInjector, compileNgModule as compileR3NgModule, jitExpression} from '@angular/compiler';\n\nimport {ModuleWithProviders, NgModule, NgModuleDefInternal, NgModuleTransitiveScopes} from '../../metadata/ng_module';\nimport {Type} from '../../type';\nimport {ComponentDefInternal} from '../interfaces/definition';\n\nimport {angularCoreEnv} from './environment';\nimport {NG_COMPONENT_DEF, NG_DIRECTIVE_DEF, NG_INJECTOR_DEF, NG_MODULE_DEF, NG_PIPE_DEF} from './fields';\nimport {reflectDependencies} from './util';\n\nconst EMPTY_ARRAY: Type<any>[] = [];\n\nexport function compileNgModule(type: Type<any>, ngModule: NgModule): void {\n  const declarations: Type<any>[] = flatten(ngModule.declarations || EMPTY_ARRAY);\n\n  let ngModuleDef: any = null;\n  Object.defineProperty(type, NG_MODULE_DEF, {\n    get: () => {\n      if (ngModuleDef === null) {\n        const meta: R3NgModuleMetadata = {\n          type: wrap(type),\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(wrap),\n          declarations: declarations.map(wrap),\n          imports:\n              flatten(ngModule.imports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),\n          exports:\n              flatten(ngModule.exports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),\n          emitInline: true,\n        };\n        const res = compileR3NgModule(meta);\n        ngModuleDef =\n            jitExpression(res.expression, angularCoreEnv, `ng://${type.name}/ngModuleDef.js`);\n      }\n      return ngModuleDef;\n    },\n  });\n\n  let ngInjectorDef: any = null;\n  Object.defineProperty(type, NG_INJECTOR_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        const meta: R3InjectorMetadata = {\n          name: type.name,\n          type: wrap(type),\n          deps: reflectDependencies(type),\n          providers: new WrappedNodeExpr(ngModule.providers || EMPTY_ARRAY),\n          imports: new WrappedNodeExpr([\n            ngModule.imports || EMPTY_ARRAY,\n            ngModule.exports || EMPTY_ARRAY,\n          ]),\n        };\n        const res = compileInjector(meta);\n        ngInjectorDef =\n            jitExpression(res.expression, angularCoreEnv, `ng://${type.name}/ngInjectorDef.js`);\n      }\n      return ngInjectorDef;\n    },\n  });\n\n  declarations.forEach(declaration => {\n    // Some declared components may be compiled asynchronously, and thus may not have their\n    // ngComponentDef set yet. If this is the case, then a reference to the module is written into\n    // the `ngSelectorScope` property of the declared type.\n    if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {\n      // An `ngComponentDef` field exists - go ahead and patch the component directly.\n      patchComponentDefWithScope(\n          (declaration as Type<any>& {ngComponentDef: ComponentDefInternal<any>}).ngComponentDef,\n          type);\n    } else if (\n        !declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      // Set `ngSelectorScope` for future reference when the component compilation finishes.\n      (declaration as Type<any>& {ngSelectorScope?: any}).ngSelectorScope = type;\n    }\n  });\n}\n\n/**\n * Patch the definition of a component with directives and pipes from the compilation scope of\n * a given module.\n */\nexport function patchComponentDefWithScope<C, M>(\n    componentDef: ComponentDefInternal<C>, module: Type<M>) {\n  componentDef.directiveDefs = () => Array.from(transitiveScopesFor(module).compilation.directives)\n                                         .map(dir => dir.ngDirectiveDef || dir.ngComponentDef)\n                                         .filter(def => !!def);\n  componentDef.pipeDefs = () =>\n      Array.from(transitiveScopesFor(module).compilation.pipes).map(pipe => pipe.ngPipeDef);\n}\n\n/**\n * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.\n *\n * This operation is memoized and the result is cached on the module's definition. It can be called\n * on modules with components that have not fully compiled yet, but the result should not be used\n * until they have.\n */\nexport function transitiveScopesFor<T>(moduleType: Type<T>): NgModuleTransitiveScopes {\n  if (!isNgModule(moduleType)) {\n    throw new Error(`${moduleType.name} does not have an ngModuleDef`);\n  }\n  const def = moduleType.ngModuleDef;\n\n  if (def.transitiveCompileScopes !== null) {\n    return def.transitiveCompileScopes;\n  }\n\n  const scopes: NgModuleTransitiveScopes = {\n    compilation: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n    exported: {\n      directives: new Set<any>(),\n      pipes: new Set<any>(),\n    },\n  };\n\n  def.declarations.forEach(declared => {\n    const declaredWithDefs = declared as Type<any>& { ngPipeDef?: any; };\n\n    if (declaredWithDefs.ngPipeDef !== undefined) {\n      scopes.compilation.pipes.add(declared);\n    } else {\n      // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't\n      // had its template compiled yet. In either case, it gets added to the compilation's\n      // directives.\n      scopes.compilation.directives.add(declared);\n    }\n  });\n\n  def.imports.forEach(<I>(imported: Type<I>) => {\n    let importedTyped = imported as Type<I>& {\n      // If imported is an @NgModule:\n      ngModuleDef?: NgModuleDefInternal<I>;\n    };\n\n    if (!isNgModule<I>(importedTyped)) {\n      throw new Error(`Importing ${importedTyped.name} which does not have an ngModuleDef`);\n    }\n\n    // When this module imports another, the imported module's exported directives and pipes are\n    // added to the compilation scope of this module.\n    const importedScope = transitiveScopesFor(importedTyped);\n    importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));\n    importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));\n  });\n\n  def.exports.forEach(<E>(exported: Type<E>) => {\n    const exportedTyped = exported as Type<E>& {\n      // Components, Directives, NgModules, and Pipes can all be exported.\n      ngComponentDef?: any;\n      ngDirectiveDef?: any;\n      ngModuleDef?: NgModuleDefInternal<E>;\n      ngPipeDef?: any;\n    };\n\n    // Either the type is a module, a pipe, or a component/directive (which may not have an\n    // ngComponentDef as it might be compiled asynchronously).\n    if (isNgModule(exportedTyped)) {\n      // When this module exports another, the exported module's exported directives and pipes are\n      // added to both the compilation and exported scopes of this module.\n      const exportedScope = transitiveScopesFor(exportedTyped);\n      exportedScope.exported.directives.forEach(entry => {\n        scopes.compilation.directives.add(entry);\n        scopes.exported.directives.add(entry);\n      });\n      exportedScope.exported.pipes.forEach(entry => {\n        scopes.compilation.pipes.add(entry);\n        scopes.exported.pipes.add(entry);\n      });\n    } else if (exportedTyped.ngPipeDef !== undefined) {\n      scopes.exported.pipes.add(exportedTyped);\n    } else {\n      scopes.exported.directives.add(exportedTyped);\n    }\n  });\n\n  def.transitiveCompileScopes = scopes;\n  return scopes;\n}\n\nfunction flatten<T>(values: any[]): T[] {\n  const out: T[] = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten<T>(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\n\nfunction expandModuleWithProviders(value: Type<any>| ModuleWithProviders): Type<any> {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\n\nfunction wrap(value: Type<any>): Expression {\n  return new WrappedNodeExpr(value);\n}\n\nfunction isModuleWithProviders(value: any): value is ModuleWithProviders {\n  return (value as{ngModule?: any}).ngModule !== undefined;\n}\n\nfunction isNgModule<T>(value: Type<T>): value is Type<T>&{ngModuleDef: NgModuleDefInternal<T>} {\n  return (value as{ngModuleDef?: NgModuleDefInternal<T>}).ngModuleDef !== undefined;\n}\n"],"sourceRoot":""}