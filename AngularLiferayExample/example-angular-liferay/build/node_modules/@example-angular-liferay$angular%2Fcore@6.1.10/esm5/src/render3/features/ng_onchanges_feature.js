Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/features/ng_onchanges_feature', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { SimpleChange } from '../../change_detection/change_detection_util';
    var PRIVATE_PREFIX = '__ngOnChanges_';
    /**
     * The NgOnChangesFeature decorates a component with support for the ngOnChanges
     * lifecycle hook, so it should be included in any component that implements
     * that hook.
     *
     * If the component or directive uses inheritance, the NgOnChangesFeature MUST
     * be included as a feature AFTER {@link InheritDefinitionFeature}, otherwise
     * inherited properties will not be propagated to the ngOnChanges lifecycle
     * hook.
     *
     * Example usage:
     *
     * ```
     * static ngComponentDef = defineComponent({
     *   ...
     *   inputs: {name: 'publicName'},
     *   features: [NgOnChangesFeature]
     * });
     * ```
     */
    export function NgOnChangesFeature(definition) {
        var declaredToMinifiedInputs = definition.declaredInputs;
        var proto = definition.type.prototype;
        var _loop_1 = function (declaredName) {
            if (declaredToMinifiedInputs.hasOwnProperty(declaredName)) {
                var minifiedKey = declaredToMinifiedInputs[declaredName];
                var privateMinKey_1 = PRIVATE_PREFIX + minifiedKey;
                // Walk the prototype chain to see if we find a property descriptor
                // That way we can honor setters and getters that were inherited.
                var originalProperty = undefined;
                var checkProto = proto;
                while (!originalProperty && checkProto && Object.getPrototypeOf(checkProto) !== Object.getPrototypeOf(Object.prototype)) {
                    originalProperty = Object.getOwnPropertyDescriptor(checkProto, minifiedKey);
                    checkProto = Object.getPrototypeOf(checkProto);
                }
                var getter = originalProperty && originalProperty.get;
                var setter_1 = originalProperty && originalProperty.set;
                // create a getter and setter for property
                Object.defineProperty(proto, minifiedKey, {
                    get: getter || (setter_1 ? undefined : function () {
                        return this[privateMinKey_1];
                    }),
                    set: function (value) {
                        var simpleChanges = this[PRIVATE_PREFIX];
                        if (!simpleChanges) {
                            simpleChanges = {};
                            // Place where we will store SimpleChanges if there is a change
                            Object.defineProperty(this, PRIVATE_PREFIX, { value: simpleChanges, writable: true });
                        }
                        var isFirstChange = !this.hasOwnProperty(privateMinKey_1);
                        var currentChange = simpleChanges[declaredName];
                        if (currentChange) {
                            currentChange.currentValue = value;
                        } else {
                            simpleChanges[declaredName] = new SimpleChange(this[privateMinKey_1], value, isFirstChange);
                        }
                        if (isFirstChange) {
                            // Create a place where the actual value will be stored and make it non-enumerable
                            Object.defineProperty(this, privateMinKey_1, { value: value, writable: true });
                        } else {
                            this[privateMinKey_1] = value;
                        }
                        if (setter_1) setter_1.call(this, value);
                    }
                });
            }
        };
        for (var declaredName in declaredToMinifiedInputs) {
            _loop_1(declaredName);
        }
        // If an onInit hook is defined, it will need to wrap the ngOnChanges call
        // so the call order is changes-init-check in creation mode. In subsequent
        // change detection runs, only the check wrapper will be called.
        if (definition.onInit != null) {
            definition.onInit = onChangesWrapper(definition.onInit);
        }
        definition.doCheck = onChangesWrapper(definition.doCheck);
    }
    function onChangesWrapper(delegateHook) {
        return function () {
            var simpleChanges = this[PRIVATE_PREFIX];
            if (simpleChanges != null) {
                this.ngOnChanges(simpleChanges);
                this[PRIVATE_PREFIX] = null;
            }
            if (delegateHook) delegateHook.apply(this);
        };
    }
});
//# sourceMappingURL=ng_onchanges_feature.js.map