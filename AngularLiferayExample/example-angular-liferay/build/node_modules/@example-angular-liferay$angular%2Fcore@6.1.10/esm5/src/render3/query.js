Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/query', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { EventEmitter } from '../event_emitter';
    import { getSymbolIterator } from '../util';
    import { assertDefined, assertEqual } from './assert';
    import { ReadFromInjectorFn, getOrCreateNodeInjectorForNode } from './di';
    import { assertPreviousIsParent, getCurrentQueries, store, storeCleanupWithContext } from './instructions';
    import { unusedValueExportToPlacateAjd as unused1 } from './interfaces/definition';
    import { unusedValueExportToPlacateAjd as unused2 } from './interfaces/injector';
    import { unusedValueExportToPlacateAjd as unused3 } from './interfaces/node';
    import { unusedValueExportToPlacateAjd as unused4 } from './interfaces/query';
    import { DIRECTIVES, TVIEW } from './interfaces/view';
    import { flatten } from './util';
    var unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4;
    var LQueries_ = /** @class */function () {
        function LQueries_(deep) {
            this.shallow = null;
            this.deep = null;
            this.deep = deep == null ? null : deep;
        }
        LQueries_.prototype.track = function (queryList, predicate, descend, read) {
            if (descend) {
                this.deep = createQuery(this.deep, queryList, predicate, read != null ? read : null);
            } else {
                this.shallow = createQuery(this.shallow, queryList, predicate, read != null ? read : null);
            }
        };
        LQueries_.prototype.clone = function () {
            return this.deep ? new LQueries_(this.deep) : null;
        };
        LQueries_.prototype.child = function () {
            if (this.deep === null) {
                // if we don't have any deep queries then no need to track anything more.
                return null;
            }
            if (this.shallow === null) {
                // DeepQuery: We can reuse the current state if the child state would be same as current
                // state.
                return this;
            } else {
                // We need to create new state
                return new LQueries_(this.deep);
            }
        };
        LQueries_.prototype.container = function () {
            var result = null;
            var query = this.deep;
            while (query) {
                var containerValues = []; // prepare room for views
                query.values.push(containerValues);
                var clonedQuery = {
                    next: null,
                    list: query.list,
                    predicate: query.predicate,
                    values: containerValues,
                    containerValues: null
                };
                clonedQuery.next = result;
                result = clonedQuery;
                query = query.next;
            }
            return result ? new LQueries_(result) : null;
        };
        LQueries_.prototype.createView = function () {
            var result = null;
            var query = this.deep;
            while (query) {
                var clonedQuery = {
                    next: null,
                    list: query.list,
                    predicate: query.predicate,
                    values: [],
                    containerValues: query.values
                };
                clonedQuery.next = result;
                result = clonedQuery;
                query = query.next;
            }
            return result ? new LQueries_(result) : null;
        };
        LQueries_.prototype.insertView = function (index) {
            var query = this.deep;
            while (query) {
                ngDevMode && assertDefined(query.containerValues, 'View queries need to have a pointer to container values.');
                query.containerValues.splice(index, 0, query.values);
                query = query.next;
            }
        };
        LQueries_.prototype.addNode = function (node) {
            add(this.shallow, node);
            add(this.deep, node);
        };
        LQueries_.prototype.removeView = function () {
            var query = this.deep;
            while (query) {
                ngDevMode && assertDefined(query.containerValues, 'View queries need to have a pointer to container values.');
                var containerValues = query.containerValues;
                var viewValuesIdx = containerValues.indexOf(query.values);
                var removed = containerValues.splice(viewValuesIdx, 1);
                // mark a query as dirty only when removed view had matching modes
                ngDevMode && assertEqual(removed.length, 1, 'removed.length');
                if (removed[0].length) {
                    query.list.setDirty();
                }
                query = query.next;
            }
        };
        return LQueries_;
    }();
    export { LQueries_ };
    /**
     * Iterates over local names for a given node and returns directive index
     * (or -1 if a local name points to an element).
     *
     * @param tNode static data of a node to check
     * @param selector selector to match
     * @returns directive index, -1 or null if a selector didn't match any of the local names
     */
    function getIdxOfMatchingSelector(tNode, selector) {
        var localNames = tNode.localNames;
        if (localNames) {
            for (var i = 0; i < localNames.length; i += 2) {
                if (localNames[i] === selector) {
                    return localNames[i + 1];
                }
            }
        }
        return null;
    }
    /**
     * Iterates over all the directives for a node and returns index of a directive for a given type.
     *
     * @param node Node on which directives are present.
     * @param type Type of a directive to look for.
     * @returns Index of a found directive or null when none found.
     */
    function getIdxOfMatchingDirective(node, type) {
        var defs = node.view[TVIEW].directives;
        var flags = node.tNode.flags;
        var count = flags & 4095 /* DirectiveCountMask */;
        var start = flags >> 14 /* DirectiveStartingIndexShift */;
        var end = start + count;
        for (var i = start; i < end; i++) {
            var def = defs[i];
            if (def.type === type && def.diPublic) {
                return i;
            }
        }
        return null;
    }
    function readFromNodeInjector(nodeInjector, node, read, directiveIdx) {
        if (read instanceof ReadFromInjectorFn) {
            return read.read(nodeInjector, node, directiveIdx);
        } else {
            var matchingIdx = getIdxOfMatchingDirective(node, read);
            if (matchingIdx !== null) {
                return node.view[DIRECTIVES][matchingIdx];
            }
        }
        return null;
    }
    function add(query, node) {
        var nodeInjector = getOrCreateNodeInjectorForNode(node);
        while (query) {
            var predicate = query.predicate;
            var type = predicate.type;
            if (type) {
                var directiveIdx = getIdxOfMatchingDirective(node, type);
                if (directiveIdx !== null) {
                    // a node is matching a predicate - determine what to read
                    // if read token and / or strategy is not specified, use type as read token
                    var result = readFromNodeInjector(nodeInjector, node, predicate.read || type, directiveIdx);
                    if (result !== null) {
                        addMatch(query, result);
                    }
                }
            } else {
                var selector = predicate.selector;
                for (var i = 0; i < selector.length; i++) {
                    var directiveIdx = getIdxOfMatchingSelector(node.tNode, selector[i]);
                    if (directiveIdx !== null) {
                        // a node is matching a predicate - determine what to read
                        // note that queries using name selector must specify read strategy
                        ngDevMode && assertDefined(predicate.read, 'the node should have a predicate');
                        var result = readFromNodeInjector(nodeInjector, node, predicate.read, directiveIdx);
                        if (result !== null) {
                            addMatch(query, result);
                        }
                    }
                }
            }
            query = query.next;
        }
    }
    function addMatch(query, matchingValue) {
        query.values.push(matchingValue);
        query.list.setDirty();
    }
    function createPredicate(predicate, read) {
        var isArray = Array.isArray(predicate);
        return {
            type: isArray ? null : predicate,
            selector: isArray ? predicate : null,
            read: read
        };
    }
    function createQuery(previous, queryList, predicate, read) {
        return {
            next: previous,
            list: queryList,
            predicate: createPredicate(predicate, read),
            values: queryList._valuesTree,
            containerValues: null
        };
    }
    var QueryList_ = /** @class */function () {
        function QueryList_() {
            this.dirty = true;
            this.changes = new EventEmitter();
            this._values = [];
            /** @internal */
            this._valuesTree = [];
        }
        Object.defineProperty(QueryList_.prototype, "length", {
            get: function () {
                return this._values.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList_.prototype, "first", {
            get: function () {
                var values = this._values;
                return values.length ? values[0] : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QueryList_.prototype, "last", {
            get: function () {
                var values = this._values;
                return values.length ? values[values.length - 1] : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * See
         * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
         */
        QueryList_.prototype.map = function (fn) {
            return this._values.map(fn);
        };
        /**
         * See
         * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
         */
        QueryList_.prototype.filter = function (fn) {
            return this._values.filter(fn);
        };
        /**
         * See
         * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
         */
        QueryList_.prototype.find = function (fn) {
            return this._values.find(fn);
        };
        /**
         * See
         * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
         */
        QueryList_.prototype.reduce = function (fn, init) {
            return this._values.reduce(fn, init);
        };
        /**
         * See
         * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
         */
        QueryList_.prototype.forEach = function (fn) {
            this._values.forEach(fn);
        };
        /**
         * See
         * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
         */
        QueryList_.prototype.some = function (fn) {
            return this._values.some(fn);
        };
        QueryList_.prototype.toArray = function () {
            return this._values.slice(0);
        };
        QueryList_.prototype[getSymbolIterator()] = function () {
            return this._values[getSymbolIterator()]();
        };
        QueryList_.prototype.toString = function () {
            return this._values.toString();
        };
        QueryList_.prototype.reset = function (res) {
            this._values = flatten(res);
            this.dirty = false;
        };
        QueryList_.prototype.notifyOnChanges = function () {
            this.changes.emit(this);
        };
        QueryList_.prototype.setDirty = function () {
            this.dirty = true;
        };
        QueryList_.prototype.destroy = function () {
            this.changes.complete();
            this.changes.unsubscribe();
        };
        return QueryList_;
    }();
    export var QueryList = QueryList_;
    /**
     * Creates and returns a QueryList.
     *
     * @param memoryIndex The index in memory where the QueryList should be saved. If null,
     * this is is a content query and the QueryList will be saved later through directiveCreate.
     * @param predicate The type for which the query will search
     * @param descend Whether or not to descend into children
     * @param read What to save in the query
     * @returns QueryList<T>
     */
    export function query(memoryIndex, predicate, descend, read) {
        ngDevMode && assertPreviousIsParent();
        var queryList = new QueryList();
        var queries = getCurrentQueries(LQueries_);
        queries.track(queryList, predicate, descend, read);
        storeCleanupWithContext(null, queryList, queryList.destroy);
        if (memoryIndex != null) {
            store(memoryIndex, queryList);
        }
        return queryList;
    }
    /**
     * Refreshes a query by combining matches from all active views and removing matches from deleted
     * views.
     * Returns true if a query got dirty during change detection, false otherwise.
     */
    export function queryRefresh(queryList) {
        var queryListImpl = queryList;
        if (queryList.dirty) {
            queryList.reset(queryListImpl._valuesTree);
            queryList.notifyOnChanges();
            return true;
        }
        return false;
    }
});
//# sourceMappingURL=query.js.map