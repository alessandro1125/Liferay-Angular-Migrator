Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/util', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { assertLessThan } from './assert';
    import { HEADER_OFFSET } from './interfaces/view';
    /**
    * Must use this method for CD (instead of === ) since NaN !== NaN
    */
    export function isDifferent(a, b) {
        // NaN is the only value that is not equal to itself so the first
        // test checks if both a and b are not NaN
        return !(a !== a && b !== b) && a !== b;
    }
    export function stringify(value) {
        if (typeof value == 'function') return value.name || value;
        if (typeof value == 'string') return value;
        if (value == null) return '';
        return '' + value;
    }
    /**
     *  Function that throws a "not implemented" error so it's clear certain
     *  behaviors/methods aren't yet ready.
     *
     * @returns Not implemented error
     */
    export function notImplemented() {
        return new Error('NotImplemented');
    }
    /**
     * Flattens an array in non-recursive way. Input arrays are not modified.
     */
    export function flatten(list) {
        var result = [];
        var i = 0;
        while (i < list.length) {
            var item = list[i];
            if (Array.isArray(item)) {
                if (item.length > 0) {
                    list = item.concat(list.slice(i + 1));
                    i = 0;
                } else {
                    i++;
                }
            } else {
                result.push(item);
                i++;
            }
        }
        return result;
    }
    /** Retrieves a value from any `LViewData`. */
    export function loadInternal(index, arr) {
        ngDevMode && assertDataInRangeInternal(index + HEADER_OFFSET, arr);
        return arr[index + HEADER_OFFSET];
    }
    export function assertDataInRangeInternal(index, arr) {
        assertLessThan(index, arr ? arr.length : 0, 'index expected to be a valid data index');
    }
    /** Retrieves an element value from the provided `viewData`.
      *
      * Elements that are read may be wrapped in a style context,
      * therefore reading the value may involve unwrapping that.
      */
    export function loadElementInternal(index, arr) {
        var value = loadInternal(index, arr);
        return readElementValue(value);
    }
    export function readElementValue(value) {
        return Array.isArray(value) ? value[0] : value;
    }
});
//# sourceMappingURL=util.js.map