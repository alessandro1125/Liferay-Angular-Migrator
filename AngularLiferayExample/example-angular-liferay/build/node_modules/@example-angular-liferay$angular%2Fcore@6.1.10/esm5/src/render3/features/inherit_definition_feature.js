Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/features/inherit_definition_feature', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    /**
     * Sets properties on a target object from a source object, but only if
     * the property doesn't already exist on the target object.
     * @param target The target to set properties on
     * @param source The source of the property keys and values to set
     */
    function fillProperties(target, source) {
        for (var key in source) {
            if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                target[key] = source[key];
            }
        }
    }
    /**
     * Determines if a definition is a {@link ComponentDefInternal} or a {@link DirectiveDefInternal}
     * @param definition The definition to examine
     */
    function isComponentDef(definition) {
        var def = definition;
        return typeof def.template === 'function';
    }
    function getSuperType(type) {
        return Object.getPrototypeOf(type.prototype).constructor;
    }
    /**
     * Merges the definition from a super class to a sub class.
     * @param definition The definition that is a SubClass of another directive of component
     */
    export function InheritDefinitionFeature(definition) {
        var superType = getSuperType(definition.type);
        var superDef = undefined;
        var _loop_1 = function () {
            var e_1, _a;
            if (isComponentDef(definition)) {
                superDef = superType.ngComponentDef || superType.ngDirectiveDef;
            } else {
                if (superType.ngComponentDef) {
                    throw new Error('Directives cannot inherit Components');
                }
                superDef = superType.ngDirectiveDef;
            }
            if (superDef) {
                // Merge inputs and outputs
                fillProperties(definition.inputs, superDef.inputs);
                fillProperties(definition.declaredInputs, superDef.declaredInputs);
                fillProperties(definition.outputs, superDef.outputs);
                // Merge hostBindings
                var prevHostBindings_1 = definition.hostBindings;
                var superHostBindings_1 = superDef.hostBindings;
                if (superHostBindings_1) {
                    if (prevHostBindings_1) {
                        definition.hostBindings = function (directiveIndex, elementIndex) {
                            superHostBindings_1(directiveIndex, elementIndex);
                            prevHostBindings_1(directiveIndex, elementIndex);
                        };
                    } else {
                        definition.hostBindings = superHostBindings_1;
                    }
                }
                // Inherit hooks
                // Assume super class inheritance feature has already run.
                definition.afterContentChecked = definition.afterContentChecked || superDef.afterContentChecked;
                definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;
                definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;
                definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;
                definition.doCheck = definition.doCheck || superDef.doCheck;
                definition.onDestroy = definition.onDestroy || superDef.onDestroy;
                definition.onInit = definition.onInit || superDef.onInit;
                // Run parent features
                var features = superDef.features;
                if (features) {
                    try {
                        for (var features_1 = tslib_1.__values(features), features_1_1 = features_1.next(); !features_1_1.done; features_1_1 = features_1.next()) {
                            var feature = features_1_1.value;
                            if (feature && feature !== InheritDefinitionFeature) {
                                feature(definition);
                            }
                        }
                    } catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    } finally {
                        try {
                            if (features_1_1 && !features_1_1.done && (_a = features_1.return)) _a.call(features_1);
                        } finally {
                            if (e_1) throw e_1.error;
                        }
                    }
                }
            } else {
                // Even if we don't have a definition, check the type for the hooks and use those if need be
                var superPrototype = superType.prototype;
                if (superPrototype) {
                    definition.afterContentChecked = definition.afterContentChecked || superPrototype.afterContentChecked;
                    definition.afterContentInit = definition.afterContentInit || superPrototype.afterContentInit;
                    definition.afterViewChecked = definition.afterViewChecked || superPrototype.afterViewChecked;
                    definition.afterViewInit = definition.afterViewInit || superPrototype.afterViewInit;
                    definition.doCheck = definition.doCheck || superPrototype.doCheck;
                    definition.onDestroy = definition.onDestroy || superPrototype.onDestroy;
                    definition.onInit = definition.onInit || superPrototype.onInit;
                }
            }
            superType = Object.getPrototypeOf(superType);
        };
        while (superType && !superDef) {
            _loop_1();
        }
    }
});
//# sourceMappingURL=inherit_definition_feature.js.map