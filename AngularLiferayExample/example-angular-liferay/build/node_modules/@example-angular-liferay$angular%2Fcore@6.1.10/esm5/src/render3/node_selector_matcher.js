Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/node_selector_matcher', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import './ng_dev_mode';
    import { assertDefined, assertNotEqual } from './assert';
    import { unusedValueExportToPlacateAjd as unused1 } from './interfaces/node';
    import { NG_PROJECT_AS_ATTR_NAME, unusedValueExportToPlacateAjd as unused2 } from './interfaces/projection';
    var unusedValueToPlacateAjd = unused1 + unused2;
    function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {
        var nodeClassesLen = nodeClassAttrVal.length;
        var matchIndex = nodeClassAttrVal.indexOf(cssClassToMatch);
        var matchEndIdx = matchIndex + cssClassToMatch.length;
        if (matchIndex === -1 // no match
        || matchIndex > 0 && nodeClassAttrVal[matchIndex - 1] !== ' ' // no space before
        || matchEndIdx < nodeClassesLen && nodeClassAttrVal[matchEndIdx] !== ' ') // no space after
            {
                return false;
            }
        return true;
    }
    /**
     * A utility function to match an Ivy node static data against a simple CSS selector
     *
     * @param node static data to match
     * @param selector
     * @returns true if node matches the selector.
     */
    export function isNodeMatchingSelector(tNode, selector) {
        ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');
        var mode = 4 /* ELEMENT */;
        var nodeAttrs = tNode.attrs;
        var selectOnlyMarkerIdx = nodeAttrs ? nodeAttrs.indexOf(1 /* SelectOnly */) : -1;
        // When processing ":not" selectors, we skip to the next ":not" if the
        // current one doesn't match
        var skipToNextSelector = false;
        for (var i = 0; i < selector.length; i++) {
            var current = selector[i];
            if (typeof current === 'number') {
                // If we finish processing a :not selector and it hasn't failed, return false
                if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {
                    return false;
                }
                // If we are skipping to the next :not() and this mode flag is positive,
                // it's a part of the current :not() selector, and we should keep skipping
                if (skipToNextSelector && isPositive(current)) continue;
                skipToNextSelector = false;
                mode = current | mode & 1 /* NOT */;
                continue;
            }
            if (skipToNextSelector) continue;
            if (mode & 4 /* ELEMENT */) {
                    mode = 2 /* ATTRIBUTE */ | mode & 1 /* NOT */;
                    if (current !== '' && current !== tNode.tagName) {
                        if (isPositive(mode)) return false;
                        skipToNextSelector = true;
                    }
                } else {
                var attrName = mode & 8 /* CLASS */ ? 'class' : current;
                var attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs);
                if (attrIndexInNode === -1) {
                    if (isPositive(mode)) return false;
                    skipToNextSelector = true;
                    continue;
                }
                var selectorAttrValue = mode & 8 /* CLASS */ ? current : selector[++i];
                if (selectorAttrValue !== '') {
                    var nodeAttrValue = void 0;
                    var maybeAttrName = nodeAttrs[attrIndexInNode];
                    if (selectOnlyMarkerIdx > -1 && attrIndexInNode > selectOnlyMarkerIdx) {
                        nodeAttrValue = '';
                    } else {
                        ngDevMode && assertNotEqual(maybeAttrName, 0 /* NamespaceURI */, 'We do not match directives on namespaced attributes');
                        nodeAttrValue = nodeAttrs[attrIndexInNode + 1];
                    }
                    if (mode & 8 /* CLASS */ && !isCssClassMatching(nodeAttrValue, selectorAttrValue) || mode & 2 /* ATTRIBUTE */ && selectorAttrValue !== nodeAttrValue) {
                        if (isPositive(mode)) return false;
                        skipToNextSelector = true;
                    }
                }
            }
        }
        return isPositive(mode) || skipToNextSelector;
    }
    function isPositive(mode) {
        return (mode & 1 /* NOT */) === 0;
    }
    /**
     * Examines an attributes definition array from a node to find the index of the
     * attribute with the specified name.
     *
     * NOTE: Will not find namespaced attributes.
     *
     * @param name the name of the attribute to find
     * @param attrs the attribute array to examine
     */
    function findAttrIndexInNode(name, attrs) {
        if (attrs === null) return -1;
        var selectOnlyMode = false;
        var i = 0;
        while (i < attrs.length) {
            var maybeAttrName = attrs[i];
            if (maybeAttrName === name) {
                return i;
            } else if (maybeAttrName === 0 /* NamespaceURI */) {
                    // NOTE(benlesh): will not find namespaced attributes. This is by design.
                    i += 4;
                } else {
                if (maybeAttrName === 1 /* SelectOnly */) {
                        selectOnlyMode = true;
                    }
                i += selectOnlyMode ? 1 : 2;
            }
        }
        return -1;
    }
    export function isNodeMatchingSelectorList(tNode, selector) {
        for (var i = 0; i < selector.length; i++) {
            if (isNodeMatchingSelector(tNode, selector[i])) {
                return true;
            }
        }
        return false;
    }
    export function getProjectAsAttrValue(tNode) {
        var nodeAttrs = tNode.attrs;
        if (nodeAttrs != null) {
            var ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);
            // only check for ngProjectAs in attribute names, don't accidentally match attribute's value
            // (attribute names are stored at even indexes)
            if ((ngProjectAsAttrIdx & 1) === 0) {
                return nodeAttrs[ngProjectAsAttrIdx + 1];
            }
        }
        return null;
    }
    /**
     * Checks a given node against matching selectors and returns
     * selector index (or 0 if none matched).
     *
     * This function takes into account the ngProjectAs attribute: if present its value will be compared
     * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.
     */
    export function matchingSelectorIndex(tNode, selectors, textSelectors) {
        var ngProjectAsAttrVal = getProjectAsAttrValue(tNode);
        for (var i = 0; i < selectors.length; i++) {
            // if a node has the ngProjectAs attribute match it against unparsed selector
            // match a node against a parsed selector only if ngProjectAs attribute is not present
            if (ngProjectAsAttrVal === textSelectors[i] || ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {
                return i + 1; // first matching selector "captures" a given node
            }
        }
        return 0;
    }
});
//# sourceMappingURL=node_selector_matcher.js.map