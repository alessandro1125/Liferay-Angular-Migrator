{"version":3,"sources":["../../../../../../../../../../../packages/core/src/render3/jit/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, LiteralExpr, R3DependencyMetadata, WrappedNodeExpr, compileInjectable as compileR3Injectable, jitExpression} from '@angular/compiler';\n\nimport {Injectable} from '../../di/injectable';\nimport {ClassSansProvider, ExistingSansProvider, FactorySansProvider, StaticClassSansProvider, ValueProvider, ValueSansProvider} from '../../di/provider';\nimport {Type} from '../../type';\nimport {getClosureSafeProperty} from '../../util/property';\n\nimport {angularCoreEnv} from './environment';\nimport {NG_INJECTABLE_DEF} from './fields';\nimport {convertDependencies, reflectDependencies} from './util';\n\n\n/**\n * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting\n * `ngInjectableDef` onto the injectable type.\n */\nexport function compileInjectable(type: Type<any>, meta?: Injectable): void {\n  // TODO(alxhub): handle JIT of bare @Injectable().\n  if (!meta) {\n    return;\n  }\n\n  let def: any = null;\n  Object.defineProperty(type, NG_INJECTABLE_DEF, {\n    get: () => {\n      if (def === null) {\n        // Check whether the injectable metadata includes a provider specification.\n        const hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) ||\n            isUseValueProvider(meta) || isUseExistingProvider(meta);\n\n        let deps: R3DependencyMetadata[]|undefined = undefined;\n        if (!hasAProvider || (isUseClassProvider(meta) && type === meta.useClass)) {\n          deps = reflectDependencies(type);\n        } else if (isUseClassProvider(meta)) {\n          deps = meta.deps && convertDependencies(meta.deps);\n        } else if (isUseFactoryProvider(meta)) {\n          deps = meta.deps && convertDependencies(meta.deps) || [];\n        }\n\n        // Decide which flavor of factory to generate, based on the provider specified.\n        // Only one of the use* fields should be set.\n        let useClass: Expression|undefined = undefined;\n        let useFactory: Expression|undefined = undefined;\n        let useValue: Expression|undefined = undefined;\n        let useExisting: Expression|undefined = undefined;\n\n        if (!hasAProvider) {\n          // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.\n          // The deps will have been reflected above, causing the factory to create the class by\n          // calling\n          // its constructor with injected deps.\n          useClass = new WrappedNodeExpr(type);\n        } else if (isUseClassProvider(meta)) {\n          // The user explicitly specified useClass, and may or may not have provided deps.\n          useClass = new WrappedNodeExpr(meta.useClass);\n        } else if (isUseValueProvider(meta)) {\n          // The user explicitly specified useValue.\n          useValue = new WrappedNodeExpr(meta.useValue);\n        } else if (isUseFactoryProvider(meta)) {\n          // The user explicitly specified useFactory.\n          useFactory = new WrappedNodeExpr(meta.useFactory);\n        } else if (isUseExistingProvider(meta)) {\n          // The user explicitly specified useExisting.\n          useExisting = new WrappedNodeExpr(meta.useExisting);\n        } else {\n          // Can't happen - either hasAProvider will be false, or one of the providers will be set.\n          throw new Error(`Unreachable state.`);\n        }\n\n        const {expression} = compileR3Injectable({\n          name: type.name,\n          type: new WrappedNodeExpr(type),\n          providedIn: computeProvidedIn(meta.providedIn),\n          useClass,\n          useFactory,\n          useValue,\n          useExisting,\n          deps,\n        });\n\n        def = jitExpression(expression, angularCoreEnv, `ng://${type.name}/ngInjectableDef.js`);\n      }\n      return def;\n    },\n  });\n}\n\nfunction computeProvidedIn(providedIn: Type<any>| string | null | undefined): Expression {\n  if (providedIn == null || typeof providedIn === 'string') {\n    return new LiteralExpr(providedIn);\n  } else {\n    return new WrappedNodeExpr(providedIn);\n  }\n}\n\ntype UseClassProvider = Injectable & ClassSansProvider & {deps?: any[]};\n\nfunction isUseClassProvider(meta: Injectable): meta is UseClassProvider {\n  return (meta as UseClassProvider).useClass !== undefined;\n}\n\nconst GET_PROPERTY_NAME = {} as any;\nconst USE_VALUE = getClosureSafeProperty<ValueProvider>(\n    {provide: String, useValue: GET_PROPERTY_NAME}, GET_PROPERTY_NAME);\n\nfunction isUseValueProvider(meta: Injectable): meta is Injectable&ValueSansProvider {\n  return USE_VALUE in meta;\n}\n\nfunction isUseFactoryProvider(meta: Injectable): meta is Injectable&FactorySansProvider {\n  return (meta as FactorySansProvider).useFactory !== undefined;\n}\n\nfunction isUseExistingProvider(meta: Injectable): meta is Injectable&ExistingSansProvider {\n  return (meta as ExistingSansProvider).useExisting !== undefined;\n}\n"],"sourceRoot":""}