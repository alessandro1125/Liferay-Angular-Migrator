{"version":3,"sources":["../../../../../../../../../../packages/core/src/render3/styling.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {InitialStylingFlags} from './interfaces/definition';\nimport {LElementNode} from './interfaces/node';\nimport {Renderer3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\n\n\n/**\n * The styling context acts as a styling manifest (shaped as an array) for determining which\n * styling properties have been assigned via the provided `updateStylingMap`, `updateStyleProp`\n * and `updateClassProp` functions. There are also two initialization functions\n * `allocStylingContext` and `createStylingContextTemplate` which are used to initialize\n * and/or clone the context.\n *\n * The context is an array where the first two cells are used for static data (initial styling)\n * and dirty flags / index offsets). The remaining set of cells is used for multi (map) and single\n * (prop) style values.\n *\n * each value from here onwards is mapped as so:\n * [i] = mutation/type flag for the style/class value\n * [i + 1] = prop string (or null incase it has been removed)\n * [i + 2] = value string (or null incase it has been removed)\n *\n * There are three types of styling types stored in this context:\n *   initial: any styles that are passed in once the context is created\n *            (these are stored in the first cell of the array and the first\n *             value of this array is always `null` even if no initial styling exists.\n *             the `null` value is there so that any new styles have a parent to point\n *             to. This way we can always assume that there is a parent.)\n *\n *   single: any styles that are updated using `updateStyleProp` or `updateClassProp` (fixed set)\n *\n *   multi: any styles that are updated using `updateStylingMap` (dynamic set)\n *\n * Note that context is only used to collect style information. Only when `renderStyling`\n * is called is when the styling payload will be rendered (or built as a key/value map).\n *\n * When the context is created, depending on what initial styling values are passed in, the\n * context itself will be pre-filled with slots based on the initial style properties. Say\n * for example we have a series of initial styles that look like so:\n *\n *   style=\"width:100px; height:200px;\"\n *   class=\"foo\"\n *\n * Then the initial state of the context (once initialized) will look like so:\n *\n * ```\n * context = [\n *   element,\n *   styleSanitizer | null,\n *   [null, '100px', '200px', true],  // property names are not needed since they have already been\n * written to DOM.\n *\n *   configMasterVal,\n *   1, // this instructs how many `style` values there are so that class index values can be\n * offsetted\n *   'last class string applied',\n *\n *   // 6\n *   'width',\n *   pointers(1, 15);  // Point to static `width`: `100px` and multi `width`.\n *   null,\n *\n *   // 9\n *   'height',\n *   pointers(2, 18); // Point to static `height`: `200px` and multi `height`.\n *   null,\n *\n *   // 12\n *   'foo',\n *   pointers(1, 21);  // Point to static `foo`: `true` and multi `foo`.\n *   null,\n *\n *   // 15\n *   'width',\n *   pointers(1, 6);  // Point to static `width`: `100px` and single `width`.\n *   null,\n *\n *   // 18\n *   'height',\n *   pointers(2, 9);  // Point to static `height`: `200px` and single `height`.\n *   null,\n *\n *   // 21\n *   'foo',\n *   pointers(3, 12);  // Point to static `foo`: `true` and single `foo`.\n *   null,\n * ]\n *\n * function pointers(staticIndex: number, dynamicIndex: number) {\n *   // combine the two indices into a single word.\n *   return (staticIndex << StylingFlags.BitCountSize) |\n *     (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n * }\n * ```\n *\n * The values are duplicated so that space is set aside for both multi ([style] and [class])\n * and single ([style.prop] or [class.named]) values. The respective config values\n * (configValA, configValB, etc...) are a combination of the StylingFlags with two index\n * values: the `initialIndex` (which points to the index location of the style value in\n * the initial styles array in slot 0) and the `dynamicIndex` (which points to the\n * matching single/multi index position in the context array for the same prop).\n *\n * This means that every time `updateStyleProp` or `updateClassProp` are called then they\n * must be called using an index value (not a property string) which references the index\n * value of the initial style prop/class when the context was created. This also means that\n * `updateStyleProp` or `updateClassProp` cannot be called with a new property (only\n * `updateStylingMap` can include new CSS properties that will be added to the context).\n */\nexport interface StylingContext extends\n    Array<InitialStyles|number|string|boolean|LElementNode|StyleSanitizeFn|null> {\n  /**\n   * Location of element that is used as a target for this context.\n   */\n  [0]: LElementNode|null;\n\n  /**\n   * The style sanitizer that is used within this context\n   */\n  [1]: StyleSanitizeFn|null;\n\n  /**\n   * Location of initial data shared by all instances of this style.\n   */\n  [2]: InitialStyles;\n\n  /**\n   * A numeric value representing the configuration status (whether the context is dirty or not)\n   * mixed together (using bit shifting) with a index value which tells the starting index value\n   * of where the multi style entries begin.\n   */\n  [3]: number;\n\n  /**\n   * A numeric value representing the class index offset value. Whenever a single class is\n   * applied (using `elementClassProp`) it should have an styling index value that doesn't\n   * need to take into account any style values that exist in the context.\n   */\n  [4]: number;\n\n  /**\n   * The last CLASS STRING VALUE that was interpreted by elementStylingMap. This is cached\n   * So that the algorithm can exit early incase the string has not changed.\n   */\n  [5]: string|null;\n}\n\n/**\n * The initial styles is populated whether or not there are any initial styles passed into\n * the context during allocation. The 0th value must be null so that index values of `0` within\n * the context flags can always point to a null value safely when nothing is set.\n *\n * All other entries in this array are of `string` value and correspond to the values that\n * were extracted from the `style=\"\"` attribute in the HTML code for the provided template.\n */\nexport interface InitialStyles extends Array<string|null|boolean> { [0]: null; }\n\n/**\n * Used to set the context to be dirty or not both on the master flag (position 1)\n * or for each single/multi property that exists in the context.\n */\nexport const enum StylingFlags {\n  // Implies no configurations\n  None = 0b000,\n  // Whether or not the entry or context itself is dirty\n  Dirty = 0b001,\n  // Whether or not this is a class-based assignment\n  Class = 0b010,\n  // Whether or not a sanitizer was applied to this property\n  Sanitize = 0b100,\n  // The max amount of bits used to represent these configuration values\n  BitCountSize = 3,\n  // There are only three bits here\n  BitMask = 0b111\n}\n\n/** Used as numeric pointer values to determine what cells to update in the `StylingContext` */\nexport const enum StylingIndex {\n  // Position of where the initial styles are stored in the styling context\n  ElementPosition = 0,\n  // Position of where the style sanitizer is stored within the styling context\n  StyleSanitizerPosition = 1,\n  // Position of where the initial styles are stored in the styling context\n  InitialStylesPosition = 2,\n  // Index of location where the start of single properties are stored. (`updateStyleProp`)\n  MasterFlagPosition = 3,\n  // Index of location where the class index offset value is located\n  ClassOffsetPosition = 4,\n  // Position of where the last string-based CSS class value was stored\n  CachedCssClassString = 5,\n  // Location of single (prop) value entries are stored within the context\n  SingleStylesStartPosition = 6,\n  // Multi and single entries are stored in `StylingContext` as: Flag; PropertyName;  PropertyValue\n  FlagsOffset = 0,\n  PropertyOffset = 1,\n  ValueOffset = 2,\n  // Size of each multi or single entry (flag + prop + value)\n  Size = 3,\n  // Each flag has a binary digit length of this value\n  BitCountSize = 14,  // (32 - 3) / 2 = ~14\n  // The binary digit value as a mask\n  BitMask = 0b11111111111111  // 14 bits\n}\n\n/**\n * Used clone a copy of a pre-computed template of a styling context.\n *\n * A pre-computed template is designed to be computed once for a given element\n * (instructions.ts has logic for caching this).\n */\nexport function allocStylingContext(\n    lElement: LElementNode | null, templateStyleContext: StylingContext): StylingContext {\n  // each instance gets a copy\n  const context = templateStyleContext.slice() as any as StylingContext;\n  context[StylingIndex.ElementPosition] = lElement;\n  return context;\n}\n\n/**\n * Creates a styling context template where styling information is stored.\n * Any styles that are later referenced using `updateStyleProp` must be\n * passed in within this function. Initial values for those styles are to\n * be declared after all initial style properties are declared (this change in\n * mode between declarations and initial styles is made possible using a special\n * enum value found in `definition.ts`).\n *\n * @param initialStyleDeclarations a list of style declarations and initial style values\n *    that are used later within the styling context.\n *\n *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']\n *       This implies that `width` and `height` will be later styled and that the `width`\n *       property has an initial value of `100px`.\n *\n * @param initialClassDeclarations a list of class declarations and initial class values\n *    that are used later within the styling context.\n *\n *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]\n *       This implies that `foo` and `bar` will be later styled and that the `foo`\n *       class will be applied to the element as an initial class since it's true\n */\nexport function createStylingContextTemplate(\n    initialClassDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    initialStyleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): StylingContext {\n  const initialStylingValues: InitialStyles = [null];\n  const context: StylingContext = [null, styleSanitizer || null, initialStylingValues, 0, 0, null];\n\n  // we use two maps since a class name might collide with a CSS style prop\n  const stylesLookup: {[key: string]: number} = {};\n  const classesLookup: {[key: string]: number} = {};\n\n  let totalStyleDeclarations = 0;\n  if (initialStyleDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialStyleDeclarations.length; i++) {\n      const v = initialStyleDeclarations[i] as string | InitialStylingFlags;\n\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const prop = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialStyleDeclarations[++i] as string;\n          initialStylingValues.push(value);\n          stylesLookup[prop] = initialStylingValues.length - 1;\n        } else {\n          totalStyleDeclarations++;\n          stylesLookup[prop] = 0;\n        }\n      }\n    }\n  }\n\n  // make where the class offsets begin\n  context[StylingIndex.ClassOffsetPosition] = totalStyleDeclarations;\n\n  if (initialClassDeclarations) {\n    let hasPassedDeclarations = false;\n    for (let i = 0; i < initialClassDeclarations.length; i++) {\n      const v = initialClassDeclarations[i] as string | boolean | InitialStylingFlags;\n      // this flag value marks where the declarations end the initial values begin\n      if (v === InitialStylingFlags.VALUES_MODE) {\n        hasPassedDeclarations = true;\n      } else {\n        const className = v as string;\n        if (hasPassedDeclarations) {\n          const value = initialClassDeclarations[++i] as boolean;\n          initialStylingValues.push(value);\n          classesLookup[className] = initialStylingValues.length - 1;\n        } else {\n          classesLookup[className] = 0;\n        }\n      }\n    }\n  }\n\n  const styleProps = Object.keys(stylesLookup);\n  const classNames = Object.keys(classesLookup);\n  const classNamesIndexStart = styleProps.length;\n  const totalProps = styleProps.length + classNames.length;\n\n  // *2 because we are filling for both single and multi style spaces\n  const maxLength = totalProps * StylingIndex.Size * 2 + StylingIndex.SingleStylesStartPosition;\n\n  // we need to fill the array from the start so that we can access\n  // both the multi and the single array positions in the same loop block\n  for (let i = StylingIndex.SingleStylesStartPosition; i < maxLength; i++) {\n    context.push(null);\n  }\n\n  const singleStart = StylingIndex.SingleStylesStartPosition;\n  const multiStart = totalProps * StylingIndex.Size + StylingIndex.SingleStylesStartPosition;\n\n  // fill single and multi-level styles\n  for (let i = 0; i < totalProps; i++) {\n    const isClassBased = i >= classNamesIndexStart;\n    const prop = isClassBased ? classNames[i - classNamesIndexStart] : styleProps[i];\n    const indexForInitial = isClassBased ? classesLookup[prop] : stylesLookup[prop];\n    const initialValue = initialStylingValues[indexForInitial];\n\n    const indexForMulti = i * StylingIndex.Size + multiStart;\n    const indexForSingle = i * StylingIndex.Size + singleStart;\n    const initialFlag = prepareInitialFlag(prop, isClassBased, styleSanitizer || null);\n\n    setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));\n    setProp(context, indexForSingle, prop);\n    setValue(context, indexForSingle, null);\n\n    const flagForMulti =\n        initialFlag | (initialValue !== null ? StylingFlags.Dirty : StylingFlags.None);\n    setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));\n    setProp(context, indexForMulti, prop);\n    setValue(context, indexForMulti, null);\n  }\n\n  // there is no initial value flag for the master index since it doesn't\n  // reference an initial style value\n  setFlag(context, StylingIndex.MasterFlagPosition, pointers(0, 0, multiStart));\n  setContextDirty(context, initialStylingValues.length > 1);\n\n  return context;\n}\n\nconst EMPTY_ARR: any[] = [];\nconst EMPTY_OBJ: {[key: string]: any} = {};\n/**\n * Sets and resolves all `multi` styling on an `StylingContext` so that they can be\n * applied to the element once `renderStyling` is called.\n *\n * All missing styles/class (any values that are not provided in the new `styles`\n * or `classes` params) will resolve to `null` within their respective positions\n * in the context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided style values.\n * @param classes The key/value map of CSS class names that will be used for the update.\n * @param styles The key/value map of CSS styles that will be used for the update.\n */\nexport function updateStylingMap(\n    context: StylingContext, classes: {[key: string]: any} | string | null,\n    styles?: {[key: string]: any} | null): void {\n  let classNames: string[] = EMPTY_ARR;\n  let applyAllClasses = false;\n  let ignoreAllClassUpdates = false;\n\n  // each time a string-based value pops up then it shouldn't require a deep\n  // check of what's changed.\n  if (typeof classes == 'string') {\n    const cachedClassString = context[StylingIndex.CachedCssClassString] as string | null;\n    if (cachedClassString && cachedClassString === classes) {\n      ignoreAllClassUpdates = true;\n    } else {\n      context[StylingIndex.CachedCssClassString] = classes;\n      classNames = classes.split(/\\s+/);\n      // this boolean is used to avoid having to create a key/value map of `true` values\n      // since a classname string implies that all those classes are added\n      applyAllClasses = true;\n    }\n  } else {\n    classNames = classes ? Object.keys(classes) : EMPTY_ARR;\n    context[StylingIndex.CachedCssClassString] = null;\n  }\n\n  classes = (classes || EMPTY_OBJ) as{[key: string]: any};\n\n  const styleProps = styles ? Object.keys(styles) : EMPTY_ARR;\n  styles = styles || EMPTY_OBJ;\n\n  const classesStartIndex = styleProps.length;\n  const multiStartIndex = getMultiStartIndex(context);\n\n  let dirty = false;\n  let ctxIndex = multiStartIndex;\n\n  let propIndex = 0;\n  const propLimit = styleProps.length + classNames.length;\n\n  // the main loop here will try and figure out how the shape of the provided\n  // styles differ with respect to the context. Later if the context/styles/classes\n  // are off-balance then they will be dealt in another loop after this one\n  while (ctxIndex < context.length && propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n\n    // when there is a cache-hit for a string-based class then we should\n    // avoid doing any work diffing any of the changes\n    if (!ignoreAllClassUpdates || !isClassBased) {\n      const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n      const newProp: string =\n          isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n      const newValue: string|boolean =\n          isClassBased ? (applyAllClasses ? true : classes[newProp]) : styles[newProp];\n\n      const prop = getProp(context, ctxIndex);\n      if (prop === newProp) {\n        const value = getValue(context, ctxIndex);\n        const flag = getPointers(context, ctxIndex);\n        if (hasValueChanged(flag, value, newValue)) {\n          setValue(context, ctxIndex, newValue);\n\n          const initialValue = getInitialValue(context, flag);\n\n          // there is no point in setting this to dirty if the previously\n          // rendered value was being referenced by the initial style (or null)\n          if (initialValue !== newValue) {\n            setDirty(context, ctxIndex, true);\n            dirty = true;\n          }\n        }\n      } else {\n        const indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);\n        if (indexOfEntry > 0) {\n          // it was found at a later point ... just swap the values\n          const valueToCompare = getValue(context, indexOfEntry);\n          const flagToCompare = getPointers(context, indexOfEntry);\n          swapMultiContextEntries(context, ctxIndex, indexOfEntry);\n          if (valueToCompare !== newValue) {\n            const initialValue = getInitialValue(context, flagToCompare);\n            setValue(context, ctxIndex, newValue);\n            if (initialValue !== newValue) {\n              setDirty(context, ctxIndex, true);\n              dirty = true;\n            }\n          }\n        } else {\n          // we only care to do this if the insertion is in the middle\n          const newFlag = prepareInitialFlag(newProp, isClassBased, getStyleSanitizer(context));\n          insertNewMultiProperty(context, ctxIndex, isClassBased, newProp, newFlag, newValue);\n          dirty = true;\n        }\n      }\n    }\n\n    ctxIndex += StylingIndex.Size;\n    propIndex++;\n  }\n\n  // this means that there are left-over values in the context that\n  // were not included in the provided styles/classes and in this\n  // case the  goal is to \"remove\" them from the context (by nullifying)\n  while (ctxIndex < context.length) {\n    const flag = getPointers(context, ctxIndex);\n    const isClassBased = (flag & StylingFlags.Class) === StylingFlags.Class;\n    if (ignoreAllClassUpdates && isClassBased) break;\n\n    const value = getValue(context, ctxIndex);\n    const doRemoveValue = valueExists(value, isClassBased);\n    if (doRemoveValue) {\n      setDirty(context, ctxIndex, true);\n      setValue(context, ctxIndex, null);\n      dirty = true;\n    }\n    ctxIndex += StylingIndex.Size;\n  }\n\n  // this means that there are left-over properties in the context that\n  // were not detected in the context during the loop above. In that\n  // case we want to add the new entries into the list\n  const sanitizer = getStyleSanitizer(context);\n  while (propIndex < propLimit) {\n    const isClassBased = propIndex >= classesStartIndex;\n    if (ignoreAllClassUpdates && isClassBased) break;\n\n    const adjustedPropIndex = isClassBased ? propIndex - classesStartIndex : propIndex;\n    const prop = isClassBased ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];\n    const value: string|boolean =\n        isClassBased ? (applyAllClasses ? true : classes[prop]) : styles[prop];\n    const flag = prepareInitialFlag(prop, isClassBased, sanitizer) | StylingFlags.Dirty;\n    context.push(flag, prop, value);\n    propIndex++;\n    dirty = true;\n  }\n\n  if (dirty) {\n    setContextDirty(context, true);\n  }\n}\n\n/**\n * Sets and resolves a single styling property/value on the provided `StylingContext` so\n * that they can be applied to the element once `renderStyling` is called.\n *\n * Note that prop-level styling values are considered higher priority than any styling that\n * has been applied using `updateStylingMap`, therefore, when styling values are rendered\n * then any styles/classes that have been applied using this function will be considered first\n * (then multi values second and then initial values as a backup).\n *\n * @param context The styling context that will be updated with the\n *    newly provided style value.\n * @param index The index of the property which is being updated.\n * @param value The CSS style value that will be assigned\n */\nexport function updateStyleProp(\n    context: StylingContext, index: number, value: string | boolean | null): void {\n  const singleIndex = StylingIndex.SingleStylesStartPosition + index * StylingIndex.Size;\n  const currValue = getValue(context, singleIndex);\n  const currFlag = getPointers(context, singleIndex);\n\n  // didn't change ... nothing to make a note of\n  if (hasValueChanged(currFlag, currValue, value)) {\n    // the value will always get updated (even if the dirty flag is skipped)\n    setValue(context, singleIndex, value);\n    const indexForMulti = getMultiOrSingleIndex(currFlag);\n\n    // if the value is the same in the multi-area then there's no point in re-assembling\n    const valueForMulti = getValue(context, indexForMulti);\n    if (!valueForMulti || valueForMulti !== value) {\n      let multiDirty = false;\n      let singleDirty = true;\n\n      const isClassBased = (currFlag & StylingFlags.Class) === StylingFlags.Class;\n\n      // only when the value is set to `null` should the multi-value get flagged\n      if (!valueExists(value, isClassBased) && valueExists(valueForMulti, isClassBased)) {\n        multiDirty = true;\n        singleDirty = false;\n      }\n\n      setDirty(context, indexForMulti, multiDirty);\n      setDirty(context, singleIndex, singleDirty);\n      setContextDirty(context, true);\n    }\n  }\n}\n\n/**\n * This method will toggle the referenced CSS class (by the provided index)\n * within the given context.\n *\n * @param context The styling context that will be updated with the\n *    newly provided class value.\n * @param index The index of the CSS class which is being updated.\n * @param addOrRemove Whether or not to add or remove the CSS class\n */\nexport function updateClassProp(\n    context: StylingContext, index: number, addOrRemove: boolean): void {\n  const adjustedIndex = index + context[StylingIndex.ClassOffsetPosition];\n  updateStyleProp(context, adjustedIndex, addOrRemove);\n}\n\n/**\n * Renders all queued styling using a renderer onto the given element.\n *\n * This function works by rendering any styles (that have been applied\n * using `updateStylingMap`) and any classes (that have been applied using\n * `updateStyleProp`) onto the provided element using the provided renderer.\n * Just before the styles/classes are rendered a final key/value style map\n * will be assembled (if `styleStore` or `classStore` are provided).\n *\n * @param lElement the element that the styles will be rendered on\n * @param context The styling context that will be used to determine\n *      what styles will be rendered\n * @param renderer the renderer that will be used to apply the styling\n * @param styleStore if provided, the updated style values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n * @param classStore if provided, the updated class values will be applied\n *    to this key/value map instead of being renderered via the renderer.\n */\nexport function renderStyling(\n    context: StylingContext, renderer: Renderer3, styleStore?: {[key: string]: any},\n    classStore?: {[key: string]: boolean}) {\n  if (isContextDirty(context)) {\n    const native = context[StylingIndex.ElementPosition] !.native;\n    const multiStartIndex = getMultiStartIndex(context);\n    const styleSanitizer = getStyleSanitizer(context);\n    for (let i = StylingIndex.SingleStylesStartPosition; i < context.length;\n         i += StylingIndex.Size) {\n      // there is no point in rendering styles that have not changed on screen\n      if (isDirty(context, i)) {\n        const prop = getProp(context, i);\n        const value = getValue(context, i);\n        const flag = getPointers(context, i);\n        const isClassBased = flag & StylingFlags.Class ? true : false;\n        const isInSingleRegion = i < multiStartIndex;\n\n        let valueToApply: string|boolean|null = value;\n\n        // VALUE DEFER CASE 1: Use a multi value instead of a null single value\n        // this check implies that a single value was removed and we\n        // should now defer to a multi value and use that (if set).\n        if (isInSingleRegion && !valueExists(valueToApply, isClassBased)) {\n          // single values ALWAYS have a reference to a multi index\n          const multiIndex = getMultiOrSingleIndex(flag);\n          valueToApply = getValue(context, multiIndex);\n        }\n\n        // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)\n        // the initial value will always be a string or null,\n        // therefore we can safely adopt it incase there's nothing else\n        // note that this should always be a falsy check since `false` is used\n        // for both class and style comparisons (styles can't be false and false\n        // classes are turned off and should therefore defer to their initial values)\n        if (!valueExists(valueToApply, isClassBased)) {\n          valueToApply = getInitialValue(context, flag);\n        }\n\n        if (isClassBased) {\n          setClass(native, prop, valueToApply ? true : false, renderer, classStore);\n        } else {\n          const sanitizer = (flag & StylingFlags.Sanitize) ? styleSanitizer : null;\n          setStyle(native, prop, valueToApply as string | null, renderer, sanitizer, styleStore);\n        }\n        setDirty(context, i, false);\n      }\n    }\n\n    setContextDirty(context, false);\n  }\n}\n\n/**\n * This function renders a given CSS prop/value entry using the\n * provided renderer. If a `store` value is provided then\n * that will be used a render context instead of the provided\n * renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setStyle(\n    native: any, prop: string, value: string | null, renderer: Renderer3,\n    sanitizer: StyleSanitizeFn | null, store?: {[key: string]: any}) {\n  value = sanitizer && value ? sanitizer(prop, value) : value;\n  if (store) {\n    store[prop] = value;\n  } else if (value) {\n    ngDevMode && ngDevMode.rendererSetStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) :\n        native['style'].setProperty(prop, value);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveStyle++;\n    isProceduralRenderer(renderer) ?\n        renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) :\n        native['style'].removeProperty(prop);\n  }\n}\n\n/**\n * This function renders a given CSS class value using the provided\n * renderer (by adding or removing it from the provided element).\n * If a `store` value is provided then that will be used a render\n * context instead of the provided renderer.\n *\n * @param native the DOM Element\n * @param prop the CSS style property that will be rendered\n * @param value the CSS style value that will be rendered\n * @param renderer\n * @param store an optional key/value map that will be used as a context to render styles on\n */\nfunction setClass(\n    native: any, className: string, add: boolean, renderer: Renderer3,\n    store?: {[key: string]: boolean}) {\n  if (store) {\n    store[className] = add;\n  } else if (add) {\n    ngDevMode && ngDevMode.rendererAddClass++;\n    isProceduralRenderer(renderer) ? renderer.addClass(native, className) :\n                                     native['classList'].add(className);\n  } else {\n    ngDevMode && ngDevMode.rendererRemoveClass++;\n    isProceduralRenderer(renderer) ? renderer.removeClass(native, className) :\n                                     native['classList'].remove(className);\n  }\n}\n\nfunction setDirty(context: StylingContext, index: number, isDirtyYes: boolean) {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  if (isDirtyYes) {\n    (context[adjustedIndex] as number) |= StylingFlags.Dirty;\n  } else {\n    (context[adjustedIndex] as number) &= ~StylingFlags.Dirty;\n  }\n}\n\nfunction isDirty(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Dirty) == StylingFlags.Dirty;\n}\n\nfunction isClassBased(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Class) == StylingFlags.Class;\n}\n\nfunction isSanitizable(context: StylingContext, index: number): boolean {\n  const adjustedIndex =\n      index >= StylingIndex.SingleStylesStartPosition ? (index + StylingIndex.FlagsOffset) : index;\n  return ((context[adjustedIndex] as number) & StylingFlags.Sanitize) == StylingFlags.Sanitize;\n}\n\nfunction pointers(configFlag: number, staticIndex: number, dynamicIndex: number) {\n  return (configFlag & StylingFlags.BitMask) | (staticIndex << StylingFlags.BitCountSize) |\n      (dynamicIndex << (StylingIndex.BitCountSize + StylingFlags.BitCountSize));\n}\n\nfunction getInitialValue(context: StylingContext, flag: number): string|null {\n  const index = getInitialIndex(flag);\n  return context[StylingIndex.InitialStylesPosition][index] as null | string;\n}\n\nfunction getInitialIndex(flag: number): number {\n  return (flag >> StylingFlags.BitCountSize) & StylingIndex.BitMask;\n}\n\nfunction getMultiOrSingleIndex(flag: number): number {\n  const index =\n      (flag >> (StylingIndex.BitCountSize + StylingFlags.BitCountSize)) & StylingIndex.BitMask;\n  return index >= StylingIndex.SingleStylesStartPosition ? index : -1;\n}\n\nfunction getMultiStartIndex(context: StylingContext): number {\n  return getMultiOrSingleIndex(context[StylingIndex.MasterFlagPosition]) as number;\n}\n\nfunction getStyleSanitizer(context: StylingContext): StyleSanitizeFn|null {\n  return context[StylingIndex.StyleSanitizerPosition];\n}\n\nfunction setProp(context: StylingContext, index: number, prop: string) {\n  context[index + StylingIndex.PropertyOffset] = prop;\n}\n\nfunction setValue(context: StylingContext, index: number, value: string | null | boolean) {\n  context[index + StylingIndex.ValueOffset] = value;\n}\n\nfunction setFlag(context: StylingContext, index: number, flag: number) {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  context[adjustedIndex] = flag;\n}\n\nfunction getPointers(context: StylingContext, index: number): number {\n  const adjustedIndex =\n      index === StylingIndex.MasterFlagPosition ? index : (index + StylingIndex.FlagsOffset);\n  return context[adjustedIndex] as number;\n}\n\nfunction getValue(context: StylingContext, index: number): string|boolean|null {\n  return context[index + StylingIndex.ValueOffset] as string | boolean | null;\n}\n\nfunction getProp(context: StylingContext, index: number): string {\n  return context[index + StylingIndex.PropertyOffset] as string;\n}\n\nexport function isContextDirty(context: StylingContext): boolean {\n  return isDirty(context, StylingIndex.MasterFlagPosition);\n}\n\nexport function setContextDirty(context: StylingContext, isDirtyYes: boolean): void {\n  setDirty(context, StylingIndex.MasterFlagPosition, isDirtyYes);\n}\n\nfunction findEntryPositionByProp(\n    context: StylingContext, prop: string, startIndex?: number): number {\n  for (let i = (startIndex || 0) + StylingIndex.PropertyOffset; i < context.length;\n       i += StylingIndex.Size) {\n    const thisProp = context[i];\n    if (thisProp == prop) {\n      return i - StylingIndex.PropertyOffset;\n    }\n  }\n  return -1;\n}\n\nfunction swapMultiContextEntries(context: StylingContext, indexA: number, indexB: number) {\n  const tmpValue = getValue(context, indexA);\n  const tmpProp = getProp(context, indexA);\n  const tmpFlag = getPointers(context, indexA);\n\n  let flagA = tmpFlag;\n  let flagB = getPointers(context, indexB);\n\n  const singleIndexA = getMultiOrSingleIndex(flagA);\n  if (singleIndexA >= 0) {\n    const _flag = getPointers(context, singleIndexA);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));\n  }\n\n  const singleIndexB = getMultiOrSingleIndex(flagB);\n  if (singleIndexB >= 0) {\n    const _flag = getPointers(context, singleIndexB);\n    const _initial = getInitialIndex(_flag);\n    setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));\n  }\n\n  setValue(context, indexA, getValue(context, indexB));\n  setProp(context, indexA, getProp(context, indexB));\n  setFlag(context, indexA, getPointers(context, indexB));\n\n  setValue(context, indexB, tmpValue);\n  setProp(context, indexB, tmpProp);\n  setFlag(context, indexB, tmpFlag);\n}\n\nfunction updateSinglePointerValues(context: StylingContext, indexStartPosition: number) {\n  for (let i = indexStartPosition; i < context.length; i += StylingIndex.Size) {\n    const multiFlag = getPointers(context, i);\n    const singleIndex = getMultiOrSingleIndex(multiFlag);\n    if (singleIndex > 0) {\n      const singleFlag = getPointers(context, singleIndex);\n      const initialIndexForSingle = getInitialIndex(singleFlag);\n      const flagValue = (isDirty(context, singleIndex) ? StylingFlags.Dirty : StylingFlags.None) |\n          (isClassBased(context, singleIndex) ? StylingFlags.Class : StylingFlags.None) |\n          (isSanitizable(context, singleIndex) ? StylingFlags.Sanitize : StylingFlags.None);\n      const updatedFlag = pointers(flagValue, initialIndexForSingle, i);\n      setFlag(context, singleIndex, updatedFlag);\n    }\n  }\n}\n\nfunction insertNewMultiProperty(\n    context: StylingContext, index: number, classBased: boolean, name: string, flag: number,\n    value: string | boolean): void {\n  const doShift = index < context.length;\n\n  // prop does not exist in the list, add it in\n  context.splice(\n      index, 0, flag | StylingFlags.Dirty | (classBased ? StylingFlags.Class : StylingFlags.None),\n      name, value);\n\n  if (doShift) {\n    // because the value was inserted midway into the array then we\n    // need to update all the shifted multi values' single value\n    // pointers to point to the newly shifted location\n    updateSinglePointerValues(context, index + StylingIndex.Size);\n  }\n}\n\nfunction valueExists(value: string | null | boolean, isClassBased?: boolean) {\n  if (isClassBased) {\n    return value ? true : false;\n  }\n  return value !== null;\n}\n\nfunction prepareInitialFlag(\n    name: string, isClassBased: boolean, sanitizer?: StyleSanitizeFn | null) {\n  if (isClassBased) {\n    return StylingFlags.Class;\n  } else if (sanitizer && sanitizer(name)) {\n    return StylingFlags.Sanitize;\n  }\n  return StylingFlags.None;\n}\n\nfunction hasValueChanged(\n    flag: number, a: string | boolean | null, b: string | boolean | null): boolean {\n  const isClassBased = flag & StylingFlags.Class;\n  const hasValues = a && b;\n  const usesSanitizer = flag & StylingFlags.Sanitize;\n  // the toString() comparison ensures that a value is checked\n  // ... otherwise (during sanitization bypassing) the === comparsion\n  // would fail since a new String() instance is created\n  if (!isClassBased && hasValues && usesSanitizer) {\n    // we know for sure we're dealing with strings at this point\n    return (a as string).toString() !== (b as string).toString();\n  }\n\n  // everything else is safe to check with a normal equality check\n  return a !== b;\n}\n"],"sourceRoot":""}