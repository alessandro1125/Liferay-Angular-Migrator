Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/jit/module', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { WrappedNodeExpr, compileInjector, compileNgModule as compileR3NgModule, jitExpression } from '@angular/compiler';
    import { angularCoreEnv } from './environment';
    import { NG_COMPONENT_DEF, NG_DIRECTIVE_DEF, NG_INJECTOR_DEF, NG_MODULE_DEF, NG_PIPE_DEF } from './fields';
    import { reflectDependencies } from './util';
    var EMPTY_ARRAY = [];
    export function compileNgModule(type, ngModule) {
        var declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
        var ngModuleDef = null;
        Object.defineProperty(type, NG_MODULE_DEF, {
            get: function () {
                if (ngModuleDef === null) {
                    var meta = {
                        type: wrap(type),
                        bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(wrap),
                        declarations: declarations.map(wrap),
                        imports: flatten(ngModule.imports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),
                        exports: flatten(ngModule.exports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),
                        emitInline: true
                    };
                    var res = compileR3NgModule(meta);
                    ngModuleDef = jitExpression(res.expression, angularCoreEnv, "ng://" + type.name + "/ngModuleDef.js");
                }
                return ngModuleDef;
            }
        });
        var ngInjectorDef = null;
        Object.defineProperty(type, NG_INJECTOR_DEF, {
            get: function () {
                if (ngInjectorDef === null) {
                    var meta = {
                        name: type.name,
                        type: wrap(type),
                        deps: reflectDependencies(type),
                        providers: new WrappedNodeExpr(ngModule.providers || EMPTY_ARRAY),
                        imports: new WrappedNodeExpr([ngModule.imports || EMPTY_ARRAY, ngModule.exports || EMPTY_ARRAY])
                    };
                    var res = compileInjector(meta);
                    ngInjectorDef = jitExpression(res.expression, angularCoreEnv, "ng://" + type.name + "/ngInjectorDef.js");
                }
                return ngInjectorDef;
            }
        });
        declarations.forEach(function (declaration) {
            // Some declared components may be compiled asynchronously, and thus may not have their
            // ngComponentDef set yet. If this is the case, then a reference to the module is written into
            // the `ngSelectorScope` property of the declared type.
            if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {
                // An `ngComponentDef` field exists - go ahead and patch the component directly.
                patchComponentDefWithScope(declaration.ngComponentDef, type);
            } else if (!declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
                // Set `ngSelectorScope` for future reference when the component compilation finishes.
                declaration.ngSelectorScope = type;
            }
        });
    }
    /**
     * Patch the definition of a component with directives and pipes from the compilation scope of
     * a given module.
     */
    export function patchComponentDefWithScope(componentDef, module) {
        componentDef.directiveDefs = function () {
            return Array.from(transitiveScopesFor(module).compilation.directives).map(function (dir) {
                return dir.ngDirectiveDef || dir.ngComponentDef;
            }).filter(function (def) {
                return !!def;
            });
        };
        componentDef.pipeDefs = function () {
            return Array.from(transitiveScopesFor(module).compilation.pipes).map(function (pipe) {
                return pipe.ngPipeDef;
            });
        };
    }
    /**
     * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.
     *
     * This operation is memoized and the result is cached on the module's definition. It can be called
     * on modules with components that have not fully compiled yet, but the result should not be used
     * until they have.
     */
    export function transitiveScopesFor(moduleType) {
        if (!isNgModule(moduleType)) {
            throw new Error(moduleType.name + " does not have an ngModuleDef");
        }
        var def = moduleType.ngModuleDef;
        if (def.transitiveCompileScopes !== null) {
            return def.transitiveCompileScopes;
        }
        var scopes = {
            compilation: {
                directives: new Set(),
                pipes: new Set()
            },
            exported: {
                directives: new Set(),
                pipes: new Set()
            }
        };
        def.declarations.forEach(function (declared) {
            var declaredWithDefs = declared;
            if (declaredWithDefs.ngPipeDef !== undefined) {
                scopes.compilation.pipes.add(declared);
            } else {
                // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't
                // had its template compiled yet. In either case, it gets added to the compilation's
                // directives.
                scopes.compilation.directives.add(declared);
            }
        });
        def.imports.forEach(function (imported) {
            var importedTyped = imported;
            if (!isNgModule(importedTyped)) {
                throw new Error("Importing " + importedTyped.name + " which does not have an ngModuleDef");
            }
            // When this module imports another, the imported module's exported directives and pipes are
            // added to the compilation scope of this module.
            var importedScope = transitiveScopesFor(importedTyped);
            importedScope.exported.directives.forEach(function (entry) {
                return scopes.compilation.directives.add(entry);
            });
            importedScope.exported.pipes.forEach(function (entry) {
                return scopes.compilation.pipes.add(entry);
            });
        });
        def.exports.forEach(function (exported) {
            var exportedTyped = exported;
            // Either the type is a module, a pipe, or a component/directive (which may not have an
            // ngComponentDef as it might be compiled asynchronously).
            if (isNgModule(exportedTyped)) {
                // When this module exports another, the exported module's exported directives and pipes are
                // added to both the compilation and exported scopes of this module.
                var exportedScope = transitiveScopesFor(exportedTyped);
                exportedScope.exported.directives.forEach(function (entry) {
                    scopes.compilation.directives.add(entry);
                    scopes.exported.directives.add(entry);
                });
                exportedScope.exported.pipes.forEach(function (entry) {
                    scopes.compilation.pipes.add(entry);
                    scopes.exported.pipes.add(entry);
                });
            } else if (exportedTyped.ngPipeDef !== undefined) {
                scopes.exported.pipes.add(exportedTyped);
            } else {
                scopes.exported.directives.add(exportedTyped);
            }
        });
        def.transitiveCompileScopes = scopes;
        return scopes;
    }
    function flatten(values) {
        var out = [];
        values.forEach(function (value) {
            if (Array.isArray(value)) {
                out.push.apply(out, tslib_1.__spread(flatten(value)));
            } else {
                out.push(value);
            }
        });
        return out;
    }
    function expandModuleWithProviders(value) {
        if (isModuleWithProviders(value)) {
            return value.ngModule;
        }
        return value;
    }
    function wrap(value) {
        return new WrappedNodeExpr(value);
    }
    function isModuleWithProviders(value) {
        return value.ngModule !== undefined;
    }
    function isNgModule(value) {
        return value.ngModuleDef !== undefined;
    }
});
//# sourceMappingURL=module.js.map