Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/styling', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { RendererStyleFlags3, isProceduralRenderer } from './interfaces/renderer';
    /**
     * Used clone a copy of a pre-computed template of a styling context.
     *
     * A pre-computed template is designed to be computed once for a given element
     * (instructions.ts has logic for caching this).
     */
    export function allocStylingContext(lElement, templateStyleContext) {
        // each instance gets a copy
        var context = templateStyleContext.slice();
        context[0 /* ElementPosition */] = lElement;
        return context;
    }
    /**
     * Creates a styling context template where styling information is stored.
     * Any styles that are later referenced using `updateStyleProp` must be
     * passed in within this function. Initial values for those styles are to
     * be declared after all initial style properties are declared (this change in
     * mode between declarations and initial styles is made possible using a special
     * enum value found in `definition.ts`).
     *
     * @param initialStyleDeclarations a list of style declarations and initial style values
     *    that are used later within the styling context.
     *
     *    -> ['width', 'height', SPECIAL_ENUM_VAL, 'width', '100px']
     *       This implies that `width` and `height` will be later styled and that the `width`
     *       property has an initial value of `100px`.
     *
     * @param initialClassDeclarations a list of class declarations and initial class values
     *    that are used later within the styling context.
     *
     *    -> ['foo', 'bar', SPECIAL_ENUM_VAL, 'foo', true]
     *       This implies that `foo` and `bar` will be later styled and that the `foo`
     *       class will be applied to the element as an initial class since it's true
     */
    export function createStylingContextTemplate(initialClassDeclarations, initialStyleDeclarations, styleSanitizer) {
        var initialStylingValues = [null];
        var context = [null, styleSanitizer || null, initialStylingValues, 0, 0, null];
        // we use two maps since a class name might collide with a CSS style prop
        var stylesLookup = {};
        var classesLookup = {};
        var totalStyleDeclarations = 0;
        if (initialStyleDeclarations) {
            var hasPassedDeclarations = false;
            for (var i = 0; i < initialStyleDeclarations.length; i++) {
                var v = initialStyleDeclarations[i];
                // this flag value marks where the declarations end the initial values begin
                if (v === 1 /* VALUES_MODE */) {
                        hasPassedDeclarations = true;
                    } else {
                    var prop = v;
                    if (hasPassedDeclarations) {
                        var value = initialStyleDeclarations[++i];
                        initialStylingValues.push(value);
                        stylesLookup[prop] = initialStylingValues.length - 1;
                    } else {
                        totalStyleDeclarations++;
                        stylesLookup[prop] = 0;
                    }
                }
            }
        }
        // make where the class offsets begin
        context[4 /* ClassOffsetPosition */] = totalStyleDeclarations;
        if (initialClassDeclarations) {
            var hasPassedDeclarations = false;
            for (var i = 0; i < initialClassDeclarations.length; i++) {
                var v = initialClassDeclarations[i];
                // this flag value marks where the declarations end the initial values begin
                if (v === 1 /* VALUES_MODE */) {
                        hasPassedDeclarations = true;
                    } else {
                    var className = v;
                    if (hasPassedDeclarations) {
                        var value = initialClassDeclarations[++i];
                        initialStylingValues.push(value);
                        classesLookup[className] = initialStylingValues.length - 1;
                    } else {
                        classesLookup[className] = 0;
                    }
                }
            }
        }
        var styleProps = Object.keys(stylesLookup);
        var classNames = Object.keys(classesLookup);
        var classNamesIndexStart = styleProps.length;
        var totalProps = styleProps.length + classNames.length;
        // *2 because we are filling for both single and multi style spaces
        var maxLength = totalProps * 3 /* Size */ * 2 + 6 /* SingleStylesStartPosition */;
        // we need to fill the array from the start so that we can access
        // both the multi and the single array positions in the same loop block
        for (var i = 6 /* SingleStylesStartPosition */; i < maxLength; i++) {
            context.push(null);
        }
        var singleStart = 6 /* SingleStylesStartPosition */;
        var multiStart = totalProps * 3 /* Size */ + 6 /* SingleStylesStartPosition */;
        // fill single and multi-level styles
        for (var i = 0; i < totalProps; i++) {
            var isClassBased_1 = i >= classNamesIndexStart;
            var prop = isClassBased_1 ? classNames[i - classNamesIndexStart] : styleProps[i];
            var indexForInitial = isClassBased_1 ? classesLookup[prop] : stylesLookup[prop];
            var initialValue = initialStylingValues[indexForInitial];
            var indexForMulti = i * 3 /* Size */ + multiStart;
            var indexForSingle = i * 3 /* Size */ + singleStart;
            var initialFlag = prepareInitialFlag(prop, isClassBased_1, styleSanitizer || null);
            setFlag(context, indexForSingle, pointers(initialFlag, indexForInitial, indexForMulti));
            setProp(context, indexForSingle, prop);
            setValue(context, indexForSingle, null);
            var flagForMulti = initialFlag | (initialValue !== null ? 1 /* Dirty */ : 0 /* None */);
            setFlag(context, indexForMulti, pointers(flagForMulti, indexForInitial, indexForSingle));
            setProp(context, indexForMulti, prop);
            setValue(context, indexForMulti, null);
        }
        // there is no initial value flag for the master index since it doesn't
        // reference an initial style value
        setFlag(context, 3 /* MasterFlagPosition */, pointers(0, 0, multiStart));
        setContextDirty(context, initialStylingValues.length > 1);
        return context;
    }
    var EMPTY_ARR = [];
    var EMPTY_OBJ = {};
    /**
     * Sets and resolves all `multi` styling on an `StylingContext` so that they can be
     * applied to the element once `renderStyling` is called.
     *
     * All missing styles/class (any values that are not provided in the new `styles`
     * or `classes` params) will resolve to `null` within their respective positions
     * in the context.
     *
     * @param context The styling context that will be updated with the
     *    newly provided style values.
     * @param classes The key/value map of CSS class names that will be used for the update.
     * @param styles The key/value map of CSS styles that will be used for the update.
     */
    export function updateStylingMap(context, classes, styles) {
        var classNames = EMPTY_ARR;
        var applyAllClasses = false;
        var ignoreAllClassUpdates = false;
        // each time a string-based value pops up then it shouldn't require a deep
        // check of what's changed.
        if (typeof classes == 'string') {
            var cachedClassString = context[5 /* CachedCssClassString */];
            if (cachedClassString && cachedClassString === classes) {
                ignoreAllClassUpdates = true;
            } else {
                context[5 /* CachedCssClassString */] = classes;
                classNames = classes.split(/\s+/);
                // this boolean is used to avoid having to create a key/value map of `true` values
                // since a classname string implies that all those classes are added
                applyAllClasses = true;
            }
        } else {
            classNames = classes ? Object.keys(classes) : EMPTY_ARR;
            context[5 /* CachedCssClassString */] = null;
        }
        classes = classes || EMPTY_OBJ;
        var styleProps = styles ? Object.keys(styles) : EMPTY_ARR;
        styles = styles || EMPTY_OBJ;
        var classesStartIndex = styleProps.length;
        var multiStartIndex = getMultiStartIndex(context);
        var dirty = false;
        var ctxIndex = multiStartIndex;
        var propIndex = 0;
        var propLimit = styleProps.length + classNames.length;
        // the main loop here will try and figure out how the shape of the provided
        // styles differ with respect to the context. Later if the context/styles/classes
        // are off-balance then they will be dealt in another loop after this one
        while (ctxIndex < context.length && propIndex < propLimit) {
            var isClassBased_2 = propIndex >= classesStartIndex;
            // when there is a cache-hit for a string-based class then we should
            // avoid doing any work diffing any of the changes
            if (!ignoreAllClassUpdates || !isClassBased_2) {
                var adjustedPropIndex = isClassBased_2 ? propIndex - classesStartIndex : propIndex;
                var newProp = isClassBased_2 ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];
                var newValue = isClassBased_2 ? applyAllClasses ? true : classes[newProp] : styles[newProp];
                var prop = getProp(context, ctxIndex);
                if (prop === newProp) {
                    var value = getValue(context, ctxIndex);
                    var flag = getPointers(context, ctxIndex);
                    if (hasValueChanged(flag, value, newValue)) {
                        setValue(context, ctxIndex, newValue);
                        var initialValue = getInitialValue(context, flag);
                        // there is no point in setting this to dirty if the previously
                        // rendered value was being referenced by the initial style (or null)
                        if (initialValue !== newValue) {
                            setDirty(context, ctxIndex, true);
                            dirty = true;
                        }
                    }
                } else {
                    var indexOfEntry = findEntryPositionByProp(context, newProp, ctxIndex);
                    if (indexOfEntry > 0) {
                        // it was found at a later point ... just swap the values
                        var valueToCompare = getValue(context, indexOfEntry);
                        var flagToCompare = getPointers(context, indexOfEntry);
                        swapMultiContextEntries(context, ctxIndex, indexOfEntry);
                        if (valueToCompare !== newValue) {
                            var initialValue = getInitialValue(context, flagToCompare);
                            setValue(context, ctxIndex, newValue);
                            if (initialValue !== newValue) {
                                setDirty(context, ctxIndex, true);
                                dirty = true;
                            }
                        }
                    } else {
                        // we only care to do this if the insertion is in the middle
                        var newFlag = prepareInitialFlag(newProp, isClassBased_2, getStyleSanitizer(context));
                        insertNewMultiProperty(context, ctxIndex, isClassBased_2, newProp, newFlag, newValue);
                        dirty = true;
                    }
                }
            }
            ctxIndex += 3 /* Size */;
            propIndex++;
        }
        // this means that there are left-over values in the context that
        // were not included in the provided styles/classes and in this
        // case the  goal is to "remove" them from the context (by nullifying)
        while (ctxIndex < context.length) {
            var flag = getPointers(context, ctxIndex);
            var isClassBased_3 = (flag & 2 /* Class */) === 2 /* Class */;
            if (ignoreAllClassUpdates && isClassBased_3) break;
            var value = getValue(context, ctxIndex);
            var doRemoveValue = valueExists(value, isClassBased_3);
            if (doRemoveValue) {
                setDirty(context, ctxIndex, true);
                setValue(context, ctxIndex, null);
                dirty = true;
            }
            ctxIndex += 3 /* Size */;
        }
        // this means that there are left-over properties in the context that
        // were not detected in the context during the loop above. In that
        // case we want to add the new entries into the list
        var sanitizer = getStyleSanitizer(context);
        while (propIndex < propLimit) {
            var isClassBased_4 = propIndex >= classesStartIndex;
            if (ignoreAllClassUpdates && isClassBased_4) break;
            var adjustedPropIndex = isClassBased_4 ? propIndex - classesStartIndex : propIndex;
            var prop = isClassBased_4 ? classNames[adjustedPropIndex] : styleProps[adjustedPropIndex];
            var value = isClassBased_4 ? applyAllClasses ? true : classes[prop] : styles[prop];
            var flag = prepareInitialFlag(prop, isClassBased_4, sanitizer) | 1 /* Dirty */;
            context.push(flag, prop, value);
            propIndex++;
            dirty = true;
        }
        if (dirty) {
            setContextDirty(context, true);
        }
    }
    /**
     * Sets and resolves a single styling property/value on the provided `StylingContext` so
     * that they can be applied to the element once `renderStyling` is called.
     *
     * Note that prop-level styling values are considered higher priority than any styling that
     * has been applied using `updateStylingMap`, therefore, when styling values are rendered
     * then any styles/classes that have been applied using this function will be considered first
     * (then multi values second and then initial values as a backup).
     *
     * @param context The styling context that will be updated with the
     *    newly provided style value.
     * @param index The index of the property which is being updated.
     * @param value The CSS style value that will be assigned
     */
    export function updateStyleProp(context, index, value) {
        var singleIndex = 6 /* SingleStylesStartPosition */ + index * 3 /* Size */;
        var currValue = getValue(context, singleIndex);
        var currFlag = getPointers(context, singleIndex);
        // didn't change ... nothing to make a note of
        if (hasValueChanged(currFlag, currValue, value)) {
            // the value will always get updated (even if the dirty flag is skipped)
            setValue(context, singleIndex, value);
            var indexForMulti = getMultiOrSingleIndex(currFlag);
            // if the value is the same in the multi-area then there's no point in re-assembling
            var valueForMulti = getValue(context, indexForMulti);
            if (!valueForMulti || valueForMulti !== value) {
                var multiDirty = false;
                var singleDirty = true;
                var isClassBased_5 = (currFlag & 2 /* Class */) === 2 /* Class */;
                // only when the value is set to `null` should the multi-value get flagged
                if (!valueExists(value, isClassBased_5) && valueExists(valueForMulti, isClassBased_5)) {
                    multiDirty = true;
                    singleDirty = false;
                }
                setDirty(context, indexForMulti, multiDirty);
                setDirty(context, singleIndex, singleDirty);
                setContextDirty(context, true);
            }
        }
    }
    /**
     * This method will toggle the referenced CSS class (by the provided index)
     * within the given context.
     *
     * @param context The styling context that will be updated with the
     *    newly provided class value.
     * @param index The index of the CSS class which is being updated.
     * @param addOrRemove Whether or not to add or remove the CSS class
     */
    export function updateClassProp(context, index, addOrRemove) {
        var adjustedIndex = index + context[4 /* ClassOffsetPosition */];
        updateStyleProp(context, adjustedIndex, addOrRemove);
    }
    /**
     * Renders all queued styling using a renderer onto the given element.
     *
     * This function works by rendering any styles (that have been applied
     * using `updateStylingMap`) and any classes (that have been applied using
     * `updateStyleProp`) onto the provided element using the provided renderer.
     * Just before the styles/classes are rendered a final key/value style map
     * will be assembled (if `styleStore` or `classStore` are provided).
     *
     * @param lElement the element that the styles will be rendered on
     * @param context The styling context that will be used to determine
     *      what styles will be rendered
     * @param renderer the renderer that will be used to apply the styling
     * @param styleStore if provided, the updated style values will be applied
     *    to this key/value map instead of being renderered via the renderer.
     * @param classStore if provided, the updated class values will be applied
     *    to this key/value map instead of being renderered via the renderer.
     */
    export function renderStyling(context, renderer, styleStore, classStore) {
        if (isContextDirty(context)) {
            var native = context[0 /* ElementPosition */].native;
            var multiStartIndex = getMultiStartIndex(context);
            var styleSanitizer = getStyleSanitizer(context);
            for (var i = 6 /* SingleStylesStartPosition */; i < context.length; i += 3 /* Size */) {
                // there is no point in rendering styles that have not changed on screen
                if (isDirty(context, i)) {
                    var prop = getProp(context, i);
                    var value = getValue(context, i);
                    var flag = getPointers(context, i);
                    var isClassBased_6 = flag & 2 /* Class */ ? true : false;
                    var isInSingleRegion = i < multiStartIndex;
                    var valueToApply = value;
                    // VALUE DEFER CASE 1: Use a multi value instead of a null single value
                    // this check implies that a single value was removed and we
                    // should now defer to a multi value and use that (if set).
                    if (isInSingleRegion && !valueExists(valueToApply, isClassBased_6)) {
                        // single values ALWAYS have a reference to a multi index
                        var multiIndex = getMultiOrSingleIndex(flag);
                        valueToApply = getValue(context, multiIndex);
                    }
                    // VALUE DEFER CASE 2: Use the initial value if all else fails (is falsy)
                    // the initial value will always be a string or null,
                    // therefore we can safely adopt it incase there's nothing else
                    // note that this should always be a falsy check since `false` is used
                    // for both class and style comparisons (styles can't be false and false
                    // classes are turned off and should therefore defer to their initial values)
                    if (!valueExists(valueToApply, isClassBased_6)) {
                        valueToApply = getInitialValue(context, flag);
                    }
                    if (isClassBased_6) {
                        setClass(native, prop, valueToApply ? true : false, renderer, classStore);
                    } else {
                        var sanitizer = flag & 4 /* Sanitize */ ? styleSanitizer : null;
                        setStyle(native, prop, valueToApply, renderer, sanitizer, styleStore);
                    }
                    setDirty(context, i, false);
                }
            }
            setContextDirty(context, false);
        }
    }
    /**
     * This function renders a given CSS prop/value entry using the
     * provided renderer. If a `store` value is provided then
     * that will be used a render context instead of the provided
     * renderer.
     *
     * @param native the DOM Element
     * @param prop the CSS style property that will be rendered
     * @param value the CSS style value that will be rendered
     * @param renderer
     * @param store an optional key/value map that will be used as a context to render styles on
     */
    function setStyle(native, prop, value, renderer, sanitizer, store) {
        value = sanitizer && value ? sanitizer(prop, value) : value;
        if (store) {
            store[prop] = value;
        } else if (value) {
            ngDevMode && ngDevMode.rendererSetStyle++;
            isProceduralRenderer(renderer) ? renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) : native['style'].setProperty(prop, value);
        } else {
            ngDevMode && ngDevMode.rendererRemoveStyle++;
            isProceduralRenderer(renderer) ? renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) : native['style'].removeProperty(prop);
        }
    }
    /**
     * This function renders a given CSS class value using the provided
     * renderer (by adding or removing it from the provided element).
     * If a `store` value is provided then that will be used a render
     * context instead of the provided renderer.
     *
     * @param native the DOM Element
     * @param prop the CSS style property that will be rendered
     * @param value the CSS style value that will be rendered
     * @param renderer
     * @param store an optional key/value map that will be used as a context to render styles on
     */
    function setClass(native, className, add, renderer, store) {
        if (store) {
            store[className] = add;
        } else if (add) {
            ngDevMode && ngDevMode.rendererAddClass++;
            isProceduralRenderer(renderer) ? renderer.addClass(native, className) : native['classList'].add(className);
        } else {
            ngDevMode && ngDevMode.rendererRemoveClass++;
            isProceduralRenderer(renderer) ? renderer.removeClass(native, className) : native['classList'].remove(className);
        }
    }
    function setDirty(context, index, isDirtyYes) {
        var adjustedIndex = index >= 6 /* SingleStylesStartPosition */ ? index + 0 /* FlagsOffset */ : index;
        if (isDirtyYes) {
            context[adjustedIndex] |= 1 /* Dirty */;
        } else {
            context[adjustedIndex] &= ~1 /* Dirty */;
        }
    }
    function isDirty(context, index) {
        var adjustedIndex = index >= 6 /* SingleStylesStartPosition */ ? index + 0 /* FlagsOffset */ : index;
        return (context[adjustedIndex] & 1 /* Dirty */) == 1 /* Dirty */;
    }
    function isClassBased(context, index) {
        var adjustedIndex = index >= 6 /* SingleStylesStartPosition */ ? index + 0 /* FlagsOffset */ : index;
        return (context[adjustedIndex] & 2 /* Class */) == 2 /* Class */;
    }
    function isSanitizable(context, index) {
        var adjustedIndex = index >= 6 /* SingleStylesStartPosition */ ? index + 0 /* FlagsOffset */ : index;
        return (context[adjustedIndex] & 4 /* Sanitize */) == 4 /* Sanitize */;
    }
    function pointers(configFlag, staticIndex, dynamicIndex) {
        return configFlag & 7 /* BitMask */ | staticIndex << 3 /* BitCountSize */ | dynamicIndex << 14 /* BitCountSize */ + 3 /* BitCountSize */;
    }
    function getInitialValue(context, flag) {
        var index = getInitialIndex(flag);
        return context[2 /* InitialStylesPosition */][index];
    }
    function getInitialIndex(flag) {
        return flag >> 3 /* BitCountSize */ & 16383 /* BitMask */;
    }
    function getMultiOrSingleIndex(flag) {
        var index = flag >> 14 /* BitCountSize */ + 3 /* BitCountSize */ & 16383 /* BitMask */;
        return index >= 6 /* SingleStylesStartPosition */ ? index : -1;
    }
    function getMultiStartIndex(context) {
        return getMultiOrSingleIndex(context[3 /* MasterFlagPosition */]);
    }
    function getStyleSanitizer(context) {
        return context[1 /* StyleSanitizerPosition */];
    }
    function setProp(context, index, prop) {
        context[index + 1 /* PropertyOffset */] = prop;
    }
    function setValue(context, index, value) {
        context[index + 2 /* ValueOffset */] = value;
    }
    function setFlag(context, index, flag) {
        var adjustedIndex = index === 3 /* MasterFlagPosition */ ? index : index + 0 /* FlagsOffset */;
        context[adjustedIndex] = flag;
    }
    function getPointers(context, index) {
        var adjustedIndex = index === 3 /* MasterFlagPosition */ ? index : index + 0 /* FlagsOffset */;
        return context[adjustedIndex];
    }
    function getValue(context, index) {
        return context[index + 2 /* ValueOffset */];
    }
    function getProp(context, index) {
        return context[index + 1 /* PropertyOffset */];
    }
    export function isContextDirty(context) {
        return isDirty(context, 3 /* MasterFlagPosition */);
    }
    export function setContextDirty(context, isDirtyYes) {
        setDirty(context, 3 /* MasterFlagPosition */, isDirtyYes);
    }
    function findEntryPositionByProp(context, prop, startIndex) {
        for (var i = (startIndex || 0) + 1 /* PropertyOffset */; i < context.length; i += 3 /* Size */) {
            var thisProp = context[i];
            if (thisProp == prop) {
                return i - 1 /* PropertyOffset */;
            }
        }
        return -1;
    }
    function swapMultiContextEntries(context, indexA, indexB) {
        var tmpValue = getValue(context, indexA);
        var tmpProp = getProp(context, indexA);
        var tmpFlag = getPointers(context, indexA);
        var flagA = tmpFlag;
        var flagB = getPointers(context, indexB);
        var singleIndexA = getMultiOrSingleIndex(flagA);
        if (singleIndexA >= 0) {
            var _flag = getPointers(context, singleIndexA);
            var _initial = getInitialIndex(_flag);
            setFlag(context, singleIndexA, pointers(_flag, _initial, indexB));
        }
        var singleIndexB = getMultiOrSingleIndex(flagB);
        if (singleIndexB >= 0) {
            var _flag = getPointers(context, singleIndexB);
            var _initial = getInitialIndex(_flag);
            setFlag(context, singleIndexB, pointers(_flag, _initial, indexA));
        }
        setValue(context, indexA, getValue(context, indexB));
        setProp(context, indexA, getProp(context, indexB));
        setFlag(context, indexA, getPointers(context, indexB));
        setValue(context, indexB, tmpValue);
        setProp(context, indexB, tmpProp);
        setFlag(context, indexB, tmpFlag);
    }
    function updateSinglePointerValues(context, indexStartPosition) {
        for (var i = indexStartPosition; i < context.length; i += 3 /* Size */) {
            var multiFlag = getPointers(context, i);
            var singleIndex = getMultiOrSingleIndex(multiFlag);
            if (singleIndex > 0) {
                var singleFlag = getPointers(context, singleIndex);
                var initialIndexForSingle = getInitialIndex(singleFlag);
                var flagValue = (isDirty(context, singleIndex) ? 1 /* Dirty */ : 0 /* None */) | (isClassBased(context, singleIndex) ? 2 /* Class */ : 0 /* None */) | (isSanitizable(context, singleIndex) ? 4 /* Sanitize */ : 0 /* None */);
                var updatedFlag = pointers(flagValue, initialIndexForSingle, i);
                setFlag(context, singleIndex, updatedFlag);
            }
        }
    }
    function insertNewMultiProperty(context, index, classBased, name, flag, value) {
        var doShift = index < context.length;
        // prop does not exist in the list, add it in
        context.splice(index, 0, flag | 1 /* Dirty */ | (classBased ? 2 /* Class */ : 0 /* None */), name, value);
        if (doShift) {
            // because the value was inserted midway into the array then we
            // need to update all the shifted multi values' single value
            // pointers to point to the newly shifted location
            updateSinglePointerValues(context, index + 3 /* Size */);
        }
    }
    function valueExists(value, isClassBased) {
        if (isClassBased) {
            return value ? true : false;
        }
        return value !== null;
    }
    function prepareInitialFlag(name, isClassBased, sanitizer) {
        if (isClassBased) {
            return 2 /* Class */;
        } else if (sanitizer && sanitizer(name)) {
            return 4 /* Sanitize */;
        }
        return 0 /* None */;
    }
    function hasValueChanged(flag, a, b) {
        var isClassBased = flag & 2 /* Class */;
        var hasValues = a && b;
        var usesSanitizer = flag & 4 /* Sanitize */;
        // the toString() comparison ensures that a value is checked
        // ... otherwise (during sanitization bypassing) the === comparsion
        // would fail since a new String() instance is created
        if (!isClassBased && hasValues && usesSanitizer) {
            // we know for sure we're dealing with strings at this point
            return a.toString() !== b.toString();
        }
        // everything else is safe to check with a normal equality check
        return a !== b;
    }
});
//# sourceMappingURL=styling.js.map