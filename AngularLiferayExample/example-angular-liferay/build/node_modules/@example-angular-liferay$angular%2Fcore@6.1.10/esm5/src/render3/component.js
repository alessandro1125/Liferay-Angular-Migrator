Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/component', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { assertComponentType, assertDefined } from './assert';
    import { queueInitHooks, queueLifecycleHooks } from './hooks';
    import { CLEAN_PROMISE, ROOT_DIRECTIVE_INDICES, _getComponentHostLElementNode, baseDirectiveCreate, createLViewData, createTView, detectChangesInternal, enterView, executeInitAndContentHooks, getRootView, hostElement, initChangeDetectorIfExisting, leaveView, locateHostElement, setHostBindings } from './instructions';
    import { domRendererFactory3 } from './interfaces/renderer';
    import { INJECTOR, CONTEXT, TVIEW } from './interfaces/view';
    import { stringify } from './util';
    // TODO: A hack to not pull in the NullInjector from @angular/core.
    export var NULL_INJECTOR = {
        get: function (token, notFoundValue) {
            throw new Error('NullInjector: Not found: ' + stringify(token));
        }
    };
    /**
     * Bootstraps a Component into an existing host element and returns an instance
     * of the component.
     *
     * Use this function to bootstrap a component into the DOM tree. Each invocation
     * of this function will create a separate tree of components, injectors and
     * change detection cycles and lifetimes. To dynamically insert a new component
     * into an existing tree such that it shares the same injection, change detection
     * and object lifetime, use {@link ViewContainer#createComponent}.
     *
     * @param componentType Component to bootstrap
     * @param options Optional parameters which control bootstrapping
     */
    export function renderComponent(componentType /* Type as workaround for: Microsoft/TypeScript/issues/4881 */, opts) {
        if (opts === void 0) {
            opts = {};
        }
        ngDevMode && assertComponentType(componentType);
        var rendererFactory = opts.rendererFactory || domRendererFactory3;
        var sanitizer = opts.sanitizer || null;
        var componentDef = componentType.ngComponentDef;
        if (componentDef.type != componentType) componentDef.type = componentType;
        var component;
        // The first index of the first selector is the tag name.
        var componentTag = componentDef.selectors[0][0];
        var hostNode = locateHostElement(rendererFactory, opts.host || componentTag);
        var rootContext = createRootContext(opts.scheduler || requestAnimationFrame.bind(window));
        var rootView = createLViewData(rendererFactory.createRenderer(hostNode, componentDef.rendererType), createTView(-1, null, null, null, null), rootContext, componentDef.onPush ? 4 /* Dirty */ : 2 /* CheckAlways */);
        rootView[INJECTOR] = opts.injector || null;
        var oldView = enterView(rootView, null);
        var elementNode;
        try {
            if (rendererFactory.begin) rendererFactory.begin();
            // Create element node at index 0 in data array
            elementNode = hostElement(componentTag, hostNode, componentDef, sanitizer);
            // Create directive instance with factory() and store at index 0 in directives array
            rootContext.components.push(component = baseDirectiveCreate(0, componentDef.factory(), componentDef));
            initChangeDetectorIfExisting(elementNode.nodeInjector, component, elementNode.data);
            opts.hostFeatures && opts.hostFeatures.forEach(function (feature) {
                return feature(component, componentDef);
            });
            executeInitAndContentHooks();
            setHostBindings(ROOT_DIRECTIVE_INDICES);
            detectChangesInternal(elementNode.data, elementNode, component);
        } finally {
            leaveView(oldView);
            if (rendererFactory.end) rendererFactory.end();
        }
        return component;
    }
    export function createRootContext(scheduler) {
        return {
            components: [],
            scheduler: scheduler,
            clean: CLEAN_PROMISE
        };
    }
    /**
     * Used to enable lifecycle hooks on the root component.
     *
     * Include this feature when calling `renderComponent` if the root component
     * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
     * be called properly.
     *
     * Example:
     *
     * ```
     * renderComponent(AppComponent, {features: [RootLifecycleHooks]});
     * ```
     */
    export function LifecycleHooksFeature(component, def) {
        var elementNode = _getComponentHostLElementNode(component);
        // Root component is always created at dir index 0
        var tView = elementNode.view[TVIEW];
        queueInitHooks(0, def.onInit, def.doCheck, tView);
        queueLifecycleHooks(elementNode.tNode.flags, tView);
    }
    /**
     * Retrieve the root context for any component by walking the parent `LView` until
     * reaching the root `LView`.
     *
     * @param component any component
     */
    function getRootContext(component) {
        var rootContext = getRootView(component)[CONTEXT];
        ngDevMode && assertDefined(rootContext, 'rootContext');
        return rootContext;
    }
    /**
     * Retrieve the host element of the component.
     *
     * Use this function to retrieve the host element of the component. The host
     * element is the element which the component is associated with.
     *
     * @param component Component for which the host element should be retrieved.
     */
    export function getHostElement(component) {
        return _getComponentHostLElementNode(component).native;
    }
    /**
     * Retrieves the rendered text for a given component.
     *
     * This function retrieves the host element of a component and
     * and then returns the `textContent` for that element. This implies
     * that the text returned will include re-projected content of
     * the component as well.
     *
     * @param component The component to return the content text for.
     */
    export function getRenderedText(component) {
        var hostElement = getHostElement(component);
        return hostElement.textContent || '';
    }
    /**
     * Wait on component until it is rendered.
     *
     * This function returns a `Promise` which is resolved when the component's
     * change detection is executed. This is determined by finding the scheduler
     * associated with the `component`'s render tree and waiting until the scheduler
     * flushes. If nothing is scheduled, the function returns a resolved promise.
     *
     * Example:
     * ```
     * await whenRendered(myComponent);
     * ```
     *
     * @param component Component to wait upon
     * @returns Promise which resolves when the component is rendered.
     */
    export function whenRendered(component) {
        return getRootContext(component).clean;
    }
});
//# sourceMappingURL=component.js.map