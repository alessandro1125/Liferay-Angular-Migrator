Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/definition', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { ChangeDetectionStrategy } from '../change_detection/constants';
    import { resolveRendererType2 } from '../view/util';
    /**
     * Create a component definition object.
     *
     *
     * # Example
     * ```
     * class MyDirective {
     *   // Generated by Angular Template Compiler
     *   // [Symbol] syntax will not be supported by TypeScript until v2.7
     *   static ngComponentDef = defineComponent({
     *     ...
     *   });
     * }
     * ```
     */
    export function defineComponent(componentDefinition) {
        var type = componentDefinition.type;
        var pipeTypes = componentDefinition.pipes;
        var directiveTypes = componentDefinition.directives;
        var declaredInputs = {};
        var def = {
            type: type,
            diPublic: null,
            factory: componentDefinition.factory,
            template: componentDefinition.template || null,
            hostBindings: componentDefinition.hostBindings || null,
            contentQueries: componentDefinition.contentQueries || null,
            contentQueriesRefresh: componentDefinition.contentQueriesRefresh || null,
            attributes: componentDefinition.attributes || null,
            inputs: invertObject(componentDefinition.inputs, declaredInputs),
            declaredInputs: declaredInputs,
            outputs: invertObject(componentDefinition.outputs),
            rendererType: resolveRendererType2(componentDefinition.rendererType) || null,
            exportAs: componentDefinition.exportAs || null,
            onInit: type.prototype.ngOnInit || null,
            doCheck: type.prototype.ngDoCheck || null,
            afterContentInit: type.prototype.ngAfterContentInit || null,
            afterContentChecked: type.prototype.ngAfterContentChecked || null,
            afterViewInit: type.prototype.ngAfterViewInit || null,
            afterViewChecked: type.prototype.ngAfterViewChecked || null,
            onDestroy: type.prototype.ngOnDestroy || null,
            onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
            directiveDefs: directiveTypes ? function () {
                return (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes).map(extractDirectiveDef);
            } : null,
            pipeDefs: pipeTypes ? function () {
                return (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef);
            } : null,
            selectors: componentDefinition.selectors,
            viewQuery: componentDefinition.viewQuery || null,
            features: componentDefinition.features || null
        };
        var feature = componentDefinition.features;
        feature && feature.forEach(function (fn) {
            return fn(def);
        });
        return def;
    }
    export function extractDirectiveDef(type) {
        var def = type.ngComponentDef || type.ngDirectiveDef;
        if (ngDevMode && !def) {
            throw new Error("'" + type.name + "' is neither 'ComponentType' or 'DirectiveType'.");
        }
        return def;
    }
    export function extractPipeDef(type) {
        var def = type.ngPipeDef;
        if (ngDevMode && !def) {
            throw new Error("'" + type.name + "' is not a 'PipeType'.");
        }
        return def;
    }
    export function defineNgModule(def) {
        var res = {
            type: def.type,
            bootstrap: def.bootstrap || [],
            declarations: def.declarations || [],
            imports: def.imports || [],
            exports: def.exports || [],
            transitiveCompileScopes: null
        };
        return res;
    }
    var EMPTY = {};
    /**
     * Inverts an inputs or outputs lookup such that the keys, which were the
     * minified keys, are part of the values, and the values are parsed so that
     * the publicName of the property is the new key
     *
     * e.g. for
     *
     * ```
     * class Comp {
     *   @Input()
     *   propName1: string;
     *
     *   @Input('publicName')
     *   propName2: number;
     * }
     * ```
     *
     * will be serialized as
     *
     * ```
     * {
     *   a0: 'propName1',
     *   b1: ['publicName', 'propName2'],
     * }
     * ```
     *
     * becomes
     *
     * ```
     * {
     *  'propName1': 'a0',
     *  'publicName': 'b1'
     * }
     * ```
     *
     * Optionally the function can take `secondary` which will result in:
     *
     * ```
     * {
     *  'propName1': 'a0',
     *  'propName2': 'b1'
     * }
     * ```
     *
    
     */
    function invertObject(obj, secondary) {
        if (obj == null) return EMPTY;
        var newLookup = {};
        for (var minifiedKey in obj) {
            if (obj.hasOwnProperty(minifiedKey)) {
                var publicName = obj[minifiedKey];
                var declaredName = publicName;
                if (Array.isArray(publicName)) {
                    declaredName = publicName[1];
                    publicName = publicName[0];
                }
                newLookup[publicName] = minifiedKey;
                if (secondary) {
                    secondary[declaredName] = minifiedKey;
                }
            }
        }
        return newLookup;
    }
    /**
     * Create a directive definition object.
     *
     * # Example
     * ```
     * class MyDirective {
     *   // Generated by Angular Template Compiler
     *   // [Symbol] syntax will not be supported by TypeScript until v2.7
     *   static ngDirectiveDef = defineDirective({
     *     ...
     *   });
     * }
     * ```
     */
    export var defineDirective = defineComponent;
    /**
     * Create a pipe definition object.
     *
     * # Example
     * ```
     * class MyPipe implements PipeTransform {
     *   // Generated by Angular Template Compiler
     *   static ngPipeDef = definePipe({
     *     ...
     *   });
     * }
     * ```
     * @param pipeDef Pipe definition generated by the compiler
     */
    export function definePipe(pipeDef) {
        return {
            name: pipeDef.name,
            factory: pipeDef.factory,
            pure: pipeDef.pure !== false,
            onDestroy: pipeDef.type.prototype.ngOnDestroy || null
        };
    }
});
//# sourceMappingURL=definition.js.map