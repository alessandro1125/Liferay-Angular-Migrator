Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/jit/injectable', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { LiteralExpr, WrappedNodeExpr, compileInjectable as compileR3Injectable, jitExpression } from '@angular/compiler';
    import { getClosureSafeProperty } from '../../util/property';
    import { angularCoreEnv } from './environment';
    import { NG_INJECTABLE_DEF } from './fields';
    import { convertDependencies, reflectDependencies } from './util';
    /**
     * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting
     * `ngInjectableDef` onto the injectable type.
     */
    export function compileInjectable(type, meta) {
        // TODO(alxhub): handle JIT of bare @Injectable().
        if (!meta) {
            return;
        }
        var def = null;
        Object.defineProperty(type, NG_INJECTABLE_DEF, {
            get: function () {
                if (def === null) {
                    // Check whether the injectable metadata includes a provider specification.
                    var hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) || isUseValueProvider(meta) || isUseExistingProvider(meta);
                    var deps = undefined;
                    if (!hasAProvider || isUseClassProvider(meta) && type === meta.useClass) {
                        deps = reflectDependencies(type);
                    } else if (isUseClassProvider(meta)) {
                        deps = meta.deps && convertDependencies(meta.deps);
                    } else if (isUseFactoryProvider(meta)) {
                        deps = meta.deps && convertDependencies(meta.deps) || [];
                    }
                    // Decide which flavor of factory to generate, based on the provider specified.
                    // Only one of the use* fields should be set.
                    var useClass = undefined;
                    var useFactory = undefined;
                    var useValue = undefined;
                    var useExisting = undefined;
                    if (!hasAProvider) {
                        // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.
                        // The deps will have been reflected above, causing the factory to create the class by
                        // calling
                        // its constructor with injected deps.
                        useClass = new WrappedNodeExpr(type);
                    } else if (isUseClassProvider(meta)) {
                        // The user explicitly specified useClass, and may or may not have provided deps.
                        useClass = new WrappedNodeExpr(meta.useClass);
                    } else if (isUseValueProvider(meta)) {
                        // The user explicitly specified useValue.
                        useValue = new WrappedNodeExpr(meta.useValue);
                    } else if (isUseFactoryProvider(meta)) {
                        // The user explicitly specified useFactory.
                        useFactory = new WrappedNodeExpr(meta.useFactory);
                    } else if (isUseExistingProvider(meta)) {
                        // The user explicitly specified useExisting.
                        useExisting = new WrappedNodeExpr(meta.useExisting);
                    } else {
                        // Can't happen - either hasAProvider will be false, or one of the providers will be set.
                        throw new Error("Unreachable state.");
                    }
                    var expression = compileR3Injectable({
                        name: type.name,
                        type: new WrappedNodeExpr(type),
                        providedIn: computeProvidedIn(meta.providedIn),
                        useClass: useClass,
                        useFactory: useFactory,
                        useValue: useValue,
                        useExisting: useExisting,
                        deps: deps
                    }).expression;
                    def = jitExpression(expression, angularCoreEnv, "ng://" + type.name + "/ngInjectableDef.js");
                }
                return def;
            }
        });
    }
    function computeProvidedIn(providedIn) {
        if (providedIn == null || typeof providedIn === 'string') {
            return new LiteralExpr(providedIn);
        } else {
            return new WrappedNodeExpr(providedIn);
        }
    }
    function isUseClassProvider(meta) {
        return meta.useClass !== undefined;
    }
    var GET_PROPERTY_NAME = {};
    var ɵ0 = GET_PROPERTY_NAME;
    var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 }, GET_PROPERTY_NAME);
    function isUseValueProvider(meta) {
        return USE_VALUE in meta;
    }
    function isUseFactoryProvider(meta) {
        return meta.useFactory !== undefined;
    }
    function isUseExistingProvider(meta) {
        return meta.useExisting !== undefined;
    }
    export { ɵ0 };
});
//# sourceMappingURL=injectable.js.map