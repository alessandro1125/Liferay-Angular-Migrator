Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/src/render3/jit/directive', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { ConstantPool, WrappedNodeExpr, compileComponentFromMetadata as compileR3Component, compileDirectiveFromMetadata as compileR3Directive, jitExpression, makeBindingParser, parseHostBindings, parseTemplate } from '@angular/compiler';
    import { componentNeedsResolution, maybeQueueResolutionOfComponentResources } from '../../metadata/resource_loading';
    import { stringify } from '../../util';
    import { angularCoreEnv } from './environment';
    import { NG_COMPONENT_DEF, NG_DIRECTIVE_DEF } from './fields';
    import { patchComponentDefWithScope } from './module';
    import { getReflect, reflectDependencies } from './util';
    /**
     * Compile an Angular component according to its decorator metadata, and patch the resulting
     * ngComponentDef onto the component type.
     *
     * Compilation may be asynchronous (due to the need to resolve URLs for the component template or
     * other resources, for example). In the event that compilation is not immediate, `compileComponent`
     * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`
     * until the global queue has been resolved with a call to `resolveComponentResources`.
     */
    export function compileComponent(type, metadata) {
        var def = null;
        // Metadata may have resources which need to be resolved.
        maybeQueueResolutionOfComponentResources(metadata);
        Object.defineProperty(type, NG_COMPONENT_DEF, {
            get: function () {
                if (def === null) {
                    if (componentNeedsResolution(metadata)) {
                        var error = ["Component '" + stringify(type) + "' is not resolved:"];
                        if (metadata.templateUrl) {
                            error.push(" - templateUrl: " + stringify(metadata.templateUrl));
                        }
                        if (metadata.styleUrls && metadata.styleUrls.length) {
                            error.push(" - styleUrls: " + JSON.stringify(metadata.styleUrls));
                        }
                        error.push("Did you run and wait for 'resolveComponentResources()'?");
                        throw new Error(error.join('\n'));
                    }
                    // The ConstantPool is a requirement of the JIT'er.
                    var constantPool = new ConstantPool();
                    // Parse the template and check for errors.
                    var template = parseTemplate(metadata.template, "ng://" + stringify(type) + "/template.html", {
                        preserveWhitespaces: metadata.preserveWhitespaces || false
                    });
                    if (template.errors !== undefined) {
                        var errors = template.errors.map(function (err) {
                            return err.toString();
                        }).join(', ');
                        throw new Error("Errors during JIT compilation of template for " + stringify(type) + ": " + errors);
                    }
                    // Compile the component metadata, including template, into an expression.
                    // TODO(alxhub): implement inputs, outputs, queries, etc.
                    var res = compileR3Component(tslib_1.__assign({}, directiveMetadata(type, metadata), { template: template, directives: new Map(), pipes: new Map(), viewQueries: [] }), constantPool, makeBindingParser());
                    def = jitExpression(res.expression, angularCoreEnv, "ng://" + type.name + "/ngComponentDef.js", constantPool);
                    // If component compilation is async, then the @NgModule annotation which declares the
                    // component may execute and set an ngSelectorScope property on the component type. This
                    // allows the component to patch itself with directiveDefs from the module after it finishes
                    // compiling.
                    if (hasSelectorScope(type)) {
                        patchComponentDefWithScope(def, type.ngSelectorScope);
                    }
                }
                return def;
            }
        });
    }
    function hasSelectorScope(component) {
        return component.ngSelectorScope !== undefined;
    }
    /**
     * Compile an Angular directive according to its decorator metadata, and patch the resulting
     * ngDirectiveDef onto the component type.
     *
     * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which
     * will resolve when compilation completes and the directive becomes usable.
     */
    export function compileDirective(type, directive) {
        var def = null;
        Object.defineProperty(type, NG_DIRECTIVE_DEF, {
            get: function () {
                if (def === null) {
                    var constantPool = new ConstantPool();
                    var sourceMapUrl = "ng://" + (type && type.name) + "/ngDirectiveDef.js";
                    var res = compileR3Directive(directiveMetadata(type, directive), constantPool, makeBindingParser());
                    def = jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool);
                }
                return def;
            }
        });
    }
    export function extendsDirectlyFromObject(type) {
        return Object.getPrototypeOf(type.prototype) === Object.prototype;
    }
    /**
     * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a
     * `Component`).
     */
    function directiveMetadata(type, metadata) {
        // Reflect inputs and outputs.
        var propMetadata = getReflect().propMetadata(type);
        var host = extractHostBindings(metadata, propMetadata);
        var inputsFromMetadata = parseInputOutputs(metadata.inputs || []);
        var outputsFromMetadata = parseInputOutputs(metadata.outputs || []);
        var inputsFromType = {};
        var outputsFromType = {};
        var _loop_1 = function (field) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(function (ann) {
                    if (isInput(ann)) {
                        inputsFromType[field] = ann.bindingPropertyName || field;
                    } else if (isOutput(ann)) {
                        outputsFromType[field] = ann.bindingPropertyName || field;
                    }
                });
            }
        };
        for (var field in propMetadata) {
            _loop_1(field);
        }
        return {
            name: type.name,
            type: new WrappedNodeExpr(type),
            typeArgumentCount: 0,
            selector: metadata.selector,
            deps: reflectDependencies(type), host: host,
            inputs: tslib_1.__assign({}, inputsFromMetadata, inputsFromType),
            outputs: tslib_1.__assign({}, outputsFromMetadata, outputsFromType),
            queries: [],
            lifecycle: {
                usesOnChanges: type.prototype.ngOnChanges !== undefined
            },
            typeSourceSpan: null,
            usesInheritance: !extendsDirectlyFromObject(type)
        };
    }
    function extractHostBindings(metadata, propMetadata) {
        // First parse the declarations from the metadata.
        var _a = parseHostBindings(metadata.host || {}),
            attributes = _a.attributes,
            listeners = _a.listeners,
            properties = _a.properties,
            animations = _a.animations;
        if (Object.keys(animations).length > 0) {
            throw new Error("Animation bindings are as-of-yet unsupported in Ivy");
        }
        var _loop_2 = function (field) {
            if (propMetadata.hasOwnProperty(field)) {
                propMetadata[field].forEach(function (ann) {
                    if (isHostBinding(ann)) {
                        properties[ann.hostPropertyName || field] = field;
                    } else if (isHostListener(ann)) {
                        listeners[ann.eventName || field] = field + "(" + (ann.args || []).join(',') + ")";
                    }
                });
            }
        };
        // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.
        for (var field in propMetadata) {
            _loop_2(field);
        }
        return { attributes: attributes, listeners: listeners, properties: properties };
    }
    function isInput(value) {
        return value.ngMetadataName === 'Input';
    }
    function isOutput(value) {
        return value.ngMetadataName === 'Output';
    }
    function isHostBinding(value) {
        return value.ngMetadataName === 'HostBinding';
    }
    function isHostListener(value) {
        return value.ngMetadataName === 'HostListener';
    }
    function parseInputOutputs(values) {
        return values.reduce(function (map, value) {
            var _a = tslib_1.__read(value.split(',').map(function (piece) {
                return piece.trim();
            }), 2),
                field = _a[0],
                property = _a[1];
            map[field] = property || field;
            return map;
        }, {});
    }
});
//# sourceMappingURL=directive.js.map