{"version":3,"sources":["../../../../../../../../../../packages/core/src/render3/instructions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {QueryList} from '../linker';\nimport {Sanitizer} from '../sanitization/security';\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\n\nimport {assertDefined, assertEqual, assertLessThan, assertNotDefined, assertNotEqual} from './assert';\nimport {throwCyclicDependencyError, throwErrorIfNoChangesMode, throwMultipleComponentError} from './errors';\nimport {executeHooks, executeInitHooks, queueInitHooks, queueLifecycleHooks} from './hooks';\nimport {ACTIVE_INDEX, LContainer, RENDER_PARENT, VIEWS} from './interfaces/container';\nimport {ComponentDefInternal, ComponentQuery, ComponentTemplate, DirectiveDefInternal, DirectiveDefListOrFactory, InitialStylingFlags, PipeDefListOrFactory, RenderFlags} from './interfaces/definition';\nimport {LInjector} from './interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LContainerNode, LElementNode, LNode, LProjectionNode, LTextNode, LViewNode, PropertyAliasValue, PropertyAliases, TAttributes, TContainerNode, TElementNode, TNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {CssSelectorList, NG_PROJECT_AS_ATTR_NAME} from './interfaces/projection';\nimport {LQueries} from './interfaces/query';\nimport {ProceduralRenderer3, RComment, RElement, RText, Renderer3, RendererFactory3, RendererStyleFlags3, isProceduralRenderer} from './interfaces/renderer';\nimport {BINDING_INDEX, CLEANUP, CONTAINER_INDEX, CONTENT_QUERIES, CONTEXT, CurrentMatchesList, DIRECTIVES, FLAGS, HEADER_OFFSET, HOST_NODE, INJECTOR, LViewData, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, RootContext, SANITIZER, TAIL, TData, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {appendChild, appendProjectedNode, canInsertNativeNode, createTextNode, findComponentHost, getChildLNode, getLViewChild, getNextLNode, getParentLNode, insertView, removeView} from './node_manipulation';\nimport {isNodeMatchingSelectorList, matchingSelectorIndex} from './node_selector_matcher';\nimport {StylingContext, allocStylingContext, createStylingContextTemplate, renderStyling as renderElementStyles, updateClassProp as updateElementClassProp, updateStyleProp as updateElementStyleProp, updateStylingMap} from './styling';\nimport {assertDataInRangeInternal, isDifferent, loadElementInternal, loadInternal, stringify} from './util';\nimport {ViewRef} from './view_ref';\n\n\n\n/**\n * Directive (D) sets a property on all component instances using this constant as a key and the\n * component's host node (LElement) as the value. This is used in methods like detectChanges to\n * facilitate jumping from an instance to the host node.\n */\nexport const NG_HOST_SYMBOL = '__ngHostLNode__';\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = Promise.resolve(null);\n\n/**\n * Function used to sanitize the value before writing it into the renderer.\n */\nexport type SanitizerFn = (value: any) => string;\n\n/**\n * Directive and element indices for top-level directive.\n *\n * Saved here to avoid re-instantiating an array on every change detection run.\n *\n * Note: Element is not actually stored at index 0 because of the LViewData\n * header, but the host bindings function expects an index that is NOT adjusted\n * because it will ultimately be fed to instructions like elementProperty.\n */\nconst _ROOT_DIRECTIVE_INDICES = [0, 0];\n\n/**\n * TView.data needs to fill the same number of slots as the LViewData header\n * so the indices of nodes are consistent between LViewData and TView.data.\n *\n * It's much faster to keep a blueprint of the pre-filled array and slice it\n * than it is to create a new array and fill it each time a TView is created.\n */\nconst HEADER_FILLER = new Array(HEADER_OFFSET).fill(null);\n\n/**\n * Token set in currentMatches while dependencies are being resolved.\n *\n * If we visit a directive that has a value set to CIRCULAR, we know we've\n * already seen it, and thus have a circular dependency.\n */\nexport const CIRCULAR = '__CIRCULAR__';\n\n/**\n * This property gets set before entering a template.\n *\n * This renderer can be one of two varieties of Renderer3:\n *\n * - ObjectedOrientedRenderer3\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade (reducing payload\n * size).\n *\n * - ProceduralRenderer3\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the facade\n * that enables element manipulation. This also facilitates backwards compatibility with\n * Renderer2.\n */\nlet renderer: Renderer3;\nlet rendererFactory: RendererFactory3;\nlet currentElementNode: LElementNode|null = null;\n\nexport function getRenderer(): Renderer3 {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return renderer;\n}\n\nexport function getCurrentSanitizer(): Sanitizer|null {\n  return viewData && viewData[SANITIZER];\n}\n\nexport function getViewData(): LViewData {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return viewData;\n}\n\n/** Used to set the parent property when nodes are created. */\nlet previousOrParentNode: LNode;\n\nexport function getPreviousOrParentNode(): LNode {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return previousOrParentNode;\n}\n\n/**\n * If `isParent` is:\n *  - `true`: then `previousOrParentNode` points to a parent node.\n *  - `false`: then `previousOrParentNode` points to previous node (sibling).\n */\nlet isParent: boolean;\n\nlet tView: TView;\n\nlet currentQueries: LQueries|null;\n\n/**\n * Query instructions can ask for \"current queries\" in 2 different cases:\n * - when creating view queries (at the root of a component view, before any node is created - in\n * this case currentQueries points to view queries)\n * - when creating content queries (inb this previousOrParentNode points to a node on which we\n * create content queries).\n */\nexport function getCurrentQueries(QueryType: {new (): LQueries}): LQueries {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return currentQueries ||\n      (currentQueries =\n           (previousOrParentNode.queries && previousOrParentNode.queries.clone() ||\n            new QueryType()));\n}\n\n/**\n * This property gets set before entering a template.\n */\nlet creationMode: boolean;\n\nexport function getCreationMode(): boolean {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return creationMode;\n}\n\n/**\n * State of the current view being processed.\n *\n * An array of nodes (text, element, container, etc), pipes, their bindings, and\n * any local variables that need to be stored between invocations.\n */\nlet viewData: LViewData;\n\n/**\n * An array of directive instances in the current view.\n *\n * These must be stored separately from LNodes because their presence is\n * unknown at compile-time and thus space cannot be reserved in data[].\n */\nlet directives: any[]|null;\n\nfunction getCleanup(view: LViewData): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = []);\n}\n\nfunction getTViewCleanup(view: LViewData): any[] {\n  return view[TVIEW].cleanup || (view[TVIEW].cleanup = []);\n}\n/**\n * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n *\n * Necessary to support ChangeDetectorRef.checkNoChanges().\n */\nlet checkNoChangesMode = false;\n\n/** Whether or not this is the first time the current view has been processed. */\nlet firstTemplatePass = true;\n\nconst enum BindingDirection {\n  Input,\n  Output,\n}\n\n/**\n * Swap the current state with a new state.\n *\n * For performance reasons we store the state in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the state for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New state to become active\n * @param host Element to which the View is a child of\n * @returns the previous state;\n */\nexport function enterView(newView: LViewData, host: LElementNode | LViewNode | null): LViewData {\n  const oldView: LViewData = viewData;\n  directives = newView && newView[DIRECTIVES];\n  tView = newView && newView[TVIEW];\n\n  creationMode = newView && (newView[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n  firstTemplatePass = newView && tView.firstTemplatePass;\n\n  renderer = newView && newView[RENDERER];\n\n  if (host != null) {\n    previousOrParentNode = host;\n    isParent = true;\n  }\n\n  viewData = newView;\n  currentQueries = newView && newView[QUERIES];\n\n  return oldView;\n}\n\n/**\n * Used in lieu of enterView to make it clear when we are exiting a child view. This makes\n * the direction of traversal (up or down the view tree) a bit clearer.\n *\n * @param newView New state to become active\n * @param creationOnly An optional boolean to indicate that the view was processed in creation mode\n * only, i.e. the first update will be done later. Only possible for dynamically created views.\n */\nexport function leaveView(newView: LViewData, creationOnly?: boolean): void {\n  if (!creationOnly) {\n    if (!checkNoChangesMode) {\n      executeHooks(directives !, tView.viewHooks, tView.viewCheckHooks, creationMode);\n    }\n    // Views are clean and in update mode after being checked, so these bits are cleared\n    viewData[FLAGS] &= ~(LViewFlags.CreationMode | LViewFlags.Dirty);\n  }\n  viewData[FLAGS] |= LViewFlags.RunInit;\n  viewData[BINDING_INDEX] = -1;\n  enterView(newView, null);\n}\n\n/**\n * Refreshes the view, executing the following steps in that order:\n * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host\n * bindings,\n * refreshes child components.\n * Note: view hooks are triggered later when leaving the view.\n */\nfunction refreshView() {\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n  }\n  refreshDynamicEmbeddedViews(viewData);\n  if (!checkNoChangesMode) {\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n\n  // This needs to be set before children are processed to support recursive components\n  tView.firstTemplatePass = firstTemplatePass = false;\n\n  setHostBindings(tView.hostBindings);\n  refreshContentQueries(tView);\n  refreshChildComponents(tView.components);\n}\n\n\n/** Sets the host bindings for the current view. */\nexport function setHostBindings(bindings: number[] | null): void {\n  if (bindings != null) {\n    const defs = tView.directives !;\n    for (let i = 0; i < bindings.length; i += 2) {\n      const dirIndex = bindings[i];\n      const def = defs[dirIndex] as DirectiveDefInternal<any>;\n      def.hostBindings && def.hostBindings(dirIndex, bindings[i + 1]);\n    }\n  }\n}\n\n/** Refreshes content queries for all directives in the given view. */\nfunction refreshContentQueries(tView: TView): void {\n  if (tView.contentQueries != null) {\n    for (let i = 0; i < tView.contentQueries.length; i += 2) {\n      const directiveDefIdx = tView.contentQueries[i];\n      const directiveDef = tView.directives ![directiveDefIdx];\n\n      directiveDef.contentQueriesRefresh !(directiveDefIdx, tView.contentQueries[i + 1]);\n    }\n  }\n}\n\n/** Refreshes child components in the current view. */\nfunction refreshChildComponents(components: number[] | null): void {\n  if (components != null) {\n    for (let i = 0; i < components.length; i += 2) {\n      componentRefresh(components[i], components[i + 1]);\n    }\n  }\n}\n\nexport function executeInitAndContentHooks(): void {\n  if (!checkNoChangesMode) {\n    executeInitHooks(viewData, tView, creationMode);\n    executeHooks(directives !, tView.contentHooks, tView.contentCheckHooks, creationMode);\n  }\n}\n\nexport function createLViewData<T>(\n    renderer: Renderer3, tView: TView, context: T | null, flags: LViewFlags,\n    sanitizer?: Sanitizer | null): LViewData {\n  return [\n    tView,                                                                       // tView\n    viewData,                                                                    // parent\n    null,                                                                        // next\n    null,                                                                        // queries\n    flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.RunInit,  // flags\n    null !,                                                                      // hostNode\n    -1,                                                                          // bindingIndex\n    null,                                                                        // directives\n    null,                                                                        // cleanupInstances\n    context,                                                                     // context\n    viewData && viewData[INJECTOR],                                              // injector\n    renderer,                                                                    // renderer\n    sanitizer || null,                                                           // sanitizer\n    null,                                                                        // tail\n    -1,                                                                          // containerIndex\n    null,                                                                        // contentQueries\n  ];\n}\n\n/**\n * Creation of LNode object is extracted to a separate function so we always create LNode object\n * with the same shape\n * (same properties assigned in the same order).\n */\nexport function createLNodeObject(\n    type: TNodeType, currentView: LViewData, parent: LNode | null,\n    native: RText | RElement | RComment | null, state: any,\n    queries: LQueries | null): LElementNode&LTextNode&LViewNode&LContainerNode&LProjectionNode {\n  return {\n    native: native as any,\n    view: currentView,\n    nodeInjector: parent ? parent.nodeInjector : null,\n    data: state,\n    queries: queries,\n    tNode: null !,\n    dynamicLContainerNode: null\n  };\n}\n\n/**\n * A common way of creating the LNode to make sure that all of them have same shape to\n * keep the execution code monomorphic and fast.\n *\n * @param index The index at which the LNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of LNode to create\n * @param native The native element for this LNode, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n * @param data Any data that should be saved on the LNode\n */\nexport function createLNode(\n    index: number, type: TNodeType.Element, native: RElement | RText | null, name: string | null,\n    attrs: TAttributes | null, lViewData?: LViewData | null): LElementNode;\nexport function createLNode(\n    index: number, type: TNodeType.View, native: null, name: null, attrs: null,\n    lViewData: LViewData): LViewNode;\nexport function createLNode(\n    index: number, type: TNodeType.Container, native: RComment, name: string | null,\n    attrs: TAttributes | null, lContainer: LContainer): LContainerNode;\nexport function createLNode(\n    index: number, type: TNodeType.Projection, native: null, name: null, attrs: TAttributes | null,\n    lProjection: null): LProjectionNode;\nexport function createLNode(\n    index: number, type: TNodeType, native: RText | RElement | RComment | null, name: string | null,\n    attrs: TAttributes | null, state?: null | LViewData | LContainer): LElementNode&LTextNode&\n    LViewNode&LContainerNode&LProjectionNode {\n  const parent = isParent ? previousOrParentNode :\n                            previousOrParentNode && getParentLNode(previousOrParentNode) !as LNode;\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const tParent =\n      parent && parent.view === viewData ? parent.tNode as TElementNode | TContainerNode : null;\n  let queries =\n      (isParent ? currentQueries : previousOrParentNode && previousOrParentNode.queries) ||\n      parent && parent.queries && parent.queries.child();\n  const isState = state != null;\n  const node =\n      createLNodeObject(type, viewData, parent, native, isState ? state as any : null, queries);\n\n  if (index === -1 || type === TNodeType.View) {\n    // View nodes are not stored in data because they can be added / removed at runtime (which\n    // would cause indices to change). Their TNodes are instead stored in TView.node.\n    node.tNode = (state ? (state as LViewData)[TVIEW].node : null) ||\n        createTNode(type, index, null, null, tParent, null);\n  } else {\n    const adjustedIndex = index + HEADER_OFFSET;\n\n    // This is an element or container or projection node\n    ngDevMode && assertDataNext(adjustedIndex);\n    const tData = tView.data;\n\n    viewData[adjustedIndex] = node;\n\n    // Every node adds a value to the static data array to avoid a sparse array\n    if (adjustedIndex >= tData.length) {\n      const tNode = tData[adjustedIndex] =\n          createTNode(type, adjustedIndex, name, attrs, tParent, null);\n      if (!isParent && previousOrParentNode) {\n        const previousTNode = previousOrParentNode.tNode;\n        previousTNode.next = tNode;\n        if (previousTNode.dynamicContainerNode) previousTNode.dynamicContainerNode.next = tNode;\n      }\n    }\n    node.tNode = tData[adjustedIndex] as TNode;\n\n    // Now link ourselves into the tree.\n    if (isParent) {\n      currentQueries = null;\n      if (previousOrParentNode.tNode.child == null && previousOrParentNode.view === viewData ||\n          previousOrParentNode.tNode.type === TNodeType.View) {\n        // We are in the same view, which means we are adding content node to the parent View.\n        previousOrParentNode.tNode.child = node.tNode;\n      }\n    }\n  }\n\n  // View nodes and host elements need to set their host node (components set host nodes later)\n  if ((type & TNodeType.ViewOrElement) === TNodeType.ViewOrElement && isState) {\n    const lViewData = state as LViewData;\n    ngDevMode && assertNotDefined(\n                     lViewData[HOST_NODE], 'lViewData[HOST_NODE] should not have been initialized');\n    lViewData[HOST_NODE] = node;\n    if (firstTemplatePass) lViewData[TVIEW].node = node.tNode;\n  }\n\n  previousOrParentNode = node;\n  isParent = true;\n  return node;\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Resets the application state.\n */\nexport function resetApplicationState() {\n  isParent = false;\n  previousOrParentNode = null !;\n}\n\n/**\n *\n * @param hostNode Existing node to render into.\n * @param template Template function with the instructions.\n * @param context to pass into the template.\n * @param providedRendererFactory renderer factory to use\n * @param host The host element node to use\n * @param directives Directive defs that should be used for matching\n * @param pipes Pipe defs that should be used for matching\n */\nexport function renderTemplate<T>(\n    hostNode: RElement, template: ComponentTemplate<T>, context: T,\n    providedRendererFactory: RendererFactory3, host: LElementNode | null,\n    directives?: DirectiveDefListOrFactory | null, pipes?: PipeDefListOrFactory | null,\n    sanitizer?: Sanitizer | null): LElementNode {\n  if (host == null) {\n    resetApplicationState();\n    rendererFactory = providedRendererFactory;\n    const tView = getOrCreateTView(template, directives || null, pipes || null, null);\n    host = createLNode(\n        -1, TNodeType.Element, hostNode, null, null,\n        createLViewData(\n            providedRendererFactory.createRenderer(null, null), tView, {}, LViewFlags.CheckAlways,\n            sanitizer));\n  }\n  const hostView = host.data !;\n  ngDevMode && assertDefined(hostView, 'Host node should have an LView defined in host.data.');\n  renderComponentOrTemplate(host, hostView, context, template);\n  return host;\n}\n\n/**\n * Used for creating the LViewNode of a dynamic embedded view,\n * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().\n * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).\n */\nexport function createEmbeddedViewNode<T>(\n    tView: TView, context: T, renderer: Renderer3, queries?: LQueries | null): LViewNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  isParent = true;\n  previousOrParentNode = null !;\n\n  const lView =\n      createLViewData(renderer, tView, context, LViewFlags.CheckAlways, getCurrentSanitizer());\n  if (queries) {\n    lView[QUERIES] = queries.createView();\n  }\n  const viewNode = createLNode(-1, TNodeType.View, null, null, null, lView);\n\n  isParent = _isParent;\n  previousOrParentNode = _previousOrParentNode;\n  return viewNode;\n}\n\n/**\n * Used for rendering embedded views (e.g. dynamically created views)\n *\n * Dynamically created views must store/retrieve their TViews differently from component views\n * because their template functions are nested in the template functions of their hosts, creating\n * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor inside\n * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we\n * can't store TViews in the template function itself (as we do for comps). Instead, we store the\n * TView for dynamically created views on their host TNode, which only has one instance.\n */\nexport function renderEmbeddedTemplate<T>(\n    viewNode: LViewNode | LElementNode, tView: TView, context: T, rf: RenderFlags): LViewNode|\n    LElementNode {\n  const _isParent = isParent;\n  const _previousOrParentNode = previousOrParentNode;\n  let oldView: LViewData;\n  if (viewNode.data ![PARENT] == null && viewNode.data ![CONTEXT] && !tView.template) {\n    // This is a root view inside the view tree\n    tickRootContext(viewNode.data ![CONTEXT] as RootContext);\n  } else {\n    try {\n      isParent = true;\n      previousOrParentNode = null !;\n\n      oldView = enterView(viewNode.data !, viewNode);\n      namespaceHTML();\n      tView.template !(rf, context);\n      if (rf & RenderFlags.Update) {\n        refreshView();\n      } else {\n        viewNode.data ![TVIEW].firstTemplatePass = firstTemplatePass = false;\n      }\n    } finally {\n      // renderEmbeddedTemplate() is called twice in fact, once for creation only and then once for\n      // update. When for creation only, leaveView() must not trigger view hooks, nor clean flags.\n      const isCreationOnly = (rf & RenderFlags.Create) === RenderFlags.Create;\n      leaveView(oldView !, isCreationOnly);\n      isParent = _isParent;\n      previousOrParentNode = _previousOrParentNode;\n    }\n  }\n  return viewNode;\n}\n\nexport function renderComponentOrTemplate<T>(\n    node: LElementNode, hostView: LViewData, componentOrContext: T,\n    template?: ComponentTemplate<T>) {\n  const oldView = enterView(hostView, node);\n  try {\n    if (rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (template) {\n      namespaceHTML();\n      template(getRenderFlags(hostView), componentOrContext !);\n      refreshView();\n    } else {\n      executeInitAndContentHooks();\n\n      // Element was stored at 0 in data and directive was stored at 0 in directives\n      // in renderComponent()\n      setHostBindings(_ROOT_DIRECTIVE_INDICES);\n      componentRefresh(0, HEADER_OFFSET);\n    }\n  } finally {\n    if (rendererFactory.end) {\n      rendererFactory.end();\n    }\n    leaveView(oldView);\n  }\n}\n\n/**\n * This function returns the default configuration of rendering flags depending on when the\n * template is in creation mode or update mode. By default, the update block is run with the\n * creation block when the view is in creation mode. Otherwise, the update block is run\n * alone.\n *\n * Dynamically created views do NOT use this configuration (update block and create block are\n * always run separately).\n */\nfunction getRenderFlags(view: LViewData): RenderFlags {\n  return view[FLAGS] & LViewFlags.CreationMode ? RenderFlags.Create | RenderFlags.Update :\n                                                 RenderFlags.Update;\n}\n\n//////////////////////////\n//// Namespace\n//////////////////////////\n\nlet _currentNamespace: string|null = null;\n\nexport function namespaceSVG() {\n  _currentNamespace = 'http://www.w3.org/2000/svg/';\n}\n\nexport function namespaceMathML() {\n  _currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\nexport function namespaceHTML() {\n  _currentNamespace = null;\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\n/**\n * Creates an empty element using {@link elementStart} and {@link elementEnd}\n *\n * @param index Index of the element in the data array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function element(\n    index: number, name: string, attrs?: TAttributes | null, localRefs?: string[] | null): void {\n  elementStart(index, name, attrs, localRefs);\n  elementEnd();\n}\n\n/**\n * Create DOM element. The instruction must later be followed by `elementEnd()` call.\n *\n * @param index Index of the element in the LViewData array\n * @param name Name of the DOM Node\n * @param attrs Statically bound set of attributes to be written into the DOM element on creation.\n * @param localRefs A set of local reference bindings on the element.\n *\n * Attributes and localRefs are passed as an array of strings where elements with an even index\n * hold an attribute name and elements with an odd index hold an attribute value, ex.:\n * ['id', 'warning5', 'class', 'alert']\n */\nexport function elementStart(\n    index: number, name: string, attrs?: TAttributes | null,\n    localRefs?: string[] | null): RElement {\n  ngDevMode &&\n      assertEqual(viewData[BINDING_INDEX], -1, 'elements should be created before any bindings');\n\n  ngDevMode && ngDevMode.rendererCreateElement++;\n\n  const native = elementCreate(name);\n\n  ngDevMode && assertDataInRange(index - 1);\n\n  const node: LElementNode =\n      createLNode(index, TNodeType.Element, native !, name, attrs || null, null);\n  currentElementNode = node;\n\n  if (attrs) {\n    setUpAttributes(native, attrs);\n  }\n  appendChild(getParentLNode(node), native, viewData);\n  createDirectivesAndLocals(localRefs);\n  return native;\n}\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param overriddenRenderer Optional A renderer to override the default one\n * @returns the element created\n */\nexport function elementCreate(name: string, overriddenRenderer?: Renderer3): RElement {\n  let native: RElement;\n  const rendererToUse = overriddenRenderer || renderer;\n\n  if (isProceduralRenderer(rendererToUse)) {\n    native = rendererToUse.createElement(name, _currentNamespace);\n  } else {\n    if (_currentNamespace === null) {\n      native = rendererToUse.createElement(name);\n    } else {\n      native = rendererToUse.createElementNS(_currentNamespace, name);\n    }\n  }\n  return native;\n}\n\n/**\n * Creates directive instances and populates local refs.\n *\n * @param localRefs Local refs of the current node\n */\nfunction createDirectivesAndLocals(localRefs?: string[] | null) {\n  const node = previousOrParentNode;\n\n  if (firstTemplatePass) {\n    ngDevMode && ngDevMode.firstTemplatePass++;\n    cacheMatchingDirectivesForNode(node.tNode, tView, localRefs || null);\n  } else {\n    instantiateDirectivesDirectly();\n  }\n  saveResolvedLocalsInData();\n}\n\n/**\n * On first template pass, we match each node against available directive selectors and save\n * the resulting defs in the correct instantiation order for subsequent change detection runs\n * (so dependencies are always created before the directives that inject them).\n */\nfunction cacheMatchingDirectivesForNode(\n    tNode: TNode, tView: TView, localRefs: string[] | null): void {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in tsickle.\n  const exportsMap: ({[key: string]: number} | null) = localRefs ? {'': -1} : null;\n  const matches = tView.currentMatches = findDirectiveMatches(tNode);\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDefInternal<any>;\n      const valueIndex = i + 1;\n      resolveDirective(def, valueIndex, matches, tView);\n      saveNameToExportMap(matches[valueIndex] as number, def, exportsMap);\n    }\n  }\n  if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n}\n\n/** Matches the current node against all available selectors. */\nfunction findDirectiveMatches(tNode: TNode): CurrentMatchesList|null {\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(tNode, def.selectors !)) {\n        if ((def as ComponentDefInternal<any>).template) {\n          if (tNode.flags & TNodeFlags.isComponent) throwMultipleComponentError(tNode);\n          tNode.flags = TNodeFlags.isComponent;\n        }\n        if (def.diPublic) def.diPublic(def);\n        (matches || (matches = [])).push(def, null);\n      }\n    }\n  }\n  return matches as CurrentMatchesList;\n}\n\nexport function resolveDirective(\n    def: DirectiveDefInternal<any>, valueIndex: number, matches: CurrentMatchesList,\n    tView: TView): any {\n  if (matches[valueIndex] === null) {\n    matches[valueIndex] = CIRCULAR;\n    const instance = def.factory();\n    (tView.directives || (tView.directives = [])).push(def);\n    return directiveCreate(matches[valueIndex] = tView.directives !.length - 1, instance, def);\n  } else if (matches[valueIndex] === CIRCULAR) {\n    // If we revisit this directive before it's resolved, we know it's circular\n    throwCyclicDependencyError(def.type);\n  }\n  return null;\n}\n\n/** Stores index of component's host element so it will be queued for view refresh during CD. */\nfunction queueComponentIndexForCheck(dirIndex: number): void {\n  if (firstTemplatePass) {\n    (tView.components || (tView.components = [])).push(dirIndex, viewData.length - 1);\n  }\n}\n\n/** Stores index of directive and host element so it will be queued for binding refresh during CD.\n */\nfunction queueHostBindingForCheck(dirIndex: number): void {\n  // Must subtract the header offset because hostBindings functions are generated with\n  // instructions that expect element indices that are NOT adjusted (e.g. elementProperty).\n  ngDevMode &&\n      assertEqual(firstTemplatePass, true, 'Should only be called in first template pass.');\n  (tView.hostBindings || (tView.hostBindings = [\n   ])).push(dirIndex, viewData.length - 1 - HEADER_OFFSET);\n}\n\n/** Sets the context for a ChangeDetectorRef to the given instance. */\nexport function initChangeDetectorIfExisting(\n    injector: LInjector | null, instance: any, view: LViewData): void {\n  if (injector && injector.changeDetectorRef != null) {\n    (injector.changeDetectorRef as ViewRef<any>)._setComponentContext(view, instance);\n  }\n}\n\nexport function isComponent(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponent) === TNodeFlags.isComponent;\n}\n\n/**\n * This function instantiates the given directives.\n */\nfunction instantiateDirectivesDirectly() {\n  const tNode = previousOrParentNode.tNode;\n  const count = tNode.flags & TNodeFlags.DirectiveCountMask;\n\n  if (count > 0) {\n    const start = tNode.flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const tDirectives = tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const def: DirectiveDefInternal<any> = tDirectives[i];\n      directiveCreate(i, def.factory(), def);\n    }\n  }\n}\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames = [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n * Builds up an export map as directives are created, so local refs can be quickly mapped\n * to their directive instances.\n */\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDefInternal<any>| ComponentDefInternal<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) exportsMap[def.exportAs] = index;\n    if ((def as ComponentDefInternal<any>).template) exportsMap[''] = index;\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LViewData in the same order as they are loaded in the template with load().\n */\nfunction saveResolvedLocalsInData(): void {\n  const localNames = previousOrParentNode.tNode.localNames;\n  if (localNames) {\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ? previousOrParentNode.native : directives ![index];\n      viewData.push(value);\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param template The template from which to get static data\n * @param directives Directive defs that should be saved on TView\n * @param pipes Pipe defs that should be saved on TView\n * @returns TView\n */\nfunction getOrCreateTView(\n    template: ComponentTemplate<any>, directives: DirectiveDefListOrFactory | null,\n    pipes: PipeDefListOrFactory | null, viewQuery: ComponentQuery<any>| null): TView {\n  // TODO(misko): reading `ngPrivateData` here is problematic for two reasons\n  // 1. It is a megamorphic call on each invocation.\n  // 2. For nested embedded views (ngFor inside ngFor) the template instance is per\n  //    outer template invocation, which means that no such property will exist\n  // Correct solution is to only put `ngPrivateData` on the Component template\n  // and not on embedded templates.\n\n  return template.ngPrivateData ||\n      (template.ngPrivateData = createTView(-1, template, directives, pipes, viewQuery) as never);\n}\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n */\nexport function createTView(\n    viewIndex: number, template: ComponentTemplate<any>| null,\n    directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ComponentQuery<any>| null): TView {\n  ngDevMode && ngDevMode.tView++;\n  return {\n    id: viewIndex,\n    template: template,\n    viewQuery: viewQuery,\n    node: null !,\n    data: HEADER_FILLER.slice(),  // Fill in to match HEADER_OFFSET in LViewData\n    childIndex: -1,               // Children set in addToViewTree(), if any\n    bindingStartIndex: -1,        // Set in initBindings()\n    directives: null,\n    firstTemplatePass: true,\n    initHooks: null,\n    checkHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    pipeDestroyHooks: null,\n    cleanup: null,\n    hostBindings: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === 'function' ? directives() : directives,\n    pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n    currentMatches: null\n  };\n}\n\nfunction setUpAttributes(native: RElement, attrs: TAttributes): void {\n  const isProc = isProceduralRenderer(renderer);\n  let i = 0;\n\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === NG_PROJECT_AS_ATTR_NAME) {\n      i += 2;\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (attrName === AttributeMarker.NamespaceURI) {\n        // Namespaced attributes\n        const namespaceURI = attrs[i + 1] as string;\n        const attrName = attrs[i + 2] as string;\n        const attrVal = attrs[i + 3] as string;\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName, attrVal, namespaceURI) :\n            native.setAttributeNS(namespaceURI, attrName, attrVal);\n        i += 4;\n      } else {\n        // Standard attributes\n        const attrVal = attrs[i + 1];\n        isProc ?\n            (renderer as ProceduralRenderer3)\n                .setAttribute(native, attrName as string, attrVal as string) :\n            native.setAttribute(attrName as string, attrVal as string);\n        i += 2;\n      }\n    }\n  }\n}\n\nexport function createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringify(token)}]`);\n}\n\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param elementOrSelector Render element or CSS selector to locate the element.\n */\nexport function locateHostElement(\n    factory: RendererFactory3, elementOrSelector: RElement | string): RElement|null {\n  ngDevMode && assertDataInRange(-1);\n  rendererFactory = factory;\n  const defaultRenderer = factory.createRenderer(null, null);\n  const rNode = typeof elementOrSelector === 'string' ?\n      (isProceduralRenderer(defaultRenderer) ?\n           defaultRenderer.selectRootElement(elementOrSelector) :\n           defaultRenderer.querySelector(elementOrSelector)) :\n      elementOrSelector;\n  if (ngDevMode && !rNode) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n  return rNode;\n}\n\n/**\n * Creates the host LNode.\n *\n * @param rNode Render host element.\n * @param def ComponentDef\n *\n * @returns LElementNode created\n */\nexport function hostElement(\n    tag: string, rNode: RElement | null, def: ComponentDefInternal<any>,\n    sanitizer?: Sanitizer | null): LElementNode {\n  resetApplicationState();\n  const node = createLNode(\n      0, TNodeType.Element, rNode, null, null,\n      createLViewData(\n          renderer, getOrCreateTView(def.template, def.directiveDefs, def.pipeDefs, def.viewQuery),\n          null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, sanitizer));\n\n  if (firstTemplatePass) {\n    node.tNode.flags = TNodeFlags.isComponent;\n    if (def.diPublic) def.diPublic(def);\n    tView.directives = [def];\n  }\n\n  return node;\n}\n\n\n/**\n * Adds an event listener to the current node.\n *\n * If an output exists on one of the node's directives, it also subscribes to the output\n * and saves the subscription for later cleanup.\n *\n * @param eventName Name of the event\n * @param listenerFn The function to be called when event emits\n * @param useCapture Whether or not to use capture in event listener.\n */\nexport function listener(\n    eventName: string, listenerFn: (e?: any) => any, useCapture = false): void {\n  ngDevMode && assertPreviousIsParent();\n  const node = previousOrParentNode;\n  const native = node.native as RElement;\n  ngDevMode && ngDevMode.rendererAddEventListener++;\n\n  // In order to match current behavior, native DOM event listeners must be added for all\n  // events (including outputs).\n  if (isProceduralRenderer(renderer)) {\n    const wrappedListener = wrapListenerWithDirtyLogic(viewData, listenerFn);\n    const cleanupFn = renderer.listen(native, eventName, wrappedListener);\n    storeCleanupFn(viewData, cleanupFn);\n  } else {\n    const wrappedListener = wrapListenerWithDirtyAndDefault(viewData, listenerFn);\n    native.addEventListener(eventName, wrappedListener, useCapture);\n    const cleanupInstances = getCleanup(viewData);\n    cleanupInstances.push(wrappedListener);\n    if (firstTemplatePass) {\n      getTViewCleanup(viewData).push(\n          eventName, node.tNode.index, cleanupInstances !.length - 1, useCapture);\n    }\n  }\n\n  let tNode: TNode|null = node.tNode;\n  if (tNode.outputs === undefined) {\n    // if we create TNode here, inputs must be undefined so we know they still need to be\n    // checked\n    tNode.outputs = generatePropertyAliases(node.tNode.flags, BindingDirection.Output);\n  }\n\n  const outputs = tNode.outputs;\n  let outputData: PropertyAliasValue|undefined;\n  if (outputs && (outputData = outputs[eventName])) {\n    createOutput(outputData, listenerFn);\n  }\n}\n\n/**\n * Iterates through the outputs associated with a particular event name and subscribes to\n * each output.\n */\nfunction createOutput(outputs: PropertyAliasValue, listener: Function): void {\n  for (let i = 0; i < outputs.length; i += 2) {\n    ngDevMode && assertDataInRange(outputs[i] as number, directives !);\n    const subscription = directives ![outputs[i] as number][outputs[i + 1]].subscribe(listener);\n    storeCleanupWithContext(viewData, subscription, subscription.unsubscribe);\n  }\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n    view: LViewData | null, context: any, cleanupFn: Function): void {\n  if (!view) view = viewData;\n  getCleanup(view).push(context);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(cleanupFn, view[CLEANUP] !.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(view: LViewData, cleanupFn: Function): void {\n  getCleanup(view).push(cleanupFn);\n\n  if (view[TVIEW].firstTemplatePass) {\n    getTViewCleanup(view).push(view[CLEANUP] !.length - 1, null);\n  }\n}\n\n/** Mark the end of the element. */\nexport function elementEnd() {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertHasParent();\n    previousOrParentNode = getParentLNode(previousOrParentNode) as LElementNode;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Element);\n  const queries = previousOrParentNode.queries;\n  queries && queries.addNode(previousOrParentNode);\n  queueLifecycleHooks(previousOrParentNode.tNode.flags, tView);\n  currentElementNode = null;\n}\n\n/**\n * Updates the value of removes an attribute on an Element.\n *\n * @param number index The index of the element in the data array\n * @param name name The name of the attribute.\n * @param value value The attribute is removed when value is `null` or `undefined`.\n *                  Otherwise the attribute value is set to the stringified value.\n * @param sanitizer An optional function used to sanitize the value.\n */\nexport function elementAttribute(\n    index: number, name: string, value: any, sanitizer?: SanitizerFn): void {\n  if (value !== NO_CHANGE) {\n    const element = loadElement(index);\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveAttribute++;\n      isProceduralRenderer(renderer) ? renderer.removeAttribute(element.native, name) :\n                                       element.native.removeAttribute(name);\n    } else {\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      const strValue = sanitizer == null ? stringify(value) : sanitizer(value);\n      isProceduralRenderer(renderer) ? renderer.setAttribute(element.native, name, strValue) :\n                                       element.native.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Update a property on an Element.\n *\n * If the property name also exists as an input property on one of the element's directives,\n * the component property will be set instead of the element property. This check must\n * be conducted at runtime so child components that add new @Inputs don't have to be re-compiled.\n *\n * @param index The index of the element to update in the data array\n * @param propName Name of property. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value New value to write.\n * @param sanitizer An optional function used to sanitize the value.\n */\n\nexport function elementProperty<T>(\n    index: number, propName: string, value: T | NO_CHANGE, sanitizer?: SanitizerFn): void {\n  if (value === NO_CHANGE) return;\n  const node = loadElement(index) as LElementNode;\n  const tNode = node.tNode;\n  // if tNode.inputs is undefined, a listener has created outputs, but inputs haven't\n  // yet been checked\n  if (tNode && tNode.inputs === undefined) {\n    // mark inputs as checked\n    tNode.inputs = generatePropertyAliases(node.tNode.flags, BindingDirection.Input);\n  }\n\n  const inputData = tNode && tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (inputData && (dataValue = inputData[propName])) {\n    setInputsForProperty(dataValue, value);\n    markDirtyIfOnPush(node);\n  } else {\n    // It is assumed that the sanitizer is only added when the compiler determines that the property\n    // is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value) as any) : value;\n    const native = node.native;\n    ngDevMode && ngDevMode.rendererSetProperty++;\n    isProceduralRenderer(renderer) ? renderer.setProperty(native, propName, value) :\n                                     (native.setProperty ? native.setProperty(propName, value) :\n                                                           (native as any)[propName] = value);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param parent The parent of this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    type: TNodeType, adjustedIndex: number, tagName: string | null, attrs: TAttributes | null,\n    parent: TElementNode | TContainerNode | null, tViews: TView[] | null): TNode {\n  ngDevMode && ngDevMode.tNode++;\n  return {\n    type: type,\n    index: adjustedIndex,\n    flags: 0,\n    tagName: tagName,\n    attrs: attrs,\n    localNames: null,\n    initialInputs: undefined,\n    inputs: undefined,\n    outputs: undefined,\n    tViews: tViews,\n    next: null,\n    child: null,\n    parent: parent,\n    dynamicContainerNode: null,\n    detached: null,\n    stylingTemplate: null,\n    projection: null\n  };\n}\n\n/**\n * Given a list of directive indices and minified input names, sets the\n * input properties on the corresponding directives.\n */\nfunction setInputsForProperty(inputs: PropertyAliasValue, value: any): void {\n  for (let i = 0; i < inputs.length; i += 2) {\n    ngDevMode && assertDataInRange(inputs[i] as number, directives !);\n    directives ![inputs[i] as number][inputs[i + 1]] = value;\n  }\n}\n\n/**\n * Consolidates all inputs or outputs of all directives on this logical node.\n *\n * @param number lNodeFlags logical node flags\n * @param Direction direction whether to consider inputs or outputs\n * @returns PropertyAliases|null aggregate of all properties if any, `null` otherwise\n */\nfunction generatePropertyAliases(\n    tNodeFlags: TNodeFlags, direction: BindingDirection): PropertyAliases|null {\n  const count = tNodeFlags & TNodeFlags.DirectiveCountMask;\n  let propStore: PropertyAliases|null = null;\n\n  if (count > 0) {\n    const start = tNodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n    const end = start + count;\n    const isInput = direction === BindingDirection.Input;\n    const defs = tView.directives !;\n\n    for (let i = start; i < end; i++) {\n      const directiveDef = defs[i] as DirectiveDefInternal<any>;\n      const propertyAliasMap: {[publicName: string]: string} =\n          isInput ? directiveDef.inputs : directiveDef.outputs;\n      for (let publicName in propertyAliasMap) {\n        if (propertyAliasMap.hasOwnProperty(publicName)) {\n          propStore = propStore || {};\n          const internalName = propertyAliasMap[publicName];\n          const hasProperty = propStore.hasOwnProperty(publicName);\n          hasProperty ? propStore[publicName].push(i, internalName) :\n                        (propStore[publicName] = [i, internalName]);\n        }\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Add or remove a class in a `classList` on a DOM element.\n *\n * This instruction is meant to handle the [class.foo]=\"exp\" case\n *\n * @param index The index of the element to update in the data array\n * @param className Name of class to toggle. Because it is going to DOM, this is not subject to\n *        renaming as part of minification.\n * @param value A value indicating if a given class should be added or removed.\n */\nexport function elementClassProp<T>(\n    index: number, stylingIndex: number, value: T | NO_CHANGE): void {\n  updateElementClassProp(getStylingContext(index), stylingIndex, value ? true : false);\n}\n\n/**\n * Assign any inline style values to the element during creation mode.\n *\n * This instruction is meant to be called during creation mode to apply all styling\n * (e.g. `style=\"...\"`) values to the element. This is also where the provided index\n * value is allocated for the styling details for its corresponding element (the element\n * index is the previous index value from this one).\n *\n * (Note this function calls `elementStylingApply` immediately when called.)\n *\n *\n * @param index Index value which will be allocated to store styling data for the element.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classDeclarations A key/value array of CSS classes that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any classes placed on the element by multiple (`[class]`) or singular (`[class.named]`)\n *   bindings. If a class binding changes its value to a falsy value then the matching initial\n *   class value that are passed in here will be applied to the element (if matched).\n * @param styleDeclarations A key/value array of CSS styles that will be registered on the element.\n *   Each individual style will be used on the element as long as it is not overridden\n *   by any styles placed on the element by multiple (`[style]`) or singular (`[style.prop]`)\n *   bindings. If a style binding changes its value to null then the initial styling\n *   values that are passed in here will be applied to the element (if matched).\n * @param styleSanitizer An optional sanitizer function that will be used (if provided)\n *   to sanitize the any CSS property values that are applied to the element (during rendering).\n */\nexport function elementStyling<T>(\n    classDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleDeclarations?: (string | boolean | InitialStylingFlags)[] | null,\n    styleSanitizer?: StyleSanitizeFn | null): void {\n  const lElement = currentElementNode !;\n  const tNode = lElement.tNode;\n  if (!tNode.stylingTemplate) {\n    // initialize the styling template.\n    tNode.stylingTemplate =\n        createStylingContextTemplate(classDeclarations, styleDeclarations, styleSanitizer);\n  }\n  if (styleDeclarations && styleDeclarations.length ||\n      classDeclarations && classDeclarations.length) {\n    elementStylingApply(tNode.index - HEADER_OFFSET);\n  }\n}\n\n/**\n * Retrieve the `StylingContext` at a given index.\n *\n * This method lazily creates the `StylingContext`. This is because in most cases\n * we have styling without any bindings. Creating `StylingContext` eagerly would mean that\n * every style declaration such as `<div style=\"color: red\">` would result `StyleContext`\n * which would create unnecessary memory pressure.\n *\n * @param index Index of the style allocation. See: `elementStyling`.\n */\nfunction getStylingContext(index: number): StylingContext {\n  let stylingContext = load<StylingContext>(index);\n  if (!Array.isArray(stylingContext)) {\n    const lElement = stylingContext as any as LElementNode;\n    const tNode = lElement.tNode;\n    ngDevMode &&\n        assertDefined(tNode.stylingTemplate, 'getStylingContext() called before elementStyling()');\n    stylingContext = viewData[index + HEADER_OFFSET] =\n        allocStylingContext(lElement, tNode.stylingTemplate !);\n  }\n  return stylingContext;\n}\n\n/**\n * Apply all styling values to the element which have been queued by any styling instructions.\n *\n * This instruction is meant to be run once one or more `elementStyle` and/or `elementStyleProp`\n * have been issued against the element. This function will also determine if any styles have\n * changed and will then skip the operation if there is nothing new to render.\n *\n * Once called then all queued styles will be flushed.\n *\n * @param index Index of the element's styling storage that will be rendered.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n */\nexport function elementStylingApply<T>(index: number): void {\n  renderElementStyles(getStylingContext(index), renderer);\n}\n\n/**\n * Queue a given style to be rendered on an Element.\n *\n * If the style value is `null` then it will be removed from the element\n * (or assigned a different value depending if there are any styles placed\n * on the element with `elementStyle` or any styles that are present\n * from when the element was created (with `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param styleIndex Index of the style property on this element. (Monotonically increasing.)\n * @param styleName Name of property. Because it is going to DOM this is not subject to\n *        renaming as part of minification.\n * @param value New value to write (null to remove).\n * @param suffix Optional suffix. Used with scalar values to add unit such as `px`.\n *        Note that when a suffix is provided then the underlying sanitizer will\n *        be ignored.\n */\nexport function elementStyleProp<T>(\n    index: number, styleIndex: number, value: T | null, suffix?: string): void {\n  let valueToAdd: string|null = null;\n  if (value) {\n    if (suffix) {\n      // when a suffix is applied then it will bypass\n      // sanitization entirely (b/c a new string is created)\n      valueToAdd = stringify(value) + suffix;\n    } else {\n      // sanitization happens by dealing with a String value\n      // this means that the string value will be passed through\n      // into the style rendering later (which is where the value\n      // will be sanitized before it is applied)\n      valueToAdd = value as any as string;\n    }\n  }\n  updateElementStyleProp(getStylingContext(index), styleIndex, valueToAdd);\n}\n\n/**\n * Queue a key/value map of styles to be rendered on an Element.\n *\n * This instruction is meant to handle the `[style]=\"exp\"` usage. When styles are applied to\n * the Element they will then be placed with respect to any styles set with `elementStyleProp`.\n * If any styles are set to `null` then they will be removed from the element (unless the same\n * style properties have been assigned to the element during creation using `elementStyling`).\n *\n * (Note that the styling instruction will not be applied until `elementStylingApply` is called.)\n *\n * @param index Index of the element's styling storage to change in the data array.\n *        (Note that this is not the element index, but rather an index value allocated\n *        specifically for element styling--the index must be the next index after the element\n *        index.)\n * @param classes A key/value style map of CSS classes that will be added to the given element.\n *        Any missing classes (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's list of CSS classes.\n * @param styles A key/value style map of the styles that will be applied to the given element.\n *        Any missing styles (that have already been applied to the element beforehand) will be\n *        removed (unset) from the element's styling.\n */\nexport function elementStylingMap<T>(\n    index: number, classes: {[key: string]: any} | string | null,\n    styles?: {[styleName: string]: any} | null): void {\n  updateStylingMap(getStylingContext(index), classes, styles);\n}\n\n//////////////////////////\n//// Text\n//////////////////////////\n\n/**\n * Create static text node\n *\n * @param index Index of the node in the data array\n * @param value Value to write. This value will be stringified.\n */\nexport function text(index: number, value?: any): void {\n  ngDevMode &&\n      assertEqual(viewData[BINDING_INDEX], -1, 'text nodes should be created before bindings');\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  const textNode = createTextNode(value, renderer);\n  const node = createLNode(index, TNodeType.Element, textNode, null, null);\n\n  // Text nodes are self closing.\n  isParent = false;\n  appendChild(getParentLNode(node), textNode, viewData);\n}\n\n/**\n * Create text node with binding\n * Bindings should be handled externally with the proper interpolation(1-8) method\n *\n * @param index Index of the node in the data array.\n * @param value Stringified value to write.\n */\nexport function textBinding<T>(index: number, value: T | NO_CHANGE): void {\n  if (value !== NO_CHANGE) {\n    ngDevMode && assertDataInRange(index + HEADER_OFFSET);\n    const existingNode = loadElement(index) as any as LTextNode;\n    ngDevMode && assertDefined(existingNode, 'LNode should exist');\n    ngDevMode && assertDefined(existingNode.native, 'native element should exist');\n    ngDevMode && ngDevMode.rendererSetText++;\n    isProceduralRenderer(renderer) ? renderer.setValue(existingNode.native, stringify(value)) :\n                                     existingNode.native.textContent = stringify(value);\n  }\n}\n\n//////////////////////////\n//// Directive\n//////////////////////////\n\n/**\n * Create a directive and their associated content queries.\n *\n * NOTE: directives can be created in order other than the index order. They can also\n *       be retrieved before they are created in which case the value will be null.\n *\n * @param directive The directive instance.\n * @param directiveDef DirectiveDef object which contains information about the template.\n */\nexport function directiveCreate<T>(\n    directiveDefIdx: number, directive: T,\n    directiveDef: DirectiveDefInternal<T>| ComponentDefInternal<T>): T {\n  const instance = baseDirectiveCreate(directiveDefIdx, directive, directiveDef);\n\n  ngDevMode && assertDefined(previousOrParentNode.tNode, 'previousOrParentNode.tNode');\n  const tNode = previousOrParentNode.tNode;\n\n  const isComponent = (directiveDef as ComponentDefInternal<T>).template;\n  if (isComponent) {\n    addComponentLogic(directiveDefIdx, directive, directiveDef as ComponentDefInternal<T>);\n  }\n\n  if (firstTemplatePass) {\n    // Init hooks are queued now so ngOnInit is called in host components before\n    // any projected components.\n    queueInitHooks(directiveDefIdx, directiveDef.onInit, directiveDef.doCheck, tView);\n\n    if (directiveDef.hostBindings) queueHostBindingForCheck(directiveDefIdx);\n  }\n\n  if (tNode && tNode.attrs) {\n    setInputsFromAttrs(directiveDefIdx, instance, directiveDef.inputs, tNode);\n  }\n\n  if (directiveDef.contentQueries) {\n    directiveDef.contentQueries();\n  }\n\n  return instance;\n}\n\nfunction addComponentLogic<T>(\n    directiveIndex: number, instance: T, def: ComponentDefInternal<T>): void {\n  const tView = getOrCreateTView(def.template, def.directiveDefs, def.pipeDefs, def.viewQuery);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const componentView = addToViewTree(\n      viewData, previousOrParentNode.tNode.index as number,\n      createLViewData(\n          rendererFactory.createRenderer(previousOrParentNode.native as RElement, def.rendererType),\n          tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways,\n          getCurrentSanitizer()));\n\n  // We need to set the host node/data here because when the component LNode was created,\n  // we didn't yet know it was a component (just an element).\n  (previousOrParentNode as{data: LViewData}).data = componentView;\n  (componentView as LViewData)[HOST_NODE] = previousOrParentNode as LElementNode;\n\n  initChangeDetectorIfExisting(previousOrParentNode.nodeInjector, instance, componentView);\n\n  if (firstTemplatePass) queueComponentIndexForCheck(directiveIndex);\n}\n\n/**\n * A lighter version of directiveCreate() that is used for the root component\n *\n * This version does not contain features that we don't already support at root in\n * current Angular. Example: local refs and inputs on root component.\n */\nexport function baseDirectiveCreate<T>(\n    index: number, directive: T,\n    directiveDef: DirectiveDefInternal<T>| ComponentDefInternal<T>): T {\n  ngDevMode &&\n      assertEqual(viewData[BINDING_INDEX], -1, 'directives should be created before any bindings');\n  ngDevMode && assertPreviousIsParent();\n\n  Object.defineProperty(\n      directive, NG_HOST_SYMBOL, {enumerable: false, value: previousOrParentNode});\n\n  if (directives == null) viewData[DIRECTIVES] = directives = [];\n\n  ngDevMode && assertDataNext(index, directives);\n  directives[index] = directive;\n\n  if (firstTemplatePass) {\n    const flags = previousOrParentNode.tNode.flags;\n    if ((flags & TNodeFlags.DirectiveCountMask) === 0) {\n      // When the first directive is created:\n      // - save the index,\n      // - set the number of directives to 1\n      previousOrParentNode.tNode.flags =\n          index << TNodeFlags.DirectiveStartingIndexShift | flags & TNodeFlags.isComponent | 1;\n    } else {\n      // Only need to bump the size when subsequent directives are created\n      ngDevMode && assertNotEqual(\n                       flags & TNodeFlags.DirectiveCountMask, TNodeFlags.DirectiveCountMask,\n                       'Reached the max number of directives');\n      previousOrParentNode.tNode.flags++;\n    }\n  } else {\n    const diPublic = directiveDef !.diPublic;\n    if (diPublic) diPublic(directiveDef !);\n  }\n\n  if (directiveDef !.attributes != null && previousOrParentNode.tNode.type == TNodeType.Element) {\n    setUpAttributes(\n        (previousOrParentNode as LElementNode).native, directiveDef !.attributes as string[]);\n  }\n\n  return directive;\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    directiveIndex: number, instance: T, inputs: {[P in keyof T]: string;}, tNode: TNode): void {\n  let initialInputData = tNode.initialInputs as InitialInputData | undefined;\n  if (initialInputData === undefined || directiveIndex >= initialInputData.length) {\n    initialInputData = generateInitialInputs(directiveIndex, inputs, tNode);\n  }\n\n  const initialInputs: InitialInputs|null = initialInputData[directiveIndex];\n  if (initialInputs) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      (instance as any)[initialInputs[i]] = initialInputs[i + 1];\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param directiveIndex Index to store the initial input data\n * @param inputs The list of inputs from the directive def\n * @param tNode The static data on this node\n */\nfunction generateInitialInputs(\n    directiveIndex: number, inputs: {[key: string]: string}, tNode: TNode): InitialInputData {\n  const initialInputData: InitialInputData = tNode.initialInputs || (tNode.initialInputs = []);\n  initialInputData[directiveIndex] = null;\n\n  const attrs = tNode.attrs !;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.SelectOnly) break;\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    }\n    const minifiedInputName = inputs[attrName];\n    const attrValue = attrs[i + 1];\n\n    if (minifiedInputName !== undefined) {\n      const inputsToStore: InitialInputs =\n          initialInputData[directiveIndex] || (initialInputData[directiveIndex] = []);\n      inputsToStore.push(minifiedInputName, attrValue as string);\n    }\n\n    i += 2;\n  }\n  return initialInputData;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param parentLNode the LNode in which the container's content will be rendered\n * @param currentView The parent view of the LContainer\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    parentLNode: LNode, currentView: LViewData, isForViewContainerRef?: boolean): LContainer {\n  ngDevMode && assertDefined(parentLNode, 'containers should have a parent');\n  let renderParent = canInsertNativeNode(parentLNode, currentView) ?\n      parentLNode as LElementNode | LViewNode :\n      null;\n  if (renderParent && renderParent.tNode.type === TNodeType.View) {\n    renderParent = getParentLNode(renderParent as LViewNode) !.data[RENDER_PARENT];\n  }\n  return [\n    isForViewContainerRef ? null : 0,  // active index\n    currentView,                       // parent\n    null,                              // next\n    null,                              // queries\n    [],                                // views\n    renderParent as LElementNode\n  ];\n}\n\n/**\n * Creates an LContainerNode.\n *\n * Only `LViewNodes` can go into `LContainerNodes`.\n *\n * @param index The index of the container in the data array\n * @param template Optional inline template\n * @param tagName The name of the container element, if applicable\n * @param attrs The attrs attached to the container, if applicable\n * @param localRefs A set of local reference bindings on the element.\n */\nexport function container(\n    index: number, template?: ComponentTemplate<any>, tagName?: string | null, attrs?: TAttributes,\n    localRefs?: string[] | null): void {\n  ngDevMode &&\n      assertEqual(\n          viewData[BINDING_INDEX], -1, 'container nodes should be created before any bindings');\n\n  const currentParent = isParent ? previousOrParentNode : getParentLNode(previousOrParentNode) !;\n  const lContainer = createLContainer(currentParent, viewData);\n\n  const comment = renderer.createComment(ngDevMode ? 'container' : '');\n  const node =\n      createLNode(index, TNodeType.Container, comment, tagName || null, attrs || null, lContainer);\n  appendChild(getParentLNode(node), comment, viewData);\n\n  if (firstTemplatePass) {\n    node.tNode.tViews = template ?\n        createTView(-1, template, tView.directiveRegistry, tView.pipeRegistry, null) :\n        [];\n  }\n\n  // Containers are added to the current view tree instead of their embedded views\n  // because views can be removed and re-inserted.\n  addToViewTree(viewData, index + HEADER_OFFSET, node.data);\n\n  const queries = node.queries;\n  if (queries) {\n    // prepare place for matching nodes from views inserted into a given container\n    lContainer[QUERIES] = queries.container();\n  }\n\n  createDirectivesAndLocals(localRefs);\n\n  isParent = false;\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  queries && queries.addNode(node);  // check if a given container node matches\n  queueLifecycleHooks(node.tNode.flags, tView);\n}\n\n/**\n * Sets a container up to receive views.\n *\n * @param index The index of the container in the data array\n */\nexport function containerRefreshStart(index: number): void {\n  previousOrParentNode = loadElement(index) as LNode;\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  isParent = true;\n  (previousOrParentNode as LContainerNode).data[ACTIVE_INDEX] = 0;\n\n  if (!checkNoChangesMode) {\n    // We need to execute init hooks here so ngOnInit hooks are called in top level views\n    // before they are called in embedded views (for backwards compatibility).\n    executeInitHooks(viewData, tView, creationMode);\n  }\n}\n\n/**\n * Marks the end of the LContainerNode.\n *\n * Marking the end of LContainerNode is the time when to child Views get inserted or removed.\n */\nexport function containerRefreshEnd(): void {\n  if (isParent) {\n    isParent = false;\n  } else {\n    ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n    ngDevMode && assertHasParent();\n    previousOrParentNode = getParentLNode(previousOrParentNode) !;\n  }\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.Container);\n  const container = previousOrParentNode as LContainerNode;\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  const nextIndex = container.data[ACTIVE_INDEX] !;\n\n  // remove extra views at the end of the container\n  while (nextIndex < container.data[VIEWS].length) {\n    removeView(container, nextIndex);\n  }\n}\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes them\n * by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lViewData: LViewData) {\n  for (let current = getLViewChild(lViewData); current !== null; current = current[NEXT]) {\n    // Note: current can be an LViewData or an LContainer instance, but here we are only interested\n    // in LContainer. We can tell it's an LContainer because its length is less than the LViewData\n    // header.\n    if (current.length < HEADER_OFFSET && current[ACTIVE_INDEX] === null) {\n      const container = current as LContainer;\n      for (let i = 0; i < container[VIEWS].length; i++) {\n        const lViewNode = container[VIEWS][i];\n        // The directives and pipes are not needed here as an existing view is only being refreshed.\n        const dynamicViewData = lViewNode.data;\n        ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');\n        renderEmbeddedTemplate(\n            lViewNode, dynamicViewData[TVIEW], dynamicViewData[CONTEXT] !, RenderFlags.Update);\n      }\n    }\n  }\n}\n\n\n/**\n * Looks for a view with a given view block id inside a provided LContainer.\n * Removes views that need to be deleted in the process.\n *\n * @param containerNode where to search for views\n * @param startIdx starting index in the views array to search from\n * @param viewBlockId exact view block id to look for\n * @returns index of a found view or -1 if not found\n */\nfunction scanForView(\n    containerNode: LContainerNode, startIdx: number, viewBlockId: number): LViewNode|null {\n  const views = containerNode.data[VIEWS];\n  for (let i = startIdx; i < views.length; i++) {\n    const viewAtPositionId = views[i].data[TVIEW].id;\n    if (viewAtPositionId === viewBlockId) {\n      return views[i];\n    } else if (viewAtPositionId < viewBlockId) {\n      // found a view that should not be at this position - remove\n      removeView(containerNode, i);\n    } else {\n      // found a view with id greater than the one we are searching for\n      // which means that required view doesn't exist and can't be found at\n      // later positions in the views array - stop the search here\n      break;\n    }\n  }\n  return null;\n}\n\n/**\n * Marks the start of an embedded view.\n *\n * @param viewBlockId The ID of this view\n * @return boolean Whether or not this view is in creation mode\n */\nexport function embeddedViewStart(viewBlockId: number): RenderFlags {\n  const container =\n      (isParent ? previousOrParentNode : getParentLNode(previousOrParentNode)) as LContainerNode;\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  const lContainer = container.data;\n  let viewNode: LViewNode|null = scanForView(container, lContainer[ACTIVE_INDEX] !, viewBlockId);\n\n  if (viewNode) {\n    previousOrParentNode = viewNode;\n    ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n    isParent = true;\n    enterView(viewNode.data, viewNode);\n  } else {\n    // When we create a new LView, we always reset the state of the instructions.\n    const newView = createLViewData(\n        renderer, getOrCreateEmbeddedTView(viewBlockId, container), null, LViewFlags.CheckAlways,\n        getCurrentSanitizer());\n\n    if (lContainer[QUERIES]) {\n      newView[QUERIES] = lContainer[QUERIES] !.createView();\n    }\n\n    enterView(\n        newView, viewNode = createLNode(viewBlockId, TNodeType.View, null, null, null, newView));\n  }\n  if (container) {\n    if (creationMode) {\n      // it is a new view, insert it into collection of views for a given container\n      insertView(container, viewNode, lContainer[ACTIVE_INDEX] !);\n    }\n    lContainer[ACTIVE_INDEX] !++;\n  }\n  return getRenderFlags(viewNode.data);\n}\n\n/**\n * Initialize the TView (e.g. static data) for the active embedded view.\n *\n * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's\n * static data for a particular node would overwrite the static data for a node in the view above\n * it with the same index (since it's in the same template).\n *\n * @param viewIndex The index of the TView in TNode.tViews\n * @param parent The parent container in which to look for the view's static data\n * @returns TView\n */\nfunction getOrCreateEmbeddedTView(viewIndex: number, parent: LContainerNode): TView {\n  ngDevMode && assertNodeType(parent, TNodeType.Container);\n  const containerTViews = (parent !.tNode as TContainerNode).tViews as TView[];\n  ngDevMode && assertDefined(containerTViews, 'TView expected');\n  ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');\n  if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {\n    containerTViews[viewIndex] =\n        createTView(viewIndex, null, tView.directiveRegistry, tView.pipeRegistry, null);\n  }\n  return containerTViews[viewIndex];\n}\n\n/** Marks the end of an embedded view. */\nexport function embeddedViewEnd(): void {\n  refreshView();\n  isParent = false;\n  previousOrParentNode = viewData[HOST_NODE] as LViewNode;\n  leaveView(viewData[PARENT] !);\n  ngDevMode && assertEqual(isParent, false, 'isParent');\n  ngDevMode && assertNodeType(previousOrParentNode, TNodeType.View);\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param directiveIndex Directive index in LViewData[DIRECTIVES]\n * @param adjustedElementIndex  Element index in LViewData[] (adjusted for HEADER_OFFSET)\n */\nexport function componentRefresh<T>(directiveIndex: number, adjustedElementIndex: number): void {\n  ngDevMode && assertDataInRange(adjustedElementIndex);\n  const element = viewData[adjustedElementIndex] as LElementNode;\n  ngDevMode && assertNodeType(element, TNodeType.Element);\n  ngDevMode &&\n      assertDefined(element.data, `Component's host node should have an LViewData attached.`);\n  const hostView = element.data !;\n\n  // Only attached CheckAlways components or attached, dirty OnPush components should be checked\n  if (viewAttached(hostView) && hostView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    ngDevMode && assertDataInRange(directiveIndex, directives !);\n    detectChangesInternal(hostView, element, directives ![directiveIndex]);\n  }\n}\n\n/** Returns a boolean for whether the view is attached */\nexport function viewAttached(view: LViewData): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/**\n * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.\n * It takes all the selectors from the entire component's template and decides where\n * each projected node belongs (it re-distributes nodes among \"buckets\" where each \"bucket\" is\n * backed by a selector).\n *\n * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,\n * un-parsed form.\n *\n * The parsed form is needed for efficient matching of a node against a given CSS selector.\n * The un-parsed, textual form is needed for support of the ngProjectAs attribute.\n *\n * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more\n * drawbacks:\n * - having only a textual form would require runtime parsing of CSS selectors;\n * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a\n * template author).\n *\n * @param selectors A collection of parsed CSS selectors\n * @param rawSelectors A collection of CSS selectors in the raw, un-parsed form\n */\nexport function projectionDef(selectors?: CssSelectorList[], textSelectors?: string[]): void {\n  const componentNode: LElementNode = findComponentHost(viewData);\n\n  if (!componentNode.tNode.projection) {\n    const noOfNodeBuckets = selectors ? selectors.length + 1 : 1;\n    const pData: (TNode | null)[] = componentNode.tNode.projection =\n        new Array(noOfNodeBuckets).fill(null);\n    const tails: (TNode | null)[] = pData.slice();\n\n    let componentChild = componentNode.tNode.child;\n\n    while (componentChild !== null) {\n      const bucketIndex =\n          selectors ? matchingSelectorIndex(componentChild, selectors, textSelectors !) : 0;\n      const nextNode = componentChild.next;\n\n      if (tails[bucketIndex]) {\n        tails[bucketIndex] !.next = componentChild;\n      } else {\n        pData[bucketIndex] = componentChild;\n        componentChild.next = null;\n      }\n      tails[bucketIndex] = componentChild;\n\n      componentChild = nextNode;\n    }\n  }\n}\n\n/**\n * Stack used to keep track of projection nodes in projection() instruction.\n *\n * This is deliberately created outside of projection() to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: LProjectionNode[] = [];\n\n/**\n * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call\n * to the projectionDef instruction.\n *\n * @param nodeIndex\n * @param selectorIndex:\n *        - 0 when the selector is `*` (or unspecified as this is the default value),\n *        - 1 based index of the selector from the {@link projectionDef}\n */\nexport function projection(nodeIndex: number, selectorIndex: number = 0, attrs?: string[]): void {\n  const node = createLNode(nodeIndex, TNodeType.Projection, null, null, attrs || null, null);\n\n  // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.\n  if (node.tNode.projection === null) node.tNode.projection = selectorIndex;\n\n  // `<ng-content>` has no content\n  isParent = false;\n\n  // re-distribution of projectable nodes is stored on a component's view level\n  const parent = getParentLNode(node);\n\n  if (canInsertNativeNode(parent, viewData)) {\n    const componentNode = findComponentHost(viewData);\n    let nodeToProject = (componentNode.tNode.projection as(TNode | null)[])[selectorIndex];\n    let projectedView = componentNode.view;\n    let projectionNodeIndex = -1;\n    let grandparent: LContainerNode;\n    const renderParent = parent.tNode.type === TNodeType.View ?\n        (grandparent = getParentLNode(parent) as LContainerNode) &&\n            grandparent.data[RENDER_PARENT] ! :\n        parent as LElementNode;\n\n    while (nodeToProject) {\n      if (nodeToProject.type === TNodeType.Projection) {\n        // This node is re-projected, so we must go up the tree to get its projected nodes.\n        const currentComponentHost = findComponentHost(projectedView);\n        const firstProjectedNode = (currentComponentHost.tNode.projection as(\n            TNode | null)[])[nodeToProject.projection as number];\n\n        if (firstProjectedNode) {\n          projectionNodeStack[++projectionNodeIndex] = projectedView[nodeToProject.index];\n          nodeToProject = firstProjectedNode;\n          projectedView = currentComponentHost.view;\n          continue;\n        }\n      } else {\n        const lNode = projectedView[nodeToProject.index];\n        lNode.tNode.flags |= TNodeFlags.isProjected;\n        appendProjectedNode(\n            lNode as LTextNode | LElementNode | LContainerNode, parent, viewData, renderParent);\n      }\n\n      // If we are finished with a list of re-projected nodes, we need to get\n      // back to the root projection node that was re-projected.\n      if (nodeToProject.next === null && projectedView !== componentNode.view) {\n        // move down into the view of the component we're projecting right now\n        const lNode = projectionNodeStack[projectionNodeIndex--];\n        nodeToProject = lNode.tNode;\n        projectedView = lNode.view;\n      }\n      nodeToProject = nodeToProject.next;\n    }\n  }\n}\n\n/**\n * Adds LViewData or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param currentView The view where LViewData or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LViewData[], adjusted for header\n * @param state The LViewData or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LViewData|LContainer>(\n    currentView: LViewData, adjustedHostIndex: number, state: T): T {\n  if (currentView[TAIL]) {\n    currentView[TAIL] ![NEXT] = state;\n  } else if (firstTemplatePass) {\n    tView.childIndex = adjustedHostIndex;\n  }\n  currentView[TAIL] = state;\n  return state;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n/** If node is an OnPush component, marks its LViewData dirty. */\nexport function markDirtyIfOnPush(node: LElementNode): void {\n  // Because data flows down the component tree, ancestors do not need to be marked dirty\n  if (node.data && !(node.data[FLAGS] & LViewFlags.CheckAlways)) {\n    node.data[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Necessary to support OnPush components.\n */\nexport function wrapListenerWithDirtyLogic(\n    view: LViewData, listenerFn: (e?: any) => any): (e: Event) => any {\n  return function(e: any) {\n    markViewDirty(view);\n    return listenerFn(e);\n  };\n}\n\n/**\n * Wraps an event listener so its host view and its ancestor views will be marked dirty\n * whenever the event fires. Also wraps with preventDefault behavior.\n */\nexport function wrapListenerWithDirtyAndDefault(\n    view: LViewData, listenerFn: (e?: any) => any): EventListener {\n  return function wrapListenerIn_markViewDirty(e: Event) {\n    markViewDirty(view);\n    if (listenerFn(e) === false) {\n      e.preventDefault();\n      // Necessary for legacy browsers that don't support preventDefault (e.g. IE)\n      e.returnValue = false;\n    }\n  };\n}\n\n/** Marks current view and all ancestors dirty */\nexport function markViewDirty(view: LViewData): void {\n  let currentView: LViewData = view;\n\n  while (currentView[PARENT] != null) {\n    currentView[FLAGS] |= LViewFlags.Dirty;\n    currentView = currentView[PARENT] !;\n  }\n  currentView[FLAGS] |= LViewFlags.Dirty;\n  ngDevMode && assertDefined(currentView[CONTEXT], 'rootContext');\n  scheduleTick(currentView[CONTEXT] as RootContext);\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick<T>(rootContext: RootContext) {\n  if (rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      tickRootContext(rootContext);\n      res !(null);\n      rootContext.clean = _CLEAN_PROMISE;\n    });\n  }\n}\n\n/**\n * Used to perform change detection on the whole application.\n *\n * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`\n * executes lifecycle hooks and conditionally checks components based on their\n * `ChangeDetectionStrategy` and dirtiness.\n *\n * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally\n * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a\n * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can\n * be changed when calling `renderComponent` and providing the `scheduler` option.\n */\nexport function tick<T>(component: T): void {\n  const rootView = getRootView(component);\n  const rootContext = rootView[CONTEXT] as RootContext;\n  tickRootContext(rootContext);\n}\n\nfunction tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const hostNode = _getComponentHostLElementNode(rootComponent);\n\n    ngDevMode && assertDefined(hostNode.data, 'Component host node should be attached to an LView');\n    renderComponentOrTemplate(hostNode, getRootView(rootComponent), rootComponent);\n  }\n}\n\n/**\n * Retrieve the root view from any component by walking the parent `LViewData` until\n * reaching the root `LViewData`.\n *\n * @param component any component\n */\n\nexport function getRootView(component: any): LViewData {\n  ngDevMode && assertDefined(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  let lViewData = lElementNode.view;\n  while (lViewData[PARENT]) {\n    lViewData = lViewData[PARENT] !;\n  }\n  return lViewData;\n}\n\n/**\n * Synchronously perform change detection on a component (and possibly its sub-components).\n *\n * This function triggers change detection in a synchronous way on a component. There should\n * be very little reason to call this function directly since a preferred way to do change\n * detection is to {@link markDirty} the component and wait for the scheduler to call this method\n * at some future point in time. This is because a single user action often results in many\n * components being invalidated and calling change detection on each component synchronously\n * would be inefficient. It is better to wait until all components are marked as dirty and\n * then perform single change detection across all of the components\n *\n * @param component The component which the change detection should be performed on.\n */\nexport function detectChanges<T>(component: T): void {\n  const hostNode = _getComponentHostLElementNode(component);\n  ngDevMode &&\n      assertDefined(\n          hostNode.data, 'Component host node should be attached to an LViewData instance.');\n  detectChangesInternal(hostNode.data as LViewData, hostNode, component);\n}\n\n\n/**\n * Checks the change detector and its children, and throws if any changes are detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n */\nexport function checkNoChanges<T>(component: T): void {\n  checkNoChangesMode = true;\n  try {\n    detectChanges(component);\n  } finally {\n    checkNoChangesMode = false;\n  }\n}\n\n/** Checks the view of the component provided. Does not gate on dirty checks or execute doCheck. */\nexport function detectChangesInternal<T>(\n    hostView: LViewData, hostNode: LElementNode, component: T) {\n  const oldView = enterView(hostView, hostNode);\n  const hostTView = hostView[TVIEW];\n  const template = hostTView.template !;\n  const viewQuery = hostTView.viewQuery;\n\n  try {\n    namespaceHTML();\n    createViewQuery(viewQuery, hostView[FLAGS], component);\n    template(getRenderFlags(hostView), component);\n    refreshView();\n    updateViewQuery(viewQuery, component);\n  } finally {\n    leaveView(oldView);\n  }\n}\n\nfunction createViewQuery<T>(\n    viewQuery: ComponentQuery<{}>| null, flags: LViewFlags, component: T): void {\n  if (viewQuery && (flags & LViewFlags.CreationMode)) {\n    viewQuery(RenderFlags.Create, component);\n  }\n}\n\nfunction updateViewQuery<T>(viewQuery: ComponentQuery<{}>| null, component: T): void {\n  if (viewQuery) {\n    viewQuery(RenderFlags.Update, component);\n  }\n}\n\n\n/**\n * Mark the component as dirty (needing change detection).\n *\n * Marking a component dirty will schedule a change detection on this\n * component at some point in the future. Marking an already dirty\n * component as dirty is a noop. Only one outstanding change detection\n * can be scheduled per component tree. (Two components bootstrapped with\n * separate `renderComponent` will have separate schedulers)\n *\n * When the root component is bootstrapped with `renderComponent`, a scheduler\n * can be provided.\n *\n * @param component Component to mark as dirty.\n */\nexport function markDirty<T>(component: T) {\n  ngDevMode && assertDefined(component, 'component');\n  const lElementNode = _getComponentHostLElementNode(component);\n  markViewDirty(lElementNode.view);\n}\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  brand: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE = {} as NO_CHANGE;\n\n/**\n *  Initializes the binding start index. Will get inlined.\n *\n *  This function must be called before any binding related function is called\n *  (ie `bind()`, `interpolationX()`, `pureFunctionX()`)\n */\nfunction initBindings() {\n  ngDevMode && assertEqual(\n                   viewData[BINDING_INDEX], -1,\n                   'Binding index should not yet be set ' + viewData[BINDING_INDEX]);\n  if (tView.bindingStartIndex === -1) {\n    tView.bindingStartIndex = viewData.length;\n  }\n  viewData[BINDING_INDEX] = tView.bindingStartIndex;\n}\n\n/**\n * Creates a single value binding.\n *\n * @param value Value to diff\n */\nexport function bind<T>(value: T): T|NO_CHANGE {\n  return bindingUpdated(value) ? value : NO_CHANGE;\n}\n\n/**\n * Reserves slots for pure functions (`pureFunctionX` instructions)\n *\n * Bindings for pure functions are stored after the LNodes in the data array but before the binding.\n *\n *  ----------------------------------------------------------------------------\n *  |  LNodes ... | pure function bindings | regular bindings / interpolations |\n *  ----------------------------------------------------------------------------\n *                                         ^\n *                                         TView.bindingStartIndex\n *\n * Pure function instructions are given an offset from TView.bindingStartIndex.\n * Subtracting the offset from TView.bindingStartIndex gives the first index where the bindings\n * are stored.\n *\n * NOTE: reserveSlots instructions are only ever allowed at the very end of the creation block\n */\nexport function reserveSlots(numSlots: number) {\n  // Init the slots with a unique `NO_CHANGE` value so that the first change is always detected\n  // whether it happens or not during the first change detection pass - pure functions checks\n  // might be skipped when short-circuited.\n  viewData.length += numSlots;\n  viewData.fill(NO_CHANGE, -numSlots);\n  // We need to initialize the binding in case a `pureFunctionX` kind of binding instruction is\n  // called first in the update section.\n  initBindings();\n}\n\n/**\n * Sets up the binding index before executing any `pureFunctionX` instructions.\n *\n * The index must be restored after the pure function is executed\n *\n * {@link reserveSlots}\n */\nexport function moveBindingIndexToReservedSlot(offset: number): number {\n  const currentSlot = viewData[BINDING_INDEX];\n  viewData[BINDING_INDEX] = tView.bindingStartIndex - offset;\n  return currentSlot;\n}\n\n/**\n * Restores the binding index to the given value.\n *\n * This function is typically used to restore the index after a `pureFunctionX` has\n * been executed.\n */\nexport function restoreBindingIndex(index: number): void {\n  viewData[BINDING_INDEX] = index;\n}\n\n/**\n * Create interpolation bindings with a variable number of expressions.\n *\n * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.\n * Those are faster because there is no need to create an array of expressions and iterate over it.\n *\n * `values`:\n * - has static text at even indexes,\n * - has evaluated expressions at odd indexes.\n *\n * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.\n */\nexport function interpolationV(values: any[]): string|NO_CHANGE {\n  ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');\n  ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');\n\n  let different = false;\n\n  for (let i = 1; i < values.length; i += 2) {\n    // Check if bindings (odd indexes) have changed\n    bindingUpdated(values[i]) && (different = true);\n  }\n\n  if (!different) {\n    return NO_CHANGE;\n  }\n\n  // Build the updated content\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += stringify(values[i]) + values[i + 1];\n  }\n\n  return content;\n}\n\n/**\n * Creates an interpolation binding with 1 expression.\n *\n * @param prefix static value used for concatenation only.\n * @param v0 value checked for change.\n * @param suffix static value used for concatenation only.\n */\nexport function interpolation1(prefix: string, v0: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated(v0);\n\n  return different ? prefix + stringify(v0) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 2 expressions. */\nexport function interpolation2(\n    prefix: string, v0: any, i0: string, v1: any, suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated2(v0, v1);\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + suffix : NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 3 expressions. */\nexport function interpolation3(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated2(v0, v1);\n  different = bindingUpdated(v2) || different;\n\n  return different ? prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + suffix :\n                     NO_CHANGE;\n}\n\n/** Create an interpolation binding with 4 expressions. */\nexport function interpolation4(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    suffix: string): string|NO_CHANGE {\n  const different = bindingUpdated4(v0, v1, v2, v3);\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) +\n          suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 5 expressions. */\nexport function interpolation5(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated(v4) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 6 expressions. */\nexport function interpolation6(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 7 expressions. */\nexport function interpolation7(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, suffix: string): string|\n    NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated2(v4, v5) || different;\n  different = bindingUpdated(v6) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + suffix :\n      NO_CHANGE;\n}\n\n/** Creates an interpolation binding with 8 expressions. */\nexport function interpolation8(\n    prefix: string, v0: any, i0: string, v1: any, i1: string, v2: any, i2: string, v3: any,\n    i3: string, v4: any, i4: string, v5: any, i5: string, v6: any, i6: string, v7: any,\n    suffix: string): string|NO_CHANGE {\n  let different = bindingUpdated4(v0, v1, v2, v3);\n  different = bindingUpdated4(v4, v5, v6, v7) || different;\n\n  return different ?\n      prefix + stringify(v0) + i0 + stringify(v1) + i1 + stringify(v2) + i2 + stringify(v3) + i3 +\n          stringify(v4) + i4 + stringify(v5) + i5 + stringify(v6) + i6 + stringify(v7) + suffix :\n      NO_CHANGE;\n}\n\n/** Store a value in the `data` at a given `index`. */\nexport function store<T>(index: number, value: T): void {\n  // We don't store any static data for local variables, so the first time\n  // we see the template, we should store as null to avoid a sparse array\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (adjustedIndex >= tView.data.length) {\n    tView.data[adjustedIndex] = null;\n  }\n  viewData[adjustedIndex] = value;\n}\n\n/** Retrieves a value from the `directives` array. */\nexport function loadDirective<T>(index: number): T {\n  ngDevMode && assertDefined(directives, 'Directives array should be defined if reading a dir.');\n  ngDevMode && assertDataInRange(index, directives !);\n  return directives ![index];\n}\n\nexport function loadQueryList<T>(queryListIdx: number): QueryList<T> {\n  ngDevMode && assertDefined(\n                   viewData[CONTENT_QUERIES],\n                   'Content QueryList array should be defined if reading a query.');\n  ngDevMode && assertDataInRange(queryListIdx, viewData[CONTENT_QUERIES] !);\n\n  return viewData[CONTENT_QUERIES] ![queryListIdx];\n}\n\n/** Retrieves a value from current `viewData`. */\nexport function load<T>(index: number): T {\n  return loadInternal<T>(index, viewData);\n}\n\nexport function loadElement(index: number): LElementNode {\n  return loadElementInternal(index, viewData);\n}\n\n/** Gets the current binding value and increments the binding index. */\nexport function consumeBinding(): any {\n  ngDevMode && assertDataInRange(viewData[BINDING_INDEX]);\n  ngDevMode &&\n      assertNotEqual(\n          viewData[viewData[BINDING_INDEX]], NO_CHANGE, 'Stored value should never be NO_CHANGE.');\n  return viewData[viewData[BINDING_INDEX]++];\n}\n\n/** Updates binding if changed, then returns whether it was updated. */\nexport function bindingUpdated(value: any): boolean {\n  ngDevMode && assertNotEqual(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');\n  if (viewData[BINDING_INDEX] === -1) initBindings();\n  const bindingIndex = viewData[BINDING_INDEX];\n\n  if (bindingIndex >= viewData.length) {\n    viewData[viewData[BINDING_INDEX]++] = value;\n  } else if (isDifferent(viewData[bindingIndex], value)) {\n    throwErrorIfNoChangesMode(creationMode, checkNoChangesMode, viewData[bindingIndex], value);\n    viewData[viewData[BINDING_INDEX]++] = value;\n  } else {\n    viewData[BINDING_INDEX]++;\n    return false;\n  }\n  return true;\n}\n\n/** Updates binding if changed, then returns the latest value. */\nexport function checkAndUpdateBinding(value: any): any {\n  bindingUpdated(value);\n  return value;\n}\n\n/** Updates 2 bindings if changed, then returns whether either was updated. */\nexport function bindingUpdated2(exp1: any, exp2: any): boolean {\n  const different = bindingUpdated(exp1);\n  return bindingUpdated(exp2) || different;\n}\n\n/** Updates 4 bindings if changed, then returns whether any was updated. */\nexport function bindingUpdated4(exp1: any, exp2: any, exp3: any, exp4: any): boolean {\n  const different = bindingUpdated2(exp1, exp2);\n  return bindingUpdated2(exp3, exp4) || different;\n}\n\nexport function getTView(): TView {\n  return tView;\n}\n\n/**\n * Registers a QueryList, associated with a content query, for later refresh (part of a view\n * refresh).\n */\nexport function registerContentQuery<Q>(queryList: QueryList<Q>): void {\n  const savedContentQueriesLength =\n      (viewData[CONTENT_QUERIES] || (viewData[CONTENT_QUERIES] = [])).push(queryList);\n  if (firstTemplatePass) {\n    const currentDirectiveIndex = directives !.length - 1;\n    const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n    const lastSavedDirectiveIndex =\n        tView.contentQueries.length ? tView.contentQueries[tView.contentQueries.length - 2] : -1;\n    if (currentDirectiveIndex !== lastSavedDirectiveIndex) {\n      tViewContentQueries.push(currentDirectiveIndex, savedContentQueriesLength - 1);\n    }\n  }\n}\n\nexport function assertPreviousIsParent() {\n  assertEqual(isParent, true, 'previousOrParentNode should be a parent');\n}\n\nfunction assertHasParent() {\n  assertDefined(getParentLNode(previousOrParentNode), 'previousOrParentNode should have a parent');\n}\n\nfunction assertDataInRange(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertDataInRangeInternal(index, arr || viewData);\n}\n\nfunction assertDataNext(index: number, arr?: any[]) {\n  if (arr == null) arr = viewData;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\n/**\n * On the first template pass, the reserved slots should be set `NO_CHANGE`.\n *\n * If not, they might not have been actually reserved.\n */\nexport function assertReservedSlotInitialized(slotOffset: number, numSlots: number) {\n  if (firstTemplatePass) {\n    const startIndex = tView.bindingStartIndex - slotOffset;\n    for (let i = 0; i < numSlots; i++) {\n      assertEqual(\n          viewData[startIndex + i], NO_CHANGE,\n          'The reserved slots should be set to `NO_CHANGE` on first template pass');\n    }\n  }\n}\n\nexport function _getComponentHostLElementNode<T>(component: T): LElementNode {\n  ngDevMode && assertDefined(component, 'expecting component got null');\n  const lElementNode = (component as any)[NG_HOST_SYMBOL] as LElementNode;\n  ngDevMode && assertDefined(component, 'object is not a component');\n  return lElementNode;\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\nexport const ROOT_DIRECTIVE_INDICES = _ROOT_DIRECTIVE_INDICES;\n"],"sourceRoot":""}