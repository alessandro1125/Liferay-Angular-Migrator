{"version":3,"sources":["../../../../../../../../../../packages/core/src/render3/di.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// We are temporarily importing the existing viewEngine_from core so we can be sure we are\n// correctly implementing its interfaces for backwards compatibility.\nimport {ChangeDetectorRef as viewEngine_ChangeDetectorRef} from '../change_detection/change_detector_ref';\nimport {InjectFlags, Injector, inject, setCurrentInjector} from '../di/injector';\nimport {ComponentFactory as viewEngine_ComponentFactory, ComponentRef as viewEngine_ComponentRef} from '../linker/component_factory';\nimport {ComponentFactoryResolver as viewEngine_ComponentFactoryResolver} from '../linker/component_factory_resolver';\nimport {ElementRef as viewEngine_ElementRef} from '../linker/element_ref';\nimport {NgModuleRef as viewEngine_NgModuleRef} from '../linker/ng_module_factory';\nimport {TemplateRef as viewEngine_TemplateRef} from '../linker/template_ref';\nimport {ViewContainerRef as viewEngine_ViewContainerRef} from '../linker/view_container_ref';\nimport {EmbeddedViewRef as viewEngine_EmbeddedViewRef, ViewRef as viewEngine_ViewRef} from '../linker/view_ref';\nimport {Type} from '../type';\n\nimport {assertDefined, assertGreaterThan, assertLessThan} from './assert';\nimport {ComponentFactoryResolver} from './component_ref';\nimport {addToViewTree, assertPreviousIsParent, createEmbeddedViewNode, createLContainer, createLNodeObject, createTNode, getPreviousOrParentNode, getRenderer, isComponent, renderEmbeddedTemplate, resolveDirective} from './instructions';\nimport {VIEWS} from './interfaces/container';\nimport {DirectiveDefInternal, RenderFlags} from './interfaces/definition';\nimport {LInjector} from './interfaces/injector';\nimport {AttributeMarker, LContainerNode, LElementNode, LNode, LViewNode, TContainerNode, TElementNode, TNodeFlags, TNodeType} from './interfaces/node';\nimport {LQueries, QueryReadType} from './interfaces/query';\nimport {Renderer3} from './interfaces/renderer';\nimport {DIRECTIVES, HOST_NODE, INJECTOR, LViewData, QUERIES, RENDERER, TVIEW, TView} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {addRemoveViewFromContainer, appendChild, detachView, getChildLNode, getParentLNode, insertView, removeView} from './node_manipulation';\nimport {stringify} from './util';\nimport {ViewRef} from './view_ref';\n\n\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the instance with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\nconst NG_ELEMENT_ID = '__NG_ELEMENT_ID__';\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injector The node injector in which the directive should be registered\n * @param type The directive to register\n */\nexport function bloomAdd(injector: LInjector, type: Type<any>): void {\n  let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  // This means that after 255, some directives will share slots, leading to some false positives\n  // when checking for a directive's presence.\n  const bloomBit = id % BLOOM_SIZE;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  if (bloomBit < 128) {\n    // Then use the mask to flip on the bit (0-31) associated with the directive in that bucket\n    bloomBit < 64 ? (bloomBit < 32 ? (injector.bf0 |= mask) : (injector.bf1 |= mask)) :\n                    (bloomBit < 96 ? (injector.bf2 |= mask) : (injector.bf3 |= mask));\n  } else {\n    bloomBit < 192 ? (bloomBit < 160 ? (injector.bf4 |= mask) : (injector.bf5 |= mask)) :\n                     (bloomBit < 224 ? (injector.bf6 |= mask) : (injector.bf7 |= mask));\n  }\n}\n\nexport function getOrCreateNodeInjector(): LInjector {\n  ngDevMode && assertPreviousIsParent();\n  return getOrCreateNodeInjectorForNode(getPreviousOrParentNode() as LElementNode | LContainerNode);\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param node for which an injector should be retrieved / created.\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(node: LElementNode | LContainerNode): LInjector {\n  const nodeInjector = node.nodeInjector;\n  const parent = getParentLNode(node);\n  const parentInjector = parent && parent.nodeInjector;\n  if (nodeInjector != parentInjector) {\n    return nodeInjector !;\n  }\n  return node.nodeInjector = {\n    parent: parentInjector,\n    node: node,\n    bf0: 0,\n    bf1: 0,\n    bf2: 0,\n    bf3: 0,\n    bf4: 0,\n    bf5: 0,\n    bf6: 0,\n    bf7: 0,\n    cbf0: parentInjector == null ? 0 : parentInjector.cbf0 | parentInjector.bf0,\n    cbf1: parentInjector == null ? 0 : parentInjector.cbf1 | parentInjector.bf1,\n    cbf2: parentInjector == null ? 0 : parentInjector.cbf2 | parentInjector.bf2,\n    cbf3: parentInjector == null ? 0 : parentInjector.cbf3 | parentInjector.bf3,\n    cbf4: parentInjector == null ? 0 : parentInjector.cbf4 | parentInjector.bf4,\n    cbf5: parentInjector == null ? 0 : parentInjector.cbf5 | parentInjector.bf5,\n    cbf6: parentInjector == null ? 0 : parentInjector.cbf6 | parentInjector.bf6,\n    cbf7: parentInjector == null ? 0 : parentInjector.cbf7 | parentInjector.bf7,\n    templateRef: null,\n    viewContainerRef: null,\n    elementRef: null,\n    changeDetectorRef: null,\n  };\n}\n\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param def The definition of the directive to be made public\n */\nexport function diPublicInInjector(di: LInjector, def: DirectiveDefInternal<any>): void {\n  bloomAdd(di, def.type);\n}\n\n/**\n * Makes a directive public to the DI system by adding it to an injector's bloom filter.\n *\n * @param def The definition of the directive to be made public\n */\nexport function diPublic(def: DirectiveDefInternal<any>): void {\n  diPublicInInjector(getOrCreateNodeInjector(), def);\n}\n\n/**\n * Searches for an instance of the given type up the injector tree and returns\n * that instance if found.\n *\n * If not found, it will propagate up to the next parent injector until the token\n * is found or the top is reached.\n *\n * Usage example (in factory function):\n *\n * class SomeDirective {\n *   constructor(directive: DirectiveA) {}\n *\n *   static ngDirectiveDef = defineDirective({\n *     type: SomeDirective,\n *     factory: () => new SomeDirective(directiveInject(DirectiveA))\n *   });\n * }\n *\n * NOTE: use `directiveInject` with `@Directive`, `@Component`, and `@Pipe`. For\n * all other injection use `inject` which does not walk the DOM render tree.\n *\n * @param token The directive type to search for\n * @param flags Injection flags (e.g. CheckParent)\n * @returns The instance found\n */\nexport function directiveInject<T>(token: Type<T>): T;\nexport function directiveInject<T>(token: Type<T>, flags: InjectFlags.Optional): T|null;\nexport function directiveInject<T>(token: Type<T>, flags: InjectFlags): T;\nexport function directiveInject<T>(token: Type<T>, flags = InjectFlags.Default): T|null {\n  return getOrCreateInjectable<T>(getOrCreateNodeInjector(), token, flags);\n}\n\n/**\n * Creates an ElementRef and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @returns The ElementRef instance to use\n */\nexport function injectElementRef(): viewEngine_ElementRef {\n  return getOrCreateElementRef(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @returns The TemplateRef instance to use\n */\nexport function injectTemplateRef<T>(): viewEngine_TemplateRef<T> {\n  return getOrCreateTemplateRef<T>(getOrCreateNodeInjector());\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function injectViewContainerRef(): viewEngine_ViewContainerRef {\n  return getOrCreateContainerRef(getOrCreateNodeInjector());\n}\n\n/** Returns a ChangeDetectorRef (a.k.a. a ViewRef) */\nexport function injectChangeDetectorRef(): viewEngine_ChangeDetectorRef {\n  return getOrCreateChangeDetectorRef(getOrCreateNodeInjector(), null);\n}\n\n/**\n * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the\n * ComponentFactoryResolver\n * already exists, retrieves the existing ComponentFactoryResolver.\n *\n * @returns The ComponentFactoryResolver instance to use\n */\nexport function injectComponentFactoryResolver(): viewEngine_ComponentFactoryResolver {\n  return componentFactoryResolver;\n}\nconst componentFactoryResolver: ComponentFactoryResolver = new ComponentFactoryResolver();\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.ngComponentDef = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @experimental\n */\nexport function injectAttribute(attrNameToInject: string): string|undefined {\n  ngDevMode && assertPreviousIsParent();\n  const lElement = getPreviousOrParentNode() as LElementNode;\n  ngDevMode && assertNodeType(lElement, TNodeType.Element);\n  const tElement = lElement.tNode;\n  ngDevMode && assertDefined(tElement, 'expecting tNode');\n  const attrs = tElement.attrs;\n  if (attrs) {\n    for (let i = 0; i < attrs.length; i = i + 2) {\n      const attrName = attrs[i];\n      if (attrName === AttributeMarker.SelectOnly) break;\n      if (attrName == attrNameToInject) {\n        return attrs[i + 1] as string;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).\n * Or, if it already exists, retrieves the existing instance.\n *\n * @returns The ChangeDetectorRef to use\n */\nexport function getOrCreateChangeDetectorRef(\n    di: LInjector, context: any): viewEngine_ChangeDetectorRef {\n  if (di.changeDetectorRef) return di.changeDetectorRef;\n\n  const currentNode = di.node;\n  if (isComponent(currentNode.tNode)) {\n    return di.changeDetectorRef = new ViewRef(currentNode.data as LViewData, context);\n  } else if (currentNode.tNode.type === TNodeType.Element) {\n    return di.changeDetectorRef = getOrCreateHostChangeDetector(currentNode.view[HOST_NODE]);\n  }\n  return null !;\n}\n\n/** Gets or creates ChangeDetectorRef for the closest host component */\nfunction getOrCreateHostChangeDetector(currentNode: LViewNode | LElementNode):\n    viewEngine_ChangeDetectorRef {\n  const hostNode = getClosestComponentAncestor(currentNode);\n  const hostInjector = hostNode.nodeInjector;\n  const existingRef = hostInjector && hostInjector.changeDetectorRef;\n\n  return existingRef ?\n      existingRef :\n      new ViewRef(\n          hostNode.data as LViewData,\n          hostNode\n              .view[DIRECTIVES] ![hostNode.tNode.flags >> TNodeFlags.DirectiveStartingIndexShift]);\n}\n\n/**\n * If the node is an embedded view, traverses up the view tree to return the closest\n * ancestor view that is attached to a component. If it's already a component node,\n * returns itself.\n */\nfunction getClosestComponentAncestor(node: LViewNode | LElementNode): LElementNode {\n  while (node.tNode.type === TNodeType.View) {\n    node = node.view[HOST_NODE];\n  }\n  return node as LElementNode;\n}\n\n/**\n * Searches for an instance of the given directive type up the injector tree and returns\n * that instance if found.\n *\n * Specifically, it gets the bloom filter bit associated with the directive (see bloomHashBit),\n * checks that bit against the bloom filter structure to identify an injector that might have\n * the directive (see bloomFindPossibleInjector), then searches the directives on that injector\n * for a match.\n *\n * If not found, it will propagate up to the next parent injector until the token\n * is found or the top is reached.\n *\n * @param di Node injector where the search should start\n * @param token The directive type to search for\n * @param flags Injection flags (e.g. CheckParent)\n * @returns The instance found\n */\nexport function getOrCreateInjectable<T>(\n    di: LInjector, token: Type<T>, flags: InjectFlags = InjectFlags.Default): T|null {\n  const bloomHash = bloomHashBit(token);\n\n  // If the token has a bloom hash, then it is a directive that is public to the injection system\n  // (diPublic). If there is no hash, fall back to the module injector.\n  if (bloomHash === null) {\n    const moduleInjector = getPreviousOrParentNode().view[INJECTOR];\n    const formerInjector = setCurrentInjector(moduleInjector);\n    try {\n      return inject(token, flags);\n    } finally {\n      setCurrentInjector(formerInjector);\n    }\n  } else {\n    let injector: LInjector|null = di;\n\n    while (injector) {\n      // Get the closest potential matching injector (upwards in the injector tree) that\n      // *potentially* has the token.\n      injector = bloomFindPossibleInjector(injector, bloomHash, flags);\n\n      // If no injector is found, we *know* that there is no ancestor injector that contains the\n      // token, so we abort.\n      if (!injector) {\n        break;\n      }\n\n      // At this point, we have an injector which *may* contain the token, so we step through the\n      // directives associated with the injector's corresponding node to get the directive instance.\n      const node = injector.node;\n      const nodeFlags = node.tNode.flags;\n      const count = nodeFlags & TNodeFlags.DirectiveCountMask;\n\n      if (count !== 0) {\n        const start = nodeFlags >> TNodeFlags.DirectiveStartingIndexShift;\n        const end = start + count;\n        const defs = node.view[TVIEW].directives !;\n\n        for (let i = start; i < end; i++) {\n          // Get the definition for the directive at this index and, if it is injectable (diPublic),\n          // and matches the given token, return the directive instance.\n          const directiveDef = defs[i] as DirectiveDefInternal<any>;\n          if (directiveDef.type === token && directiveDef.diPublic) {\n            return node.view[DIRECTIVES] ![i];\n          }\n        }\n      }\n\n      // If we *didn't* find the directive for the token and we are searching the current node's\n      // injector, it's possible the directive is on this node and hasn't been created yet.\n      let instance: T|null;\n      if (injector === di && (instance = searchMatchesQueuedForCreation<T>(node, token))) {\n        return instance;\n      }\n\n      // The def wasn't found anywhere on this node, so it was a false positive.\n      // If flags permit, traverse up the tree and continue searching.\n      if (flags & InjectFlags.Self || flags & InjectFlags.Host && !sameHostView(injector)) {\n        injector = null;\n      } else {\n        injector = injector.parent;\n      }\n    }\n  }\n\n  // No directive was found for the given token.\n  if (flags & InjectFlags.Optional) return null;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nfunction searchMatchesQueuedForCreation<T>(node: LNode, token: any): T|null {\n  const matches = node.view[TVIEW].currentMatches;\n  if (matches) {\n    for (let i = 0; i < matches.length; i += 2) {\n      const def = matches[i] as DirectiveDefInternal<any>;\n      if (def.type === token) {\n        return resolveDirective(def, i + 1, matches, node.view[TVIEW]);\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Given a directive type, this function returns the bit in an injector's bloom filter\n * that should be used to determine whether or not the directive is present.\n *\n * When the directive was added to the bloom filter, it was given a unique ID that can be\n * retrieved on the class. Since there are only BLOOM_SIZE slots per bloom filter, the directive's\n * ID must be modulo-ed by BLOOM_SIZE to get the correct bloom bit (directives share slots after\n * BLOOM_SIZE is reached).\n *\n * @param type The directive type\n * @returns The bloom bit to check for the directive\n */\nfunction bloomHashBit(type: Type<any>): number|null {\n  let id: number|undefined = (type as any)[NG_ELEMENT_ID];\n  return typeof id === 'number' ? id % BLOOM_SIZE : null;\n}\n\n/**\n * Finds the closest injector that might have a certain directive.\n *\n * Each directive corresponds to a bit in an injector's bloom filter. Given the bloom bit to\n * check and a starting injector, this function traverses up injectors until it finds an\n * injector that contains a 1 for that bit in its bloom filter. A 1 indicates that the\n * injector may have that directive. It only *may* have the directive because directives begin\n * to share bloom filter bits after the BLOOM_SIZE is reached, and it could correspond to a\n * different directive sharing the bit.\n *\n * Note: We can skip checking further injectors up the tree if an injector's cbf structure\n * has a 0 for that bloom bit. Since cbf contains the merged value of all the parent\n * injectors, a 0 in the bloom bit indicates that the parents definitely do not contain\n * the directive and do not need to be checked.\n *\n * @param injector The starting node injector to check\n * @param  bloomBit The bit to check in each injector's bloom filter\n * @param  flags The injection flags for this injection site (e.g. Optional or SkipSelf)\n * @returns An injector that might have the directive\n */\nexport function bloomFindPossibleInjector(\n    startInjector: LInjector, bloomBit: number, flags: InjectFlags): LInjector|null {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Traverse up the injector tree until we find a potential match or until we know there *isn't* a\n  // match.\n  let injector: LInjector|null =\n      flags & InjectFlags.SkipSelf ? startInjector.parent ! : startInjector;\n  while (injector) {\n    // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n    // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n    // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n    let value: number;\n    if (bloomBit < 128) {\n      value = bloomBit < 64 ? (bloomBit < 32 ? injector.bf0 : injector.bf1) :\n                              (bloomBit < 96 ? injector.bf2 : injector.bf3);\n    } else {\n      value = bloomBit < 192 ? (bloomBit < 160 ? injector.bf4 : injector.bf5) :\n                               (bloomBit < 224 ? injector.bf6 : injector.bf7);\n    }\n\n    // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n    // this injector is a potential match.\n    if ((value & mask) === mask) {\n      return injector;\n    } else if (flags & InjectFlags.Self || flags & InjectFlags.Host && !sameHostView(injector)) {\n      return null;\n    }\n\n    // If the current injector does not have the directive, check the bloom filters for the ancestor\n    // injectors (cbf0 - cbf7). These filters capture *all* ancestor injectors.\n    if (bloomBit < 128) {\n      value = bloomBit < 64 ? (bloomBit < 32 ? injector.cbf0 : injector.cbf1) :\n                              (bloomBit < 96 ? injector.cbf2 : injector.cbf3);\n    } else {\n      value = bloomBit < 192 ? (bloomBit < 160 ? injector.cbf4 : injector.cbf5) :\n                               (bloomBit < 224 ? injector.cbf6 : injector.cbf7);\n    }\n\n    // If the ancestor bloom filter value has the bit corresponding to the directive, traverse up to\n    // find the specific injector. If the ancestor bloom filter does not have the bit, we can abort.\n    injector = (value & mask) ? injector.parent : null;\n  }\n  return null;\n}\n\n/**\n * Checks whether the current injector and its parent are in the same host view.\n *\n * This is necessary to support @Host() decorators. If @Host() is set, we should stop searching once\n * the injector and its parent view don't match because it means we'd cross the view boundary.\n */\nfunction sameHostView(injector: LInjector): boolean {\n  return !!injector.parent && injector.parent.node.view === injector.node.view;\n}\n\nexport class ReadFromInjectorFn<T> {\n  constructor(readonly read: (injector: LInjector, node: LNode, directiveIndex?: number) => T) {}\n}\n\n/**\n * Creates an ElementRef for a given node injector and stores it on the injector.\n * Or, if the ElementRef already exists, retrieves the existing ElementRef.\n *\n * @param di The node injector where we should store a created ElementRef\n * @returns The ElementRef instance to use\n */\nexport function getOrCreateElementRef(di: LInjector): viewEngine_ElementRef {\n  return di.elementRef || (di.elementRef = new ElementRef(di.node.native));\n}\n\nexport const QUERY_READ_TEMPLATE_REF = <QueryReadType<viewEngine_TemplateRef<any>>>(\n    new ReadFromInjectorFn<viewEngine_TemplateRef<any>>(\n        (injector: LInjector) => getOrCreateTemplateRef(injector)) as any);\n\nexport const QUERY_READ_CONTAINER_REF = <QueryReadType<viewEngine_ViewContainerRef>>(\n    new ReadFromInjectorFn<viewEngine_ViewContainerRef>(\n        (injector: LInjector) => getOrCreateContainerRef(injector)) as any);\n\nexport const QUERY_READ_ELEMENT_REF =\n    <QueryReadType<viewEngine_ElementRef>>(new ReadFromInjectorFn<viewEngine_ElementRef>(\n        (injector: LInjector) => getOrCreateElementRef(injector)) as any);\n\nexport const QUERY_READ_FROM_NODE =\n    (new ReadFromInjectorFn<any>((injector: LInjector, node: LNode, directiveIdx: number) => {\n      ngDevMode && assertNodeOfPossibleTypes(node, TNodeType.Container, TNodeType.Element);\n      if (directiveIdx > -1) {\n        return node.view[DIRECTIVES] ![directiveIdx];\n      } else if (node.tNode.type === TNodeType.Element) {\n        return getOrCreateElementRef(injector);\n      } else if (node.tNode.type === TNodeType.Container) {\n        return getOrCreateTemplateRef(injector);\n      }\n      throw new Error('fail');\n    }) as any as QueryReadType<any>);\n\n/** A ref to a node's native element. */\nclass ElementRef implements viewEngine_ElementRef {\n  readonly nativeElement: any;\n  constructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n\n/**\n * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef\n * already exists, retrieves the existing ViewContainerRef.\n *\n * @returns The ViewContainerRef instance to use\n */\nexport function getOrCreateContainerRef(di: LInjector): viewEngine_ViewContainerRef {\n  if (!di.viewContainerRef) {\n    const vcRefHost = di.node;\n\n    ngDevMode && assertNodeOfPossibleTypes(vcRefHost, TNodeType.Container, TNodeType.Element);\n    const hostParent = getParentLNode(vcRefHost) !;\n    const lContainer = createLContainer(hostParent, vcRefHost.view, true);\n    const comment = vcRefHost.view[RENDERER].createComment(ngDevMode ? 'container' : '');\n    const lContainerNode: LContainerNode = createLNodeObject(\n        TNodeType.Container, vcRefHost.view, hostParent, comment, lContainer, null);\n    appendChild(hostParent, comment, vcRefHost.view);\n\n\n    if (vcRefHost.queries) {\n      lContainerNode.queries = vcRefHost.queries.container();\n    }\n\n    const hostTNode = vcRefHost.tNode as TElementNode | TContainerNode;\n    if (!hostTNode.dynamicContainerNode) {\n      hostTNode.dynamicContainerNode =\n          createTNode(TNodeType.Container, -1, null, null, hostTNode, null);\n    }\n\n    lContainerNode.tNode = hostTNode.dynamicContainerNode;\n    vcRefHost.dynamicLContainerNode = lContainerNode;\n\n    addToViewTree(vcRefHost.view, hostTNode.index as number, lContainer);\n\n    di.viewContainerRef = new ViewContainerRef(lContainerNode);\n  }\n\n  return di.viewContainerRef;\n}\n\n/**\n * A ref to a container that enables adding and removing views from that container\n * imperatively.\n */\nclass ViewContainerRef implements viewEngine_ViewContainerRef {\n  private _viewRefs: viewEngine_ViewRef[] = [];\n  // TODO(issue/24571): remove '!'.\n  element !: viewEngine_ElementRef;\n  // TODO(issue/24571): remove '!'.\n  injector !: Injector;\n  // TODO(issue/24571): remove '!'.\n  parentInjector !: Injector;\n\n  constructor(private _lContainerNode: LContainerNode) {}\n\n  clear(): void {\n    const lContainer = this._lContainerNode.data;\n    while (lContainer[VIEWS].length) {\n      this.remove(0);\n    }\n  }\n\n  get(index: number): viewEngine_ViewRef|null { return this._viewRefs[index] || null; }\n\n  get length(): number {\n    const lContainer = this._lContainerNode.data;\n    return lContainer[VIEWS].length;\n  }\n\n  createEmbeddedView<C>(templateRef: viewEngine_TemplateRef<C>, context?: C, index?: number):\n      viewEngine_EmbeddedViewRef<C> {\n    const adjustedIdx = this._adjustIndex(index);\n    const viewRef = (templateRef as TemplateRef<C>)\n                        .createEmbeddedView(context || <any>{}, this._lContainerNode, adjustedIdx);\n    (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n    this._viewRefs.splice(adjustedIdx, 0, viewRef);\n    return viewRef;\n  }\n\n  createComponent<C>(\n      componentFactory: viewEngine_ComponentFactory<C>, index?: number|undefined,\n      injector?: Injector|undefined, projectableNodes?: any[][]|undefined,\n      ngModuleRef?: viewEngine_NgModuleRef<any>|undefined): viewEngine_ComponentRef<C> {\n    const contextInjector = injector || this.parentInjector;\n    if (!ngModuleRef && contextInjector) {\n      ngModuleRef = contextInjector.get(viewEngine_NgModuleRef);\n    }\n\n    const componentRef =\n        componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n\n  insert(viewRef: viewEngine_ViewRef, index?: number): viewEngine_ViewRef {\n    if (viewRef.destroyed) {\n      throw new Error('Cannot insert a destroyed View in a ViewContainer!');\n    }\n    const lViewNode = (viewRef as ViewRef<any>)._lViewNode !;\n    const adjustedIdx = this._adjustIndex(index);\n\n    insertView(this._lContainerNode, lViewNode, adjustedIdx);\n    const views = this._lContainerNode.data[VIEWS];\n    const beforeNode = adjustedIdx + 1 < views.length ?\n        (getChildLNode(views[adjustedIdx + 1]) !).native :\n        this._lContainerNode.native;\n    addRemoveViewFromContainer(this._lContainerNode, lViewNode, true, beforeNode);\n\n    (viewRef as ViewRef<any>).attachToViewContainerRef(this);\n    this._viewRefs.splice(adjustedIdx, 0, viewRef);\n\n    return viewRef;\n  }\n\n  move(viewRef: viewEngine_ViewRef, newIndex: number): viewEngine_ViewRef {\n    const index = this.indexOf(viewRef);\n    this.detach(index);\n    this.insert(viewRef, this._adjustIndex(newIndex));\n    return viewRef;\n  }\n\n  indexOf(viewRef: viewEngine_ViewRef): number { return this._viewRefs.indexOf(viewRef); }\n\n  remove(index?: number): void {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    removeView(this._lContainerNode, adjustedIdx);\n    this._viewRefs.splice(adjustedIdx, 1);\n  }\n\n  detach(index?: number): viewEngine_ViewRef|null {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const lViewNode = detachView(this._lContainerNode, adjustedIdx);\n    return this._viewRefs.splice(adjustedIdx, 1)[0] || null;\n  }\n\n  private _adjustIndex(index?: number, shift: number = 0) {\n    if (index == null) {\n      return this._lContainerNode.data[VIEWS].length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, 'index must be positive');\n      // +1 because it's legal to insert at the end.\n      assertLessThan(index, this._lContainerNode.data[VIEWS].length + 1 + shift, 'index');\n    }\n    return index;\n  }\n}\n\n/**\n * Creates a TemplateRef and stores it on the injector. Or, if the TemplateRef already\n * exists, retrieves the existing TemplateRef.\n *\n * @param di The node injector where we should store a created TemplateRef\n * @returns The TemplateRef instance to use\n */\nexport function getOrCreateTemplateRef<T>(di: LInjector): viewEngine_TemplateRef<T> {\n  if (!di.templateRef) {\n    ngDevMode && assertNodeType(di.node, TNodeType.Container);\n    const hostNode = di.node as LContainerNode;\n    const hostTNode = hostNode.tNode;\n    ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');\n    di.templateRef = new TemplateRef<any>(\n        getOrCreateElementRef(di), hostTNode.tViews as TView, getRenderer(),\n        hostNode.data[QUERIES]);\n  }\n  return di.templateRef;\n}\n\nclass TemplateRef<T> implements viewEngine_TemplateRef<T> {\n  readonly elementRef: viewEngine_ElementRef;\n\n  constructor(\n      elementRef: viewEngine_ElementRef, private _tView: TView, private _renderer: Renderer3,\n      private _queries: LQueries|null) {\n    this.elementRef = elementRef;\n  }\n\n  createEmbeddedView(context: T, containerNode?: LContainerNode, index?: number):\n      viewEngine_EmbeddedViewRef<T> {\n    const viewNode = createEmbeddedViewNode(this._tView, context, this._renderer, this._queries);\n    if (containerNode) {\n      insertView(containerNode, viewNode, index !);\n    }\n    renderEmbeddedTemplate(viewNode, this._tView, context, RenderFlags.Create);\n    const viewRef = new ViewRef(viewNode.data, context);\n    viewRef._lViewNode = viewNode;\n    return viewRef;\n  }\n}\n"],"sourceRoot":""}