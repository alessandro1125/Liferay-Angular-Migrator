Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm5/testing/src/testing_internal', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import * as tslib_1 from "tslib";
    import { ÉµisPromise as isPromise } from '@angular/core';
    import { global } from '@angular/core/src/util';
    import { AsyncTestCompleter } from './async_test_completer';
    import { getTestBed } from './test_bed';
    export { AsyncTestCompleter } from './async_test_completer';
    export { inject } from './test_bed';
    export * from './logger';
    export * from './ng_zone_mock';
    export var proxy = function (t) {
        return t;
    };
    var _global = typeof window === 'undefined' ? global : window;
    export var afterEach = _global.afterEach;
    export var expect = _global.expect;
    var jsmBeforeEach = _global.beforeEach;
    var jsmDescribe = _global.describe;
    var jsmDDescribe = _global.fdescribe;
    var jsmXDescribe = _global.xdescribe;
    var jsmIt = _global.it;
    var jsmFIt = _global.fit;
    var jsmXIt = _global.xit;
    var runnerStack = [];
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;
    var globalTimeOut = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    var testBed = getTestBed();
    /**
     * Mechanism to run `beforeEach()` functions of Angular tests.
     *
     * Note: Jasmine own `beforeEach` is used by this library to handle DI providers.
     */
    var BeforeEachRunner = /** @class */function () {
        function BeforeEachRunner(_parent) {
            this._parent = _parent;
            this._fns = [];
        }
        BeforeEachRunner.prototype.beforeEach = function (fn) {
            this._fns.push(fn);
        };
        BeforeEachRunner.prototype.run = function () {
            if (this._parent) this._parent.run();
            this._fns.forEach(function (fn) {
                fn();
            });
        };
        return BeforeEachRunner;
    }();
    // Reset the test providers before each test
    jsmBeforeEach(function () {
        testBed.resetTestingModule();
    });
    function _describe(jsmFn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var parentRunner = runnerStack.length === 0 ? null : runnerStack[runnerStack.length - 1];
        var runner = new BeforeEachRunner(parentRunner);
        runnerStack.push(runner);
        var suite = jsmFn.apply(void 0, tslib_1.__spread(args));
        runnerStack.pop();
        return suite;
    }
    export function describe() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return _describe.apply(void 0, tslib_1.__spread([jsmDescribe], args));
    }
    export function ddescribe() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return _describe.apply(void 0, tslib_1.__spread([jsmDDescribe], args));
    }
    export function xdescribe() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return _describe.apply(void 0, tslib_1.__spread([jsmXDescribe], args));
    }
    export function beforeEach(fn) {
        if (runnerStack.length > 0) {
            // Inside a describe block, beforeEach() uses a BeforeEachRunner
            runnerStack[runnerStack.length - 1].beforeEach(fn);
        } else {
            // Top level beforeEach() are delegated to jasmine
            jsmBeforeEach(fn);
        }
    }
    /**
     * Allows overriding default providers defined in test_injector.js.
     *
     * The given function must return a list of DI providers.
     *
     * Example:
     *
     *   beforeEachProviders(() => [
     *     {provide: Compiler, useClass: MockCompiler},
     *     {provide: SomeToken, useValue: myValue},
     *   ]);
     */
    export function beforeEachProviders(fn) {
        jsmBeforeEach(function () {
            var providers = fn();
            if (!providers) return;
            testBed.configureTestingModule({ providers: providers });
        });
    }
    function _it(jsmFn, testName, testFn, testTimeout) {
        if (testTimeout === void 0) {
            testTimeout = 0;
        }
        if (runnerStack.length == 0) {
            // This left here intentionally, as we should never get here, and it aids debugging.
            debugger;
            throw new Error('Empty Stack!');
        }
        var runner = runnerStack[runnerStack.length - 1];
        var timeout = Math.max(globalTimeOut, testTimeout);
        jsmFn(testName, function (done) {
            var completerProvider = {
                provide: AsyncTestCompleter,
                useFactory: function () {
                    // Mark the test as async when an AsyncTestCompleter is injected in an it()
                    return new AsyncTestCompleter();
                }
            };
            testBed.configureTestingModule({ providers: [completerProvider] });
            runner.run();
            if (testFn.length === 0) {
                var retVal = testFn();
                if (isPromise(retVal)) {
                    // Asynchronous test function that returns a Promise - wait for completion.
                    retVal.then(done, done.fail);
                } else {
                    // Synchronous test function - complete immediately.
                    done();
                }
            } else {
                // Asynchronous test function that takes in 'done' parameter.
                testFn(done);
            }
        }, timeout);
    }
    export function it(expectation, assertion, timeout) {
        return _it(jsmIt, expectation, assertion, timeout);
    }
    export function fit(expectation, assertion, timeout) {
        return _it(jsmFIt, expectation, assertion, timeout);
    }
    export function xit(expectation, assertion, timeout) {
        return _it(jsmXIt, expectation, assertion, timeout);
    }
    var SpyObject = /** @class */function () {
        function SpyObject(type) {
            if (type) {
                for (var prop in type.prototype) {
                    var m = null;
                    try {
                        m = type.prototype[prop];
                    } catch (e) {
                        // As we are creating spys for abstract classes,
                        // these classes might have getters that throw when they are accessed.
                        // As we are only auto creating spys for methods, this
                        // should not matter.
                    }
                    if (typeof m === 'function') {
                        this.spy(prop);
                    }
                }
            }
        }
        SpyObject.prototype.spy = function (name) {
            if (!this[name]) {
                this[name] = jasmine.createSpy(name);
            }
            return this[name];
        };
        SpyObject.prototype.prop = function (name, value) {
            this[name] = value;
        };
        SpyObject.stub = function (object, config, overrides) {
            if (object === void 0) {
                object = null;
            }
            if (config === void 0) {
                config = null;
            }
            if (overrides === void 0) {
                overrides = null;
            }
            if (!(object instanceof SpyObject)) {
                overrides = config;
                config = object;
                object = new SpyObject();
            }
            var m = tslib_1.__assign({}, config, overrides);
            Object.keys(m).forEach(function (key) {
                object.spy(key).and.returnValue(m[key]);
            });
            return object;
        };
        return SpyObject;
    }();
    export { SpyObject };
});
//# sourceMappingURL=testing_internal.js.map