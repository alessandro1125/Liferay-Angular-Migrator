{"version":3,"sources":["../../../../../../../../../../../packages/core/testing/src/test_compiler.ts"],"names":[],"mappings":";;;;;;;;;;AAQA,aAAQ,QAAR,EAA2E,UAA3E,QAA4H,eAA5H;AAIA,aAAA,aAAA,GAAA;AACE,cAAM,MAAM,eAAN,CAAN;AACD;AAED;;;;;AAMA,QAAA,kBAAA,aAAA,UAAA,MAAA,EAAA;AAAqC,gBAAA,SAAA,CAAA,eAAA,EAAA,MAAA;AAArC,iBAAA,eAAA,GAAA;;AAgCC;AA/BC,eAAA,cAAA,CAAI,gBAAA,SAAJ,EAAI,UAAJ,EAAY;iBAAZ,YAAA;AAA2B,sBAAM,eAAN;AAAwB,aAAvC;4BAAA;;AAAA,SAAZ;AACA,wBAAA,SAAA,CAAA,cAAA,GAAA,UAAe,MAAf,EAAkC,SAAlC,EAAuE;AACrE,kBAAM,eAAN;AACD,SAFD;AAGA,wBAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,SAAlB,EAAwC,SAAxC,EAA8E;AAC5E,kBAAM,eAAN;AACD,SAFD;AAGA,wBAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,SAAlB,EAAwC,SAAxC,EAA8E;AAC5E,kBAAM,eAAN;AACD,SAFD;AAGA,wBAAA,SAAA,CAAA,YAAA,GAAA,UAAa,SAAb,EAAmC,SAAnC,EAAoE;AAClE,kBAAM,eAAN;AACD,SAFD;AAGA;;;;AAIA,wBAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,SAAjB,EAAuC;AAAI,kBAAM,eAAN;AAAwB,SAAnE;AAEA;;;;;AAKA,wBAAA,SAAA,CAAA,mBAAA,GAAA,UAAuB,SAAvB,EAAyC;AAAyB,kBAAM,eAAN;AAAwB,SAA1F;AAEA;;;;AAIA,wBAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,KAAtB,EAAkC;AAAoB,kBAAM,eAAN;AAAwB,SAA9E;AA/BW,0BAAe,QAAA,UAAA,CAAA,CAD3B,YAC2B,CAAA,EAAf,eAAe,CAAf;AAgCb,eAAA,eAAA;AAAC,KAhCD,CAAqC,QAArC,CAAA;aAAa,e;AAkCb;;;;;AAKA,QAAA,yBAAA,aAAA,YAAA;AAAA,iBAAA,sBAAA,GAAA,CAEC;AAAD,eAAA,sBAAA;AAAC,KAFD,EAAA","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Compiler, CompilerOptions, Component, ComponentFactory, Directive, Injectable, Injector, NgModule, Pipe, Type} from '@angular/core';\n\nimport {MetadataOverride} from './metadata_override';\n\nfunction unimplemented(): any {\n  throw Error('unimplemented');\n}\n\n/**\n * Special interface to the compiler only used by testing\n *\n * @experimental\n */\n@Injectable()\nexport class TestingCompiler extends Compiler {\n  get injector(): Injector { throw unimplemented(); }\n  overrideModule(module: Type<any>, overrides: MetadataOverride<NgModule>): void {\n    throw unimplemented();\n  }\n  overrideDirective(directive: Type<any>, overrides: MetadataOverride<Directive>): void {\n    throw unimplemented();\n  }\n  overrideComponent(component: Type<any>, overrides: MetadataOverride<Component>): void {\n    throw unimplemented();\n  }\n  overridePipe(directive: Type<any>, overrides: MetadataOverride<Pipe>): void {\n    throw unimplemented();\n  }\n  /**\n   * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n   * so that it can use the code generated by AOT.\n   */\n  loadAotSummaries(summaries: () => any[]) { throw unimplemented(); }\n\n  /**\n   * Gets the component factory for the given component.\n   * This assumes that the component has been compiled before calling this call using\n   * `compileModuleAndAllComponents*`.\n   */\n  getComponentFactory<T>(component: Type<T>): ComponentFactory<T> { throw unimplemented(); }\n\n  /**\n   * Returns the component type that is stored in the given error.\n   * This can be used for errors created by compileModule...\n   */\n  getComponentFromError(error: Error): Type<any>|null { throw unimplemented(); }\n}\n\n/**\n * A factory for creating a Compiler\n *\n * @experimental\n */\nexport abstract class TestingCompilerFactory {\n  abstract createTestingCompiler(options?: CompilerOptions[]): TestingCompiler;\n}\n"],"sourceRoot":""}