{"version":3,"sources":["../../../../../../../packages/core/src/view/view_attach.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ElementData, NodeDef, NodeFlags, Services, ViewData, ViewDefinition, ViewState} from './types';\nimport {RenderNodeAction, declaredViewContainer, isComponentView, renderNode, visitRootRenderNodes} from './util';\n\nexport function attachEmbeddedView(\n    parentView: ViewData, elementData: ElementData, viewIndex: number | undefined | null,\n    view: ViewData) {\n  let embeddedViews = elementData.viewContainer !._embeddedViews;\n  if (viewIndex === null || viewIndex === undefined) {\n    viewIndex = embeddedViews.length;\n  }\n  view.viewContainerParent = parentView;\n  addToArray(embeddedViews, viewIndex !, view);\n  attachProjectedView(elementData, view);\n\n  Services.dirtyParentQueries(view);\n\n  const prevView = viewIndex ! > 0 ? embeddedViews[viewIndex ! - 1] : null;\n  renderAttachEmbeddedView(elementData, prevView, view);\n}\n\nfunction attachProjectedView(vcElementData: ElementData, view: ViewData) {\n  const dvcElementData = declaredViewContainer(view);\n  if (!dvcElementData || dvcElementData === vcElementData ||\n      view.state & ViewState.IsProjectedView) {\n    return;\n  }\n  // Note: For performance reasons, we\n  // - add a view to template._projectedViews only 1x throughout its lifetime,\n  //   and remove it not until the view is destroyed.\n  //   (hard, as when a parent view is attached/detached we would need to attach/detach all\n  //    nested projected views as well, even across component boundaries).\n  // - don't track the insertion order of views in the projected views array\n  //   (hard, as when the views of the same template are inserted different view containers)\n  view.state |= ViewState.IsProjectedView;\n  let projectedViews = dvcElementData.template._projectedViews;\n  if (!projectedViews) {\n    projectedViews = dvcElementData.template._projectedViews = [];\n  }\n  projectedViews.push(view);\n  // Note: we are changing the NodeDef here as we cannot calculate\n  // the fact whether a template is used for projection during compilation.\n  markNodeAsProjectedTemplate(view.parent !.def, view.parentNodeDef !);\n}\n\nfunction markNodeAsProjectedTemplate(viewDef: ViewDefinition, nodeDef: NodeDef) {\n  if (nodeDef.flags & NodeFlags.ProjectedTemplate) {\n    return;\n  }\n  viewDef.nodeFlags |= NodeFlags.ProjectedTemplate;\n  nodeDef.flags |= NodeFlags.ProjectedTemplate;\n  let parentNodeDef = nodeDef.parent;\n  while (parentNodeDef) {\n    parentNodeDef.childFlags |= NodeFlags.ProjectedTemplate;\n    parentNodeDef = parentNodeDef.parent;\n  }\n}\n\nexport function detachEmbeddedView(elementData: ElementData, viewIndex?: number): ViewData|null {\n  const embeddedViews = elementData.viewContainer !._embeddedViews;\n  if (viewIndex == null || viewIndex >= embeddedViews.length) {\n    viewIndex = embeddedViews.length - 1;\n  }\n  if (viewIndex < 0) {\n    return null;\n  }\n  const view = embeddedViews[viewIndex];\n  view.viewContainerParent = null;\n  removeFromArray(embeddedViews, viewIndex);\n\n  // See attachProjectedView for why we don't update projectedViews here.\n  Services.dirtyParentQueries(view);\n\n  renderDetachView(view);\n\n  return view;\n}\n\nexport function detachProjectedView(view: ViewData) {\n  if (!(view.state & ViewState.IsProjectedView)) {\n    return;\n  }\n  const dvcElementData = declaredViewContainer(view);\n  if (dvcElementData) {\n    const projectedViews = dvcElementData.template._projectedViews;\n    if (projectedViews) {\n      removeFromArray(projectedViews, projectedViews.indexOf(view));\n      Services.dirtyParentQueries(view);\n    }\n  }\n}\n\nexport function moveEmbeddedView(\n    elementData: ElementData, oldViewIndex: number, newViewIndex: number): ViewData {\n  const embeddedViews = elementData.viewContainer !._embeddedViews;\n  const view = embeddedViews[oldViewIndex];\n  removeFromArray(embeddedViews, oldViewIndex);\n  if (newViewIndex == null) {\n    newViewIndex = embeddedViews.length;\n  }\n  addToArray(embeddedViews, newViewIndex, view);\n\n  // Note: Don't need to change projectedViews as the order in there\n  // as always invalid...\n\n  Services.dirtyParentQueries(view);\n\n  renderDetachView(view);\n  const prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;\n  renderAttachEmbeddedView(elementData, prevView, view);\n\n  return view;\n}\n\nfunction renderAttachEmbeddedView(\n    elementData: ElementData, prevView: ViewData | null, view: ViewData) {\n  const prevRenderNode = prevView ? renderNode(prevView, prevView.def.lastRenderRootNode !) :\n                                    elementData.renderElement;\n  const parentNode = view.renderer.parentNode(prevRenderNode);\n  const nextSibling = view.renderer.nextSibling(prevRenderNode);\n  // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!\n  // However, browsers automatically do `appendChild` when there is no `nextSibling`.\n  visitRootRenderNodes(view, RenderNodeAction.InsertBefore, parentNode, nextSibling, undefined);\n}\n\nexport function renderDetachView(view: ViewData) {\n  visitRootRenderNodes(view, RenderNodeAction.RemoveChild, null, null, undefined);\n}\n\nfunction addToArray(arr: any[], index: number, value: any) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nfunction removeFromArray(arr: any[], index: number) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    arr.pop();\n  } else {\n    arr.splice(index, 1);\n  }\n}\n"],"sourceRoot":""}