{"version":3,"sources":["../../../../../../../../packages/core/src/render3/jit/directive.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,aAAQ,YAAR,EAA2C,eAA3C,EAA4D,gCAAgC,kBAA5F,EAAgH,gCAAgC,kBAAhJ,EAAoK,aAApK,EAAmL,iBAAnL,EAAsM,iBAAtM,EAAyN,aAAzN,QAA6O,mBAA7O;AAGA,aAAQ,wBAAR,EAAkC,wCAAlC,QAAiF,iCAAjF;AAGA,aAAQ,SAAR,QAAwB,YAAxB;AAEA,aAAQ,cAAR,QAA6B,eAA7B;AACA,aAAQ,gBAAR,EAA0B,gBAA1B,QAAiD,UAAjD;AACA,aAAQ,0BAAR,QAAyC,UAAzC;AACA,aAAQ,UAAR,EAAoB,mBAApB,QAA8C,QAA9C;;;;;;;;;;;;;;;AAeA,WAAM,SAAA,gBAAA,CAA2B,IAA3B,EAA4C,QAA5C,EAA+D;;AACnE,YAAI,MAAW,IAAf;;AAEA,iDAAyC,QAAzC;AACA,eAAO,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;AAC5C,iBAAK,MAAK;AACR,oBAAI,QAAQ,IAAZ,EAAkB;AAChB,wBAAI,yBAAyB,QAAzB,CAAJ,EAAwC;;AACtC,8BAAM,QAAQ,CAAC,cAAc,UAAU,IAAV,CAAe,oBAA9B,CAAd;AACA,4BAAI,SAAS,WAAb,EAA0B;AACxB,kCAAM,IAAN,CAAW,mBAAmB,UAAU,SAAS,WAAnB,CAA+B,EAA7D;AACD;AACD,4BAAI,SAAS,SAAT,IAAsB,SAAS,SAAT,CAAmB,MAA7C,EAAqD;AACnD,kCAAM,IAAN,CAAW,iBAAiB,KAAK,SAAL,CAAe,SAAS,SAAxB,CAAkC,EAA9D;AACD;AACD,8BAAM,IAAN,CAAW,yDAAX;AACA,8BAAM,IAAI,KAAJ,CAAU,MAAM,IAAN,CAAW,IAAX,CAAV,CAAN;AACD;;AAED,0BAAM,eAAe,IAAI,YAAJ,EAArB;;AAGA,0BAAM,WACF,eAAa,gBAAC,SAAS,QAAvB,EAAmC,QAAQ,UAAU,IAAV,CAAe,gBAA1D,EAA4E;AAC1E,6CAAqB,SAAS,mBAAT,IAAgC;AADqB,qBAA5E,CADJ;AAIA,wBAAI,SAAS,MAAT,KAAoB,SAAxB,EAAmC;;AACjC,8BAAM,SAAS,SAAS,MAAT,CAAgB,GAAhB,CAAoB,OAAO,IAAI,QAAJ,EAA3B,EAA2C,IAA3C,CAAgD,IAAhD,CAAf;AACA,8BAAM,IAAI,KAAJ,CACF,iDAAiD,UAAU,IAAV,CAAe,KAAK,MAAM,EADzE,CAAN;AAED;;AAID,0BAAM,MAAM,mBAAkB,OAAA,MAAA,CAAA,EAAA,EAErB,kBAAkB,IAAlB,EAAwB,QAAxB,CAFqB,EAEY,EACpC,QADoC,EAEpC,YAAY,IAAI,GAAJ,EAFwB,EAGpC,OAAO,IAAI,GAAJ,EAH6B,EAIpC,aAAa,EAJuB,EAFZ,CAAlB,EAQR,YARQ,EAQM,mBARN,CAAZ;AAUA,0BAAM,cACF,IAAI,UADF,EACc,cADd,EAC8B,QAAQ,KAAK,IAAI,oBAD/C,EACqE,YADrE,CAAN;;;;;AAOA,wBAAI,iBAAiB,IAAjB,CAAJ,EAA4B;AAC1B,mDAA2B,GAA3B,EAAgC,KAAK,eAArC;AACD;AACF;AACD,uBAAO,GAAP;AACD;AApD2C,SAA9C;AAsDD;;;;;;AAED,aAAA,gBAAA,CAA6B,SAA7B,EAA+C;AAE7C,eAAO,iBAAC,SAAD,CAAsC,eAAtC,KAA0D;AAAjE;AACD;;;;;;;;;;;AASD,WAAM,SAAA,gBAAA,CAA2B,IAA3B,EAA4C,SAA5C,EAAgE;;AACpE,YAAI,MAAW,IAAf;AACA,eAAO,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;AAC5C,iBAAK,MAAK;AACR,oBAAI,QAAQ,IAAZ,EAAkB;;AAChB,0BAAM,eAAe,IAAI,YAAJ,EAArB;;AACA,0BAAM,eAAe,QAAQ,QAAQ,KAAK,IAAI,oBAA9C;;AACA,0BAAM,MAAM,mBACR,kBAAkB,IAAlB,EAAwB,SAAxB,CADQ,EAC4B,YAD5B,EAC0C,mBAD1C,CAAZ;AAEA,0BAAM,cAAc,IAAI,UAAlB,EAA8B,cAA9B,EAA8C,YAA9C,EAA4D,YAA5D,CAAN;AACD;AACD,uBAAO,GAAP;AACD;AAV2C,SAA9C;AAYD;;;;;AAGD,WAAM,SAAA,yBAAA,CAAoC,IAApC,EAAmD;AACvD,eAAO,OAAO,cAAP,CAAsB,KAAK,SAA3B,MAA0C,OAAO,SAAxD;AACD;;;;;;;;AAMD,aAAA,iBAAA,CAA2B,IAA3B,EAA4C,QAA5C,EAA+D;;AAE7D,cAAM,eAAe,aAAa,YAAb,CAA0B,IAA1B,CAArB;;AAEA,cAAM,OAAO,oBAAoB,QAApB,EAA8B,YAA9B,CAAb;;AAEA,cAAM,qBAAqB,kBAAkB,SAAS,MAAT,IAAmB,EAArC,CAA3B;;AACA,cAAM,sBAAsB,kBAAkB,SAAS,OAAT,IAAoB,EAAtC,CAA5B;;AAEA,cAAM,iBAA4B,EAAlC;;AACA,cAAM,kBAA6B,EAAnC;AACA,aAAK,MAAM,KAAX,IAAoB,YAApB,EAAkC;AAChC,gBAAI,aAAa,cAAb,CAA4B,KAA5B,CAAJ,EAAwC;AACtC,6BAAa,KAAb,EAAoB,OAApB,CAA4B,OAAM;AAChC,wBAAI,QAAQ,GAAR,CAAJ,EAAkB;AAChB,uCAAe,KAAf,IAAwB,IAAI,mBAAJ,IAA2B,KAAnD;AACD,qBAFD,MAEO,IAAI,SAAS,GAAT,CAAJ,EAAmB;AACxB,wCAAgB,KAAhB,IAAyB,IAAI,mBAAJ,IAA2B,KAApD;AACD;AACF,iBAND;AAOD;AACF;AAED,eAAO;AACL,kBAAM,KAAK,IADN;AAEL,kBAAM,IAAI,eAAJ,CAAoB,IAApB,CAFD;AAGL,+BAAmB,CAHd;AAIL,sBAAQ,gBAAE,SAAS,QAJd;AAKL,kBAAM,oBAAoB,IAApB,CALD,EAK4B,IAL5B;AAML,oBAAM,OAAA,MAAA,CAAA,EAAA,EAAM,kBAAN,EAA6B,cAA7B,CAND;AAOL,qBAAO,OAAA,MAAA,CAAA,EAAA,EAAM,mBAAN,EAA8B,eAA9B,CAPF;AAQL,qBAAS,EARJ;AASL,uBAAW;AACT,+BAAe,KAAK,SAAL,CAAe,WAAf,KAA+B;AADrC,aATN;AAYL,4BAAc,gBAAE,IAZX;AAaL,6BAAiB,CAAC,0BAA0B,IAA1B;AAbb,SAAP;AAeD;;;;;;AAED,aAAA,mBAAA,CAA6B,QAA7B,EAAkD,YAAlD,EAAsF;AAMpF,cAAM,EAAC,UAAD,EAAa,SAAb,EAAwB,UAAxB,EAAoC,UAApC,KAAkD,kBAAkB,SAAS,IAAT,IAAiB,EAAnC,CAAxD;AAEA,YAAI,OAAO,IAAP,CAAY,UAAZ,EAAwB,MAAxB,GAAiC,CAArC,EAAwC;AACtC,kBAAM,IAAI,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAGD,aAAK,MAAM,KAAX,IAAoB,YAApB,EAAkC;AAChC,gBAAI,aAAa,cAAb,CAA4B,KAA5B,CAAJ,EAAwC;AACtC,6BAAa,KAAb,EAAoB,OAApB,CAA4B,OAAM;AAChC,wBAAI,cAAc,GAAd,CAAJ,EAAwB;AACtB,mCAAW,IAAI,gBAAJ,IAAwB,KAAnC,IAA4C,KAA5C;AACD,qBAFD,MAEO,IAAI,eAAe,GAAf,CAAJ,EAAyB;AAC9B,kCAAU,IAAI,SAAJ,IAAiB,KAA3B,IAAoC,GAAG,KAAK,IAAI,CAAC,IAAI,IAAJ,IAAY,EAAb,EAAiB,IAAjB,CAAsB,GAAtB,CAA0B,GAA1E;AACD;AACF,iBAND;AAOD;AACF;AAED,eAAO,EAAC,UAAD,EAAa,SAAb,EAAwB,UAAxB,EAAP;AACD;;;;;AAED,aAAA,OAAA,CAAiB,KAAjB,EAA2B;AACzB,eAAO,MAAM,cAAN,KAAyB,OAAhC;AACD;;;;;AAED,aAAA,QAAA,CAAkB,KAAlB,EAA4B;AAC1B,eAAO,MAAM,cAAN,KAAyB,QAAhC;AACD;;;;;AAED,aAAA,aAAA,CAAuB,KAAvB,EAAiC;AAC/B,eAAO,MAAM,cAAN,KAAyB,aAAhC;AACD;;;;;AAED,aAAA,cAAA,CAAwB,KAAxB,EAAkC;AAChC,eAAO,MAAM,cAAN,KAAyB,cAAhC;AACD;;;;;AAED,aAAA,iBAAA,CAA2B,MAA3B,EAA2C;AACzC,eAAO,OAAO,MAAP,CACH,CAAC,GAAD,EAAM,KAAN,KAAe;AACb,kBAAM,CAAC,KAAD,EAAQ,QAAR,IAAoB,MAAM,KAAN,CAAY,GAAZ,EAAiB,GAAjB,CAAqB,SAAS,MAAM,IAAN,EAA9B,CAA1B;AACA,gBAAI,KAAJ,IAAa,YAAY,KAAzB;AACA,mBAAO,GAAP;AACD,SALE,EAKF,gBACD,EANG,CAAP;AAOD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool, R3DirectiveMetadata, WrappedNodeExpr, compileComponentFromMetadata as compileR3Component, compileDirectiveFromMetadata as compileR3Directive, jitExpression, makeBindingParser, parseHostBindings, parseTemplate} from '@angular/compiler';\n\nimport {Component, Directive, HostBinding, HostListener, Input, Output} from '../../metadata/directives';\nimport {componentNeedsResolution, maybeQueueResolutionOfComponentResources} from '../../metadata/resource_loading';\nimport {ReflectionCapabilities} from '../../reflection/reflection_capabilities';\nimport {Type} from '../../type';\nimport {stringify} from '../../util';\n\nimport {angularCoreEnv} from './environment';\nimport {NG_COMPONENT_DEF, NG_DIRECTIVE_DEF} from './fields';\nimport {patchComponentDefWithScope} from './module';\nimport {getReflect, reflectDependencies} from './util';\n\ntype StringMap = {\n  [key: string]: string\n};\n\n/**\n * Compile an Angular component according to its decorator metadata, and patch the resulting\n * ngComponentDef onto the component type.\n *\n * Compilation may be asynchronous (due to the need to resolve URLs for the component template or\n * other resources, for example). In the event that compilation is not immediate, `compileComponent`\n * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`\n * until the global queue has been resolved with a call to `resolveComponentResources`.\n */\nexport function compileComponent(type: Type<any>, metadata: Component): void {\n  let def: any = null;\n  // Metadata may have resources which need to be resolved.\n  maybeQueueResolutionOfComponentResources(metadata);\n  Object.defineProperty(type, NG_COMPONENT_DEF, {\n    get: () => {\n      if (def === null) {\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${stringify(type)}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${stringify(metadata.templateUrl)}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join('\\n'));\n        }\n        // The ConstantPool is a requirement of the JIT'er.\n        const constantPool = new ConstantPool();\n\n        // Parse the template and check for errors.\n        const template =\n            parseTemplate(metadata.template !, `ng://${stringify(type)}/template.html`, {\n              preserveWhitespaces: metadata.preserveWhitespaces || false,\n            });\n        if (template.errors !== undefined) {\n          const errors = template.errors.map(err => err.toString()).join(', ');\n          throw new Error(\n              `Errors during JIT compilation of template for ${stringify(type)}: ${errors}`);\n        }\n\n        // Compile the component metadata, including template, into an expression.\n        // TODO(alxhub): implement inputs, outputs, queries, etc.\n        const res = compileR3Component(\n            {\n              ...directiveMetadata(type, metadata),\n              template,\n              directives: new Map(),\n              pipes: new Map(),\n              viewQueries: [],\n            },\n            constantPool, makeBindingParser());\n\n        def = jitExpression(\n            res.expression, angularCoreEnv, `ng://${type.name}/ngComponentDef.js`, constantPool);\n\n        // If component compilation is async, then the @NgModule annotation which declares the\n        // component may execute and set an ngSelectorScope property on the component type. This\n        // allows the component to patch itself with directiveDefs from the module after it finishes\n        // compiling.\n        if (hasSelectorScope(type)) {\n          patchComponentDefWithScope(def, type.ngSelectorScope);\n        }\n      }\n      return def;\n    },\n  });\n}\n\nfunction hasSelectorScope<T>(component: Type<T>): component is Type<T>&\n    {ngSelectorScope: Type<any>} {\n  return (component as{ngSelectorScope?: any}).ngSelectorScope !== undefined;\n}\n\n/**\n * Compile an Angular directive according to its decorator metadata, and patch the resulting\n * ngDirectiveDef onto the component type.\n *\n * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which\n * will resolve when compilation completes and the directive becomes usable.\n */\nexport function compileDirective(type: Type<any>, directive: Directive): void {\n  let def: any = null;\n  Object.defineProperty(type, NG_DIRECTIVE_DEF, {\n    get: () => {\n      if (def === null) {\n        const constantPool = new ConstantPool();\n        const sourceMapUrl = `ng://${type && type.name}/ngDirectiveDef.js`;\n        const res = compileR3Directive(\n            directiveMetadata(type, directive), constantPool, makeBindingParser());\n        def = jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool);\n      }\n      return def;\n    },\n  });\n}\n\n\nexport function extendsDirectlyFromObject(type: Type<any>): boolean {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\n\n/**\n * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a\n * `Component`).\n */\nfunction directiveMetadata(type: Type<any>, metadata: Directive): R3DirectiveMetadata {\n  // Reflect inputs and outputs.\n  const propMetadata = getReflect().propMetadata(type);\n\n  const host = extractHostBindings(metadata, propMetadata);\n\n  const inputsFromMetadata = parseInputOutputs(metadata.inputs || []);\n  const outputsFromMetadata = parseInputOutputs(metadata.outputs || []);\n\n  const inputsFromType: StringMap = {};\n  const outputsFromType: StringMap = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] = ann.bindingPropertyName || field;\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.bindingPropertyName || field;\n        }\n      });\n    }\n  }\n\n  return {\n    name: type.name,\n    type: new WrappedNodeExpr(type),\n    typeArgumentCount: 0,\n    selector: metadata.selector !,\n    deps: reflectDependencies(type), host,\n    inputs: {...inputsFromMetadata, ...inputsFromType},\n    outputs: {...outputsFromMetadata, ...outputsFromType},\n    queries: [],\n    lifecycle: {\n      usesOnChanges: type.prototype.ngOnChanges !== undefined,\n    },\n    typeSourceSpan: null !,\n    usesInheritance: !extendsDirectlyFromObject(type),\n  };\n}\n\nfunction extractHostBindings(metadata: Directive, propMetadata: {[key: string]: any[]}): {\n  attributes: StringMap,\n  listeners: StringMap,\n  properties: StringMap,\n} {\n  // First parse the declarations from the metadata.\n  const {attributes, listeners, properties, animations} = parseHostBindings(metadata.host || {});\n\n  if (Object.keys(animations).length > 0) {\n    throw new Error(`Animation bindings are as-of-yet unsupported in Ivy`);\n  }\n\n  // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          properties[ann.hostPropertyName || field] = field;\n        } else if (isHostListener(ann)) {\n          listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n\n  return {attributes, listeners, properties};\n}\n\nfunction isInput(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value: any): value is Output {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction isHostBinding(value: any): value is HostBinding {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value: any): value is HostListener {\n  return value.ngMetadataName === 'HostListener';\n}\n\nfunction parseInputOutputs(values: string[]): StringMap {\n  return values.reduce(\n      (map, value) => {\n        const [field, property] = value.split(',').map(piece => piece.trim());\n        map[field] = property || field;\n        return map;\n      },\n      {} as StringMap);\n}\n"],"sourceRoot":""}