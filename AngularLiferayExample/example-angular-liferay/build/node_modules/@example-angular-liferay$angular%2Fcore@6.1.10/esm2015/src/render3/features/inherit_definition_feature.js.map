{"version":3,"sources":["../../../../../../../../packages/core/src/render3/features/inherit_definition_feature.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../type';\nimport {ComponentDefInternal, ComponentType, DirectiveDefFeature, DirectiveDefInternal} from '../interfaces/definition';\n\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nfunction fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n/**\n * Determines if a definition is a {@link ComponentDefInternal} or a {@link DirectiveDefInternal}\n * @param definition The definition to examine\n */\nfunction isComponentDef<T>(definition: ComponentDefInternal<T>| DirectiveDefInternal<T>):\n    definition is ComponentDefInternal<T> {\n  const def = definition as ComponentDefInternal<T>;\n  return typeof def.template === 'function';\n}\n\nfunction getSuperType(type: Type<any>): Type<any>&\n    {ngComponentDef?: ComponentDefInternal<any>, ngDirectiveDef?: DirectiveDefInternal<any>} {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\n\n/**\n * Merges the definition from a super class to a sub class.\n * @param definition The definition that is a SubClass of another directive of component\n */\nexport function InheritDefinitionFeature(\n    definition: DirectiveDefInternal<any>| ComponentDefInternal<any>): void {\n  let superType = getSuperType(definition.type);\n  let superDef: DirectiveDefInternal<any>|ComponentDefInternal<any>|undefined = undefined;\n\n  while (superType && !superDef) {\n    if (isComponentDef(definition)) {\n      superDef = superType.ngComponentDef || superType.ngDirectiveDef;\n    } else {\n      if (superType.ngComponentDef) {\n        throw new Error('Directives cannot inherit Components');\n      }\n      superDef = superType.ngDirectiveDef;\n    }\n\n    if (superDef) {\n      // Merge inputs and outputs\n      fillProperties(definition.inputs, superDef.inputs);\n      fillProperties(definition.declaredInputs, superDef.declaredInputs);\n      fillProperties(definition.outputs, superDef.outputs);\n\n      // Merge hostBindings\n      const prevHostBindings = definition.hostBindings;\n      const superHostBindings = superDef.hostBindings;\n      if (superHostBindings) {\n        if (prevHostBindings) {\n          definition.hostBindings = (directiveIndex: number, elementIndex: number) => {\n            superHostBindings(directiveIndex, elementIndex);\n            prevHostBindings(directiveIndex, elementIndex);\n          };\n        } else {\n          definition.hostBindings = superHostBindings;\n        }\n      }\n\n      // Inherit hooks\n      // Assume super class inheritance feature has already run.\n      definition.afterContentChecked =\n          definition.afterContentChecked || superDef.afterContentChecked;\n      definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;\n      definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;\n      definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;\n      definition.doCheck = definition.doCheck || superDef.doCheck;\n      definition.onDestroy = definition.onDestroy || superDef.onDestroy;\n      definition.onInit = definition.onInit || superDef.onInit;\n\n      // Run parent features\n      const features = superDef.features;\n      if (features) {\n        for (const feature of features) {\n          if (feature && feature !== InheritDefinitionFeature) {\n            (feature as DirectiveDefFeature)(definition);\n          }\n        }\n      }\n    } else {\n      // Even if we don't have a definition, check the type for the hooks and use those if need be\n      const superPrototype = superType.prototype;\n\n      if (superPrototype) {\n        definition.afterContentChecked =\n            definition.afterContentChecked || superPrototype.afterContentChecked;\n        definition.afterContentInit =\n            definition.afterContentInit || superPrototype.afterContentInit;\n        definition.afterViewChecked =\n            definition.afterViewChecked || superPrototype.afterViewChecked;\n        definition.afterViewInit = definition.afterViewInit || superPrototype.afterViewInit;\n        definition.doCheck = definition.doCheck || superPrototype.doCheck;\n        definition.onDestroy = definition.onDestroy || superPrototype.onDestroy;\n        definition.onInit = definition.onInit || superPrototype.onInit;\n      }\n    }\n\n    superType = Object.getPrototypeOf(superType);\n  }\n}\n"],"sourceRoot":""}