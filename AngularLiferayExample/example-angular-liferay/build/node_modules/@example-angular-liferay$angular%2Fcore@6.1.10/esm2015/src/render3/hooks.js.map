{"version":3,"sources":["../../../../../../../packages/core/src/render3/hooks.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual} from './assert';\nimport {DirectiveDefInternal} from './interfaces/definition';\nimport {TNodeFlags} from './interfaces/node';\nimport {DIRECTIVES, FLAGS, HookData, LViewData, LViewFlags, TView} from './interfaces/view';\n\n\n/**\n * If this is the first template pass, any ngOnInit or ngDoCheck hooks will be queued into\n * TView.initHooks during directiveCreate.\n *\n * The directive index and hook type are encoded into one number (1st bit: type, remaining bits:\n * directive index), then saved in the even indices of the initHooks array. The odd indices\n * hold the hook functions themselves.\n *\n * @param index The index of the directive in LViewData[DIRECTIVES]\n * @param hooks The static hooks map on the directive def\n * @param tView The current TView\n */\nexport function queueInitHooks(\n    index: number, onInit: (() => void) | null, doCheck: (() => void) | null, tView: TView): void {\n  ngDevMode &&\n      assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');\n  if (onInit) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, onInit);\n  }\n\n  if (doCheck) {\n    (tView.initHooks || (tView.initHooks = [])).push(index, doCheck);\n    (tView.checkHooks || (tView.checkHooks = [])).push(index, doCheck);\n  }\n}\n\n/**\n * Loops through the directives on a node and queues all their hooks except ngOnInit\n * and ngDoCheck, which are queued separately in directiveCreate.\n */\nexport function queueLifecycleHooks(flags: number, tView: TView): void {\n  if (tView.firstTemplatePass) {\n    const start = flags >> TNodeFlags.DirectiveStartingIndexShift;\n    const count = flags & TNodeFlags.DirectiveCountMask;\n    const end = start + count;\n\n    // It's necessary to loop through the directives at elementEnd() (rather than processing in\n    // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n    // hooks for projected components and directives must be called *before* their hosts.\n    for (let i = start; i < end; i++) {\n      const def: DirectiveDefInternal<any> = tView.directives ![i];\n      queueContentHooks(def, tView, i);\n      queueViewHooks(def, tView, i);\n      queueDestroyHooks(def, tView, i);\n    }\n  }\n}\n\n/** Queues afterContentInit and afterContentChecked hooks on TView */\nfunction queueContentHooks(def: DirectiveDefInternal<any>, tView: TView, i: number): void {\n  if (def.afterContentInit) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentInit);\n  }\n\n  if (def.afterContentChecked) {\n    (tView.contentHooks || (tView.contentHooks = [])).push(i, def.afterContentChecked);\n    (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, def.afterContentChecked);\n  }\n}\n\n/** Queues afterViewInit and afterViewChecked hooks on TView */\nfunction queueViewHooks(def: DirectiveDefInternal<any>, tView: TView, i: number): void {\n  if (def.afterViewInit) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewInit);\n  }\n\n  if (def.afterViewChecked) {\n    (tView.viewHooks || (tView.viewHooks = [])).push(i, def.afterViewChecked);\n    (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, def.afterViewChecked);\n  }\n}\n\n/** Queues onDestroy hooks on TView */\nfunction queueDestroyHooks(def: DirectiveDefInternal<any>, tView: TView, i: number): void {\n  if (def.onDestroy != null) {\n    (tView.destroyHooks || (tView.destroyHooks = [])).push(i, def.onDestroy);\n  }\n}\n\n/**\n * Calls onInit and doCheck calls if they haven't already been called.\n *\n * @param currentView The current view\n */\nexport function executeInitHooks(\n    currentView: LViewData, tView: TView, creationMode: boolean): void {\n  if (currentView[FLAGS] & LViewFlags.RunInit) {\n    executeHooks(currentView[DIRECTIVES] !, tView.initHooks, tView.checkHooks, creationMode);\n    currentView[FLAGS] &= ~LViewFlags.RunInit;\n  }\n}\n\n/**\n * Iterates over afterViewInit and afterViewChecked functions and calls them.\n *\n * @param currentView The current view\n */\nexport function executeHooks(\n    data: any[], allHooks: HookData | null, checkHooks: HookData | null,\n    creationMode: boolean): void {\n  const hooksToCall = creationMode ? allHooks : checkHooks;\n  if (hooksToCall) {\n    callHooks(data, hooksToCall);\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * creation mode.\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n */\nexport function callHooks(data: any[], arr: HookData): void {\n  for (let i = 0; i < arr.length; i += 2) {\n    (arr[i + 1] as() => void).call(data[arr[i] as number]);\n  }\n}\n"],"sourceRoot":""}