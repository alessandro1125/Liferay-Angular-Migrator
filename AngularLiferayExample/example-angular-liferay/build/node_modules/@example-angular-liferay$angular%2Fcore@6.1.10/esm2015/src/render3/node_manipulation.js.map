{"version":3,"sources":["../../../../../../../packages/core/src/render3/node_manipulation.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from './assert';\nimport {callHooks} from './hooks';\nimport {LContainer, RENDER_PARENT, VIEWS, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {LContainerNode, LElementNode, LNode, LProjectionNode, LTextNode, LViewNode, TNode, TNodeFlags, TNodeType, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RComment, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {CLEANUP, CONTAINER_INDEX, DIRECTIVES, FLAGS, HEADER_OFFSET, HOST_NODE, HookData, LViewData, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {readElementValue, stringify} from './util';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\n/** Retrieves the sibling node for the given node. */\nexport function getNextLNode(node: LNode): LNode|null {\n  // View nodes don't have TNodes, so their next must be retrieved through their LView.\n  if (node.tNode.type === TNodeType.View) {\n    const viewData = node.data as LViewData;\n    return viewData[NEXT] ? (viewData[NEXT] as LViewData)[HOST_NODE] : null;\n  }\n  return node.tNode.next ? node.view[node.tNode.next.index] : null;\n}\n\n/** Retrieves the first child of a given node */\nexport function getChildLNode(node: LNode): LNode|null {\n  if (node.tNode.child) {\n    const viewData = node.tNode.type === TNodeType.View ? node.data as LViewData : node.view;\n    return readElementValue(viewData[node.tNode.child.index]);\n  }\n  return null;\n}\n\n/** Retrieves the parent LNode of a given node. */\nexport function getParentLNode(node: LContainerNode | LElementNode | LTextNode | LProjectionNode):\n    LElementNode|LViewNode;\nexport function getParentLNode(node: LViewNode): LContainerNode|null;\nexport function getParentLNode(node: LNode): LElementNode|LContainerNode|LViewNode|null;\nexport function getParentLNode(node: LNode): LElementNode|LContainerNode|LViewNode|null {\n  if (node.tNode.index === -1 && node.tNode.type === TNodeType.View) {\n    // This is a dynamically created view inside a dynamic container.\n    // If the host index is -1, the view has not yet been inserted, so it has no parent.\n    const containerHostIndex = (node.data as LViewData)[CONTAINER_INDEX];\n    return containerHostIndex === -1 ? null : node.view[containerHostIndex].dynamicLContainerNode;\n  }\n  const parent = node.tNode.parent;\n  return readElementValue(parent ? node.view[parent.index] : node.view[HOST_NODE]);\n}\n\nconst enum WalkLNodeTreeAction {\n  /** node insert in the native environment */\n  Insert = 0,\n\n  /** node detach from the native environment */\n  Detach = 1,\n\n  /** node destruction using the renderer's API */\n  Destroy = 2,\n}\n\n\n/**\n * Stack used to keep track of projection nodes in walkLNodeTree.\n *\n * This is deliberately created outside of walkLNodeTree to avoid allocating\n * a new array each time the function is called. Instead the array will be\n * re-used by each invocation. This works because the function is not reentrant.\n */\nconst projectionNodeStack: LProjectionNode[] = [];\n\n/**\n * Walks a tree of LNodes, applying a transformation on the LElement nodes, either only on the first\n * one found, or on all of them.\n *\n * @param startingNode the node from which the walk is started.\n * @param rootNode the root node considered. This prevents walking past that node.\n * @param action identifies the action to be performed on the LElement nodes.\n * @param renderer the current renderer.\n * @param renderParentNode Optional the render parent node to be set in all LContainerNodes found,\n * required for action modes Insert and Destroy.\n * @param beforeNode Optional the node before which elements should be added, required for action\n * Insert.\n */\nfunction walkLNodeTree(\n    startingNode: LNode | null, rootNode: LNode, action: WalkLNodeTreeAction, renderer: Renderer3,\n    renderParentNode?: LElementNode | null, beforeNode?: RNode | null) {\n  let node: LNode|null = startingNode;\n  let projectionNodeIndex = -1;\n  while (node) {\n    let nextNode: LNode|null = null;\n    const parent = renderParentNode ? renderParentNode.native : null;\n    const nodeType = node.tNode.type;\n    if (nodeType === TNodeType.Element) {\n      // Execute the action\n      executeNodeAction(action, renderer, parent, node.native !, beforeNode);\n      if (node.dynamicLContainerNode) {\n        executeNodeAction(\n            action, renderer, parent, node.dynamicLContainerNode.native !, beforeNode);\n      }\n    } else if (nodeType === TNodeType.Container) {\n      executeNodeAction(action, renderer, parent, node.native !, beforeNode);\n      const lContainerNode: LContainerNode = (node as LContainerNode);\n      const childContainerData: LContainer = lContainerNode.dynamicLContainerNode ?\n          lContainerNode.dynamicLContainerNode.data :\n          lContainerNode.data;\n      if (renderParentNode) {\n        childContainerData[RENDER_PARENT] = renderParentNode;\n      }\n      nextNode =\n          childContainerData[VIEWS].length ? getChildLNode(childContainerData[VIEWS][0]) : null;\n      if (nextNode) {\n        // When the walker enters a container, then the beforeNode has to become the local native\n        // comment node.\n        beforeNode = lContainerNode.dynamicLContainerNode ?\n            lContainerNode.dynamicLContainerNode.native :\n            lContainerNode.native;\n      }\n    } else if (nodeType === TNodeType.Projection) {\n      const componentHost = findComponentHost(node.view);\n      const head =\n          (componentHost.tNode.projection as(TNode | null)[])[node.tNode.projection as number];\n\n      projectionNodeStack[++projectionNodeIndex] = node as LProjectionNode;\n\n      nextNode = head ? (componentHost.data as LViewData)[PARENT] ![head.index] : null;\n    } else {\n      // Otherwise look at the first child\n      nextNode = getChildLNode(node as LViewNode);\n    }\n\n    if (nextNode === null) {\n      nextNode = getNextLNode(node);\n\n      // this last node was projected, we need to get back down to its projection node\n      if (nextNode === null && (node.tNode.flags & TNodeFlags.isProjected)) {\n        nextNode = getNextLNode(projectionNodeStack[projectionNodeIndex--] as LNode);\n      }\n      /**\n       * Find the next node in the LNode tree, taking into account the place where a node is\n       * projected (in the shadow DOM) rather than where it comes from (in the light DOM).\n       *\n       * If there is no sibling node, then it goes to the next sibling of the parent node...\n       * until it reaches rootNode (at which point null is returned).\n       */\n      while (node && !nextNode) {\n        node = getParentLNode(node);\n        if (node === null || node === rootNode) return null;\n\n        // When exiting a container, the beforeNode must be restored to the previous value\n        if (!node.tNode.next && nodeType === TNodeType.Container) {\n          beforeNode = node.native;\n        }\n        nextNode = getNextLNode(node);\n      }\n    }\n    node = nextNode;\n  }\n}\n\n\n/**\n * Given a current view, finds the nearest component's host (LElement).\n *\n * @param lViewData LViewData for which we want a host element node\n * @returns The host node\n */\nexport function findComponentHost(lViewData: LViewData): LElementNode {\n  let viewRootLNode = lViewData[HOST_NODE];\n\n  while (viewRootLNode.tNode.type === TNodeType.View) {\n    ngDevMode && assertDefined(lViewData[PARENT], 'lViewData.parent');\n    lViewData = lViewData[PARENT] !;\n    viewRootLNode = lViewData[HOST_NODE];\n  }\n\n  ngDevMode && assertNodeType(viewRootLNode, TNodeType.Element);\n  ngDevMode && assertDefined(viewRootLNode.data, 'node.data');\n\n  return viewRootLNode as LElementNode;\n}\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction executeNodeAction(\n    action: WalkLNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    node: RComment | RElement | RText, beforeNode?: RNode | null) {\n  if (action === WalkLNodeTreeAction.Insert) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).insertBefore(parent !, node, beforeNode as RNode | null) :\n        parent !.insertBefore(node, beforeNode as RNode | null, true);\n  } else if (action === WalkLNodeTreeAction.Detach) {\n    isProceduralRenderer(renderer !) ?\n        (renderer as ProceduralRenderer3).removeChild(parent !, node) :\n        parent !.removeChild(node);\n  } else if (action === WalkLNodeTreeAction.Destroy) {\n    ngDevMode && ngDevMode.rendererDestroyNode++;\n    (renderer as ProceduralRenderer3).destroyNode !(node);\n  }\n}\n\nexport function createTextNode(value: any, renderer: Renderer3): RText {\n  return isProceduralRenderer(renderer) ? renderer.createText(stringify(value)) :\n                                          renderer.createTextNode(stringify(value));\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param container The container to which the root view belongs\n * @param rootNode The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: true,\n    beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: false): void;\nexport function addRemoveViewFromContainer(\n    container: LContainerNode, rootNode: LViewNode, insertMode: boolean,\n    beforeNode?: RNode | null): void {\n  ngDevMode && assertNodeType(container, TNodeType.Container);\n  ngDevMode && assertNodeType(rootNode, TNodeType.View);\n  const parentNode = container.data[RENDER_PARENT];\n  const parent = parentNode ? parentNode.native : null;\n  if (parent) {\n    let node: LNode|null = getChildLNode(rootNode);\n    const renderer = container.view[RENDERER];\n    walkLNodeTree(\n        node, rootNode, insertMode ? WalkLNodeTreeAction.Insert : WalkLNodeTreeAction.Detach,\n        renderer, parentNode, beforeNode);\n  }\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LViewData): void {\n  // If the view has no children, we can clean it up and return early.\n  if (rootView[TVIEW].childIndex === -1) {\n    return cleanUpView(rootView);\n  }\n  let viewOrContainer: LViewData|LContainer|null = getLViewChild(rootView);\n\n  while (viewOrContainer) {\n    let next: LViewData|LContainer|null = null;\n\n    if (viewOrContainer.length >= HEADER_OFFSET) {\n      // If LViewData, traverse down to child.\n      const view = viewOrContainer as LViewData;\n      if (view[TVIEW].childIndex > -1) next = getLViewChild(view);\n    } else {\n      // If container, traverse down to its first LViewData.\n      const container = viewOrContainer as LContainer;\n      if (container[VIEWS].length) next = container[VIEWS][0].data;\n    }\n\n    if (next == null) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (viewOrContainer && !viewOrContainer ![NEXT] && viewOrContainer !== rootView) {\n        cleanUpView(viewOrContainer);\n        viewOrContainer = getParentState(viewOrContainer, rootView);\n      }\n      cleanUpView(viewOrContainer || rootView);\n      next = viewOrContainer && viewOrContainer ![NEXT];\n    }\n    viewOrContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param container The container into which the view should be inserted\n * @param viewNode The view to insert\n * @param index The index at which to insert the view\n * @returns The inserted view\n */\nexport function insertView(\n    container: LContainerNode, viewNode: LViewNode, index: number): LViewNode {\n  const state = container.data;\n  const views = state[VIEWS];\n  const lView = viewNode.data as LViewData;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    views[index - 1].data[NEXT] = lView;\n  }\n\n  if (index < views.length) {\n    lView[NEXT] = views[index].data;\n    views.splice(index, 0, viewNode);\n  } else {\n    views.push(viewNode);\n    lView[NEXT] = null;\n  }\n\n  // Dynamically inserted views need a reference to their parent container'S host so it's\n  // possible to jump from a view to its container's next when walking the node tree.\n  if (viewNode.tNode.index === -1) {\n    lView[CONTAINER_INDEX] = container.tNode.parent !.index;\n    (viewNode as{view: LViewData}).view = container.view;\n  }\n\n  // Notify query that a new view has been added\n  if (lView[QUERIES]) {\n    lView[QUERIES] !.insertView(index);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n\n  return viewNode;\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method splices the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param container The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns The detached view\n */\nexport function detachView(container: LContainerNode, removeIndex: number): LViewNode {\n  const views = container.data[VIEWS];\n  const viewNode = views[removeIndex];\n  if (removeIndex > 0) {\n    views[removeIndex - 1].data[NEXT] = viewNode.data[NEXT] as LViewData;\n  }\n  views.splice(removeIndex, 1);\n  if (!container.tNode.detached) {\n    addRemoveViewFromContainer(container, viewNode, false);\n  }\n  // Notify query that view has been removed\n  const removedLView = viewNode.data;\n  if (removedLView[QUERIES]) {\n    removedLView[QUERIES] !.removeView();\n  }\n  removedLView[CONTAINER_INDEX] = -1;\n  (viewNode as{view: LViewData | null}).view = null;\n  // Unsets the attached flag\n  viewNode.data[FLAGS] &= ~LViewFlags.Attached;\n  return viewNode;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param container The container from which to remove a view\n * @param removeIndex The index of the view to remove\n * @returns The removed view\n */\nexport function removeView(container: LContainerNode, removeIndex: number): LViewNode {\n  const viewNode = container.data[VIEWS][removeIndex];\n  detachView(container, removeIndex);\n  destroyLView(viewNode.data);\n  return viewNode;\n}\n\n/** Gets the child of the given LViewData */\nexport function getLViewChild(viewData: LViewData): LViewData|LContainer|null {\n  if (viewData[TVIEW].childIndex === -1) return null;\n\n  const hostNode: LElementNode|LContainerNode = viewData[viewData[TVIEW].childIndex];\n\n  return hostNode.data ? hostNode.data : (hostNode.dynamicLContainerNode as LContainerNode).data;\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting cleanup (e.g. removing listeners, calling onDestroys).\n *\n * @param view The view to be destroyed.\n */\nexport function destroyLView(view: LViewData) {\n  const renderer = view[RENDERER];\n  if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n    walkLNodeTree(view[HOST_NODE], view[HOST_NODE], WalkLNodeTreeAction.Destroy, renderer);\n  }\n  destroyViewTree(view);\n  // Sets the destroyed flag\n  view[FLAGS] |= LViewFlags.Destroyed;\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param state The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(state: LViewData | LContainer, rootView: LViewData): LViewData|\n    LContainer|null {\n  let node;\n  if ((node = (state as LViewData) ![HOST_NODE]) && node.tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getParentLNode(node) !.data as any;\n  } else {\n    // otherwise, use parent view for containers or component views\n    return state[PARENT] === rootView ? null : state[PARENT];\n  }\n}\n\n/**\n * Removes all listeners and call all onDestroys in a given view.\n *\n * @param view The LViewData to clean up\n */\nfunction cleanUpView(viewOrContainer: LViewData | LContainer): void {\n  if ((viewOrContainer as LViewData)[TVIEW]) {\n    const view = viewOrContainer as LViewData;\n    removeListeners(view);\n    executeOnDestroys(view);\n    executePipeOnDestroys(view);\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (view[TVIEW].id === -1 && isProceduralRenderer(view[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (view[RENDERER] as ProceduralRenderer3).destroy();\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(viewData: LViewData): void {\n  const cleanup = viewData[TVIEW].cleanup !;\n  if (cleanup != null) {\n    for (let i = 0; i < cleanup.length - 1; i += 2) {\n      if (typeof cleanup[i] === 'string') {\n        // This is a listener with the native renderer\n        const native = readElementValue(viewData[cleanup[i + 1]]).native;\n        const listener = viewData[CLEANUP] ![cleanup[i + 2]];\n        native.removeEventListener(cleanup[i], listener, cleanup[i + 3]);\n        i += 2;\n      } else if (typeof cleanup[i] === 'number') {\n        // This is a listener with renderer2 (cleanup fn can be found by index)\n        const cleanupFn = viewData[CLEANUP] ![cleanup[i]];\n        cleanupFn();\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = viewData[CLEANUP] ![cleanup[i + 1]];\n        cleanup[i].call(context);\n      }\n    }\n    viewData[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(view: LViewData): void {\n  const tView = view[TVIEW];\n  let destroyHooks: HookData|null;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    callHooks(view[DIRECTIVES] !, destroyHooks);\n  }\n}\n\n/** Calls pipe destroy hooks for this view */\nfunction executePipeOnDestroys(viewData: LViewData): void {\n  const pipeDestroyHooks = viewData[TVIEW] && viewData[TVIEW].pipeDestroyHooks;\n  if (pipeDestroyHooks) {\n    callHooks(viewData !, pipeDestroyHooks);\n  }\n}\n\n/**\n * Returns whether a native element can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is mare for projection but has not been inserted\n *   into destination.\n *\n\n *\n * @param parent The parent where the child will be inserted into.\n * @param currentView Current LView being processed.\n * @return boolean Whether the child should be inserted now (or delayed until later).\n */\nexport function canInsertNativeNode(parent: LNode, currentView: LViewData): boolean {\n  // We can only insert into a Component or View. Any other type should be an Error.\n  ngDevMode && assertNodeOfPossibleTypes(parent, TNodeType.Element, TNodeType.View);\n\n  if (parent.tNode.type === TNodeType.Element) {\n    // Parent is an element.\n    if (parent.view !== currentView) {\n      // If the Parent view is not the same as current view than we are inserting across\n      // Views. This happens when we insert a root element of the component view into\n      // the component host element and it should always be eager.\n      return true;\n    }\n    // Parent elements can be a component which may have projection.\n    if (parent.data === null) {\n      // Parent is a regular non-component element. We should eagerly insert into it\n      // since we know that this relationship will never be broken.\n      return true;\n    } else {\n      // Parent is a Component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since the projection would than move it to its final destination.\n      return false;\n    }\n  } else {\n    // Parent is a View.\n    ngDevMode && assertNodeType(parent, TNodeType.View);\n\n    // Because we are inserting into a `View` the `View` may be disconnected.\n    const grandParentContainer = getParentLNode(parent) as LContainerNode;\n    if (grandParentContainer == null) {\n      // The `View` is not inserted into a `Container` we have to delay insertion.\n      return false;\n    }\n    ngDevMode && assertNodeType(grandParentContainer, TNodeType.Container);\n    if (grandParentContainer.data[RENDER_PARENT] == null) {\n      // The parent `Container` itself is disconnected. So we have to delay.\n      return false;\n    } else {\n      // The parent `Container` is in inserted state, so we can eagerly insert into\n      // this location.\n      return true;\n    }\n  }\n}\n\n/**\n * Appends the `child` element to the `parent`.\n *\n * The element insertion might be delayed {@link canInsertNativeNode}.\n *\n * @param parent The parent to which to append the child\n * @param child The child that should be appended\n * @param currentView The current LView\n * @returns Whether or not the child was appended\n */\nexport function appendChild(parent: LNode, child: RNode | null, currentView: LViewData): boolean {\n  if (child !== null && canInsertNativeNode(parent, currentView)) {\n    const renderer = currentView[RENDERER];\n    if (parent.tNode.type === TNodeType.View) {\n      const container = getParentLNode(parent) as LContainerNode;\n      const renderParent = container.data[RENDER_PARENT];\n      const views = container.data[VIEWS];\n      const index = views.indexOf(parent as LViewNode);\n      const beforeNode =\n          index + 1 < views.length ? (getChildLNode(views[index + 1]) !).native : container.native;\n      isProceduralRenderer(renderer) ?\n          renderer.insertBefore(renderParent !.native, child, beforeNode) :\n          renderParent !.native.insertBefore(child, beforeNode, true);\n    } else {\n      isProceduralRenderer(renderer) ? renderer.appendChild(parent.native !as RElement, child) :\n                                       parent.native !.appendChild(child);\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Removes the `child` element of the `parent` from the DOM.\n *\n * @param parent The parent from which to remove the child\n * @param child The child that should be removed\n * @param currentView The current LView\n * @returns Whether or not the child was removed\n */\nexport function removeChild(parent: LNode, child: RNode | null, currentView: LViewData): boolean {\n  if (child !== null && canInsertNativeNode(parent, currentView)) {\n    // We only remove the element if not in View or not projected.\n    const renderer = currentView[RENDERER];\n    isProceduralRenderer(renderer) ? renderer.removeChild(parent.native as RElement, child) :\n                                     parent.native !.removeChild(child);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Appends a projected node to the DOM, or in the case of a projected container,\n * appends the nodes from all of the container's active views to the DOM.\n *\n * @param node The node to process\n * @param currentParent The last parent element to be processed\n * @param currentView Current LView\n */\nexport function appendProjectedNode(\n    node: LElementNode | LTextNode | LContainerNode, currentParent: LElementNode | LViewNode,\n    currentView: LViewData, renderParent: LElementNode): void {\n  appendChild(currentParent, node.native, currentView);\n  if (node.tNode.type === TNodeType.Container) {\n    // The node we are adding is a container and we are adding it to an element which\n    // is not a component (no more re-projection).\n    // Alternatively a container is projected at the root of a component's template\n    // and can't be re-projected (as not content of any component).\n    // Assign the final projection location in those cases.\n    const lContainer = (node as LContainerNode).data;\n    lContainer[RENDER_PARENT] = renderParent;\n    const views = lContainer[VIEWS];\n    for (let i = 0; i < views.length; i++) {\n      addRemoveViewFromContainer(node as LContainerNode, views[i], true, node.native);\n    }\n  }\n  if (node.dynamicLContainerNode) {\n    node.dynamicLContainerNode.data[RENDER_PARENT] = renderParent;\n    appendChild(currentParent, node.dynamicLContainerNode.native, currentView);\n  }\n}\n"],"sourceRoot":""}