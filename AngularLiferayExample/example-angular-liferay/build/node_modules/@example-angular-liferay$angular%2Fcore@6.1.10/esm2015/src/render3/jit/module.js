Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm2015/src/render3/jit/module', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { WrappedNodeExpr, compileInjector, compileNgModule as compileR3NgModule, jitExpression } from '@angular/compiler';
    import { angularCoreEnv } from './environment';
    import { NG_COMPONENT_DEF, NG_DIRECTIVE_DEF, NG_INJECTOR_DEF, NG_MODULE_DEF, NG_PIPE_DEF } from './fields';
    import { reflectDependencies } from './util';
    /** @type {?} */
    const EMPTY_ARRAY = [];
    /**
     * @param {?} type
     * @param {?} ngModule
     * @return {?}
     */
    export function compileNgModule(type, ngModule) {
        /** @type {?} */
        const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);
        /** @type {?} */
        let ngModuleDef = null;
        Object.defineProperty(type, NG_MODULE_DEF, {
            get: () => {
                if (ngModuleDef === null) {
                    /** @type {?} */
                    const meta = {
                        type: wrap(type),
                        bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(wrap),
                        declarations: declarations.map(wrap),
                        imports: flatten(ngModule.imports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),
                        exports: flatten(ngModule.exports || EMPTY_ARRAY).map(expandModuleWithProviders).map(wrap),
                        emitInline: true
                    };
                    /** @type {?} */
                    const res = compileR3NgModule(meta);
                    ngModuleDef = jitExpression(res.expression, angularCoreEnv, `ng://${type.name}/ngModuleDef.js`);
                }
                return ngModuleDef;
            }
        });
        /** @type {?} */
        let ngInjectorDef = null;
        Object.defineProperty(type, NG_INJECTOR_DEF, {
            get: () => {
                if (ngInjectorDef === null) {
                    /** @type {?} */
                    const meta = {
                        name: type.name,
                        type: wrap(type),
                        deps: reflectDependencies(type),
                        providers: new WrappedNodeExpr(ngModule.providers || EMPTY_ARRAY),
                        imports: new WrappedNodeExpr([ngModule.imports || EMPTY_ARRAY, ngModule.exports || EMPTY_ARRAY])
                    };
                    /** @type {?} */
                    const res = compileInjector(meta);
                    ngInjectorDef = jitExpression(res.expression, angularCoreEnv, `ng://${type.name}/ngInjectorDef.js`);
                }
                return ngInjectorDef;
            }
        });
        declarations.forEach(declaration => {
            // Some declared components may be compiled asynchronously, and thus may not have their
            // ngComponentDef set yet. If this is the case, then a reference to the module is written into
            // the `ngSelectorScope` property of the declared type.
            if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {
                // An `ngComponentDef` field exists - go ahead and patch the component directly.
                patchComponentDefWithScope( /** @type {?} */declaration.ngComponentDef, type);
            } else if (!declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
                // Set `ngSelectorScope` for future reference when the component compilation finishes.
                /** @type {?} */declaration.ngSelectorScope = type;
            }
        });
    }
    /**
     * Patch the definition of a component with directives and pipes from the compilation scope of
     * a given module.
     * @template C, M
     * @param {?} componentDef
     * @param {?} module
     * @return {?}
     */
    export function patchComponentDefWithScope(componentDef, module) {
        componentDef.directiveDefs = () => Array.from(transitiveScopesFor(module).compilation.directives).map(dir => dir.ngDirectiveDef || dir.ngComponentDef).filter(def => !!def);
        componentDef.pipeDefs = () => Array.from(transitiveScopesFor(module).compilation.pipes).map(pipe => pipe.ngPipeDef);
    }
    /**
     * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.
     *
     * This operation is memoized and the result is cached on the module's definition. It can be called
     * on modules with components that have not fully compiled yet, but the result should not be used
     * until they have.
     * @template T
     * @param {?} moduleType
     * @return {?}
     */
    export function transitiveScopesFor(moduleType) {
        if (!isNgModule(moduleType)) {
            throw new Error(`${moduleType.name} does not have an ngModuleDef`);
        }
        /** @type {?} */
        const def = moduleType.ngModuleDef;
        if (def.transitiveCompileScopes !== null) {
            return def.transitiveCompileScopes;
        }
        /** @type {?} */
        const scopes = {
            compilation: {
                directives: new Set(),
                pipes: new Set()
            },
            exported: {
                directives: new Set(),
                pipes: new Set()
            }
        };
        def.declarations.forEach(declared => {
            /** @type {?} */
            const declaredWithDefs = /** @type {?} */declared;
            if (declaredWithDefs.ngPipeDef !== undefined) {
                scopes.compilation.pipes.add(declared);
            } else {
                // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't
                // had its template compiled yet. In either case, it gets added to the compilation's
                // directives.
                scopes.compilation.directives.add(declared);
            }
        });
        def.imports.forEach(imported => {
            /** @type {?} */
            let importedTyped = /** @type {?} */imported;
            if (!isNgModule(importedTyped)) {
                throw new Error(`Importing ${importedTyped.name} which does not have an ngModuleDef`);
            }
            /** @type {?} */
            const importedScope = transitiveScopesFor(importedTyped);
            importedScope.exported.directives.forEach(entry => scopes.compilation.directives.add(entry));
            importedScope.exported.pipes.forEach(entry => scopes.compilation.pipes.add(entry));
        });
        def.exports.forEach(exported => {
            /** @type {?} */
            const exportedTyped = /** @type {?} */exported;
            // Either the type is a module, a pipe, or a component/directive (which may not have an
            // ngComponentDef as it might be compiled asynchronously).
            if (isNgModule(exportedTyped)) {
                /** @type {?} */
                const exportedScope = transitiveScopesFor(exportedTyped);
                exportedScope.exported.directives.forEach(entry => {
                    scopes.compilation.directives.add(entry);
                    scopes.exported.directives.add(entry);
                });
                exportedScope.exported.pipes.forEach(entry => {
                    scopes.compilation.pipes.add(entry);
                    scopes.exported.pipes.add(entry);
                });
            } else if (exportedTyped.ngPipeDef !== undefined) {
                scopes.exported.pipes.add(exportedTyped);
            } else {
                scopes.exported.directives.add(exportedTyped);
            }
        });
        def.transitiveCompileScopes = scopes;
        return scopes;
    }
    /**
     * @template T
     * @param {?} values
     * @return {?}
     */
    function flatten(values) {
        /** @type {?} */
        const out = [];
        values.forEach(value => {
            if (Array.isArray(value)) {
                out.push(...flatten(value));
            } else {
                out.push(value);
            }
        });
        return out;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function expandModuleWithProviders(value) {
        if (isModuleWithProviders(value)) {
            return value.ngModule;
        }
        return value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function wrap(value) {
        return new WrappedNodeExpr(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    function isModuleWithProviders(value) {
        return (/** @type {?} */value.ngModule !== undefined
        );
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */
    function isNgModule(value) {
        return (/** @type {?} */value.ngModuleDef !== undefined
        );
    }
});
//# sourceMappingURL=module.js.map