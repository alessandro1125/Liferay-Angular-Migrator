{"version":3,"sources":["../../../../../../../packages/core/src/render3/node_selector_matcher.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\nimport {assertDefined, assertNotEqual} from './assert';\nimport {AttributeMarker, TAttributes, TNode, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, NG_PROJECT_AS_ATTR_NAME, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nfunction isCssClassMatching(nodeClassAttrVal: string, cssClassToMatch: string): boolean {\n  const nodeClassesLen = nodeClassAttrVal.length;\n  const matchIndex = nodeClassAttrVal !.indexOf(cssClassToMatch);\n  const matchEndIdx = matchIndex + cssClassToMatch.length;\n  if (matchIndex === -1                                                  // no match\n      || (matchIndex > 0 && nodeClassAttrVal ![matchIndex - 1] !== ' ')  // no space before\n      ||\n      (matchEndIdx < nodeClassesLen && nodeClassAttrVal ![matchEndIdx] !== ' '))  // no space after\n  {\n    return false;\n  }\n  return true;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data to match\n * @param selector\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(tNode: TNode, selector: CssSelector): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs !;\n  const selectOnlyMarkerIdx = nodeAttrs ? nodeAttrs.indexOf(AttributeMarker.SelectOnly) : -1;\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current as number)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && current !== tNode.tagName) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const attrName = mode & SelectorFlags.CLASS ? 'class' : current;\n      const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        const maybeAttrName = nodeAttrs[attrIndexInNode];\n        if (selectOnlyMarkerIdx > -1 && attrIndexInNode > selectOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(\n                           maybeAttrName, AttributeMarker.NamespaceURI,\n                           'We do not match directives on namespaced attributes');\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1] as string;\n        }\n        if (mode & SelectorFlags.CLASS &&\n                !isCssClassMatching(nodeAttrValue as string, selectorAttrValue as string) ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines an attributes definition array from a node to find the index of the\n * attribute with the specified name.\n *\n * NOTE: Will not find namespaced attributes.\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n */\nfunction findAttrIndexInNode(name: string, attrs: TAttributes | null): number {\n  if (attrs === null) return -1;\n  let selectOnlyMode = false;\n  let i = 0;\n  while (i < attrs.length) {\n    const maybeAttrName = attrs[i];\n    if (maybeAttrName === name) {\n      return i;\n    } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n      // NOTE(benlesh): will not find namespaced attributes. This is by design.\n      i += 4;\n    } else {\n      if (maybeAttrName === AttributeMarker.SelectOnly) {\n        selectOnlyMode = true;\n      }\n      i += selectOnlyMode ? 1 : 2;\n    }\n  }\n\n  return -1;\n}\n\nexport function isNodeMatchingSelectorList(tNode: TNode, selector: CssSelectorList): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): string|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(NG_PROJECT_AS_ATTR_NAME);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as string;\n    }\n  }\n  return null;\n}\n\n/**\n * Checks a given node against matching selectors and returns\n * selector index (or 0 if none matched).\n *\n * This function takes into account the ngProjectAs attribute: if present its value will be compared\n * to the raw (un-parsed) CSS selector instead of using standard selector matching logic.\n */\nexport function matchingSelectorIndex(\n    tNode: TNode, selectors: CssSelectorList[], textSelectors: string[]): number {\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < selectors.length; i++) {\n    // if a node has the ngProjectAs attribute match it against unparsed selector\n    // match a node against a parsed selector only if ngProjectAs attribute is not present\n    if (ngProjectAsAttrVal === textSelectors[i] ||\n        ngProjectAsAttrVal === null && isNodeMatchingSelectorList(tNode, selectors[i])) {\n      return i + 1;  // first matching selector \"captures\" a given node\n    }\n  }\n  return 0;\n}\n"],"sourceRoot":""}