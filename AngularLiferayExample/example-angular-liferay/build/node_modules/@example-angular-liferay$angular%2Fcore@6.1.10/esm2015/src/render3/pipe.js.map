{"version":3,"sources":["../../../../../../../packages/core/src/render3/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {PipeTransform} from '../change_detection/pipe_transform';\n\nimport {getTView, load, store} from './instructions';\nimport {PipeDefInternal, PipeDefList} from './interfaces/definition';\nimport {HEADER_OFFSET} from './interfaces/view';\nimport {pureFunction1, pureFunction2, pureFunction3, pureFunction4, pureFunctionV} from './pure_function';\n\n/**\n * Create a pipe.\n *\n * @param index Pipe index where the pipe will be stored.\n * @param pipeName The name of the pipe\n * @returns T the instance of the pipe.\n */\nexport function pipe(index: number, pipeName: string): any {\n  const tView = getTView();\n  let pipeDef: PipeDefInternal<any>;\n  const adjustedIndex = index + HEADER_OFFSET;\n\n  if (tView.firstTemplatePass) {\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.pipeDestroyHooks || (tView.pipeDestroyHooks = [\n       ])).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex] as PipeDefInternal<any>;\n  }\n\n  const pipeInstance = pipeDef.factory();\n  store(index, pipeInstance);\n  return pipeInstance;\n}\n\n/**\n * Searches the pipe registry for a pipe with the given name. If one is found,\n * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.\n *\n * @param name Name of pipe to resolve\n * @param registry Full list of available pipes\n * @returns Matching PipeDef\n */\nfunction getPipeDef(name: string, registry: PipeDefList | null): PipeDefInternal<any> {\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  throw new Error(`Pipe with name '${name}' not found!`);\n}\n\n/**\n * Invokes a pipe with 1 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space {@link reserveSlots}\n * @param v1 1st argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind1(index: number, slotOffset: number, v1: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) :\n                         pipeInstance.transform(v1);\n}\n\n/**\n * Invokes a pipe with 2 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space {@link reserveSlots}\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind2(index: number, slotOffset: number, v1: any, v2: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunction2(slotOffset, pipeInstance.transform, v1, v2, pipeInstance) :\n                         pipeInstance.transform(v1, v2);\n}\n\n/**\n * Invokes a pipe with 3 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space {@link reserveSlots}\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 4rd argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind3(index: number, slotOffset: number, v1: any, v2: any, v3: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ?\n      pureFunction3(slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) :\n      pipeInstance.transform(v1, v2, v3);\n}\n\n/**\n * Invokes a pipe with 4 arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space {@link reserveSlots}\n * @param v1 1st argument to {@link PipeTransform#transform}.\n * @param v2 2nd argument to {@link PipeTransform#transform}.\n * @param v3 3rd argument to {@link PipeTransform#transform}.\n * @param v4 4th argument to {@link PipeTransform#transform}.\n */\nexport function pipeBind4(\n    index: number, slotOffset: number, v1: any, v2: any, v3: any, v4: any): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ?\n      pureFunction4(slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) :\n      pipeInstance.transform(v1, v2, v3, v4);\n}\n\n/**\n * Invokes a pipe with variable number of arguments.\n *\n * This instruction acts as a guard to {@link PipeTransform#transform} invoking\n * the pipe only when an input to the pipe changes.\n *\n * @param index Pipe index where the pipe was stored on creation.\n * @param slotOffset the offset in the reserved slot space {@link reserveSlots}\n * @param values Array of arguments to pass to {@link PipeTransform#transform} method.\n */\nexport function pipeBindV(index: number, slotOffset: number, values: any[]): any {\n  const pipeInstance = load<PipeTransform>(index);\n  return isPure(index) ? pureFunctionV(slotOffset, pipeInstance.transform, values, pipeInstance) :\n                         pipeInstance.transform.apply(pipeInstance, values);\n}\n\nfunction isPure(index: number): boolean {\n  return (<PipeDefInternal<any>>getTView().data[index + HEADER_OFFSET]).pure;\n}\n"],"sourceRoot":""}