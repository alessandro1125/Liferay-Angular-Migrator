{"version":3,"sources":["../../../../../../../packages/core/src/testability/testability.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '../di';\nimport {scheduleMicroTask} from '../util';\nimport {NgZone} from '../zone/ng_zone';\n\n/**\n * Testability API.\n * `declare` keyword causes tsickle to generate externs, so these methods are\n * not renamed by Closure Compiler.\n * @experimental\n */\nexport declare interface PublicTestability {\n  isStable(): boolean;\n  whenStable(callback: Function, timeout?: number, updateCallback?: Function): void;\n  findProviders(using: any, provider: string, exactMatch: boolean): any[];\n}\n\n// Angular internal, not intended for public API.\nexport interface PendingMacrotask {\n  source: string;\n  isPeriodic: boolean;\n  delay?: number;\n  creationLocation: Error;\n  xhr?: XMLHttpRequest;\n}\n\n// Angular internal, not intended for public API.\nexport type DoneCallback = (didWork: boolean, tasks?: PendingMacrotask[]) => void;\nexport type UpdateCallback = (tasks: PendingMacrotask[]) => boolean;\n\ninterface WaitCallback {\n  // Needs to be 'any' - setTimeout returns a number according to ES6, but\n  // on NodeJS it returns a Timer.\n  timeoutId: any;\n  doneCb: DoneCallback;\n  updateCb?: UpdateCallback;\n}\n\n/**\n * The Testability service provides testing hooks that can be accessed from\n * the browser and by services such as Protractor. Each bootstrapped Angular\n * application on the page will have an instance of Testability.\n * @experimental\n */\n@Injectable()\nexport class Testability implements PublicTestability {\n  private _pendingCount: number = 0;\n  private _isZoneStable: boolean = true;\n  /**\n   * Whether any work was done since the last 'whenStable' callback. This is\n   * useful to detect if this could have potentially destabilized another\n   * component while it is stabilizing.\n   * @internal\n   */\n  private _didWork: boolean = false;\n  private _callbacks: WaitCallback[] = [];\n\n  private taskTrackingZone: any;\n\n  constructor(private _ngZone: NgZone) {\n    this._watchAngularEvents();\n    _ngZone.run(() => { this.taskTrackingZone = Zone.current.get('TaskTrackingZone'); });\n  }\n\n  private _watchAngularEvents(): void {\n    this._ngZone.onUnstable.subscribe({\n      next: () => {\n        this._didWork = true;\n        this._isZoneStable = false;\n      }\n    });\n\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.subscribe({\n        next: () => {\n          NgZone.assertNotInAngularZone();\n          scheduleMicroTask(() => {\n            this._isZoneStable = true;\n            this._runCallbacksIfReady();\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Increases the number of pending request\n   * @deprecated pending requests are now tracked with zones.\n   */\n  increasePendingRequestCount(): number {\n    this._pendingCount += 1;\n    this._didWork = true;\n    return this._pendingCount;\n  }\n\n  /**\n   * Decreases the number of pending request\n   * @deprecated pending requests are now tracked with zones\n   */\n  decreasePendingRequestCount(): number {\n    this._pendingCount -= 1;\n    if (this._pendingCount < 0) {\n      throw new Error('pending async requests below zero');\n    }\n    this._runCallbacksIfReady();\n    return this._pendingCount;\n  }\n\n  /**\n   * Whether an associated application is stable\n   */\n  isStable(): boolean {\n    return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;\n  }\n\n  private _runCallbacksIfReady(): void {\n    if (this.isStable()) {\n      // Schedules the call backs in a new frame so that it is always async.\n      scheduleMicroTask(() => {\n        while (this._callbacks.length !== 0) {\n          let cb = this._callbacks.pop() !;\n          clearTimeout(cb.timeoutId);\n          cb.doneCb(this._didWork);\n        }\n        this._didWork = false;\n      });\n    } else {\n      // Still not stable, send updates.\n      let pending = this.getPendingTasks();\n      this._callbacks = this._callbacks.filter((cb) => {\n        if (cb.updateCb && cb.updateCb(pending)) {\n          clearTimeout(cb.timeoutId);\n          return false;\n        }\n\n        return true;\n      });\n\n      this._didWork = true;\n    }\n  }\n\n  private getPendingTasks(): PendingMacrotask[] {\n    if (!this.taskTrackingZone) {\n      return [];\n    }\n\n    return this.taskTrackingZone.macroTasks.map((t: Task) => {\n      return {\n        source: t.source,\n        isPeriodic: t.data.isPeriodic,\n        delay: t.data.delay,\n        // From TaskTrackingZone:\n        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\n        creationLocation: (t as any).creationLocation as Error,\n        // Added by Zones for XHRs\n        // https://github.com/angular/zone.js/blob/master/lib/browser/browser.ts#L133\n        xhr: (t.data as any).target\n      };\n    });\n  }\n\n  private addCallback(cb: DoneCallback, timeout?: number, updateCb?: UpdateCallback) {\n    let timeoutId: any = -1;\n    if (timeout && timeout > 0) {\n      timeoutId = setTimeout(() => {\n        this._callbacks = this._callbacks.filter((cb) => cb.timeoutId !== timeoutId);\n        cb(this._didWork, this.getPendingTasks());\n      }, timeout);\n    }\n    this._callbacks.push(<WaitCallback>{doneCb: cb, timeoutId: timeoutId, updateCb: updateCb});\n  }\n\n  /**\n   * Wait for the application to be stable with a timeout. If the timeout is reached before that\n   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n   *\n   * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n   *    whichever comes first.\n   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n   *    specified, whenStable() will wait forever.\n   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n   *    and no further updates will be issued.\n   */\n  whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void {\n    if (updateCb && !this.taskTrackingZone) {\n      throw new Error(\n          'Task tracking zone is required when passing an update callback to ' +\n          'whenStable(). Is \"zone.js/dist/task-tracking.js\" loaded?');\n    }\n    // These arguments are 'Function' above to keep the public API simple.\n    this.addCallback(doneCb as DoneCallback, timeout, updateCb as UpdateCallback);\n    this._runCallbacksIfReady();\n  }\n\n  /**\n   * Get the number of pending requests\n   * @deprecated pending requests are now tracked with zones\n   */\n  getPendingRequestCount(): number { return this._pendingCount; }\n\n  /**\n   * Find providers by name\n   * @param using The root element to search from\n   * @param provider The name of binding variable\n   * @param exactMatch Whether using exactMatch\n   */\n  findProviders(using: any, provider: string, exactMatch: boolean): any[] {\n    // TODO(juliemr): implement.\n    return [];\n  }\n}\n\n/**\n * A global registry of {@link Testability} instances for specific elements.\n * @experimental\n */\n@Injectable()\nexport class TestabilityRegistry {\n  /** @internal */\n  _applications = new Map<any, Testability>();\n\n  constructor() { _testabilityGetter.addToWindow(this); }\n\n  /**\n   * Registers an application with a testability hook so that it can be tracked\n   * @param token token of application, root element\n   * @param testability Testability hook\n   */\n  registerApplication(token: any, testability: Testability) {\n    this._applications.set(token, testability);\n  }\n\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   */\n  unregisterApplication(token: any) { this._applications.delete(token); }\n\n  /**\n   * Unregisters all applications\n   */\n  unregisterAllApplications() { this._applications.clear(); }\n\n  /**\n   * Get a testability hook associated with the application\n   * @param elem root element\n   */\n  getTestability(elem: any): Testability|null { return this._applications.get(elem) || null; }\n\n  /**\n   * Get all registered testabilities\n   */\n  getAllTestabilities(): Testability[] { return Array.from(this._applications.values()); }\n\n  /**\n   * Get all registered applications(root elements)\n   */\n  getAllRootElements(): any[] { return Array.from(this._applications.keys()); }\n\n  /**\n   * Find testability of a node in the Tree\n   * @param elem node\n   * @param findInAncestors whether finding testability in ancestors if testability was not found in\n   * current node\n   */\n  findTestabilityInTree(elem: Node, findInAncestors: boolean = true): Testability|null {\n    return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);\n  }\n}\n\n/**\n * Adapter interface for retrieving the `Testability` service associated for a\n * particular context.\n *\n * @experimental Testability apis are primarily intended to be used by e2e test tool vendors like\n * the Protractor team.\n */\nexport interface GetTestability {\n  addToWindow(registry: TestabilityRegistry): void;\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null;\n}\n\nclass _NoopGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {}\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    return null;\n  }\n}\n\n/**\n * Set the {@link GetTestability} implementation used by the Angular testing framework.\n * @experimental\n */\nexport function setTestabilityGetter(getter: GetTestability): void {\n  _testabilityGetter = getter;\n}\n\nlet _testabilityGetter: GetTestability = new _NoopGetTestability();\n"],"sourceRoot":""}