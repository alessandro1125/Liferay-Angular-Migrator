{"version":3,"sources":["../../../../../../../packages/core/src/di/r3_injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OnDestroy} from '../metadata/lifecycle_hooks';\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, InjectableType, InjectorDef, InjectorType, InjectorTypeWithProviders} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectableDefToken, InjectionToken} from './injection_token';\nimport {INJECTOR, InjectFlags, Injector, NullInjector, THROW_IF_NOT_FOUND, USE_VALUE, inject, injectArgs, setCurrentInjector} from './injector';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, Provider, StaticClassProvider, StaticProvider, TypeProvider, ValueProvider} from './provider';\nimport {APP_ROOT} from './scope';\n\n\n\n/**\n * Internal type for a single provider in a deep provider array.\n */\ntype SingleProvider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider |\n    ExistingProvider | FactoryProvider | StaticClassProvider;\n\n/**\n * Marker which indicates that a value has not yet been created from the factory function.\n */\nconst NOT_YET = {};\n\n/**\n * Marker which indicates that the factory function for a token is in the process of being called.\n *\n * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates\n * injection of a dependency has recursively attempted to inject the original token, and there is\n * a circular dependency among the providers.\n */\nconst CIRCULAR = {};\n\nconst EMPTY_ARRAY = [] as any[];\n\n/**\n * A lazily initialized NullInjector.\n */\nlet NULL_INJECTOR: Injector|undefined = undefined;\n\nfunction getNullInjector(): Injector {\n  if (NULL_INJECTOR === undefined) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\n\n/**\n * An entry in the injector which tracks information about the given token, including a possible\n * current value.\n */\ninterface Record<T> {\n  factory: (() => T)|undefined;\n  value: T|{};\n  multi: any[]|undefined;\n}\n\n/**\n * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.\n *\n * @experimental\n */\nexport function createInjector(\n    defType: /* InjectorType<any> */ any, parent: Injector | null = null,\n    additionalProviders: StaticProvider[] | null = null): Injector {\n  parent = parent || getNullInjector();\n  return new R3Injector(defType, additionalProviders, parent);\n}\n\nexport class R3Injector {\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   */\n  private records = new Map<Type<any>|InjectionToken<any>, Record<any>>();\n\n  /**\n   * The transitive set of `InjectorType`s which define this injector.\n   */\n  private injectorDefTypes = new Set<InjectorType<any>>();\n\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  private onDestroy = new Set<OnDestroy>();\n\n  /**\n   * Flag indicating this injector provides the APP_ROOT_SCOPE token, and thus counts as the\n   * root scope.\n   */\n  private readonly isRootInjector: boolean;\n\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  private destroyed = false;\n\n  constructor(\n      def: InjectorType<any>, additionalProviders: StaticProvider[]|null,\n      readonly parent: Injector) {\n    // Start off by creating Records for every provider declared in every InjectorType\n    // included transitively in `def`.\n    deepForEach(\n        [def], injectorDef => this.processInjectorType(injectorDef, new Set<InjectorType<any>>()));\n\n    additionalProviders &&\n        deepForEach(additionalProviders, provider => this.processProvider(provider));\n\n\n    // Make sure the INJECTOR token provides this injector.\n    this.records.set(INJECTOR, makeRecord(undefined, this));\n\n    // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide\n    // any injectable scoped to APP_ROOT_SCOPE.\n    this.isRootInjector = this.records.has(APP_ROOT);\n\n    // Eagerly instantiate the InjectorType classes themselves.\n    this.injectorDefTypes.forEach(defType => this.get(defType));\n  }\n\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy(): void {\n    this.assertNotDestroyed();\n\n    // Set destroyed = true first, in case lifecycle hooks re-enter destroy().\n    this.destroyed = true;\n    try {\n      // Call all the lifecycle hooks.\n      this.onDestroy.forEach(service => service.ngOnDestroy());\n    } finally {\n      // Release all references.\n      this.records.clear();\n      this.onDestroy.clear();\n      this.injectorDefTypes.clear();\n    }\n  }\n\n  get<T>(\n      token: Type<T>|InjectionToken<T>, notFoundValue: any = THROW_IF_NOT_FOUND,\n      flags = InjectFlags.Default): T {\n    this.assertNotDestroyed();\n    // Set the injection context.\n    const previousInjector = setCurrentInjector(this);\n    try {\n      // Check for the SkipSelf flag.\n      if (!(flags & InjectFlags.SkipSelf)) {\n        // SkipSelf isn't set, check if the record belongs to this injector.\n        let record: Record<T>|undefined = this.records.get(token);\n        if (record === undefined) {\n          // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef\n          // with a scope matching this injector.\n          const def = couldBeInjectableType(token) &&\n                  (token as InjectableType<any>| InjectableDefToken<any>).ngInjectableDef ||\n              undefined;\n          if (def !== undefined && this.injectableDefInScope(def)) {\n            // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here\n            // all along.\n            record = injectableDefRecord(token);\n            this.records.set(token, record);\n          }\n        }\n        // If a record was found, get the instance for it and return it.\n        if (record !== undefined) {\n          return this.hydrate(token, record);\n        }\n      }\n\n      // Select the next injector based on the Self flag - if self is set, the next injector is\n      // the NullInjector, otherwise it's the parent.\n      let next = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      return this.parent.get(token, notFoundValue);\n    } finally {\n      // Lastly, clean up the state by restoring the previous injector.\n      setCurrentInjector(previousInjector);\n    }\n  }\n\n  private assertNotDestroyed(): void {\n    if (this.destroyed) {\n      throw new Error('Injector has already been destroyed.');\n    }\n  }\n\n  /**\n   * Add an `InjectorType` or `InjectorDefTypeWithProviders` and all of its transitive providers\n   * to this injector.\n   */\n  private processInjectorType(\n      defOrWrappedDef: InjectorType<any>|InjectorTypeWithProviders<any>,\n      parents: Set<InjectorType<any>>) {\n    defOrWrappedDef = resolveForwardRef(defOrWrappedDef);\n\n    // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an\n    // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic\n    // read, so care is taken to only do the read once.\n\n    // First attempt to read the ngInjectorDef.\n    let def = (defOrWrappedDef as InjectorType<any>).ngInjectorDef as(InjectorDef<any>| undefined);\n\n    // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.\n    const ngModule =\n        (def == null) && (defOrWrappedDef as InjectorTypeWithProviders<any>).ngModule || undefined;\n\n    // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,\n    // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type\n    // is the `ngModule`.\n    const defType: InjectorType<any> =\n        (ngModule === undefined) ? (defOrWrappedDef as InjectorType<any>) : ngModule;\n\n    // If defOrWrappedType was an InjectorDefTypeWithProviders, then .providers may hold some\n    // extra providers.\n    const providers =\n        (ngModule !== undefined) && (defOrWrappedDef as InjectorTypeWithProviders<any>).providers ||\n        EMPTY_ARRAY;\n\n    // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual\n    // `InjectorDef` is on its `ngModule`.\n    if (ngModule !== undefined) {\n      def = ngModule.ngInjectorDef;\n    }\n\n    // If no definition was found, it might be from exports. Remove it.\n    if (def == null) {\n      return;\n    }\n\n    // Check for circular dependencies.\n    if (parents.has(defType)) {\n      throw new Error(`Circular dependency: type ${stringify(defType)} ends up importing itself.`);\n    }\n\n    // Track the InjectorType and add a provider for it.\n    this.injectorDefTypes.add(defType);\n    this.records.set(defType, makeRecord(def.factory));\n\n    // Add providers in the same way that @NgModule resolution did:\n\n    // First, include providers from any imports.\n    if (def.imports != null) {\n      // Before processing defType's imports, add it to the set of parents. This way, if it ends\n      // up deeply importing itself, this can be detected.\n      parents.add(defType);\n      try {\n        deepForEach(def.imports, imported => this.processInjectorType(imported, parents));\n      } finally {\n        // Remove it from the parents set when finished.\n        parents.delete(defType);\n      }\n    }\n\n    // Next, include providers listed on the definition itself.\n    if (def.providers != null) {\n      deepForEach(def.providers, provider => this.processProvider(provider));\n    }\n\n    // Finally, include providers from an InjectorDefTypeWithProviders if there was one.\n    deepForEach(providers, provider => this.processProvider(provider));\n  }\n\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  private processProvider(provider: SingleProvider): void {\n    // Determine the token from the provider. Either it's its own token, or has a {provide: ...}\n    // property.\n    provider = resolveForwardRef(provider);\n    let token: any = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n\n    // Construct a `Record` for the provider.\n    const record = providerToRecord(provider);\n\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      // If the provider indicates that it's a multi-provider, process it specially.\n      // First check whether it's been defined already.\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        // It has. Throw a nice error if\n        if (multiRecord.multi === undefined) {\n          throw new Error(`Mixed multi-provider for ${token}.`);\n        }\n      } else {\n        multiRecord = makeRecord(undefined, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord !.multi !);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi !.push(provider);\n    } else {\n      const existing = this.records.get(token);\n      if (existing && existing.multi !== undefined) {\n        throw new Error(`Mixed multi-provider for ${stringify(token)}`);\n      }\n    }\n    this.records.set(token, record);\n  }\n\n  private hydrate<T>(token: Type<T>|InjectionToken<T>, record: Record<T>): T {\n    if (record.value === CIRCULAR) {\n      throw new Error(`Circular dep for ${stringify(token)}`);\n    } else if (record.value === NOT_YET) {\n      record.value = CIRCULAR;\n      record.value = record.factory !();\n    }\n    if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {\n      this.onDestroy.add(record.value);\n    }\n    return record.value as T;\n  }\n\n  private injectableDefInScope(def: InjectableDef<any>): boolean {\n    if (!def.providedIn) {\n      return false;\n    } else if (typeof def.providedIn === 'string') {\n      return def.providedIn === 'any' || (def.providedIn === 'root' && this.isRootInjector);\n    } else {\n      return this.injectorDefTypes.has(def.providedIn);\n    }\n  }\n}\n\nfunction injectableDefRecord(token: Type<any>| InjectionToken<any>): Record<any> {\n  const def = (token as InjectableType<any>).ngInjectableDef as InjectableDef<any>;\n  if (def === undefined) {\n    if (token instanceof InjectionToken) {\n      throw new Error(`Token ${stringify(token)} is missing an ngInjectableDef definition.`);\n    }\n    // TODO(alxhub): there should probably be a strict mode which throws here instead of assuming a\n    // no-args constructor.\n    return makeRecord(() => new (token as Type<any>)());\n  }\n  return makeRecord(def.factory);\n}\n\nfunction providerToRecord(provider: SingleProvider): Record<any> {\n  let token = resolveForwardRef(provider);\n  let value: any = NOT_YET;\n  let factory: (() => any)|undefined = undefined;\n  if (isTypeProvider(provider)) {\n    return injectableDefRecord(provider);\n  } else {\n    token = resolveForwardRef(provider.provide);\n    if (isValueProvider(provider)) {\n      value = provider.useValue;\n    } else if (isExistingProvider(provider)) {\n      factory = () => inject(provider.useExisting);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else {\n      const classRef = (provider as StaticClassProvider | ClassProvider).useClass || token;\n      if (hasDeps(provider)) {\n        factory = () => new (classRef)(...injectArgs(provider.deps));\n      } else {\n        return injectableDefRecord(classRef);\n      }\n    }\n  }\n  return makeRecord(factory, value);\n}\n\nfunction makeRecord<T>(\n    factory: (() => T) | undefined, value: T | {} = NOT_YET, multi: boolean = false): Record<T> {\n  return {\n    factory: factory,\n    value: value,\n    multi: multi ? [] : undefined,\n  };\n}\n\nfunction deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nfunction isValueProvider(value: SingleProvider): value is ValueProvider {\n  return USE_VALUE in value;\n}\n\nfunction isExistingProvider(value: SingleProvider): value is ExistingProvider {\n  return !!(value as ExistingProvider).useExisting;\n}\n\nfunction isFactoryProvider(value: SingleProvider): value is FactoryProvider {\n  return !!(value as FactoryProvider).useFactory;\n}\n\nfunction isClassProvider(value: SingleProvider): value is ClassProvider {\n  return !!(value as ClassProvider).useClass;\n}\n\nfunction isTypeProvider(value: SingleProvider): value is TypeProvider {\n  return typeof value === 'function';\n}\n\nfunction hasDeps(value: ClassProvider | ConstructorProvider | StaticClassProvider):\n    value is ClassProvider&{deps: any[]} {\n  return !!(value as any).deps;\n}\n\nfunction hasOnDestroy(value: any): value is OnDestroy {\n  return typeof value === 'object' && value != null && (value as OnDestroy).ngOnDestroy &&\n      typeof(value as OnDestroy).ngOnDestroy === 'function';\n}\n\nfunction couldBeInjectableType(value: any): value is Type<any>|InjectionToken<any> {\n  return (typeof value === 'function') ||\n      (typeof value === 'object' && value instanceof InjectionToken);\n}\n"],"sourceRoot":""}