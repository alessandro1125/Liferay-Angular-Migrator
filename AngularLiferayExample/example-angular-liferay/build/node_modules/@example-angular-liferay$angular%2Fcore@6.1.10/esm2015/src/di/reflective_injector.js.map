{"version":3,"sources":["../../../../../../../packages/core/src/di/reflective_injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst UNDEFINED = new Object();\n\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n *\n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n *\n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n *\n * @usageNotes\n * ### Example\n *\n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n *\n * ```typescript\n * @Injectable()\n * class Engine {\n * }\n *\n * @Injectable()\n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n *\n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n *\n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n *\n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n */\nexport abstract class ReflectiveInjector implements Injector {\n  /**\n   * Turns an array of provider definitions into an array of resolved providers.\n   *\n   * A resolution is a process of flattening multiple nested arrays and converting individual\n   * providers into an array of `ResolvedReflectiveProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n   *\n   * expect(providers.length).toEqual(2);\n   *\n   * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n   * expect(providers[0].key.displayName).toBe(\"Car\");\n   * expect(providers[0].dependencies.length).toEqual(1);\n   * expect(providers[0].factory).toBeDefined();\n   *\n   * expect(providers[1].key.displayName).toBe(\"Engine\");\n   * });\n   * ```\n   *\n   */\n  static resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n\n  /**\n   * Resolves an array of providers and creates an injector from those providers.\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   */\n  static resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n\n  /**\n   * Creates an injector from previously resolved providers.\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var providers = ReflectiveInjector.resolve([Car, Engine]);\n   * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n   * expect(injector.get(Car) instanceof Car).toBe(true);\n   * ```\n   * @experimental\n   */\n  static fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, `Provider`,\n   * or a recursive array of more providers.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n  private static INJECTOR_KEY = ReflectiveKey.get(Injector);\n  /** @internal */\n  _constructionCounter: number = 0;\n  /** @internal */\n  public _providers: ResolvedReflectiveProvider[];\n  public readonly parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n  /**\n   * Private\n   */\n  constructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this.parent = _parent || null;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n\n  resolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n\n  createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const inj = new ReflectiveInjector_(providers);\n    (inj as{parent: Injector | null}).parent = this;\n    return inj;\n  }\n\n  resolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n\n  instantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n\n  getProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n\n  /** @internal */\n  _new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n\n  private _getMaxNumberOfObjects(): number { return this.objs.length; }\n\n  private _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const res = new Array(provider.resolvedFactories.length);\n      for (let i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n\n  private _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const factory = ResolvedReflectiveFactory.factory;\n\n    let deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch (e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let obj: any;\n    try {\n      obj = factory(...deps);\n    } catch (e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n\n  private _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n\n  private _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n\n  private _getObjByKeyId(keyId: number): any {\n    for (let i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n\n  /** @internal */\n  _throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n\n  /** @internal */\n  _getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n\n  /** @internal */\n  _getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this.parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const inj_ = <ReflectiveInjector_>inj;\n      const obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_.parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n\n  get displayName(): string {\n    const providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n\n  toString(): string { return this.displayName; }\n}\n\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const res: any[] = new Array(injector._providers.length);\n  for (let i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n"],"sourceRoot":""}