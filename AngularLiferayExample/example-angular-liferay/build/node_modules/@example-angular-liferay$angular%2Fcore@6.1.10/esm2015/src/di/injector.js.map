{"version":3,"sources":["../../../../../../../packages/core/src/di/injector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../type';\nimport {stringify} from '../util';\n\nimport {InjectableDef, defineInjectable} from './defs';\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, StaticProvider, ValueProvider} from './provider';\n\nexport const SOURCE = '__source';\nconst _THROW_IF_NOT_FOUND = new Object();\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @experimental\n */\nexport const INJECTOR = new InjectionToken<Injector>('INJECTOR');\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if(ngDevMode) debugger;\n      throw new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n\n/**\n * Concrete injectors implement this interface.\n *\n * For more details, see the [\"Dependency Injection Guide\"](guide/dependency-injection).\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='Injector'}\n *\n * `Injector` returns itself when given `Injector` as a token:\n *\n * {@example core/di/ts/injector_spec.ts region='injectInjector'}\n *\n *\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new NullInjector();\n\n  /**\n   * Retrieves an instance from the injector based on the provided token.\n   * @returns The instance from the injector if defined, otherwise the `notFoundValue`.\n   * @throws When the `notFoundValue` is `undefined` or `Injector.THROW_IF_NOT_FOUND`.\n   */\n  abstract get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  /**\n   * @deprecated from v4.0.0 use Type<T> or InjectionToken<T>\n   * @suppress {duplicate}\n   */\n  abstract get(token: any, notFoundValue?: any): any;\n\n  /**\n   * @deprecated from v5 use the new signature Injector.create(options)\n   */\n  static create(providers: StaticProvider[], parent?: Injector): Injector;\n\n  static create(options: {providers: StaticProvider[], parent?: Injector, name?: string}): Injector;\n\n  /**\n   * Create a new Injector which is configure using `StaticProvider`s.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}\n   */\n  static create(\n      options: StaticProvider[]|{providers: StaticProvider[], parent?: Injector, name?: string},\n      parent?: Injector): Injector {\n    if (Array.isArray(options)) {\n      return new StaticInjector(options, parent);\n    } else {\n      return new StaticInjector(options.providers, options.parent, options.name || null);\n    }\n  }\n\n  static ngInjectableDef = defineInjectable({\n    providedIn: 'any' as any,\n    factory: () => inject(INJECTOR),\n  });\n}\n\n\n\nconst IDENT = function<T>(value: T): T {\n  return value;\n};\nconst EMPTY = <any[]>[];\nconst CIRCULAR = IDENT;\nconst MULTI_PROVIDER_FN = function(): any[] {\n  return Array.prototype.slice.call(arguments);\n};\nconst GET_PROPERTY_NAME = {} as any;\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: GET_PROPERTY_NAME});\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst enum OptionFlags {\n  Optional = 1 << 0,\n  CheckSelf = 1 << 1,\n  CheckParent = 1 << 2,\n  Default = CheckSelf | CheckParent\n}\nconst NULL_INJECTOR = Injector.NULL;\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\n\nexport class StaticInjector implements Injector {\n  readonly parent: Injector;\n  readonly source: string|null;\n\n  private _records: Map<any, Record>;\n\n  constructor(\n      providers: StaticProvider[], parent: Injector = NULL_INJECTOR, source: string|null = null) {\n    this.parent = parent;\n    this.source = source;\n    const records = this._records = new Map<any, Record>();\n    records.set(\n        Injector, <Record>{token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    records.set(\n        INJECTOR, <Record>{token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false});\n    recursivelyProcessProviders(records, providers);\n  }\n\n  get<T>(token: Type<T>|InjectionToken<T>, notFoundValue?: T, flags?: InjectFlags): T;\n  get(token: any, notFoundValue?: any): any;\n  get(token: any, notFoundValue?: any, flags: InjectFlags = InjectFlags.Default): any {\n    const record = this._records.get(token);\n    try {\n      return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);\n    } catch (e) {\n      const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n      if (token[SOURCE]) {\n        tokenPath.unshift(token[SOURCE]);\n      }\n      e.message = formatError('\\n' + e.message, tokenPath, this.source);\n      e[NG_TOKEN_PATH] = tokenPath;\n      e[NG_TEMP_TOKEN_PATH] = null;\n      throw e;\n    }\n  }\n\n  toString() {\n    const tokens = <string[]>[], records = this._records;\n    records.forEach((v, token) => tokens.push(stringify(token)));\n    return `StaticInjector[${tokens.join(', ')}]`;\n  }\n}\n\ntype SupportedProvider =\n    ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider;\n\ninterface Record {\n  fn: Function;\n  useNew: boolean;\n  deps: DependencyRecord[];\n  value: any;\n}\n\ninterface DependencyRecord {\n  token: any;\n  options: number;\n}\n\ntype TokenPath = Array<any>;\n\nfunction resolveProvider(provider: SupportedProvider): Record {\n  const deps = computeDeps(provider);\n  let fn: Function = IDENT;\n  let value: any = EMPTY;\n  let useNew: boolean = false;\n  let provide = resolveForwardRef(provider.provide);\n  if (USE_VALUE in provider) {\n    // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.\n    value = (provider as ValueProvider).useValue;\n  } else if ((provider as FactoryProvider).useFactory) {\n    fn = (provider as FactoryProvider).useFactory;\n  } else if ((provider as ExistingProvider).useExisting) {\n    // Just use IDENT\n  } else if ((provider as StaticClassProvider).useClass) {\n    useNew = true;\n    fn = resolveForwardRef((provider as StaticClassProvider).useClass);\n  } else if (typeof provide == 'function') {\n    useNew = true;\n    fn = provide;\n  } else {\n    throw staticError(\n        'StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable',\n        provider);\n  }\n  return {deps, fn, useNew, value};\n}\n\nfunction multiProviderMixError(token: any) {\n  return staticError('Cannot mix multi providers and regular providers', token);\n}\n\nfunction recursivelyProcessProviders(records: Map<any, Record>, provider: StaticProvider) {\n  if (provider) {\n    provider = resolveForwardRef(provider);\n    if (provider instanceof Array) {\n      // if we have an array recurse into the array\n      for (let i = 0; i < provider.length; i++) {\n        recursivelyProcessProviders(records, provider[i]);\n      }\n    } else if (typeof provider === 'function') {\n      // Functions were supported in ReflectiveInjector, but are not here. For safety give useful\n      // error messages\n      throw staticError('Function/Class not supported', provider);\n    } else if (provider && typeof provider === 'object' && provider.provide) {\n      // At this point we have what looks like a provider: {provide: ?, ....}\n      let token = resolveForwardRef(provider.provide);\n      const resolvedProvider = resolveProvider(provider);\n      if (provider.multi === true) {\n        // This is a multi provider.\n        let multiProvider: Record|undefined = records.get(token);\n        if (multiProvider) {\n          if (multiProvider.fn !== MULTI_PROVIDER_FN) {\n            throw multiProviderMixError(token);\n          }\n        } else {\n          // Create a placeholder factory which will look up the constituents of the multi provider.\n          records.set(token, multiProvider = <Record>{\n            token: provider.provide,\n            deps: [],\n            useNew: false,\n            fn: MULTI_PROVIDER_FN,\n            value: EMPTY\n          });\n        }\n        // Treat the provider as the token.\n        token = provider;\n        multiProvider.deps.push({token, options: OptionFlags.Default});\n      }\n      const record = records.get(token);\n      if (record && record.fn == MULTI_PROVIDER_FN) {\n        throw multiProviderMixError(token);\n      }\n      records.set(token, resolvedProvider);\n    } else {\n      throw staticError('Unexpected provider', provider);\n    }\n  }\n}\n\nfunction tryResolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  try {\n    return resolveToken(token, record, records, parent, notFoundValue, flags);\n  } catch (e) {\n    // ensure that 'e' is of type Error.\n    if (!(e instanceof Error)) {\n      e = new Error(e);\n    }\n    const path: any[] = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n    path.unshift(token);\n    if (record && record.value == CIRCULAR) {\n      // Reset the Circular flag.\n      record.value = EMPTY;\n    }\n    throw e;\n  }\n}\n\nfunction resolveToken(\n    token: any, record: Record | undefined, records: Map<any, Record>, parent: Injector,\n    notFoundValue: any, flags: InjectFlags): any {\n  let value;\n  if (record && !(flags & InjectFlags.SkipSelf)) {\n    // If we don't have a record, this implies that we don't own the provider hence don't know how\n    // to resolve it.\n    value = record.value;\n    if (value == CIRCULAR) {\n      throw Error(NO_NEW_LINE + 'Circular dependency');\n    } else if (value === EMPTY) {\n      record.value = CIRCULAR;\n      let obj = undefined;\n      let useNew = record.useNew;\n      let fn = record.fn;\n      let depRecords = record.deps;\n      let deps = EMPTY;\n      if (depRecords.length) {\n        deps = [];\n        for (let i = 0; i < depRecords.length; i++) {\n          const depRecord: DependencyRecord = depRecords[i];\n          const options = depRecord.options;\n          const childRecord =\n              options & OptionFlags.CheckSelf ? records.get(depRecord.token) : undefined;\n          deps.push(tryResolveToken(\n              // Current Token to resolve\n              depRecord.token,\n              // A record which describes how to resolve the token.\n              // If undefined, this means we don't have such a record\n              childRecord,\n              // Other records we know about.\n              records,\n              // If we don't know how to resolve dependency and we should not check parent for it,\n              // than pass in Null injector.\n              !childRecord && !(options & OptionFlags.CheckParent) ? NULL_INJECTOR : parent,\n              options & OptionFlags.Optional ? null : Injector.THROW_IF_NOT_FOUND,\n              InjectFlags.Default));\n        }\n      }\n      record.value = value = useNew ? new (fn as any)(...deps) : fn.apply(obj, deps);\n    }\n  } else if (!(flags & InjectFlags.Self)) {\n    value = parent.get(token, notFoundValue, InjectFlags.Default);\n  }\n  return value;\n}\n\n\nfunction computeDeps(provider: StaticProvider): DependencyRecord[] {\n  let deps: DependencyRecord[] = EMPTY;\n  const providerDeps: any[] =\n      (provider as ExistingProvider & StaticClassProvider & ConstructorProvider).deps;\n  if (providerDeps && providerDeps.length) {\n    deps = [];\n    for (let i = 0; i < providerDeps.length; i++) {\n      let options = OptionFlags.Default;\n      let token = resolveForwardRef(providerDeps[i]);\n      if (token instanceof Array) {\n        for (let j = 0, annotations = token; j < annotations.length; j++) {\n          const annotation = annotations[j];\n          if (annotation instanceof Optional || annotation == Optional) {\n            options = options | OptionFlags.Optional;\n          } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {\n            options = options & ~OptionFlags.CheckSelf;\n          } else if (annotation instanceof Self || annotation == Self) {\n            options = options & ~OptionFlags.CheckParent;\n          } else if (annotation instanceof Inject) {\n            token = (annotation as Inject).token;\n          } else {\n            token = resolveForwardRef(annotation);\n          }\n        }\n      }\n      deps.push({token, options});\n    }\n  } else if ((provider as ExistingProvider).useExisting) {\n    const token = resolveForwardRef((provider as ExistingProvider).useExisting);\n    deps = [{token, options: OptionFlags.Default}];\n  } else if (!providerDeps && !(USE_VALUE in provider)) {\n    // useValue & useExisting are the only ones which are exempt from deps all others need it.\n    throw staticError('\\'deps\\' required', provider);\n  }\n  return deps;\n}\n\nfunction formatError(text: string, obj: any, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (obj instanceof Array) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `StaticInjectorError${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n\nfunction staticError(text: string, obj: any): Error {\n  return new Error(formatError(text, obj));\n}\n\nfunction getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === GET_PROPERTY_NAME) {\n      return key;\n    }\n  }\n  throw Error('!prop');\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0b0000,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * This function must be used in the context of a factory function such as one defined for an\n * `InjectionToken`, and will throw an error if not called from such a context.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakeableInjectionToken'}\n *\n * Within such a factory function `inject` is utilized to request injection of a dependency, instead\n * of providing an additional array of dependencies as was common to do with `useFactory` providers.\n * `inject` is faster and more type-safe.\n *\n * @experimental\n */\nexport function inject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function inject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    const injectableDef: InjectableDef<T> = (token as any).ngInjectableDef;\n    if (injectableDef && injectableDef.providedIn == 'root') {\n      return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                                 injectableDef.value;\n    }\n    if (flags & InjectFlags.Optional) return null;\n    throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = types[i];\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional') {\n          flags |= InjectFlags.Optional;\n        } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf') {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self') {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(inject(type !, flags));\n    } else {\n      args.push(inject(arg));\n    }\n  }\n  return args;\n}\n"],"sourceRoot":""}