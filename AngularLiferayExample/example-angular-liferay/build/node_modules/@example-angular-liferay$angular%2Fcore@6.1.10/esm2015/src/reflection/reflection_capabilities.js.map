{"version":3,"sources":["../../../../../../../packages/core/src/reflection/reflection_capabilities.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,aAAQ,IAAR,EAAc,MAAd,QAA2B,SAA3B;AACA,aAAQ,MAAR,EAAgB,SAAhB,QAAgC,SAAhC;AACA,aAAQ,WAAR,EAAqB,UAArB,EAAiC,aAAjC,QAAqD,oBAArD;;;;AASA,WAAA,MAAa,gBAAgB,4DAA7B;;AACA,WAAA,MAAa,kBAAkB,sDAA/B;;AACA,WAAA,MAAa,4BACT,6EADJ;AAGA,WAAM,MAAA,sBAAA,CAAA;;;;AAGJ,oBAAY,OAAZ,EAAyB;AAAI,iBAAK,QAAL,GAAgB,WAAW,OAAO,SAAP,CAA3B;AAA+C;;;;AAE5E,8BAAmB;AAAc,mBAAO,IAAP;AAAc;;;;;;AAE/C,gBAAW,CAAX,EAAqB;AAAwB,mBAAO,CAAC,GAAG,IAAJ,KAAoB,IAAI,CAAJ,CAAM,GAAG,IAAT,CAA3B;AAA4C;;;;;;;AAGzF,gCAAwB,UAAxB,EAA2C,gBAA3C,EAAkE;;AAChE,gBAAI,MAAJ;AAEA,gBAAI,OAAO,UAAP,KAAsB,WAA1B,EAAuC;AACrC,yBAAS,IAAI,KAAJ,CAAU,iBAAiB,MAA3B,CAAT;AACD,aAFD,MAEO;AACL,yBAAS,IAAI,KAAJ,CAAU,WAAW,MAArB,CAAT;AACD;AAED,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,OAAO,MAA3B,EAAmC,GAAnC,EAAwC;;;;AAItC,oBAAI,OAAO,UAAP,KAAsB,WAA1B,EAAuC;AACrC,2BAAO,CAAP,IAAY,EAAZ;AACD,iBAFD,MAEO,IAAI,WAAW,CAAX,KAAiB,MAArB,EAA6B;AAClC,2BAAO,CAAP,IAAY,CAAC,WAAW,CAAX,CAAD,CAAZ;AACD,iBAFM,MAEA;AACL,2BAAO,CAAP,IAAY,EAAZ;AACD;AACD,oBAAI,oBAAoB,iBAAiB,CAAjB,KAAuB,IAA/C,EAAqD;AACnD,2BAAO,CAAP,IAAY,OAAO,CAAP,EAAU,MAAV,CAAiB,iBAAiB,CAAjB,CAAjB,CAAZ;AACD;AACF;AACD,mBAAO,MAAP;AACD;;;;;;AAEO,uBAAe,IAAf,EAAgC,UAAhC,EAA+C;;AACrD,kBAAM,UAAU,KAAK,QAAL,EAAhB;;;;;;;;AAQA,gBAAI,cAAc,IAAd,CAAmB,OAAnB,KACC,gBAAgB,IAAhB,CAAqB,OAArB,KAAiC,CAAC,0BAA0B,IAA1B,CAA+B,OAA/B,CADvC,EACiF;AAC/E,uBAAO,IAAP;AACD;;AAGD,gBAAI,CAAA,gBAAM,IAAN,CAAY,UAAZ,IAA0B,gBAAM,IAAN,CAAY,UAAZ,KAA2B,WAAW,UAApE,EAAgF;AAC9E,uBAAO,iBAAM,IAAN,CAAY;AAAnB;AACD;;AAGD,kBAAM,oBAAoB,gBAAM,IAAN,CAAY,cAAtC;AACA,gBAAI,qBAAqB,sBAAsB,WAAW,cAA1D,EAA0E;;AAGxE,sBAAM,iBACF,OAAO,iBAAP,KAA6B,UAA7B,GAA0C,mBAA1C,GAAgE,iBADpE;;AAEA,sBAAM,aAAa,eAAe,GAAf,CAAoB,SAAD,IAAoB,aAAa,UAAU,IAA9D,CAAnB;;AACA,sBAAM,mBAAmB,eAAe,GAAf,CACpB,SAAD,IACI,aAAa,oCAAoC,UAAU,UAA9C,CAFI,CAAzB;AAGA,uBAAO,KAAK,uBAAL,CAA6B,UAA7B,EAAyC,gBAAzC,CAAP;AACD;;AAGD,kBAAM,mBAAmB,KAAK,cAAL,CAAoB,UAApB,KAAmC,gBAAC,IAAD,CAAc,UAAd,CAA5D;;AACA,kBAAM,aAAa,KAAK,QAAL,IAAiB,KAAK,QAAL,CAAc,cAA/B,IACf,KAAK,QAAL,CAAc,cAAd,CAA6B,mBAA7B,EAAkD,IAAlD,CADJ;AAEA,gBAAI,cAAc,gBAAlB,EAAoC;AAClC,uBAAO,KAAK,uBAAL,CAA6B,UAA7B,EAAyC,gBAAzC,CAAP;AACD;;;;;AAMD,mBAAO,IAAI,KAAJ,EAAU,gBAAM,KAAK,MAArB,EAA8B,IAA9B,CAAmC,SAAnC,CAAP;;;;;;AAGF,mBAAW,IAAX,EAA0B;;;AAGxB,gBAAI,CAAC,OAAO,IAAP,CAAL,EAAmB;AACjB,uBAAO,EAAP;AACD;;AACD,kBAAM,aAAa,cAAc,IAAd,CAAnB;;AACA,gBAAI,aAAa,KAAK,cAAL,CAAoB,IAApB,EAA0B,UAA1B,CAAjB;AACA,gBAAI,CAAC,UAAD,IAAe,eAAe,MAAlC,EAA0C;AACxC,6BAAa,KAAK,UAAL,CAAgB,UAAhB,CAAb;AACD;AACD,mBAAO,cAAc,EAArB;AACD;;;;;;AAEO,wBAAgB,UAAhB,EAAuC,UAAvC,EAAsD;;AAE5D,gBAAI,CAAA,gBAAM,UAAN,CAAkB,WAAlB,IAAiC,gBAAM,UAAN,CAAkB,WAAlB,KAAkC,WAAW,WAAlF,EAA+F;;AAC7F,oBAAI,cAAc,gBAAM,UAAN,CAAkB,WAApC;AACA,oBAAI,OAAO,WAAP,KAAuB,UAAvB,IAAqC,YAAY,WAArD,EAAkE;AAChE,kCAAc,YAAY,WAA1B;AACD;AACD,uBAAO,WAAP;AACD;;AAGD,gBAAI,CAAA,gBAAM,UAAN,CAAkB,UAAlB,IAAgC,gBAAM,UAAN,CAAkB,UAAlB,KAAiC,WAAW,UAAhF,EAA4F;AAC1F,uBAAO,oCAAoC,CAAA,gBAAM,UAAN,CAAkB,UAAtD,CAAP;AACD;;AAGD,gBAAI,WAAW,cAAX,CAA0B,WAA1B,CAAJ,EAA4C;AAC1C,uBAAO,iBAAC,UAAD,CAAoB,WAApB;AAAP;AACD;AACD,mBAAO,IAAP;;;;;;AAGF,oBAAY,UAAZ,EAAiC;AAC/B,gBAAI,CAAC,OAAO,UAAP,CAAL,EAAyB;AACvB,uBAAO,EAAP;AACD;;AACD,kBAAM,aAAa,cAAc,UAAd,CAAnB;;AACA,kBAAM,iBAAiB,KAAK,eAAL,CAAqB,UAArB,EAAiC,UAAjC,KAAgD,EAAvE;;AACA,kBAAM,oBAAoB,eAAe,MAAf,GAAwB,KAAK,WAAL,CAAiB,UAAjB,CAAxB,GAAuD,EAAjF;AACA,mBAAO,kBAAkB,MAAlB,CAAyB,cAAzB,CAAP;AACD;;;;;;AAEO,yBAAiB,UAAjB,EAAkC,UAAlC,EAAiD;;AAEvD,gBAAI,CAAA,gBAAM,UAAN,CAAkB,YAAlB,IACA,gBAAM,UAAN,CAAkB,YAAlB,KAAmC,WAAW,YADlD,EACgE;;AAC9D,oBAAI,eAAe,gBAAM,UAAN,CAAkB,YAArC;AACA,oBAAI,OAAO,YAAP,KAAwB,UAAxB,IAAsC,aAAa,YAAvD,EAAqE;AACnE,mCAAe,aAAa,YAA5B;AACD;AACD,uBAAO,YAAP;AACD;;AAGD,gBAAI,CAAA,gBAAM,UAAN,CAAkB,cAAlB,IACA,gBAAM,UAAN,CAAkB,cAAlB,KAAqC,WAAW,cADpD,EACoE;;AAClE,sBAAM,iBAAiB,gBAAM,UAAN,CAAkB,cAAzC;;AACA,sBAAM,eAAY,gBAA2B,EAA7C;AACA,uBAAO,IAAP,CAAY,cAAZ,EAA4B,OAA5B,CAAoC,QAAO;AACzC,iCAAa,IAAb,IAAqB,oCAAoC,eAAe,IAAf,CAApC,CAArB;AACD,iBAFD;AAGA,uBAAO,YAAP;AACD;;AAGD,gBAAI,WAAW,cAAX,CAA0B,aAA1B,CAAJ,EAA8C;AAC5C,uBAAO,iBAAC,UAAD,CAAoB,aAApB;AAAP;AACD;AACD,mBAAO,IAAP;;;;;;AAGF,qBAAa,UAAb,EAA4B;AAC1B,gBAAI,CAAC,OAAO,UAAP,CAAL,EAAyB;AACvB,uBAAO,EAAP;AACD;;AACD,kBAAM,aAAa,cAAc,UAAd,CAAnB;;AACA,kBAAM,eAAuC,EAA7C;AACA,gBAAI,eAAe,MAAnB,EAA2B;;AACzB,sBAAM,qBAAqB,KAAK,YAAL,CAAkB,UAAlB,CAA3B;AACA,uBAAO,IAAP,CAAY,kBAAZ,EAAgC,OAAhC,CAAyC,QAAD,IAAa;AACnD,iCAAa,QAAb,IAAyB,mBAAmB,QAAnB,CAAzB;AACD,iBAFD;AAGD;;AACD,kBAAM,kBAAkB,KAAK,gBAAL,CAAsB,UAAtB,EAAkC,UAAlC,CAAxB;AACA,gBAAI,eAAJ,EAAqB;AACnB,uBAAO,IAAP,CAAY,eAAZ,EAA6B,OAA7B,CAAsC,QAAD,IAAa;;AAChD,0BAAM,aAAoB,EAA1B;AACA,wBAAI,aAAa,cAAb,CAA4B,QAA5B,CAAJ,EAA2C;AACzC,mCAAW,IAAX,CAAgB,GAAG,aAAa,QAAb,CAAnB;AACD;AACD,+BAAW,IAAX,CAAgB,GAAG,gBAAgB,QAAhB,CAAnB;AACA,iCAAa,QAAb,IAAyB,UAAzB;AACD,iBAPD;AAQD;AACD,mBAAO,YAAP;AACD;;;;;;AAED,yBAAiB,IAAjB,EAA4B,UAA5B,EAA8C;AAC5C,mBAAO,gBAAgB,IAAhB,IAAwB,cAAc,KAAK,SAAlD;AACD;;;;;AAED,eAAO,IAAP,EAAgB;AAA0B,mBAAO,EAAP;AAAY;;;;;AAEtD,eAAO,IAAP,EAAmB;AAAc,mBAAA,iBAAiB,IAAI,QAAJ,CAAa,GAAb,EAAkB,cAAc,IAAd,GAAqB,GAAvC;AAAjB;AAA+D;;;;;AAEhG,eAAO,IAAP,EAAmB;AACjB,mBAAA,iBAAiB,IAAI,QAAJ,CAAa,GAAb,EAAkB,GAAlB,EAAuB,cAAc,IAAd,GAAqB,OAA5C;AAAjB;AACD;;;;;AAED,eAAO,IAAP,EAAmB;;AACjB,kBAAM,eAAe,UAAU,IAAI,uBAAuB,IAAI;mBAC/C,IAAI,kBADnB;AAEA,mBAAA,iBAAiB,IAAI,QAAJ,CAAa,GAAb,EAAkB,MAAlB,EAA0B,YAA1B;AAAjB;AACD;;;;;AAGD,kBAAU,IAAV,EAAmB;;AAEjB,gBAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAK,UAAL,CAAhC,EAAkD;AAChD,uBAAO,KAAK,UAAL,CAAP;AACD;;AAED,mBAAO,KAAK,UAAU,IAAV,CAAe,EAA3B;AACD;;;;;AAED,oBAAY,IAAZ,EAAqB;AAAY,mBAAO,KAAK,UAAU,IAAV,CAAe,EAA3B;AAAgC;;;;;;;;AAEjE,0BAAkB,IAAlB,EAAgC,SAAhC,EAAmD,OAAnD,EAAsE,OAAtE,EAAkF;AAChF,mBAAO,OAAP;AACD;;;;;;AACD,oBAAY,cAAZ,EAAiC,IAAjC,EAA6C;AAAS,mBAAO,eAAe,IAAf,CAAP;AAA8B;AA3NhF;;;;;;;;;AA8NN,aAAA,mCAAA,CAA6C,oBAA7C,EAAwE;AACtE,YAAI,CAAC,oBAAL,EAA2B;AACzB,mBAAO,EAAP;AACD;AACD,eAAO,qBAAqB,GAArB,CAAyB,uBAAsB;;AACpD,kBAAM,gBAAgB,oBAAoB,IAA1C;;AACA,kBAAM,gBAAgB,cAAc,aAApC;;AACA,kBAAM,iBAAiB,oBAAoB,IAApB,GAA2B,oBAAoB,IAA/C,GAAsD,EAA7E;AACA,mBAAO,IAAI,aAAJ,CAAkB,GAAG,cAArB,CAAP;AACD,SALM,CAAP;AAMD;;;;;AAED,aAAA,aAAA,CAAuB,IAAvB,EAAqC;;AACnC,cAAM,cAAc,KAAK,SAAL,GAAiB,OAAO,cAAP,CAAsB,KAAK,SAA3B,CAAjB,GAAyD,IAA7E;;AACA,cAAM,aAAa,cAAc,YAAY,WAA1B,GAAwC,IAA3D;;;AAGA,eAAO,cAAc,MAArB;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type, isType} from '../type';\nimport {global, stringify} from '../util';\nimport {ANNOTATIONS, PARAMETERS, PROP_METADATA} from '../util/decorators';\n\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\n\n/**\n * Attention: These regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*arguments\\)/;\nexport const INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[A-Za-z\\d$_]+\\s*{/;\nexport const INHERITED_CLASS_WITH_CTOR =\n    /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[A-Za-z\\d$_]+\\s*{[\\s\\S]*constructor\\s*\\(/;\n\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\n  private _reflect: any;\n\n  constructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n\n  isReflectionEnabled(): boolean { return true; }\n\n  factory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = new Array(paramAnnotations.length);\n    } else {\n      result = new Array(paramTypes.length);\n    }\n\n    for (let i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n\n  private _ownParameters(type: Type<any>, parentCtor: any): any[][]|null {\n    const typeStr = type.toString();\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (DELEGATE_CTOR.exec(typeStr) ||\n        (INHERITED_CLASS.exec(typeStr) && !INHERITED_CLASS_WITH_CTOR.exec(typeStr))) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if ((<any>type).parameters && (<any>type).parameters !== parentCtor.parameters) {\n      return (<any>type).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const tsickleCtorParams = (<any>type).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && (type as any)[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata &&\n        this._reflect.getOwnMetadata('design:paramtypes', type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return new Array((<any>type.length)).fill(undefined);\n  }\n\n  parameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n\n  private _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[]|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).annotations && (<any>typeOrFunc).annotations !== parentCtor.annotations) {\n      let annotations = (<any>typeOrFunc).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).decorators && (<any>typeOrFunc).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata((<any>typeOrFunc).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return (typeOrFunc as any)[ANNOTATIONS];\n    }\n    return null;\n  }\n\n  annotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n\n  private _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]}|null {\n    // Prefer the direct API.\n    if ((<any>typeOrFunc).propMetadata &&\n        (<any>typeOrFunc).propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = (<any>typeOrFunc).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if ((<any>typeOrFunc).propDecorators &&\n        (<any>typeOrFunc).propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = (<any>typeOrFunc).propDecorators;\n      const propMetadata = <{[key: string]: any[]}>{};\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return (typeOrFunc as any)[PROP_METADATA];\n    }\n    return null;\n  }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n\n  guards(type: any): {[key: string]: any} { return {}; }\n\n  getter(name: string): GetterFn { return <GetterFn>new Function('o', 'return o.' + name + ';'); }\n\n  setter(name: string): SetterFn {\n    return <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;');\n  }\n\n  method(name: string): MethodFn {\n    const functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return <MethodFn>new Function('o', 'args', functionBody);\n  }\n\n  // There is not a concept of import uri in Js, but this is useful in developing Dart applications.\n  importUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n\n  resourceUri(type: any): string { return `./${stringify(type)}`; }\n\n  resolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n  resolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n\nfunction getParentCtor(ctor: Function): Type<any> {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n"],"sourceRoot":""}