{"version":3,"sources":["../../../../../../../../packages/core/src/change_detection/differs/keyvalue_differs.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAQA,WAAQ,QAAR,EAAkB,QAAlB,QAAiD,UAAjD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4GA,SAAM,MAAA,eAAA,CAAA;;;;AAMJ,gBAAY,SAAZ,EAA8C;AAAI,WAAK,SAAL,GAAiB,SAAjB;AAA6B;;;;;;;AAE/E,WAAO,MAAP,CAAiB,SAAjB,EAAqD,MAArD,EAA6E;AAC3E,UAAI,MAAJ,EAAY;;AACV,cAAM,SAAS,OAAO,SAAP,CAAiB,KAAjB,EAAf;AACA,oBAAY,UAAU,MAAV,CAAiB,MAAjB,CAAZ;AACD;AACD,aAAO,IAAI,eAAJ,CAAoB,SAApB,CAAP;AACD;;;;;;;;;;;;;;;;;;;;;;;;AAsBD,WAAO,MAAP,CAAiB,SAAjB,EAAmD;AACjD,aAAO;AACL,iBAAS,eADJ;AAEL,oBAAa,MAAD,IAA4B;AACtC,cAAI,CAAC,MAAL,EAAa;;;AAGX,kBAAM,IAAI,KAAJ,CAAU,yDAAV,CAAN;AACD;AACD,iBAAO,gBAAgB,MAAhB,CAAuB,SAAvB,EAAkC,MAAlC,CAAP;AACD,SATI;;AAWL,cAAM,CAAC,CAAC,eAAD,EAAkB,IAAI,QAAJ,EAAlB,EAAkC,IAAI,QAAJ,EAAlC,CAAD;AAXD,OAAP;AAaD;;;;;AAED,SAAK,EAAL,EAAY;;AACV,YAAM,UAAU,KAAK,SAAL,CAAe,IAAf,CAAoB,KAAK,EAAE,QAAF,CAAW,EAAX,CAAzB,CAAhB;AACA,UAAI,OAAJ,EAAa;AACX,eAAO,OAAP;AACD;AACD,YAAM,IAAI,KAAJ,CAAU,2CAA2C,EAAE,GAAvD,CAAN;AACD;AA1DG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Optional, SkipSelf, StaticProvider} from '../../di';\n\n\n/**\n * A differ that tracks changes made to an object over time.\n *\n *\n */\nexport interface KeyValueDiffer<K, V> {\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: Map<K, V>): KeyValueChanges<K, V>|null;\n\n  /**\n   * Compute a difference between the previous state and the new `object` state.\n   *\n   * @param object containing the new value.\n   * @returns an object describing the difference. The return value is only valid until the next\n   * `diff()` invocation.\n   */\n  diff(object: {[key: string]: V}): KeyValueChanges<string, V>|null;\n  // TODO(TS2.1): diff<KP extends string>(this: KeyValueDiffer<KP, V>, object: Record<KP, V>):\n  // KeyValueDiffer<KP, V>;\n}\n\n/**\n * An object describing the changes in the `Map` or `{[k:string]: string}` since last time\n * `KeyValueDiffer#diff()` was invoked.\n *\n *\n */\nexport interface KeyValueChanges<K, V> {\n  /**\n   * Iterate over all changes. `KeyValueChangeRecord` will contain information about changes\n   * to each item.\n   */\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over changes in the order of original Map showing where the original items\n   * have moved.\n   */\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all keys for which values have changed.\n   */\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all added items.\n   */\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n\n  /**\n   * Iterate over all removed items.\n   */\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;\n}\n\n/**\n * Record representing the item change information.\n *\n *\n */\nexport interface KeyValueChangeRecord<K, V> {\n  /**\n   * Current key in the Map.\n   */\n  readonly key: K;\n\n  /**\n   * Current value for the key or `null` if removed.\n   */\n  readonly currentValue: V|null;\n\n  /**\n   * Previous value for the key or `null` if added.\n   */\n  readonly previousValue: V|null;\n}\n\n/**\n * Provides a factory for {@link KeyValueDiffer}.\n *\n *\n */\nexport interface KeyValueDifferFactory {\n  /**\n   * Test to see if the differ knows how to diff this kind of object.\n   */\n  supports(objects: any): boolean;\n\n  /**\n   * Create a `KeyValueDiffer`.\n   */\n  create<K, V>(): KeyValueDiffer<K, V>;\n}\n\n/**\n * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.\n *\n */\nexport class KeyValueDiffers {\n  /**\n   * @deprecated v4.0.0 - Should be private.\n   */\n  factories: KeyValueDifferFactory[];\n\n  constructor(factories: KeyValueDifferFactory[]) { this.factories = factories; }\n\n  static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers {\n    if (parent) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n    return new KeyValueDiffers(factories);\n  }\n\n  /**\n   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n   * {@link KeyValueDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link KeyValueDiffer} available.\n   *\n   * ```\n   * @Component({\n   *   viewProviders: [\n   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider {\n    return {\n      provide: KeyValueDiffers,\n      useFactory: (parent: KeyValueDiffers) => {\n        if (!parent) {\n          // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed\n          // to bootstrap(), which would override default pipes instead of extending them.\n          throw new Error('Cannot extend KeyValueDiffers without a parent injector');\n        }\n        return KeyValueDiffers.create(factories, parent);\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n\n  find(kv: any): KeyValueDifferFactory {\n    const factory = this.factories.find(f => f.supports(kv));\n    if (factory) {\n      return factory;\n    }\n    throw new Error(`Cannot find a differ supporting object '${kv}'`);\n  }\n}\n"],"sourceRoot":""}