{"version":3,"sources":["../../../../../../../../packages/core/src/change_detection/differs/default_keyvalue_differ.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {looseIdentical, stringify} from '../../util';\nimport {isJsObject} from '../change_detection_util';\nimport {KeyValueChangeRecord, KeyValueChanges, KeyValueDiffer, KeyValueDifferFactory} from './keyvalue_differs';\n\n\nexport class DefaultKeyValueDifferFactory<K, V> implements KeyValueDifferFactory {\n  constructor() {}\n  supports(obj: any): boolean { return obj instanceof Map || isJsObject(obj); }\n\n  create<K, V>(): KeyValueDiffer<K, V> { return new DefaultKeyValueDiffer<K, V>(); }\n}\n\nexport class DefaultKeyValueDiffer<K, V> implements KeyValueDiffer<K, V>, KeyValueChanges<K, V> {\n  private _records = new Map<K, KeyValueChangeRecord_<K, V>>();\n  private _mapHead: KeyValueChangeRecord_<K, V>|null = null;\n  // _appendAfter is used in the check loop\n  private _appendAfter: KeyValueChangeRecord_<K, V>|null = null;\n  private _previousMapHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _changesTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _additionsTail: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsHead: KeyValueChangeRecord_<K, V>|null = null;\n  private _removalsTail: KeyValueChangeRecord_<K, V>|null = null;\n\n  get isDirty(): boolean {\n    return this._additionsHead !== null || this._changesHead !== null ||\n        this._removalsHead !== null;\n  }\n\n  forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n\n  forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n\n  forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n\n  forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n\n  forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void) {\n    let record: KeyValueChangeRecord_<K, V>|null;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n\n  diff(map?: Map<any, any>|{[k: string]: any}|null): any {\n    if (!map) {\n      map = new Map();\n    } else if (!(map instanceof Map || isJsObject(map))) {\n      throw new Error(\n          `Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`);\n    }\n\n    return this.check(map) ? this : null;\n  }\n\n  onDestroy() {}\n\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map: Map<any, any>|{[k: string]: any}): boolean {\n    this._reset();\n\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n\n    this._forEach(map, (value: any, key: any) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n\n    // Items remaining at the end of the list have been deleted\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n\n      this._removalsHead = insertBefore;\n\n      for (let record: KeyValueChangeRecord_<K, V>|null = insertBefore; record !== null;\n           record = record._nextRemoved) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n\n    // Make sure tails have no next records from previous runs\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n\n    return this.isDirty;\n  }\n\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  private _insertBeforeOrAppend(\n      before: KeyValueChangeRecord_<K, V>|null,\n      record: KeyValueChangeRecord_<K, V>): KeyValueChangeRecord_<K, V>|null {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n\n      this._appendAfter = before;\n      return before;\n    }\n\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n\n    this._appendAfter = record;\n    return null;\n  }\n\n  private _getOrCreateRecordForKey(key: K, value: V): KeyValueChangeRecord_<K, V> {\n    if (this._records.has(key)) {\n      const record = this._records.get(key) !;\n      this._maybeAddToChanges(record, value);\n      const prev = record._prev;\n      const next = record._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record._next = null;\n      record._prev = null;\n\n      return record;\n    }\n\n    const record = new KeyValueChangeRecord_<K, V>(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record: KeyValueChangeRecord_<K, V>|null;\n      // let `_previousMapHead` contain the state of the map before the changes\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n\n      // Update `record.previousValue` with the value of the item before the changes\n      // We need to update all changed items (that's those which have been added and changed)\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  private _maybeAddToChanges(record: KeyValueChangeRecord_<K, V>, newValue: any): void {\n    if (!looseIdentical(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n\n  private _addToAdditions(record: KeyValueChangeRecord_<K, V>) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail !._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n\n  private _addToChanges(record: KeyValueChangeRecord_<K, V>) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail !._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n\n  /** @internal */\n  private _forEach<K, V>(obj: Map<K, V>|{[k: string]: V}, fn: (v: V, k: any) => void) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach(k => fn(obj[k], k));\n    }\n  }\n}\n\nclass KeyValueChangeRecord_<K, V> implements KeyValueChangeRecord<K, V> {\n  previousValue: V|null = null;\n  currentValue: V|null = null;\n\n  /** @internal */\n  _nextPrevious: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _next: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _prev: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextAdded: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextRemoved: KeyValueChangeRecord_<K, V>|null = null;\n  /** @internal */\n  _nextChanged: KeyValueChangeRecord_<K, V>|null = null;\n\n  constructor(public key: K) {}\n}\n"],"sourceRoot":""}