{"version":3,"sources":["../../../../../../../packages/core/src/sanitization/inert_body.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nexport class InertBodyHelper {\n  private inertBodyElement: HTMLElement;\n  private inertDocument: Document;\n\n  constructor(private defaultDoc: Document) {\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n    this.inertBodyElement = this.inertDocument.body;\n\n    if (this.inertBodyElement == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      this.inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(this.inertBodyElement);\n    }\n\n    this.inertBodyElement.innerHTML = '<svg><g onload=\"this.parentNode.remove()\"></g></svg>';\n    if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {\n      // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\n      // so use the XHR strategy.\n      this.getInertBodyElement = this.getInertBodyElement_XHR;\n      return;\n    }\n\n    this.inertBodyElement.innerHTML =\n        '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">';\n    if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {\n      // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\n      // so use the DOMParser strategy, if it is available.\n      // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\n      // fall through to the default strategy below.\n      if (isDOMParserAvailable()) {\n        this.getInertBodyElement = this.getInertBodyElement_DOMParser;\n        return;\n      }\n    }\n\n    // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\n    this.getInertBodyElement = this.getInertBodyElement_InertDocument;\n  }\n\n  /**\n   * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n   * The implementation of this is determined in the constructor, when the class is instantiated.\n   */\n  getInertBodyElement: (html: string) => HTMLElement | null;\n\n  /**\n   * Use XHR to create and fill an inert body element (on Safari 10.1)\n   * See\n   * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n   */\n  private getInertBodyElement_XHR(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      html = encodeURI(html);\n    } catch (e) {\n      return null;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'document';\n    xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\n    xhr.send(null);\n    const body: HTMLBodyElement = xhr.response.body;\n    body.removeChild(body.firstChild !);\n    return body;\n  }\n\n  /**\n   * Use DOMParser to create and fill an inert body element (on Firefox)\n   * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n   *\n   */\n  private getInertBodyElement_DOMParser(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      const body = new (window as any)\n                       .DOMParser()\n                       .parseFromString(html, 'text/html')\n                       .body as HTMLBodyElement;\n      body.removeChild(body.firstChild !);\n      return body;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * Use an HTML5 `template` element, if supported, or an inert body element created via\n   * `createHtmlDocument` to create and fill an inert DOM element.\n   * This is the default sane strategy to use if the browser does not require one of the specialised\n   * strategies above.\n   */\n  private getInertBodyElement_InertDocument(html: string) {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n    if ('content' in templateEl) {\n      templateEl.innerHTML = html;\n      return templateEl;\n    }\n\n    this.inertBodyElement.innerHTML = html;\n\n    // Support: IE 9-11 only\n    // strip custom-namespaced attributes on IE<=11\n    if ((this.defaultDoc as any).documentMode) {\n      this.stripCustomNsAttrs(this.inertBodyElement);\n    }\n\n    return this.inertBodyElement;\n  }\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n  private stripCustomNsAttrs(el: Element) {\n    const elAttrs = el.attributes;\n    // loop backwards so that we can support removals.\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib !.name;\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n    let childNode = el.firstChild;\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode as Element);\n      childNode = childNode.nextSibling;\n    }\n  }\n}\n\n/**\n * We need to determine whether the DOMParser exists in the global context.\n * The try-catch is because, on some browsers, trying to access this property\n * on window can actually throw an error.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!(window as any).DOMParser;\n  } catch (e) {\n    return false;\n  }\n}\n"],"sourceRoot":""}