Liferay.Loader.define('@example-angular-liferay$angular/core@6.1.10/esm2015/testing/src/testing_internal', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { ÉµisPromise as isPromise } from '@angular/core';
    import { global } from '@angular/core/src/util';
    import { AsyncTestCompleter } from './async_test_completer';
    import { getTestBed } from './test_bed';
    export { AsyncTestCompleter } from './async_test_completer';
    export { inject } from './test_bed';
    export { Log } from './logger';
    export { MockNgZone } from './ng_zone_mock';
    /** @type {?} */
    export const proxy = t => t;
    /** @type {?} */
    const _global = /** @type {?} */typeof window === 'undefined' ? global : window;
    /** @type {?} */
    export const afterEach = _global.afterEach;
    /** @type {?} */
    export const expect = _global.expect;
    /** @type {?} */
    const jsmBeforeEach = _global.beforeEach;
    /** @type {?} */
    const jsmDescribe = _global.describe;
    /** @type {?} */
    const jsmDDescribe = _global.fdescribe;
    /** @type {?} */
    const jsmXDescribe = _global.xdescribe;
    /** @type {?} */
    const jsmIt = _global.it;
    /** @type {?} */
    const jsmFIt = _global.fit;
    /** @type {?} */
    const jsmXIt = _global.xit;
    /** @type {?} */
    const runnerStack = [];
    jasmine.DEFAULT_TIMEOUT_INTERVAL = 3000;
    /** @type {?} */
    const globalTimeOut = jasmine.DEFAULT_TIMEOUT_INTERVAL;
    /** @type {?} */
    const testBed = getTestBed();
    /**
     * Mechanism to run `beforeEach()` functions of Angular tests.
     *
     * Note: Jasmine own `beforeEach` is used by this library to handle DI providers.
     */
    class BeforeEachRunner {
        /**
         * @param {?} _parent
         */
        constructor(_parent) {
            this._parent = _parent;
            this._fns = [];
        }
        /**
         * @param {?} fn
         * @return {?}
         */
        beforeEach(fn) {
            this._fns.push(fn);
        }
        /**
         * @return {?}
         */
        run() {
            if (this._parent) this._parent.run();
            this._fns.forEach(fn => {
                fn();
            });
        }
    }
    if (false) {
        /** @type {?} */
        BeforeEachRunner.prototype._fns;
        /** @type {?} */
        BeforeEachRunner.prototype._parent;
    }
    // Reset the test providers before each test
    jsmBeforeEach(() => {
        testBed.resetTestingModule();
    });
    /**
     * @param {?} jsmFn
     * @param {...?} args
     * @return {?}
     */
    function _describe(jsmFn, ...args) {
        /** @type {?} */
        const parentRunner = runnerStack.length === 0 ? null : runnerStack[runnerStack.length - 1];
        /** @type {?} */
        const runner = new BeforeEachRunner( /** @type {?} */parentRunner);
        runnerStack.push(runner);
        /** @type {?} */
        const suite = jsmFn(...args);
        runnerStack.pop();
        return suite;
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    export function describe(...args) {
        return _describe(jsmDescribe, ...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    export function ddescribe(...args) {
        return _describe(jsmDDescribe, ...args);
    }
    /**
     * @param {...?} args
     * @return {?}
     */
    export function xdescribe(...args) {
        return _describe(jsmXDescribe, ...args);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    export function beforeEach(fn) {
        if (runnerStack.length > 0) {
            // Inside a describe block, beforeEach() uses a BeforeEachRunner
            runnerStack[runnerStack.length - 1].beforeEach(fn);
        } else {
            // Top level beforeEach() are delegated to jasmine
            jsmBeforeEach(fn);
        }
    }
    /**
     * Allows overriding default providers defined in test_injector.js.
     *
     * The given function must return a list of DI providers.
     *
     * Example:
     *
     *   beforeEachProviders(() => [
     *     {provide: Compiler, useClass: MockCompiler},
     *     {provide: SomeToken, useValue: myValue},
     *   ]);
     * @param {?} fn
     * @return {?}
     */
    export function beforeEachProviders(fn) {
        jsmBeforeEach(() => {
            /** @type {?} */
            const providers = fn();
            if (!providers) return;
            testBed.configureTestingModule({ providers: providers });
        });
    }
    /**
     * @param {?} jsmFn
     * @param {?} testName
     * @param {?} testFn
     * @param {?=} testTimeout
     * @return {?}
     */
    function _it(jsmFn, testName, testFn, testTimeout = 0) {
        if (runnerStack.length == 0) {
            // This left here intentionally, as we should never get here, and it aids debugging.
            debugger;
            throw new Error('Empty Stack!');
        }
        /** @type {?} */
        const runner = runnerStack[runnerStack.length - 1];
        /** @type {?} */
        const timeout = Math.max(globalTimeOut, testTimeout);
        jsmFn(testName, done => {
            /** @type {?} */
            const completerProvider = {
                provide: AsyncTestCompleter,
                useFactory: () => {
                    // Mark the test as async when an AsyncTestCompleter is injected in an it()
                    return new AsyncTestCompleter();
                }
            };
            testBed.configureTestingModule({ providers: [completerProvider] });
            runner.run();
            if (testFn.length === 0) {
                /** @type {?} */
                const retVal = testFn();
                if (isPromise(retVal)) {
                    // Asynchronous test function that returns a Promise - wait for completion.
                    retVal.then(done, done.fail);
                } else {
                    // Synchronous test function - complete immediately.
                    done();
                }
            } else {
                // Asynchronous test function that takes in 'done' parameter.
                testFn(done);
            }
        }, timeout);
    }
    /**
     * @param {?} expectation
     * @param {?} assertion
     * @param {?=} timeout
     * @return {?}
     */
    export function it(expectation, assertion, timeout) {
        return _it(jsmIt, expectation, assertion, timeout);
    }
    /**
     * @param {?} expectation
     * @param {?} assertion
     * @param {?=} timeout
     * @return {?}
     */
    export function fit(expectation, assertion, timeout) {
        return _it(jsmFIt, expectation, assertion, timeout);
    }
    /**
     * @param {?} expectation
     * @param {?} assertion
     * @param {?=} timeout
     * @return {?}
     */
    export function xit(expectation, assertion, timeout) {
        return _it(jsmXIt, expectation, assertion, timeout);
    }
    export class SpyObject {
        /**
         * @param {?=} type
         */
        constructor(type) {
            if (type) {
                for (const prop in type.prototype) {
                    /** @type {?} */
                    let m = null;
                    try {
                        m = type.prototype[prop];
                    } catch (e) {
                        // As we are creating spys for abstract classes,
                        // these classes might have getters that throw when they are accessed.
                        // As we are only auto creating spys for methods, this
                        // should not matter.
                    }
                    if (typeof m === 'function') {
                        this.spy(prop);
                    }
                }
            }
        }
        /**
         * @param {?} name
         * @return {?}
         */
        spy(name) {
            if (! /** @type {?} */this[name]) {
                /** @type {?} */this[name] = jasmine.createSpy(name);
            }
            return (/** @type {?} */this[name]
            );
        }
        /**
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        prop(name, value) {
            /** @type {?} */this[name] = value;
        }
        /**
         * @param {?=} object
         * @param {?=} config
         * @param {?=} overrides
         * @return {?}
         */
        static stub(object = null, config = null, overrides = null) {
            if (!(object instanceof SpyObject)) {
                overrides = config;
                config = object;
                object = new SpyObject();
            }
            /** @type {?} */
            const m = Object.assign({}, config, overrides);
            Object.keys(m).forEach(key => {
                object.spy(key).and.returnValue(m[key]);
            });
            return object;
        }
    }
});
//# sourceMappingURL=testing_internal.js.map