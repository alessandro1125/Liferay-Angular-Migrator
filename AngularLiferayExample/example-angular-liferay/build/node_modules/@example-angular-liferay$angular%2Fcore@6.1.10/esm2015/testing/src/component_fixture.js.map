{"version":3,"sources":["../../../../../../../packages/core/testing/src/component_fixture.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectorRef, ComponentRef, DebugElement, ElementRef, NgZone, RendererFactory2, getDebugNode} from '@angular/core';\n\n\n/**\n * Fixture for debugging and testing a component.\n *\n *\n */\nexport class ComponentFixture<T> {\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement: DebugElement;\n\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance: T;\n\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement: any;\n\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef: ElementRef;\n\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef: ChangeDetectorRef;\n\n  private _renderer: RendererFactory2|null|undefined;\n  private _isStable: boolean = true;\n  private _isDestroyed: boolean = false;\n  private _resolve: ((result: any) => void)|null = null;\n  private _promise: Promise<any>|null = null;\n  private _onUnstableSubscription: any /** TODO #9100 */ = null;\n  private _onStableSubscription: any /** TODO #9100 */ = null;\n  private _onMicrotaskEmptySubscription: any /** TODO #9100 */ = null;\n  private _onErrorSubscription: any /** TODO #9100 */ = null;\n\n  constructor(\n      public componentRef: ComponentRef<T>, public ngZone: NgZone|null,\n      private _autoDetect: boolean) {\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = <DebugElement>getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription =\n            ngZone.onUnstable.subscribe({next: () => { this._isStable = false; }});\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true;\n            // Check whether there is a pending whenStable() completer to resolve.\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve !(true);\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n\n        this._onErrorSubscription =\n            ngZone.onError.subscribe({next: (error: any) => { throw error; }});\n      });\n    }\n  }\n\n  private _tick(checkNoChanges: boolean) {\n    this.changeDetectorRef.detectChanges();\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges: boolean = true): void {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => { this._tick(checkNoChanges); });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges(): void { this.changeDetectorRef.checkNoChanges(); }\n\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n  autoDetectChanges(autoDetect: boolean = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable(): boolean { return this._isStable && !this.ngZone !.hasPendingMacrotasks; }\n\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable(): Promise<any> {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => { this._resolve = res; });\n      return this._promise;\n    }\n  }\n\n\n  private _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer as RendererFactory2 | null;\n  }\n\n  /**\n    * Get a promise that resolves when the ui state is stable following animations.\n    */\n  whenRenderingDone(): Promise<any> {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n\n  /**\n   * Trigger component destruction.\n   */\n  destroy(): void {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n        this._onUnstableSubscription = null;\n      }\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n        this._onStableSubscription = null;\n      }\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n        this._onMicrotaskEmptySubscription = null;\n      }\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n        this._onErrorSubscription = null;\n      }\n      this._isDestroyed = true;\n    }\n  }\n}\n\nfunction scheduleMicroTask(fn: Function) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n"],"sourceRoot":""}