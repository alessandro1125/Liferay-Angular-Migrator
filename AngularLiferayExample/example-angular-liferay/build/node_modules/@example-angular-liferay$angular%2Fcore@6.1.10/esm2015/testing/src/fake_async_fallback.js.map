{"version":3,"sources":["../../../../../../../packages/core/testing/src/fake_async_fallback.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAYA,UAAM,QAAa,OAAO,IAAP,KAAgB,WAAhB,GAA8B,IAA9B,GAAqC,IAAxD;;AACA,UAAM,wBAAwB,SAAS,MAAM,uBAAN,CAAvC;;AAIA,UAAM,gBACF,SAAS,MAAM,eAAN,CADb;;AAGA,QAAI,yBAA8B,IAAlC;;;;;;;;AAQA,WAAM,SAAA,0BAAA,GAAA;AACJ,iCAAyB,IAAzB;;AAEA,yBAAiB,cAAc,aAAd,GAA8B,aAA9B,EAAjB;AACD;;AAED,QAAI,mBAAmB,KAAvB;;;;;;;;;;;;;;;;;;;;AAqBA,WAAM,SAAA,iBAAA,CAA4B,EAA5B,EAAwC;;AAE5C,eAAO,UAAS,GAAG,IAAZ,EAAuB;;AAC5B,kBAAM,gBAAgB,cAAc,aAAd,EAAtB;AACA,gBAAI,gBAAJ,EAAsB;AACpB,sBAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACD;AACD,+BAAmB,IAAnB;AACA,gBAAI;AACF,oBAAI,CAAC,sBAAL,EAA6B;AAC3B,wBAAI,cAAc,WAAd,cAAuC,qBAA3C,EAAkE;AAChE,8BAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AACD;AAED,6CAAyB,IAAI,qBAAJ,EAAzB;AACD;;AAED,oBAAI,GAAJ;;AACA,sBAAM,oBAAoB,cAAc,WAAd,EAA1B;AACA,8BAAc,WAAd,CAA0B,sBAA1B;AACA,oBAAI;AACF,0BAAM,GAAG,KAAH,CAAS,IAAT,EAAe,IAAf,CAAN;AACA;AACD,iBAHD,SAGU;AACR,kCAAc,WAAd,CAA0B,iBAA1B;AACD;AAED,oBAAI,uBAAuB,qBAAvB,CAA6C,MAA7C,GAAsD,CAA1D,EAA6D;AAC3D,0BAAM,IAAI,KAAJ,CACF,GAAG,uBAAuB,qBAAvB,CAA6C,MAAM,GAAtD,GACA,uCAFE,CAAN;AAGD;AAED,oBAAI,uBAAuB,aAAvB,CAAqC,MAArC,GAA8C,CAAlD,EAAqD;AACnD,0BAAM,IAAI,KAAJ,CACF,GAAG,uBAAuB,aAAvB,CAAqC,MAAM,+BAD5C,CAAN;AAED;AACD,uBAAO,GAAP;AACD,aA9BD,SA8BU;AACR,mCAAmB,KAAnB;AACA;AACD;AACF,SAxCD;AAyCD;;;;AAED,aAAA,qBAAA,GAAA;AACE,YAAI,0BAA0B,IAA9B,EAAoC;AAClC,kBAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACD;AACD,eAAO,sBAAP;AACD;;;;;;;;;;;;;;;;AAeD,WAAM,SAAA,YAAA,CAAuB,SAAiB,CAAxC,EAAyC;AAC7C,gCAAwB,IAAxB,CAA6B,MAA7B;AACD;;;;;;;;;;;AAYD,WAAM,SAAA,aAAA,CAAwB,QAAxB,EAAyC;AAC7C,eAAO,wBAAwB,KAAxB,CAA8B,QAA9B,CAAP;AACD;;;;;;;AAOD,WAAM,SAAA,4BAAA,GAAA;;AACJ,cAAM,WAAW,uBAAjB;AACA,iBAAS,qBAAT,CAA+B,MAA/B,GAAwC,CAAxC;AACD;;;;;;;AAOD,WAAM,SAAA,uBAAA,GAAA;AACJ,gCAAwB,eAAxB;AACD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * fakeAsync has been moved to zone.js\n * this file is for fallback in case old version of zone.js is used\n */\nconst _Zone: any = typeof Zone !== 'undefined' ? Zone : null;\nconst FakeAsyncTestZoneSpec = _Zone && _Zone['FakeAsyncTestZoneSpec'];\ntype ProxyZoneSpec = {\n  setDelegate(delegateSpec: ZoneSpec): void; getDelegate(): ZoneSpec; resetDelegate(): void;\n};\nconst ProxyZoneSpec: {get(): ProxyZoneSpec; assertPresent: () => ProxyZoneSpec} =\n    _Zone && _Zone['ProxyZoneSpec'];\n\nlet _fakeAsyncTestZoneSpec: any = null;\n\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @experimental\n */\nexport function resetFakeAsyncZoneFallback() {\n  _fakeAsyncTestZoneSpec = null;\n  // in node.js testing we may not have ProxyZoneSpec in which case there is nothing to reset.\n  ProxyZoneSpec && ProxyZoneSpec.assertPresent().resetDelegate();\n}\n\nlet _inFakeAsyncCall = false;\n\n/**\n * Wraps a function to be executed in the fakeAsync zone:\n * - microtasks are manually executed by calling `flushMicrotasks()`,\n * - timers are synchronous, `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception will be thrown.\n *\n * Can be used to wrap inject() calls.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @param fn\n * @returns The function wrapped to be executed in the fakeAsync zone\n *\n * @experimental\n */\nexport function fakeAsyncFallback(fn: Function): (...args: any[]) => any {\n  // Not using an arrow function to preserve context passed from call site\n  return function(...args: any[]) {\n    const proxyZoneSpec = ProxyZoneSpec.assertPresent();\n    if (_inFakeAsyncCall) {\n      throw new Error('fakeAsync() calls can not be nested');\n    }\n    _inFakeAsyncCall = true;\n    try {\n      if (!_fakeAsyncTestZoneSpec) {\n        if (proxyZoneSpec.getDelegate() instanceof FakeAsyncTestZoneSpec) {\n          throw new Error('fakeAsync() calls can not be nested');\n        }\n\n        _fakeAsyncTestZoneSpec = new FakeAsyncTestZoneSpec();\n      }\n\n      let res: any;\n      const lastProxyZoneSpec = proxyZoneSpec.getDelegate();\n      proxyZoneSpec.setDelegate(_fakeAsyncTestZoneSpec);\n      try {\n        res = fn.apply(this, args);\n        flushMicrotasksFallback();\n      } finally {\n        proxyZoneSpec.setDelegate(lastProxyZoneSpec);\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length > 0) {\n        throw new Error(\n            `${_fakeAsyncTestZoneSpec.pendingPeriodicTimers.length} ` +\n            `periodic timer(s) still in the queue.`);\n      }\n\n      if (_fakeAsyncTestZoneSpec.pendingTimers.length > 0) {\n        throw new Error(\n            `${_fakeAsyncTestZoneSpec.pendingTimers.length} timer(s) still in the queue.`);\n      }\n      return res;\n    } finally {\n      _inFakeAsyncCall = false;\n      resetFakeAsyncZoneFallback();\n    }\n  };\n}\n\nfunction _getFakeAsyncZoneSpec(): any {\n  if (_fakeAsyncTestZoneSpec == null) {\n    throw new Error('The code should be running in the fakeAsync zone to call this function');\n  }\n  return _fakeAsyncTestZoneSpec;\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * @experimental\n */\nexport function tickFallback(millis: number = 0): void {\n  _getFakeAsyncZoneSpec().tick(millis);\n}\n\n/**\n * Simulates the asynchronous passage of time for the timers in the fakeAsync zone by\n * draining the macrotask queue until it is empty. The returned value is the milliseconds\n * of time that would have been elapsed.\n *\n * @param maxTurns\n * @returns The simulated time elapsed, in millis.\n *\n * @experimental\n */\nexport function flushFallback(maxTurns?: number): number {\n  return _getFakeAsyncZoneSpec().flush(maxTurns);\n}\n\n/**\n * Discard all remaining periodic tasks.\n *\n * @experimental\n */\nexport function discardPeriodicTasksFallback(): void {\n  const zoneSpec = _getFakeAsyncZoneSpec();\n  zoneSpec.pendingPeriodicTimers.length = 0;\n}\n\n/**\n * Flush any pending microtasks.\n *\n * @experimental\n */\nexport function flushMicrotasksFallback(): void {\n  _getFakeAsyncZoneSpec().flushMicrotasks();\n}\n"],"sourceRoot":""}