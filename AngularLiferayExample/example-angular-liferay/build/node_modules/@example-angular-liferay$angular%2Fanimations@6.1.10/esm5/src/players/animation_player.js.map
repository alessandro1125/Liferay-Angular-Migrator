{"version":3,"sources":["../../../../../../../../../../packages/animations/src/players/animation_player.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {scheduleMicroTask} from '../util';\n\n/**\n * Provides programmatic control of a reusable animation sequence,\n * built using the `build()` method of `AnimationBuilder`. The `build()` method\n * returns a factory, whose `create()` method instantiates and initializes this interface.\n *\n * @see `AnimationBuilder`\n * @see `AnimationFactory`\n * @see `animate()` \n *\n */\nexport interface AnimationPlayer {\n  /**\n   * Provides a callback to invoke when the animation finishes.\n   * @param fn The callback function.\n   * @see `finish()`\n   */\n  onDone(fn: () => void): void;\n  /**\n   * Provides a callback to invoke when the animation starts.\n   * @param fn The callback function.\n   * @see `run()`\n   */\n  onStart(fn: () => void): void;\n  /**\n   * Provides a callback to invoke after the animation is destroyed.\n   * @param fn The callback function.\n   * @see `destroy()`\n   * @see `beforeDestroy()`\n   */\n  onDestroy(fn: () => void): void;\n  /**\n   * Initializes the animation.\n   */\n  init(): void;\n  /**\n   * Reports whether the animation has started.\n   * @returns True if the animation has started, false otherwise.\n   */\n  hasStarted(): boolean;\n  /**\n   * Runs the animation, invoking the `onStart()` callback.\n   */\n  play(): void;\n  /**\n   * Pauses the animation.\n   */\n  pause(): void;\n  /**\n   * Restarts the paused animation.\n   */\n  restart(): void;\n  /**\n   * Ends the animation, invoking the `onDone()` callback.\n   */\n  finish(): void;\n  /**\n   * Destroys the animation, after invoking the `beforeDestroy()` callback.\n   * Calls the `onDestroy()` callback when destruction is completed.\n   */\n  destroy(): void;\n  /**\n   * Resets the animation to its initial state.\n   */\n  reset(): void;\n  /**\n   * Sets the position of the animation.\n   * @param position A 0-based offset into the duration, in milliseconds.\n   */\n  setPosition(position: any /** TODO #9100 */): void;\n  /**\n   * Reports the current position of the animation.\n   * @returns A 0-based offset into the duration, in milliseconds.\n   */\n  getPosition(): number;\n  /**\n   * The parent of this player, if any.\n   */\n  parentPlayer: AnimationPlayer|null;\n  /**\n   * The total run time of the animation, in milliseconds.\n   */\n  readonly totalTime: number;\n  /**\n   * Provides a callback to invoke before the animation is destroyed.\n   */\n  beforeDestroy?: () => any;\n  /** @internal\n   * Internal\n   */\n  triggerCallback?: (phaseName: string) => void;\n  /** @internal\n   * Internal\n   */\n  disabled?: boolean;\n}\n\n/**\n * An empty programmatic controller for reusable animations.\n * Used internally when animations are disabled, to avoid\n * checking for the null case when an animation player is expected.\n *\n * @see `animate()`\n * @see `AnimationPlayer`\n * @see `GroupPlayer`\n *\n */\nexport class NoopAnimationPlayer implements AnimationPlayer {\n  private _onDoneFns: Function[] = [];\n  private _onStartFns: Function[] = [];\n  private _onDestroyFns: Function[] = [];\n  private _started = false;\n  private _destroyed = false;\n  private _finished = false;\n  public parentPlayer: AnimationPlayer|null = null;\n  public readonly totalTime: number;\n  constructor(duration: number = 0, delay: number = 0) { this.totalTime = duration + delay; }\n  private _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n  onStart(fn: () => void): void { this._onStartFns.push(fn); }\n  onDone(fn: () => void): void { this._onDoneFns.push(fn); }\n  onDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n  hasStarted(): boolean { return this._started; }\n  init(): void {}\n  play(): void {\n    if (!this.hasStarted()) {\n      this._onStart();\n      this.triggerMicrotask();\n    }\n    this._started = true;\n  }\n\n  /** @internal */\n  triggerMicrotask() { scheduleMicroTask(() => this._onFinish()); }\n\n  private _onStart() {\n    this._onStartFns.forEach(fn => fn());\n    this._onStartFns = [];\n  }\n\n  pause(): void {}\n  restart(): void {}\n  finish(): void { this._onFinish(); }\n  destroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      if (!this.hasStarted()) {\n        this._onStart();\n      }\n      this.finish();\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n  reset(): void {}\n  setPosition(position: number): void {}\n  getPosition(): number { return 0; }\n\n  /** @internal */\n  triggerCallback(phaseName: string): void {\n    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\n"],"sourceRoot":""}