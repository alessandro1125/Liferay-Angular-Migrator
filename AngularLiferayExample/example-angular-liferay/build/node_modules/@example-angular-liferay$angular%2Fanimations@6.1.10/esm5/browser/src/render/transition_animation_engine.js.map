{"version":3,"sources":["../../../../../../../../../../../../packages/animations/browser/src/render/transition_animation_engine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationOptions, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer as AnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionFactory} from '../dsl/animation_transition_factory';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger} from '../dsl/animation_trigger';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {ENTER_CLASSNAME, LEAVE_CLASSNAME, NG_ANIMATING_CLASSNAME, NG_ANIMATING_SELECTOR, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, copyObj, eraseStyles, iteratorToArray, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\n\nconst EMPTY_PLAYER_ARRAY: TransitionAnimationPlayer[] = [];\nconst NULL_REMOVAL_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForRemoval: false,\n  setForMove: false,\n  hasAnimation: false,\n  removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForMove: false,\n  setForRemoval: false,\n  hasAnimation: false,\n  removedBeforeQueried: true\n};\n\ninterface TriggerListener {\n  name: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nexport interface QueueInstruction {\n  element: any;\n  triggerName: string;\n  fromState: StateValue;\n  toState: StateValue;\n  transition: AnimationTransitionFactory;\n  player: TransitionAnimationPlayer;\n  isFallbackTransition: boolean;\n}\n\nexport const REMOVAL_FLAG = '__ng_removed';\n\nexport interface ElementAnimationState {\n  setForRemoval: boolean;\n  setForMove: boolean;\n  hasAnimation: boolean;\n  namespaceId: string;\n  removedBeforeQueried: boolean;\n}\n\nexport class StateValue {\n  public value: string;\n  public options: AnimationOptions;\n\n  get params(): {[key: string]: any} { return this.options.params as{[key: string]: any}; }\n\n  constructor(input: any, public namespaceId: string = '') {\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    if (isObj) {\n      const options = copyObj(input as any);\n      delete options['value'];\n      this.options = options as AnimationOptions;\n    } else {\n      this.options = {};\n    }\n    if (!this.options.params) {\n      this.options.params = {};\n    }\n  }\n\n  absorbOptions(options: AnimationOptions) {\n    const newParams = options.params;\n    if (newParams) {\n      const oldParams = this.options.params !;\n      Object.keys(newParams).forEach(prop => {\n        if (oldParams[prop] == null) {\n          oldParams[prop] = newParams[prop];\n        }\n      });\n    }\n  }\n}\n\nexport const VOID_VALUE = 'void';\nexport const DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\n\nexport class AnimationTransitionNamespace {\n  public players: TransitionAnimationPlayer[] = [];\n\n  private _triggers: {[triggerName: string]: AnimationTrigger} = {};\n  private _queue: QueueInstruction[] = [];\n\n  private _elementListeners = new Map<any, TriggerListener[]>();\n\n  private _hostClassName: string;\n\n  constructor(\n      public id: string, public hostElement: any, private _engine: TransitionAnimationEngine) {\n    this._hostClassName = 'ng-tns-' + id;\n    addClass(hostElement, this._hostClassName);\n  }\n\n  listen(element: any, name: string, phase: string, callback: (event: any) => boolean): () => any {\n    if (!this._triggers.hasOwnProperty(name)) {\n      throw new Error(`Unable to listen on the animation trigger event \"${\n          phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n    }\n\n    if (phase == null || phase.length == 0) {\n      throw new Error(`Unable to listen on the animation trigger \"${\n          name}\" because the provided event is undefined!`);\n    }\n\n    if (!isTriggerEventValid(phase)) {\n      throw new Error(`The provided animation trigger event \"${phase}\" for the animation trigger \"${\n          name}\" is not supported!`);\n    }\n\n    const listeners = getOrSetAsInMap(this._elementListeners, element, []);\n    const data = {name, phase, callback};\n    listeners.push(data);\n\n    const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n    if (!triggersWithStates.hasOwnProperty(name)) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates[name] = DEFAULT_STATE_VALUE;\n    }\n\n    return () => {\n      // the event listener is removed AFTER the flush has occurred such\n      // that leave animations callbacks can fire (otherwise if the node\n      // is removed in between then the listeners would be deregistered)\n      this._engine.afterFlush(() => {\n        const index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n\n        if (!this._triggers[name]) {\n          delete triggersWithStates[name];\n        }\n      });\n    };\n  }\n\n  register(name: string, ast: AnimationTrigger): boolean {\n    if (this._triggers[name]) {\n      // throw\n      return false;\n    } else {\n      this._triggers[name] = ast;\n      return true;\n    }\n  }\n\n  private _getTrigger(name: string) {\n    const trigger = this._triggers[name];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${name}\" has not been registered!`);\n    }\n    return trigger;\n  }\n\n  trigger(element: any, triggerName: string, value: any, defaultToFallback: boolean = true):\n      TransitionAnimationPlayer|undefined {\n    const trigger = this._getTrigger(triggerName);\n    const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n    let triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = {});\n    }\n\n    let fromState = triggersWithStates[triggerName];\n    const toState = new StateValue(value, this.id);\n\n    const isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbOptions(fromState.options);\n    }\n\n    triggersWithStates[triggerName] = toState;\n\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    }\n\n    const isRemoval = toState.value === VOID_VALUE;\n\n    // normally this isn't reached by here, however, if an object expression\n    // is passed in then it may be a new object each time. Comparing the value\n    // is important since that will stay the same despite there being a new object.\n    // The removal arc here is special cased because the same element is triggered\n    // twice in the event that it contains animations on the outer/inner portions\n    // of the host container\n    if (!isRemoval && fromState.value === toState.value) {\n      // this means that despite the value not changing, some inner params\n      // have changed which means that the animation final styles need to be applied\n      if (!objEquals(fromState.params, toState.params)) {\n        const errors: any[] = [];\n        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n        if (errors.length) {\n          this._engine.reportError(errors);\n        } else {\n          this._engine.afterFlush(() => {\n            eraseStyles(element, fromStyles);\n            setStyles(element, toStyles);\n          });\n        }\n      }\n      return;\n    }\n\n    const playersOnElement: TransitionAnimationPlayer[] =\n        getOrSetAsInMap(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      // only remove the player if it is queued on the EXACT same trigger/namespace\n      // we only also deal with queued players here because if the animation has\n      // started then we want to keep the player alive until the flush happens\n      // (which is where the previousPlayers are passed into the new palyer)\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n\n    let transition =\n        trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n    let isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n\n    this._engine.totalQueuedPlayers++;\n    this._queue.push(\n        {element, triggerName, transition, fromState, toState, player, isFallbackTransition});\n\n    if (!isFallbackTransition) {\n      addClass(element, QUEUED_CLASSNAME);\n      player.onStart(() => { removeClass(element, QUEUED_CLASSNAME); });\n    }\n\n    player.onDone(() => {\n      let index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n\n      const players = this._engine.playersByElement.get(element);\n      if (players) {\n        let index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n\n    this.players.push(player);\n    playersOnElement.push(player);\n\n    return player;\n  }\n\n  deregister(name: string) {\n    delete this._triggers[name];\n\n    this._engine.statesByElement.forEach((stateMap, element) => { delete stateMap[name]; });\n\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(\n          element, listeners.filter(entry => { return entry.name != name; }));\n    });\n  }\n\n  clearElementCache(element: any) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n\n  private _signalRemovalForInnerTriggers(rootElement: any, context: any, animate: boolean = false) {\n    // emulate a leave animation for all inner nodes within this node.\n    // If there are no animations found for any of the nodes then clear the cache\n    // for the element.\n    this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(elm => {\n      // this means that an inner remove() operation has already kicked off\n      // the animation on this element...\n      if (elm[REMOVAL_FLAG]) return;\n\n      const namespaces = this._engine.fetchNamespacesByElement(elm);\n      if (namespaces.size) {\n        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n      } else {\n        this.clearElementCache(elm);\n      }\n    });\n  }\n\n  triggerLeaveAnimation(\n      element: any, context: any, destroyAfterComplete?: boolean,\n      defaultToFallback?: boolean): boolean {\n    const triggerStates = this._engine.statesByElement.get(element);\n    if (triggerStates) {\n      const players: TransitionAnimationPlayer[] = [];\n      Object.keys(triggerStates).forEach(triggerName => {\n        // this check is here in the event that an element is removed\n        // twice (both on the host level and the component level)\n        if (this._triggers[triggerName]) {\n          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n\n      if (players.length) {\n        this._engine.markElementAsRemoved(this.id, element, true, context);\n        if (destroyAfterComplete) {\n          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  prepareLeaveAnimationListeners(element: any) {\n    const listeners = this._elementListeners.get(element);\n    if (listeners) {\n      const visitedTriggers = new Set<string>();\n      listeners.forEach(listener => {\n        const triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n\n        const trigger = this._triggers[triggerName];\n        const transition = trigger.fallbackTransition;\n        const elementStates = this._engine.statesByElement.get(element) !;\n        const fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\n        const toState = new StateValue(VOID_VALUE);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n  }\n\n  removeNode(element: any, context: any): void {\n    const engine = this._engine;\n\n    if (element.childElementCount) {\n      this._signalRemovalForInnerTriggers(element, context, true);\n    }\n\n    // this means that a * => VOID animation was detected and kicked off\n    if (this.triggerLeaveAnimation(element, context, true)) return;\n\n    // find the player that is animating and make sure that the\n    // removal is delayed until that player has completed\n    let containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const currentPlayers =\n          engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n\n      // when this `if statement` does not continue forward it means that\n      // a previous animation query has selected the current element and\n      // is animating it. In this situation want to continue forwards and\n      // allow the element to be queued up for animation later.\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let parent = element;\n        while (parent = parent.parentNode) {\n          const triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // at this stage we know that the element will either get removed\n    // during flush or will be picked up by a parent query. Either way\n    // we need to fire the listeners for this element when it DOES get\n    // removed (once the query parent animation is done or after flush)\n    this.prepareLeaveAnimationListeners(element);\n\n    // whether or not a parent has an animation we need to delay the deferral of the leave\n    // operation until we have more information (which we do after flush() has been called)\n    if (containsPotentialParentTransition) {\n      engine.markElementAsRemoved(this.id, element, false, context);\n    } else {\n      // we do this after the flush has occurred such\n      // that the callbacks can be fired\n      engine.afterFlush(() => this.clearElementCache(element));\n      engine.destroyInnerAnimations(element);\n      engine._onRemovalComplete(element, context);\n    }\n  }\n\n  insertNode(element: any, parent: any): void { addClass(element, this._hostClassName); }\n\n  drainQueuedTransitions(microtaskId: number): QueueInstruction[] {\n    const instructions: QueueInstruction[] = [];\n    this._queue.forEach(entry => {\n      const player = entry.player;\n      if (player.destroyed) return;\n\n      const element = entry.element;\n      const listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach((listener: TriggerListener) => {\n          if (listener.name == entry.triggerName) {\n            const baseEvent = makeAnimationEvent(\n                element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            (baseEvent as any)['_data'] = microtaskId;\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          // now we can destroy the element properly since the event listeners have\n          // been bound to the player\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n\n    this._queue = [];\n\n    return instructions.sort((a, b) => {\n      // if depCount == 0 them move to front\n      // otherwise if a contains b then move back\n      const d0 = a.transition.ast.depCount;\n      const d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n    });\n  }\n\n  destroy(context: any) {\n    this.players.forEach(p => p.destroy());\n    this._signalRemovalForInnerTriggers(this.hostElement, context);\n  }\n\n  elementContainsData(element: any): boolean {\n    let containsData = false;\n    if (this._elementListeners.has(element)) containsData = true;\n    containsData =\n        (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n    return containsData;\n  }\n}\n\nexport interface QueuedTransition {\n  element: any;\n  instruction: AnimationTransitionInstruction;\n  player: TransitionAnimationPlayer;\n}\n\nexport class TransitionAnimationEngine {\n  public players: TransitionAnimationPlayer[] = [];\n  public newHostElements = new Map<any, AnimationTransitionNamespace>();\n  public playersByElement = new Map<any, TransitionAnimationPlayer[]>();\n  public playersByQueriedElement = new Map<any, TransitionAnimationPlayer[]>();\n  public statesByElement = new Map<any, {[triggerName: string]: StateValue}>();\n  public disabledNodes = new Set<any>();\n\n  public totalAnimations = 0;\n  public totalQueuedPlayers = 0;\n\n  private _namespaceLookup: {[id: string]: AnimationTransitionNamespace} = {};\n  private _namespaceList: AnimationTransitionNamespace[] = [];\n  private _flushFns: (() => any)[] = [];\n  private _whenQuietFns: (() => any)[] = [];\n\n  public namespacesByHostElement = new Map<any, AnimationTransitionNamespace>();\n  public collectedEnterElements: any[] = [];\n  public collectedLeaveElements: any[] = [];\n\n  // this method is designed to be overridden by the code that uses this engine\n  public onRemovalComplete = (element: any, context: any) => {};\n\n  /** @internal */\n  _onRemovalComplete(element: any, context: any) { this.onRemovalComplete(element, context); }\n\n  constructor(\n      public bodyNode: any, public driver: AnimationDriver,\n      private _normalizer: AnimationStyleNormalizer) {}\n\n  get queuedPlayers(): TransitionAnimationPlayer[] {\n    const players: TransitionAnimationPlayer[] = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n\n  createNamespace(namespaceId: string, hostElement: any) {\n    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (hostElement.parentNode) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      // defer this later until flush during when the host element has\n      // been inserted so that we know exactly where to place it in\n      // the namespace list\n      this.newHostElements.set(hostElement, ns);\n\n      // given that this host element is apart of the animation code, it\n      // may or may not be inserted by a parent node that is an of an\n      // animation renderer type. If this happens then we can still have\n      // access to this item when we query for :enter nodes. If the parent\n      // is a renderer then the set data-structure will normalize the entry\n      this.collectEnterElement(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n\n  private _balanceNamespaceList(ns: AnimationTransitionNamespace, hostElement: any) {\n    const limit = this._namespaceList.length - 1;\n    if (limit >= 0) {\n      let found = false;\n      for (let i = limit; i >= 0; i--) {\n        const nextNamespace = this._namespaceList[i];\n        if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {\n          this._namespaceList.splice(i + 1, 0, ns);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        this._namespaceList.splice(0, 0, ns);\n      }\n    } else {\n      this._namespaceList.push(ns);\n    }\n\n    this.namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n\n  register(namespaceId: string, hostElement: any) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    return ns;\n  }\n\n  registerTrigger(namespaceId: string, name: string, trigger: AnimationTrigger) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (ns && ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n\n  destroy(namespaceId: string, context: any) {\n    if (!namespaceId) return;\n\n    const ns = this._fetchNamespace(namespaceId);\n\n    this.afterFlush(() => {\n      this.namespacesByHostElement.delete(ns.hostElement);\n      delete this._namespaceLookup[namespaceId];\n      const index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n    });\n\n    this.afterFlushAnimationsDone(() => ns.destroy(context));\n  }\n\n  private _fetchNamespace(id: string) { return this._namespaceLookup[id]; }\n\n  fetchNamespacesByElement(element: any): Set<AnimationTransitionNamespace> {\n    // normally there should only be one namespace per element, however\n    // if @triggers are placed on both the component element and then\n    // its host element (within the component code) then there will be\n    // two namespaces returned. We use a set here to simply the dedupe\n    // of namespaces incase there are multiple triggers both the elm and host\n    const namespaces = new Set<AnimationTransitionNamespace>();\n    const elementStates = this.statesByElement.get(element);\n    if (elementStates) {\n      const keys = Object.keys(elementStates);\n      for (let i = 0; i < keys.length; i++) {\n        const nsId = elementStates[keys[i]].namespaceId;\n        if (nsId) {\n          const ns = this._fetchNamespace(nsId);\n          if (ns) {\n            namespaces.add(ns);\n          }\n        }\n      }\n    }\n    return namespaces;\n  }\n\n  trigger(namespaceId: string, element: any, name: string, value: any): boolean {\n    if (isElementNode(element)) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.trigger(element, name, value);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  insertNode(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    if (!isElementNode(element)) return;\n\n    // special case for when an element is removed and reinserted (move operation)\n    // when this occurs we do not want to use the element for deletion later\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      details.setForRemoval = false;\n      details.setForMove = true;\n      const index = this.collectedLeaveElements.indexOf(element);\n      if (index >= 0) {\n        this.collectedLeaveElements.splice(index, 1);\n      }\n    }\n\n    // in the event that the namespaceId is blank then the caller\n    // code does not contain any animation code in it, but it is\n    // just being called so that the node is marked as being inserted\n    if (namespaceId) {\n      const ns = this._fetchNamespace(namespaceId);\n      // This if-statement is a workaround for router issue #21947.\n      // The router sometimes hits a race condition where while a route\n      // is being instantiated a new navigation arrives, triggering leave\n      // animation of DOM that has not been fully initialized, until this\n      // is resolved, we need to handle the scenario when DOM is not in a\n      // consistent state during the animation.\n      if (ns) {\n        ns.insertNode(element, parent);\n      }\n    }\n\n    // only *directives and host elements are inserted before\n    if (insertBefore) {\n      this.collectEnterElement(element);\n    }\n  }\n\n  collectEnterElement(element: any) { this.collectedEnterElements.push(element); }\n\n  markElementAsDisabled(element: any, value: boolean) {\n    if (value) {\n      if (!this.disabledNodes.has(element)) {\n        this.disabledNodes.add(element);\n        addClass(element, DISABLED_CLASSNAME);\n      }\n    } else if (this.disabledNodes.has(element)) {\n      this.disabledNodes.delete(element);\n      removeClass(element, DISABLED_CLASSNAME);\n    }\n  }\n\n  removeNode(namespaceId: string, element: any, context: any): void {\n    if (!isElementNode(element)) {\n      this._onRemovalComplete(element, context);\n      return;\n    }\n\n    const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n    if (ns) {\n      ns.removeNode(element, context);\n    } else {\n      this.markElementAsRemoved(namespaceId, element, false, context);\n    }\n  }\n\n  markElementAsRemoved(namespaceId: string, element: any, hasAnimation?: boolean, context?: any) {\n    this.collectedLeaveElements.push(element);\n    element[REMOVAL_FLAG] = {\n      namespaceId,\n      setForRemoval: context, hasAnimation,\n      removedBeforeQueried: false\n    };\n  }\n\n  listen(\n      namespaceId: string, element: any, name: string, phase: string,\n      callback: (event: any) => boolean): () => any {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n\n  private _buildInstruction(\n      entry: QueueInstruction, subTimelines: ElementInstructionMap, enterClassName: string,\n      leaveClassName: string, skipBuildAst?: boolean) {\n    return entry.transition.build(\n        this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName,\n        leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n  }\n\n  destroyInnerAnimations(containerElement: any) {\n    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n\n    if (this.playersByQueriedElement.size == 0) return;\n\n    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n  }\n\n  destroyActiveAnimationsForElement(element: any) {\n    const players = this.playersByElement.get(element);\n    if (players) {\n      players.forEach(player => {\n        // special case for when an element is set for destruction, but hasn't started.\n        // in this situation we want to delay the destruction until the flush occurs\n        // so that any event listeners attached to the player are triggered.\n        if (player.queued) {\n          player.markedForDestroy = true;\n        } else {\n          player.destroy();\n        }\n      });\n    }\n  }\n\n  finishActiveQueriedAnimationOnElement(element: any) {\n    const players = this.playersByQueriedElement.get(element);\n    if (players) {\n      players.forEach(player => player.finish());\n    }\n  }\n\n  whenRenderingDone(): Promise<any> {\n    return new Promise(resolve => {\n      if (this.players.length) {\n        return optimizeGroupPlayer(this.players).onDone(() => resolve());\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  processLeaveNode(element: any) {\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      // this will prevent it from removing it twice\n      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n      if (details.namespaceId) {\n        this.destroyInnerAnimations(element);\n        const ns = this._fetchNamespace(details.namespaceId);\n        if (ns) {\n          ns.clearElementCache(element);\n        }\n      }\n      this._onRemovalComplete(element, details.setForRemoval);\n    }\n\n    if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {\n      this.markElementAsDisabled(element, false);\n    }\n\n    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n      this.markElementAsDisabled(element, false);\n    });\n  }\n\n  flush(microtaskId: number = -1) {\n    let players: AnimationPlayer[] = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n      this.newHostElements.clear();\n    }\n\n    if (this.totalAnimations && this.collectedEnterElements.length) {\n      for (let i = 0; i < this.collectedEnterElements.length; i++) {\n        const elm = this.collectedEnterElements[i];\n        addClass(elm, STAR_CLASSNAME);\n      }\n    }\n\n    if (this._namespaceList.length &&\n        (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n      const cleanupFns: Function[] = [];\n      try {\n        players = this._flushAnimations(cleanupFns, microtaskId);\n      } finally {\n        for (let i = 0; i < cleanupFns.length; i++) {\n          cleanupFns[i]();\n        }\n      }\n    } else {\n      for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n        const element = this.collectedLeaveElements[i];\n        this.processLeaveNode(element);\n      }\n    }\n\n    this.totalQueuedPlayers = 0;\n    this.collectedEnterElements.length = 0;\n    this.collectedLeaveElements.length = 0;\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n\n    if (this._whenQuietFns.length) {\n      // we move these over to a variable so that\n      // if any new callbacks are registered in another\n      // flush they do not populate the existing set\n      const quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => { quietFns.forEach(fn => fn()); });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n\n  reportError(errors: string[]) {\n    throw new Error(\n        `Unable to process animations due to the following failed trigger transitions\\n ${\n            errors.join('\\n')}`);\n  }\n\n  private _flushAnimations(cleanupFns: Function[], microtaskId: number):\n      TransitionAnimationPlayer[] {\n    const subTimelines = new ElementInstructionMap();\n    const skippedPlayers: TransitionAnimationPlayer[] = [];\n    const skippedPlayersMap = new Map<any, AnimationPlayer[]>();\n    const queuedInstructions: QueuedTransition[] = [];\n    const queriedElements = new Map<any, TransitionAnimationPlayer[]>();\n    const allPreStyleElements = new Map<any, Set<string>>();\n    const allPostStyleElements = new Map<any, Set<string>>();\n\n    const disabledElementsSet = new Set<any>();\n    this.disabledNodes.forEach(node => {\n      disabledElementsSet.add(node);\n      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n      for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n        disabledElementsSet.add(nodesThatAreDisabled[i]);\n      }\n    });\n\n    const bodyNode = this.bodyNode;\n    const allTriggerElements = Array.from(this.statesByElement.keys());\n    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n\n    // this must occur before the instructions are built below such that\n    // the :enter queries match the elements (since the timeline queries\n    // are fired during instruction building).\n    const enterNodeMapIds = new Map<any, string>();\n    let i = 0;\n    enterNodeMap.forEach((nodes, root) => {\n      const className = ENTER_CLASSNAME + i++;\n      enterNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    const allLeaveNodes: any[] = [];\n    const mergedLeaveNodes = new Set<any>();\n    const leaveNodesWithoutAnimations = new Set<any>();\n    for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n      const element = this.collectedLeaveElements[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      if (details && details.setForRemoval) {\n        allLeaveNodes.push(element);\n        mergedLeaveNodes.add(element);\n        if (details.hasAnimation) {\n          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n        } else {\n          leaveNodesWithoutAnimations.add(element);\n        }\n      }\n    }\n\n    const leaveNodeMapIds = new Map<any, string>();\n    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n    leaveNodeMap.forEach((nodes, root) => {\n      const className = LEAVE_CLASSNAME + i++;\n      leaveNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    cleanupFns.push(() => {\n      enterNodeMap.forEach((nodes, root) => {\n        const className = enterNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      leaveNodeMap.forEach((nodes, root) => {\n        const className = leaveNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      allLeaveNodes.forEach(element => { this.processLeaveNode(element); });\n    });\n\n    const allPlayers: TransitionAnimationPlayer[] = [];\n    const erroneousTransitions: AnimationTransitionInstruction[] = [];\n    for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n      const ns = this._namespaceList[i];\n      ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n        const player = entry.player;\n        const element = entry.element;\n        allPlayers.push(player);\n\n        if (this.collectedEnterElements.length) {\n          const details = element[REMOVAL_FLAG] as ElementAnimationState;\n          // move animations are currently not supported...\n          if (details && details.setForMove) {\n            player.destroy();\n            return;\n          }\n        }\n\n        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n        const leaveClassName = leaveNodeMapIds.get(element) !;\n        const enterClassName = enterNodeMapIds.get(element) !;\n        const instruction = this._buildInstruction(\n            entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned) !;\n        if (instruction.errors && instruction.errors.length) {\n          erroneousTransitions.push(instruction);\n          return;\n        }\n\n        // even though the element may not be apart of the DOM, it may\n        // still be added at a later point (due to the mechanics of content\n        // projection and/or dynamic component insertion) therefore it's\n        // important we still style the element.\n        if (nodeIsOrphaned) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // if a unmatched transition is queued to go then it SHOULD NOT render\n        // an animation and cancel the previously running animations.\n        if (entry.isFallbackTransition) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this means that if a parent animation uses this animation as a sub trigger\n        // then it will instruct the timeline builder to not add a player delay, but\n        // instead stretch the first keyframe gap up until the animation starts. The\n        // reason this is important is to prevent extra initialization styles from being\n        // required by the user in the animation.\n        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n\n        subTimelines.append(element, instruction.timelines);\n\n        const tuple = {instruction, player, element};\n\n        queuedInstructions.push(tuple);\n\n        instruction.queriedElements.forEach(\n            element => getOrSetAsInMap(queriedElements, element, []).push(player));\n\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          if (props.length) {\n            let setVal: Set<string> = allPreStyleElements.get(element) !;\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set<string>());\n            }\n            props.forEach(prop => setVal.add(prop));\n          }\n        });\n\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          let setVal: Set<string> = allPostStyleElements.get(element) !;\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set<string>());\n          }\n          props.forEach(prop => setVal.add(prop));\n        });\n      });\n    }\n\n    if (erroneousTransitions.length) {\n      const errors: string[] = [];\n      erroneousTransitions.forEach(instruction => {\n        errors.push(`@${instruction.triggerName} has failed due to:\\n`);\n        instruction.errors !.forEach(error => errors.push(`- ${error}\\n`));\n      });\n\n      allPlayers.forEach(player => player.destroy());\n      this.reportError(errors);\n    }\n\n    const allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n    // this map works to tell which element in the DOM tree is contained by\n    // which animation. Further down below this map will get populated once\n    // the players are built and in doing so it can efficiently figure out\n    // if a sub player is skipped due to a parent player having priority.\n    const animationElementMap = new Map<any, any>();\n    queuedInstructions.forEach(entry => {\n      const element = entry.element;\n      if (subTimelines.has(element)) {\n        animationElementMap.set(element, element);\n        this._beforeAnimationBuild(\n            entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n\n    skippedPlayers.forEach(player => {\n      const element = player.element;\n      const previousPlayers =\n          this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n      previousPlayers.forEach(prevPlayer => {\n        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);\n        prevPlayer.destroy();\n      });\n    });\n\n    // this is a special case for nodes that will be removed (either by)\n    // having their own leave animations or by being queried in a container\n    // that will be removed once a parent animation is complete. The idea\n    // here is that * styles must be identical to ! styles because of\n    // backwards compatibility (* is also filled in by default in many places).\n    // Otherwise * styles will return an empty value or auto since the element\n    // that is being getComputedStyle'd will not be visible (since * = destination)\n    const replaceNodes = allLeaveNodes.filter(node => {\n      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n    });\n\n    // POST STAGE: fill the * styles\n    const postStylesMap = new Map<any, ɵStyleData>();\n    const allLeaveQueriedNodes = cloakAndComputeStyles(\n        postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n\n    allLeaveQueriedNodes.forEach(node => {\n      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n        replaceNodes.push(node);\n      }\n    });\n\n    // PRE STAGE: fill the ! styles\n    const preStylesMap = new Map<any, ɵStyleData>();\n    enterNodeMap.forEach((nodes, root) => {\n      cloakAndComputeStyles(\n          preStylesMap, this.driver, new Set(nodes), allPreStyleElements, PRE_STYLE);\n    });\n\n    replaceNodes.forEach(node => {\n      const post = postStylesMap.get(node);\n      const pre = preStylesMap.get(node);\n      postStylesMap.set(node, { ...post, ...pre } as any);\n    });\n\n    const rootPlayers: TransitionAnimationPlayer[] = [];\n    const subPlayers: TransitionAnimationPlayer[] = [];\n    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n    queuedInstructions.forEach(entry => {\n      const {element, player, instruction} = entry;\n      // this means that it was never consumed by a parent animation which\n      // means that it is independent and therefore should be set for animation\n      if (subTimelines.has(element)) {\n        if (disabledElementsSet.has(element)) {\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          player.disabled = true;\n          player.overrideTotalTime(instruction.totalTime);\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this will flow up the DOM and query the map to figure out\n        // if a parent animation has priority over it. In the situation\n        // that a parent is detected then it will cancel the loop. If\n        // nothing is detected, or it takes a few hops to find a parent,\n        // then it will fill in the missing nodes and signal them as having\n        // a detected parent (or a NO_PARENT value via a special constant).\n        let parentWithAnimation: any = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n        if (animationElementMap.size > 1) {\n          let elm = element;\n          const parentsToAdd: any[] = [];\n          while (elm = elm.parentNode) {\n            const detectedParent = animationElementMap.get(elm);\n            if (detectedParent) {\n              parentWithAnimation = detectedParent;\n              break;\n            }\n            parentsToAdd.push(elm);\n          }\n          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n        }\n\n        const innerPlayer = this._buildAnimation(\n            player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap,\n            postStylesMap);\n\n        player.setRealPlayer(innerPlayer);\n\n        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n          rootPlayers.push(player);\n        } else {\n          const parentPlayers = this.playersByElement.get(parentWithAnimation);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        // there still might be a ancestor player animating this\n        // element therefore we will still add it as a sub player\n        // even if its animation may be disabled\n        subPlayers.push(player);\n        if (disabledElementsSet.has(element)) {\n          skippedPlayers.push(player);\n        }\n      }\n    });\n\n    // find all of the sub players' corresponding inner animation player\n    subPlayers.forEach(player => {\n      // even if any players are not found for a sub animation then it\n      // will still complete itself after the next tick since it's Noop\n      const playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n\n    // the reason why we don't actually play the animation is\n    // because all that a skipped player is designed to do is to\n    // fire the start/done transition callback events\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.syncPlayerEvents(player.parentPlayer);\n      } else {\n        player.destroy();\n      }\n    });\n\n    // run through all of the queued removals and see if they\n    // were picked up by a query. If not then perform the removal\n    // operation right away unless a parent animation is ongoing.\n    for (let i = 0; i < allLeaveNodes.length; i++) {\n      const element = allLeaveNodes[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      removeClass(element, LEAVE_CLASSNAME);\n\n      // this means the element has a removal animation that is being\n      // taken care of and therefore the inner elements will hang around\n      // until that animation is over (or the parent queried animation)\n      if (details && details.hasAnimation) continue;\n\n      let players: TransitionAnimationPlayer[] = [];\n\n      // if this element is queried or if it contains queried children\n      // then we want for the element not to be removed from the page\n      // until the queried animations have finished\n      if (queriedElements.size) {\n        let queriedPlayerResults = queriedElements.get(element);\n        if (queriedPlayerResults && queriedPlayerResults.length) {\n          players.push(...queriedPlayerResults);\n        }\n\n        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n        for (let j = 0; j < queriedInnerElements.length; j++) {\n          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n          if (queriedPlayers && queriedPlayers.length) {\n            players.push(...queriedPlayers);\n          }\n        }\n      }\n\n      const activePlayers = players.filter(p => !p.destroyed);\n      if (activePlayers.length) {\n        removeNodesAfterAnimationDone(this, element, activePlayers);\n      } else {\n        this.processLeaveNode(element);\n      }\n    }\n\n    // this is required so the cleanup method doesn't remove them\n    allLeaveNodes.length = 0;\n\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n\n        const index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n\n    return rootPlayers;\n  }\n\n  elementContainsData(namespaceId: string, element: any) {\n    let containsData = false;\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) containsData = true;\n    if (this.playersByElement.has(element)) containsData = true;\n    if (this.playersByQueriedElement.has(element)) containsData = true;\n    if (this.statesByElement.has(element)) containsData = true;\n    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n  }\n\n  afterFlush(callback: () => any) { this._flushFns.push(callback); }\n\n  afterFlushAnimationsDone(callback: () => any) { this._whenQuietFns.push(callback); }\n\n  private _getPreviousPlayers(\n      element: string, isQueriedElement: boolean, namespaceId?: string, triggerName?: string,\n      toStateValue?: any): TransitionAnimationPlayer[] {\n    let players: TransitionAnimationPlayer[] = [];\n    if (isQueriedElement) {\n      const queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      });\n    }\n    return players;\n  }\n\n  private _beforeAnimationBuild(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // when a removal animation occurs, ALL previous players are collected\n    // and destroyed (even if they are outside of the current namespace)\n    const targetNameSpaceId: string|undefined =\n        instruction.isRemovalTransition ? undefined : namespaceId;\n    const targetTriggerName: string|undefined =\n        instruction.isRemovalTransition ? undefined : triggerName;\n\n    for (const timelineInstruction of instruction.timelines) {\n      const element = timelineInstruction.element;\n      const isQueriedElement = element !== rootElement;\n      const players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n      const previousPlayers = this._getPreviousPlayers(\n          element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n      previousPlayers.forEach(player => {\n        const realPlayer = player.getRealPlayer() as any;\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        player.destroy();\n        players.push(player);\n      });\n    }\n\n    // this needs to be done so that the PRE/POST styles can be\n    // computed properly without interfering with the previous animation\n    eraseStyles(rootElement, instruction.fromStyles);\n  }\n\n  private _buildAnimation(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>,\n      skippedPlayersMap: Map<any, AnimationPlayer[]>, preStylesMap: Map<any, ɵStyleData>,\n      postStylesMap: Map<any, ɵStyleData>): AnimationPlayer {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    const allQueriedPlayers: TransitionAnimationPlayer[] = [];\n    const allConsumedElements = new Set<any>();\n    const allSubElements = new Set<any>();\n    const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const element = timelineInstruction.element;\n      allConsumedElements.add(element);\n\n      // FIXME (matsko): make sure to-be-removed animations are removed properly\n      const details = element[REMOVAL_FLAG];\n      if (details && details.removedBeforeQueried)\n        return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n\n      const isQueriedElement = element !== rootElement;\n      const previousPlayers =\n          flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\n                                  .map(p => p.getRealPlayer()))\n              .filter(p => {\n                // the `element` is not apart of the AnimationPlayer definition, but\n                // Mock/WebAnimations\n                // use the element within their implementation. This will be added in Angular5 to\n                // AnimationPlayer\n                const pp = p as any;\n                return pp.element ? pp.element === element : false;\n              });\n\n      const preStyles = preStylesMap.get(element);\n      const postStyles = postStylesMap.get(element);\n      const keyframes = normalizeKeyframes(\n          this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles,\n          postStyles);\n      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n\n      // this means that this particular player belongs to a sub trigger. It is\n      // important that we match this player up with the corresponding (@trigger.listener)\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n\n      if (isQueriedElement) {\n        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n\n      return player;\n    });\n\n    allQueriedPlayers.forEach(player => {\n      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n    });\n\n    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n    const player = optimizeGroupPlayer(allNewPlayers);\n    player.onDestroy(() => {\n      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n      setStyles(rootElement, instruction.toStyles);\n    });\n\n    // this basically makes all of the callbacks for sub element animations\n    // be dependent on the upper players for when they finish\n    allSubElements.forEach(\n        element => { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\n\n    return player;\n  }\n\n  private _buildPlayer(\n      instruction: AnimationTimelineInstruction, keyframes: ɵStyleData[],\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    if (keyframes.length > 0) {\n      return this.driver.animate(\n          instruction.element, keyframes, instruction.duration, instruction.delay,\n          instruction.easing, previousPlayers);\n    }\n\n    // special case for when an empty transition|definition is provided\n    // ... there is no point in rendering an empty animation\n    return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n  }\n}\n\nexport class TransitionAnimationPlayer implements AnimationPlayer {\n  private _player: AnimationPlayer = new NoopAnimationPlayer();\n  private _containsRealPlayer = false;\n\n  private _queuedCallbacks: {[name: string]: (() => any)[]} = {};\n  public readonly destroyed = false;\n  // TODO(issue/24571): remove '!'.\n  public parentPlayer !: AnimationPlayer;\n\n  public markedForDestroy: boolean = false;\n  public disabled = false;\n\n  readonly queued: boolean = true;\n  public readonly totalTime: number = 0;\n\n  constructor(public namespaceId: string, public triggerName: string, public element: any) {}\n\n  setRealPlayer(player: AnimationPlayer) {\n    if (this._containsRealPlayer) return;\n\n    this._player = player;\n    Object.keys(this._queuedCallbacks).forEach(phase => {\n      this._queuedCallbacks[phase].forEach(\n          callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks = {};\n    this._containsRealPlayer = true;\n    this.overrideTotalTime(player.totalTime);\n    (this as{queued: boolean}).queued = false;\n  }\n\n  getRealPlayer() { return this._player; }\n\n  overrideTotalTime(totalTime: number) { (this as any).totalTime = totalTime; }\n\n  syncPlayerEvents(player: AnimationPlayer) {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      player.onStart(() => p.triggerCallback !('start'));\n    }\n    player.onDone(() => this.finish());\n    player.onDestroy(() => this.destroy());\n  }\n\n  private _queueEvent(name: string, callback: (event: any) => any): void {\n    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n  }\n\n  onDone(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n\n  onStart(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n\n  onDestroy(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n\n  init(): void { this._player.init(); }\n\n  hasStarted(): boolean { return this.queued ? false : this._player.hasStarted(); }\n\n  play(): void { !this.queued && this._player.play(); }\n\n  pause(): void { !this.queued && this._player.pause(); }\n\n  restart(): void { !this.queued && this._player.restart(); }\n\n  finish(): void { this._player.finish(); }\n\n  destroy(): void {\n    (this as{destroyed: boolean}).destroyed = true;\n    this._player.destroy();\n  }\n\n  reset(): void { !this.queued && this._player.reset(); }\n\n  setPosition(p: any): void {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n\n  getPosition(): number { return this.queued ? 0 : this._player.getPosition(); }\n\n  /** @internal */\n  triggerCallback(phaseName: string): void {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      p.triggerCallback(phaseName);\n    }\n  }\n}\n\nfunction deleteOrUnsetInMap(map: Map<any, any[]>| {[key: string]: any}, key: any, value: any) {\n  let currentValues: any[]|null|undefined;\n  if (map instanceof Map) {\n    currentValues = map.get(key);\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        map.delete(key);\n      }\n    }\n  } else {\n    currentValues = map[key];\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        delete map[key];\n      }\n    }\n  }\n  return currentValues;\n}\n\nfunction normalizeTriggerValue(value: any): any {\n  // we use `!= null` here because it's the most simple\n  // way to test against a \"falsy\" value without mixing\n  // in empty strings or a zero value. DO NOT OPTIMIZE.\n  return value != null ? value : null;\n}\n\nfunction isElementNode(node: any) {\n  return node && node['nodeType'] === 1;\n}\n\nfunction isTriggerEventValid(eventName: string): boolean {\n  return eventName == 'start' || eventName == 'done';\n}\n\nfunction cloakElement(element: any, value?: string) {\n  const oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\n\nfunction cloakAndComputeStyles(\n    valuesMap: Map<any, ɵStyleData>, driver: AnimationDriver, elements: Set<any>,\n    elementPropsMap: Map<any, Set<string>>, defaultStyle: string): any[] {\n  const cloakVals: string[] = [];\n  elements.forEach(element => cloakVals.push(cloakElement(element)));\n\n  const failedElements: any[] = [];\n\n  elementPropsMap.forEach((props: Set<string>, element: any) => {\n    const styles: ɵStyleData = {};\n    props.forEach(prop => {\n      const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n\n      // there is no easy way to detect this because a sub element could be removed\n      // by a parent animation element being detached.\n      if (!value || value.length == 0) {\n        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n        failedElements.push(element);\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n\n  // we use a index variable here since Set.forEach(a, i) does not return\n  // an index value for the closure (but instead just the value)\n  let i = 0;\n  elements.forEach(element => cloakElement(element, cloakVals[i++]));\n\n  return failedElements;\n}\n\n/*\nSince the Angular renderer code will return a collection of inserted\nnodes in all areas of a DOM tree, it's up to this algorithm to figure\nout which nodes are roots for each animation @trigger.\n\nBy placing each inserted node into a Set and traversing upwards, it\nis possible to find the @trigger elements and well any direct *star\ninsertion nodes, if a @trigger root is found then the enter element\nis placed into the Map[@trigger] spot.\n */\nfunction buildRootMap(roots: any[], nodes: any[]): Map<any, any[]> {\n  const rootMap = new Map<any, any[]>();\n  roots.forEach(root => rootMap.set(root, []));\n\n  if (nodes.length == 0) return rootMap;\n\n  const NULL_NODE = 1;\n  const nodeSet = new Set(nodes);\n  const localRootMap = new Map<any, any>();\n\n  function getRoot(node: any): any {\n    if (!node) return NULL_NODE;\n\n    let root = localRootMap.get(node);\n    if (root) return root;\n\n    const parent = node.parentNode;\n    if (rootMap.has(parent)) {  // ngIf inside @trigger\n      root = parent;\n    } else if (nodeSet.has(parent)) {  // ngIf inside ngIf\n      root = NULL_NODE;\n    } else {  // recurse upwards\n      root = getRoot(parent);\n    }\n\n    localRootMap.set(node, root);\n    return root;\n  }\n\n  nodes.forEach(node => {\n    const root = getRoot(node);\n    if (root !== NULL_NODE) {\n      rootMap.get(root) !.push(node);\n    }\n  });\n\n  return rootMap;\n}\n\nconst CLASSES_CACHE_KEY = '$$classes';\nfunction containsClass(element: any, className: string): boolean {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    const classes = element[CLASSES_CACHE_KEY];\n    return classes && classes[className];\n  }\n}\n\nfunction addClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (!classes) {\n      classes = element[CLASSES_CACHE_KEY] = {};\n    }\n    classes[className] = true;\n  }\n}\n\nfunction removeClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (classes) {\n      delete classes[className];\n    }\n  }\n}\n\nfunction removeNodesAfterAnimationDone(\n    engine: TransitionAnimationEngine, element: any, players: AnimationPlayer[]) {\n  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\n\nfunction flattenGroupPlayers(players: AnimationPlayer[]): AnimationPlayer[] {\n  const finalPlayers: AnimationPlayer[] = [];\n  _flattenGroupPlayersRecur(players, finalPlayers);\n  return finalPlayers;\n}\n\nfunction _flattenGroupPlayersRecur(players: AnimationPlayer[], finalPlayers: AnimationPlayer[]) {\n  for (let i = 0; i < players.length; i++) {\n    const player = players[i];\n    if (player instanceof AnimationGroupPlayer) {\n      _flattenGroupPlayersRecur(player.players, finalPlayers);\n    } else {\n      finalPlayers.push(player as AnimationPlayer);\n    }\n  }\n}\n\nfunction objEquals(a: {[key: string]: any}, b: {[key: string]: any}): boolean {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) return false;\n  for (let i = 0; i < k1.length; i++) {\n    const prop = k1[i];\n    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;\n  }\n  return true;\n}\n\nfunction replacePostStylesAsPre(\n    element: any, allPreStyleElements: Map<any, Set<string>>,\n    allPostStyleElements: Map<any, Set<string>>): boolean {\n  const postEntry = allPostStyleElements.get(element);\n  if (!postEntry) return false;\n\n  let preEntry = allPreStyleElements.get(element);\n  if (preEntry) {\n    postEntry.forEach(data => preEntry !.add(data));\n  } else {\n    allPreStyleElements.set(element, postEntry);\n  }\n\n  allPostStyleElements.delete(element);\n  return true;\n}\n"],"sourceRoot":""}