Liferay.Loader.define('@example-angular-liferay$angular/animations@6.1.10/esm5/browser/src/render/animation_engine_next', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    import * as tslib_1 from "tslib";
    import { buildAnimationAst } from '../dsl/animation_ast_builder';
    import { buildTrigger } from '../dsl/animation_trigger';
    import { parseTimelineCommand } from './shared';
    import { TimelineAnimationEngine } from './timeline_animation_engine';
    import { TransitionAnimationEngine } from './transition_animation_engine';
    var AnimationEngine = /** @class */function () {
        function AnimationEngine(bodyNode, _driver, normalizer) {
            var _this = this;
            this.bodyNode = bodyNode;
            this._driver = _driver;
            this._triggerCache = {};
            // this method is designed to be overridden by the code that uses this engine
            this.onRemovalComplete = function (element, context) {};
            this._transitionEngine = new TransitionAnimationEngine(bodyNode, _driver, normalizer);
            this._timelineEngine = new TimelineAnimationEngine(bodyNode, _driver, normalizer);
            this._transitionEngine.onRemovalComplete = function (element, context) {
                return _this.onRemovalComplete(element, context);
            };
        }
        AnimationEngine.prototype.registerTrigger = function (componentId, namespaceId, hostElement, name, metadata) {
            var cacheKey = componentId + '-' + name;
            var trigger = this._triggerCache[cacheKey];
            if (!trigger) {
                var errors = [];
                var ast = buildAnimationAst(this._driver, metadata, errors);
                if (errors.length) {
                    throw new Error("The animation trigger \"" + name + "\" has failed to build due to the following errors:\n - " + errors.join("\n - "));
                }
                trigger = buildTrigger(name, ast);
                this._triggerCache[cacheKey] = trigger;
            }
            this._transitionEngine.registerTrigger(namespaceId, name, trigger);
        };
        AnimationEngine.prototype.register = function (namespaceId, hostElement) {
            this._transitionEngine.register(namespaceId, hostElement);
        };
        AnimationEngine.prototype.destroy = function (namespaceId, context) {
            this._transitionEngine.destroy(namespaceId, context);
        };
        AnimationEngine.prototype.onInsert = function (namespaceId, element, parent, insertBefore) {
            this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
        };
        AnimationEngine.prototype.onRemove = function (namespaceId, element, context) {
            this._transitionEngine.removeNode(namespaceId, element, context);
        };
        AnimationEngine.prototype.disableAnimations = function (element, disable) {
            this._transitionEngine.markElementAsDisabled(element, disable);
        };
        AnimationEngine.prototype.process = function (namespaceId, element, property, value) {
            if (property.charAt(0) == '@') {
                var _a = tslib_1.__read(parseTimelineCommand(property), 2),
                    id = _a[0],
                    action = _a[1];
                var args = value;
                this._timelineEngine.command(id, element, action, args);
            } else {
                this._transitionEngine.trigger(namespaceId, element, property, value);
            }
        };
        AnimationEngine.prototype.listen = function (namespaceId, element, eventName, eventPhase, callback) {
            // @@listen
            if (eventName.charAt(0) == '@') {
                var _a = tslib_1.__read(parseTimelineCommand(eventName), 2),
                    id = _a[0],
                    action = _a[1];
                return this._timelineEngine.listen(id, element, action, callback);
            }
            return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
        };
        AnimationEngine.prototype.flush = function (microtaskId) {
            if (microtaskId === void 0) {
                microtaskId = -1;
            }
            this._transitionEngine.flush(microtaskId);
        };
        Object.defineProperty(AnimationEngine.prototype, "players", {
            get: function () {
                return this._transitionEngine.players.concat(this._timelineEngine.players);
            },
            enumerable: true,
            configurable: true
        });
        AnimationEngine.prototype.whenRenderingDone = function () {
            return this._transitionEngine.whenRenderingDone();
        };
        return AnimationEngine;
    }();
    export { AnimationEngine };
});
//# sourceMappingURL=animation_engine_next.js.map