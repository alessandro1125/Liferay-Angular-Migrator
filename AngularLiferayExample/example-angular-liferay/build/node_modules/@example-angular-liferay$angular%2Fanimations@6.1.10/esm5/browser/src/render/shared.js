Liferay.Loader.define('@example-angular-liferay$angular/animations@6.1.10/esm5/browser/src/render/shared', ['module', 'exports', 'require'], function (module, exports, require) {
    var define = undefined;
    import * as tslib_1 from "tslib";
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    import { AUTO_STYLE, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE } from '@angular/animations';
    export function isBrowser() {
        return typeof window !== 'undefined' && typeof window.document !== 'undefined';
    }
    export function isNode() {
        return typeof process !== 'undefined';
    }
    export function optimizeGroupPlayer(players) {
        switch (players.length) {
            case 0:
                return new NoopAnimationPlayer();
            case 1:
                return players[0];
            default:
                return new ɵAnimationGroupPlayer(players);
        }
    }
    export function normalizeKeyframes(driver, normalizer, element, keyframes, preStyles, postStyles) {
        if (preStyles === void 0) {
            preStyles = {};
        }
        if (postStyles === void 0) {
            postStyles = {};
        }
        var errors = [];
        var normalizedKeyframes = [];
        var previousOffset = -1;
        var previousKeyframe = null;
        keyframes.forEach(function (kf) {
            var offset = kf['offset'];
            var isSameOffset = offset == previousOffset;
            var normalizedKeyframe = isSameOffset && previousKeyframe || {};
            Object.keys(kf).forEach(function (prop) {
                var normalizedProp = prop;
                var normalizedValue = kf[prop];
                if (prop !== 'offset') {
                    normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
                    switch (normalizedValue) {
                        case PRE_STYLE:
                            normalizedValue = preStyles[prop];
                            break;
                        case AUTO_STYLE:
                            normalizedValue = postStyles[prop];
                            break;
                        default:
                            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
                            break;
                    }
                }
                normalizedKeyframe[normalizedProp] = normalizedValue;
            });
            if (!isSameOffset) {
                normalizedKeyframes.push(normalizedKeyframe);
            }
            previousKeyframe = normalizedKeyframe;
            previousOffset = offset;
        });
        if (errors.length) {
            var LINE_START = '\n - ';
            throw new Error("Unable to animate due to the following errors:" + LINE_START + errors.join(LINE_START));
        }
        return normalizedKeyframes;
    }
    export function listenOnPlayer(player, eventName, event, callback) {
        switch (eventName) {
            case 'start':
                player.onStart(function () {
                    return callback(event && copyAnimationEvent(event, 'start', player));
                });
                break;
            case 'done':
                player.onDone(function () {
                    return callback(event && copyAnimationEvent(event, 'done', player));
                });
                break;
            case 'destroy':
                player.onDestroy(function () {
                    return callback(event && copyAnimationEvent(event, 'destroy', player));
                });
                break;
        }
    }
    export function copyAnimationEvent(e, phaseName, player) {
        var totalTime = player.totalTime;
        var disabled = player.disabled ? true : false;
        var event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == undefined ? e.totalTime : totalTime, disabled);
        var data = e['_data'];
        if (data != null) {
            event['_data'] = data;
        }
        return event;
    }
    export function makeAnimationEvent(element, triggerName, fromState, toState, phaseName, totalTime, disabled) {
        if (phaseName === void 0) {
            phaseName = '';
        }
        if (totalTime === void 0) {
            totalTime = 0;
        }
        return { element: element, triggerName: triggerName, fromState: fromState, toState: toState, phaseName: phaseName, totalTime: totalTime, disabled: !!disabled };
    }
    export function getOrSetAsInMap(map, key, defaultValue) {
        var value;
        if (map instanceof Map) {
            value = map.get(key);
            if (!value) {
                map.set(key, value = defaultValue);
            }
        } else {
            value = map[key];
            if (!value) {
                value = map[key] = defaultValue;
            }
        }
        return value;
    }
    export function parseTimelineCommand(command) {
        var separatorPos = command.indexOf(':');
        var id = command.substring(1, separatorPos);
        var action = command.substr(separatorPos + 1);
        return [id, action];
    }
    var _contains = function (elm1, elm2) {
        return false;
    };
    var ɵ0 = _contains;
    var _matches = function (element, selector) {
        return false;
    };
    var ɵ1 = _matches;
    var _query = function (element, selector, multi) {
        return [];
    };
    var ɵ2 = _query;
    // Define utility methods for browsers and platform-server(domino) where Element
    // and utility methods exist.
    var _isNode = isNode();
    if (_isNode || typeof Element !== 'undefined') {
        // this is well supported in all browsers
        _contains = function (elm1, elm2) {
            return elm1.contains(elm2);
        };
        if (_isNode || Element.prototype.matches) {
            _matches = function (element, selector) {
                return element.matches(selector);
            };
        } else {
            var proto = Element.prototype;
            var fn_1 = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
            if (fn_1) {
                _matches = function (element, selector) {
                    return fn_1.apply(element, [selector]);
                };
            }
        }
        _query = function (element, selector, multi) {
            var results = [];
            if (multi) {
                results.push.apply(results, tslib_1.__spread(element.querySelectorAll(selector)));
            } else {
                var elm = element.querySelector(selector);
                if (elm) {
                    results.push(elm);
                }
            }
            return results;
        };
    }
    function containsVendorPrefix(prop) {
        // Webkit is the only real popular vendor prefix nowadays
        // cc: http://shouldiprefix.com/
        return prop.substring(1, 6) == 'ebkit'; // webkit or Webkit
    }
    var _CACHED_BODY = null;
    var _IS_WEBKIT = false;
    export function validateStyleProperty(prop) {
        if (!_CACHED_BODY) {
            _CACHED_BODY = getBodyNode() || {};
            _IS_WEBKIT = _CACHED_BODY.style ? 'WebkitAppearance' in _CACHED_BODY.style : false;
        }
        var result = true;
        if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
            result = prop in _CACHED_BODY.style;
            if (!result && _IS_WEBKIT) {
                var camelProp = 'Webkit' + prop.charAt(0).toUpperCase() + prop.substr(1);
                result = camelProp in _CACHED_BODY.style;
            }
        }
        return result;
    }
    export function getBodyNode() {
        if (typeof document != 'undefined') {
            return document.body;
        }
        return null;
    }
    export var matchesElement = _matches;
    export var containsElement = _contains;
    export var invokeQuery = _query;
    export function hypenatePropsObject(object) {
        var newObj = {};
        Object.keys(object).forEach(function (prop) {
            var newProp = prop.replace(/([a-z])([A-Z])/g, '$1-$2');
            newObj[newProp] = object[prop];
        });
        return newObj;
    }
    export { ɵ0, ɵ1, ɵ2 };
});
//# sourceMappingURL=shared.js.map