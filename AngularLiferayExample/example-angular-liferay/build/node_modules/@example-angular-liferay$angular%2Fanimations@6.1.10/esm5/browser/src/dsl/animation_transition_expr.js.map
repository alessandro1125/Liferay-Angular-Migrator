{"version":3,"sources":["../../../../../../../../../../../../packages/animations/browser/src/dsl/animation_transition_expr.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport const ANY_STATE = '*';\nexport declare type TransitionMatcherFn =\n    (fromState: any, toState: any, element: any, params: {[key: string]: any}) => boolean;\n\nexport function parseTransitionExpr(\n    transitionValue: string | TransitionMatcherFn, errors: string[]): TransitionMatcherFn[] {\n  const expressions: TransitionMatcherFn[] = [];\n  if (typeof transitionValue == 'string') {\n    (<string>transitionValue)\n        .split(/\\s*,\\s*/)\n        .forEach(str => parseInnerTransitionStr(str, expressions, errors));\n  } else {\n    expressions.push(<TransitionMatcherFn>transitionValue);\n  }\n  return expressions;\n}\n\nfunction parseInnerTransitionStr(\n    eventStr: string, expressions: TransitionMatcherFn[], errors: string[]) {\n  if (eventStr[0] == ':') {\n    const result = parseAnimationAlias(eventStr, errors);\n    if (typeof result == 'function') {\n      expressions.push(result);\n      return;\n    }\n    eventStr = result as string;\n  }\n\n  const match = eventStr.match(/^(\\*|[-\\w]+)\\s*(<?[=-]>)\\s*(\\*|[-\\w]+)$/);\n  if (match == null || match.length < 4) {\n    errors.push(`The provided transition expression \"${eventStr}\" is not supported`);\n    return expressions;\n  }\n\n  const fromState = match[1];\n  const separator = match[2];\n  const toState = match[3];\n  expressions.push(makeLambdaFromStates(fromState, toState));\n\n  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;\n  if (separator[0] == '<' && !isFullAnyStateExpr) {\n    expressions.push(makeLambdaFromStates(toState, fromState));\n  }\n}\n\nfunction parseAnimationAlias(alias: string, errors: string[]): string|TransitionMatcherFn {\n  switch (alias) {\n    case ':enter':\n      return 'void => *';\n    case ':leave':\n      return '* => void';\n    case ':increment':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) > parseFloat(fromState);\n    case ':decrement':\n      return (fromState: any, toState: any): boolean => parseFloat(toState) < parseFloat(fromState);\n    default:\n      errors.push(`The transition alias value \"${alias}\" is not supported`);\n      return '* => *';\n  }\n}\n\n// DO NOT REFACTOR ... keep the follow set instantiations\n// with the values intact (closure compiler for some reason\n// removes follow-up lines that add the values outside of\n// the constructor...\nconst TRUE_BOOLEAN_VALUES = new Set<string>(['true', '1']);\nconst FALSE_BOOLEAN_VALUES = new Set<string>(['false', '0']);\n\nfunction makeLambdaFromStates(lhs: string, rhs: string): TransitionMatcherFn {\n  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);\n  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);\n\n  return (fromState: any, toState: any): boolean => {\n    let lhsMatch = lhs == ANY_STATE || lhs == fromState;\n    let rhsMatch = rhs == ANY_STATE || rhs == toState;\n\n    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === 'boolean') {\n      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);\n    }\n    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === 'boolean') {\n      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);\n    }\n\n    return lhsMatch && rhsMatch;\n  };\n}\n"],"sourceRoot":""}