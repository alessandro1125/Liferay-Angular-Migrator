{"version":3,"sources":["../../../../../../../../packages/animations/browser/src/dsl/animation_timeline_builder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimateChildOptions, AnimateTimings, AnimationMetadataType, AnimationOptions, AnimationQueryOptions, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../render/animation_driver';\nimport {copyObj, copyStyles, interpolateParams, iteratorToArray, resolveTiming, resolveTimingValue, visitDslNode} from '../util';\n\nimport {AnimateAst, AnimateChildAst, AnimateRefAst, Ast, AstVisitor, DynamicTimingAst, GroupAst, KeyframesAst, QueryAst, ReferenceAst, SequenceAst, StaggerAst, StateAst, StyleAst, TimingAst, TransitionAst, TriggerAst} from './animation_ast';\nimport {AnimationTimelineInstruction, createTimelineInstruction} from './animation_timeline_instruction';\nimport {ElementInstructionMap} from './element_instruction_map';\n\nconst ONE_FRAME_IN_MILLISECONDS = 1;\nconst ENTER_TOKEN = ':enter';\nconst ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');\nconst LEAVE_TOKEN = ':leave';\nconst LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');\n\n/*\n * The code within this file aims to generate web-animations-compatible keyframes from Angular's\n * animation DSL code.\n *\n * The code below will be converted from:\n *\n * ```\n * sequence([\n *   style({ opacity: 0 }),\n *   animate(1000, style({ opacity: 0 }))\n * ])\n * ```\n *\n * To:\n * ```\n * keyframes = [{ opacity: 0, offset: 0 }, { opacity: 1, offset: 1 }]\n * duration = 1000\n * delay = 0\n * easing = ''\n * ```\n *\n * For this operation to cover the combination of animation verbs (style, animate, group, etc...) a\n * combination of prototypical inheritance, AST traversal and merge-sort-like algorithms are used.\n *\n * [AST Traversal]\n * Each of the animation verbs, when executed, will return an string-map object representing what\n * type of action it is (style, animate, group, etc...) and the data associated with it. This means\n * that when functional composition mix of these functions is evaluated (like in the example above)\n * then it will end up producing a tree of objects representing the animation itself.\n *\n * When this animation object tree is processed by the visitor code below it will visit each of the\n * verb statements within the visitor. And during each visit it will build the context of the\n * animation keyframes by interacting with the `TimelineBuilder`.\n *\n * [TimelineBuilder]\n * This class is responsible for tracking the styles and building a series of keyframe objects for a\n * timeline between a start and end time. The builder starts off with an initial timeline and each\n * time the AST comes across a `group()`, `keyframes()` or a combination of the two wihtin a\n * `sequence()` then it will generate a sub timeline for each step as well as a new one after\n * they are complete.\n *\n * As the AST is traversed, the timing state on each of the timelines will be incremented. If a sub\n * timeline was created (based on one of the cases above) then the parent timeline will attempt to\n * merge the styles used within the sub timelines into itself (only with group() this will happen).\n * This happens with a merge operation (much like how the merge works in mergesort) and it will only\n * copy the most recently used styles from the sub timelines into the parent timeline. This ensures\n * that if the styles are used later on in another phase of the animation then they will be the most\n * up-to-date values.\n *\n * [How Missing Styles Are Updated]\n * Each timeline has a `backFill` property which is responsible for filling in new styles into\n * already processed keyframes if a new style shows up later within the animation sequence.\n *\n * ```\n * sequence([\n *   style({ width: 0 }),\n *   animate(1000, style({ width: 100 })),\n *   animate(1000, style({ width: 200 })),\n *   animate(1000, style({ width: 300 }))\n *   animate(1000, style({ width: 400, height: 400 })) // notice how `height` doesn't exist anywhere\n * else\n * ])\n * ```\n *\n * What is happening here is that the `height` value is added later in the sequence, but is missing\n * from all previous animation steps. Therefore when a keyframe is created it would also be missing\n * from all previous keyframes up until where it is first used. For the timeline keyframe generation\n * to properly fill in the style it will place the previous value (the value from the parent\n * timeline) or a default value of `*` into the backFill object. Given that each of the keyframe\n * styles are objects that prototypically inhert from the backFill object, this means that if a\n * value is added into the backFill then it will automatically propagate any missing values to all\n * keyframes. Therefore the missing `height` value will be properly filled into the already\n * processed keyframes.\n *\n * When a sub-timeline is created it will have its own backFill property. This is done so that\n * styles present within the sub-timeline do not accidentally seep into the previous/future timeline\n * keyframes\n *\n * (For prototypically-inherited contents to be detected a `for(i in obj)` loop must be used.)\n *\n * [Validation]\n * The code in this file is not responsible for validation. That functionality happens with within\n * the `AnimationValidatorVisitor` code.\n */\nexport function buildAnimationTimelines(\n    driver: AnimationDriver, rootElement: any, ast: Ast<AnimationMetadataType>,\n    enterClassName: string, leaveClassName: string, startingStyles: ɵStyleData = {},\n    finalStyles: ɵStyleData = {}, options: AnimationOptions,\n    subInstructions?: ElementInstructionMap, errors: any[] = []): AnimationTimelineInstruction[] {\n  return new AnimationTimelineBuilderVisitor().buildKeyframes(\n      driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles,\n      options, subInstructions, errors);\n}\n\nexport class AnimationTimelineBuilderVisitor implements AstVisitor {\n  buildKeyframes(\n      driver: AnimationDriver, rootElement: any, ast: Ast<AnimationMetadataType>,\n      enterClassName: string, leaveClassName: string, startingStyles: ɵStyleData,\n      finalStyles: ɵStyleData, options: AnimationOptions, subInstructions?: ElementInstructionMap,\n      errors: any[] = []): AnimationTimelineInstruction[] {\n    subInstructions = subInstructions || new ElementInstructionMap();\n    const context = new AnimationTimelineContext(\n        driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);\n    context.options = options;\n    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);\n\n    visitDslNode(this, ast, context);\n\n    // this checks to see if an actual animation happened\n    const timelines = context.timelines.filter(timeline => timeline.containsAnimation());\n    if (timelines.length && Object.keys(finalStyles).length) {\n      const tl = timelines[timelines.length - 1];\n      if (!tl.allowOnlyTimelineStyles()) {\n        tl.setStyles([finalStyles], null, context.errors, options);\n      }\n    }\n\n    return timelines.length ? timelines.map(timeline => timeline.buildKeyframes()) :\n                              [createTimelineInstruction(rootElement, [], [], [], 0, 0, '', false)];\n  }\n\n  visitTrigger(ast: TriggerAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitState(ast: StateAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitTransition(ast: TransitionAst, context: AnimationTimelineContext): any {\n    // these values are not visited in this AST\n  }\n\n  visitAnimateChild(ast: AnimateChildAst, context: AnimationTimelineContext): any {\n    const elementInstructions = context.subInstructions.consume(context.element);\n    if (elementInstructions) {\n      const innerContext = context.createSubContext(ast.options);\n      const startTime = context.currentTimeline.currentTime;\n      const endTime = this._visitSubInstructions(\n          elementInstructions, innerContext, innerContext.options as AnimateChildOptions);\n      if (startTime != endTime) {\n        // we do this on the upper context because we created a sub context for\n        // the sub child animations\n        context.transformIntoNewTimeline(endTime);\n      }\n    }\n    context.previousNode = ast;\n  }\n\n  visitAnimateRef(ast: AnimateRefAst, context: AnimationTimelineContext): any {\n    const innerContext = context.createSubContext(ast.options);\n    innerContext.transformIntoNewTimeline();\n    this.visitReference(ast.animation, innerContext);\n    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);\n    context.previousNode = ast;\n  }\n\n  private _visitSubInstructions(\n      instructions: AnimationTimelineInstruction[], context: AnimationTimelineContext,\n      options: AnimateChildOptions): number {\n    const startTime = context.currentTimeline.currentTime;\n    let furthestTime = startTime;\n\n    // this is a special-case for when a user wants to skip a sub\n    // animation from being fired entirely.\n    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;\n    const delay = options.delay != null ? resolveTimingValue(options.delay) : null;\n    if (duration !== 0) {\n      instructions.forEach(instruction => {\n        const instructionTimings =\n            context.appendInstructionToTimeline(instruction, duration, delay);\n        furthestTime =\n            Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);\n      });\n    }\n\n    return furthestTime;\n  }\n\n  visitReference(ast: ReferenceAst, context: AnimationTimelineContext) {\n    context.updateOptions(ast.options, true);\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n  }\n\n  visitSequence(ast: SequenceAst, context: AnimationTimelineContext) {\n    const subContextCount = context.subContextCount;\n    let ctx = context;\n    const options = ast.options;\n\n    if (options && (options.params || options.delay)) {\n      ctx = context.createSubContext(options);\n      ctx.transformIntoNewTimeline();\n\n      if (options.delay != null) {\n        if (ctx.previousNode.type == AnimationMetadataType.Style) {\n          ctx.currentTimeline.snapshotCurrentStyles();\n          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n        }\n\n        const delay = resolveTimingValue(options.delay);\n        ctx.delayNextStep(delay);\n      }\n    }\n\n    if (ast.steps.length) {\n      ast.steps.forEach(s => visitDslNode(this, s, ctx));\n\n      // this is here just incase the inner steps only contain or end with a style() call\n      ctx.currentTimeline.applyStylesToKeyframe();\n\n      // this means that some animation function within the sequence\n      // ended up creating a sub timeline (which means the current\n      // timeline cannot overlap with the contents of the sequence)\n      if (ctx.subContextCount > subContextCount) {\n        ctx.transformIntoNewTimeline();\n      }\n    }\n\n    context.previousNode = ast;\n  }\n\n  visitGroup(ast: GroupAst, context: AnimationTimelineContext) {\n    const innerTimelines: TimelineBuilder[] = [];\n    let furthestTime = context.currentTimeline.currentTime;\n    const delay = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;\n\n    ast.steps.forEach(s => {\n      const innerContext = context.createSubContext(ast.options);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n\n      visitDslNode(this, s, innerContext);\n      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);\n      innerTimelines.push(innerContext.currentTimeline);\n    });\n\n    // this operation is run after the AST loop because otherwise\n    // if the parent timeline's collected styles were updated then\n    // it would pass in invalid data into the new-to-be forked items\n    innerTimelines.forEach(\n        timeline => context.currentTimeline.mergeTimelineCollectedStyles(timeline));\n    context.transformIntoNewTimeline(furthestTime);\n    context.previousNode = ast;\n  }\n\n  private _visitTiming(ast: TimingAst, context: AnimationTimelineContext): AnimateTimings {\n    if ((ast as DynamicTimingAst).dynamic) {\n      const strValue = (ast as DynamicTimingAst).strValue;\n      const timingValue =\n          context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;\n      return resolveTiming(timingValue, context.errors);\n    } else {\n      return {duration: ast.duration, delay: ast.delay, easing: ast.easing};\n    }\n  }\n\n  visitAnimate(ast: AnimateAst, context: AnimationTimelineContext) {\n    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);\n    const timeline = context.currentTimeline;\n    if (timings.delay) {\n      context.incrementTime(timings.delay);\n      timeline.snapshotCurrentStyles();\n    }\n\n    const style = ast.style;\n    if (style.type == AnimationMetadataType.Keyframes) {\n      this.visitKeyframes(style, context);\n    } else {\n      context.incrementTime(timings.duration);\n      this.visitStyle(style as StyleAst, context);\n      timeline.applyStylesToKeyframe();\n    }\n\n    context.currentAnimateTimings = null;\n    context.previousNode = ast;\n  }\n\n  visitStyle(ast: StyleAst, context: AnimationTimelineContext) {\n    const timeline = context.currentTimeline;\n    const timings = context.currentAnimateTimings !;\n\n    // this is a special case for when a style() call\n    // directly follows  an animate() call (but not inside of an animate() call)\n    if (!timings && timeline.getCurrentStyleProperties().length) {\n      timeline.forwardFrame();\n    }\n\n    const easing = (timings && timings.easing) || ast.easing;\n    if (ast.isEmptyStep) {\n      timeline.applyEmptyStep(easing);\n    } else {\n      timeline.setStyles(ast.styles, easing, context.errors, context.options);\n    }\n\n    context.previousNode = ast;\n  }\n\n  visitKeyframes(ast: KeyframesAst, context: AnimationTimelineContext) {\n    const currentAnimateTimings = context.currentAnimateTimings !;\n    const startTime = (context.currentTimeline !).duration;\n    const duration = currentAnimateTimings.duration;\n    const innerContext = context.createSubContext();\n    const innerTimeline = innerContext.currentTimeline;\n    innerTimeline.easing = currentAnimateTimings.easing;\n\n    ast.styles.forEach(step => {\n      const offset: number = step.offset || 0;\n      innerTimeline.forwardTime(offset * duration);\n      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);\n      innerTimeline.applyStylesToKeyframe();\n    });\n\n    // this will ensure that the parent timeline gets all the styles from\n    // the child even if the new timeline below is not used\n    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);\n\n    // we do this because the window between this timeline and the sub timeline\n    // should ensure that the styles within are exactly the same as they were before\n    context.transformIntoNewTimeline(startTime + duration);\n    context.previousNode = ast;\n  }\n\n  visitQuery(ast: QueryAst, context: AnimationTimelineContext) {\n    // in the event that the first step before this is a style step we need\n    // to ensure the styles are applied before the children are animated\n    const startTime = context.currentTimeline.currentTime;\n    const options = (ast.options || {}) as AnimationQueryOptions;\n    const delay = options.delay ? resolveTimingValue(options.delay) : 0;\n\n    if (delay && (context.previousNode.type === AnimationMetadataType.Style ||\n                  (startTime == 0 && context.currentTimeline.getCurrentStyleProperties().length))) {\n      context.currentTimeline.snapshotCurrentStyles();\n      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    }\n\n    let furthestTime = startTime;\n    const elms = context.invokeQuery(\n        ast.selector, ast.originalSelector, ast.limit, ast.includeSelf,\n        options.optional ? true : false, context.errors);\n\n    context.currentQueryTotal = elms.length;\n    let sameElementTimeline: TimelineBuilder|null = null;\n    elms.forEach((element, i) => {\n\n      context.currentQueryIndex = i;\n      const innerContext = context.createSubContext(ast.options, element);\n      if (delay) {\n        innerContext.delayNextStep(delay);\n      }\n\n      if (element === context.element) {\n        sameElementTimeline = innerContext.currentTimeline;\n      }\n\n      visitDslNode(this, ast.animation, innerContext);\n\n      // this is here just incase the inner steps only contain or end\n      // with a style() call (which is here to signal that this is a preparatory\n      // call to style an element before it is animated again)\n      innerContext.currentTimeline.applyStylesToKeyframe();\n\n      const endTime = innerContext.currentTimeline.currentTime;\n      furthestTime = Math.max(furthestTime, endTime);\n    });\n\n    context.currentQueryIndex = 0;\n    context.currentQueryTotal = 0;\n    context.transformIntoNewTimeline(furthestTime);\n\n    if (sameElementTimeline) {\n      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);\n      context.currentTimeline.snapshotCurrentStyles();\n    }\n\n    context.previousNode = ast;\n  }\n\n  visitStagger(ast: StaggerAst, context: AnimationTimelineContext) {\n    const parentContext = context.parentContext !;\n    const tl = context.currentTimeline;\n    const timings = ast.timings;\n    const duration = Math.abs(timings.duration);\n    const maxTime = duration * (context.currentQueryTotal - 1);\n    let delay = duration * context.currentQueryIndex;\n\n    let staggerTransformer = timings.duration < 0 ? 'reverse' : timings.easing;\n    switch (staggerTransformer) {\n      case 'reverse':\n        delay = maxTime - delay;\n        break;\n      case 'full':\n        delay = parentContext.currentStaggerTime;\n        break;\n    }\n\n    const timeline = context.currentTimeline;\n    if (delay) {\n      timeline.delayNextStep(delay);\n    }\n\n    const startingTime = timeline.currentTime;\n    visitDslNode(this, ast.animation, context);\n    context.previousNode = ast;\n\n    // time = duration + delay\n    // the reason why this computation is so complex is because\n    // the inner timeline may either have a delay value or a stretched\n    // keyframe depending on if a subtimeline is not used or is used.\n    parentContext.currentStaggerTime =\n        (tl.currentTime - startingTime) + (tl.startTime - parentContext.currentTimeline.startTime);\n  }\n}\n\nexport declare type StyleAtTime = {\n  time: number; value: string | number;\n};\n\nconst DEFAULT_NOOP_PREVIOUS_NODE = <Ast<AnimationMetadataType>>{};\nexport class AnimationTimelineContext {\n  public parentContext: AnimationTimelineContext|null = null;\n  public currentTimeline: TimelineBuilder;\n  public currentAnimateTimings: AnimateTimings|null = null;\n  public previousNode: Ast<AnimationMetadataType> = DEFAULT_NOOP_PREVIOUS_NODE;\n  public subContextCount = 0;\n  public options: AnimationOptions = {};\n  public currentQueryIndex: number = 0;\n  public currentQueryTotal: number = 0;\n  public currentStaggerTime: number = 0;\n\n  constructor(\n      private _driver: AnimationDriver, public element: any,\n      public subInstructions: ElementInstructionMap, private _enterClassName: string,\n      private _leaveClassName: string, public errors: any[], public timelines: TimelineBuilder[],\n      initialTimeline?: TimelineBuilder) {\n    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);\n    timelines.push(this.currentTimeline);\n  }\n\n  get params() { return this.options.params; }\n\n  updateOptions(options: AnimationOptions|null, skipIfExists?: boolean) {\n    if (!options) return;\n\n    const newOptions = options as any;\n    let optionsToUpdate = this.options;\n\n    // NOTE: this will get patched up when other animation methods support duration overrides\n    if (newOptions.duration != null) {\n      (optionsToUpdate as any).duration = resolveTimingValue(newOptions.duration);\n    }\n\n    if (newOptions.delay != null) {\n      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);\n    }\n\n    const newParams = newOptions.params;\n    if (newParams) {\n      let paramsToUpdate: {[name: string]: any} = optionsToUpdate.params !;\n      if (!paramsToUpdate) {\n        paramsToUpdate = this.options.params = {};\n      }\n\n      Object.keys(newParams).forEach(name => {\n        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {\n          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);\n        }\n      });\n    }\n  }\n\n  private _copyOptions() {\n    const options: AnimationOptions = {};\n    if (this.options) {\n      const oldParams = this.options.params;\n      if (oldParams) {\n        const params: {[name: string]: any} = options['params'] = {};\n        Object.keys(oldParams).forEach(name => { params[name] = oldParams[name]; });\n      }\n    }\n    return options;\n  }\n\n  createSubContext(options: AnimationOptions|null = null, element?: any, newTime?: number):\n      AnimationTimelineContext {\n    const target = element || this.element;\n    const context = new AnimationTimelineContext(\n        this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName,\n        this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));\n    context.previousNode = this.previousNode;\n    context.currentAnimateTimings = this.currentAnimateTimings;\n\n    context.options = this._copyOptions();\n    context.updateOptions(options);\n\n    context.currentQueryIndex = this.currentQueryIndex;\n    context.currentQueryTotal = this.currentQueryTotal;\n    context.parentContext = this;\n    this.subContextCount++;\n    return context;\n  }\n\n  transformIntoNewTimeline(newTime?: number) {\n    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;\n    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);\n    this.timelines.push(this.currentTimeline);\n    return this.currentTimeline;\n  }\n\n  appendInstructionToTimeline(\n      instruction: AnimationTimelineInstruction, duration: number|null,\n      delay: number|null): AnimateTimings {\n    const updatedTimings: AnimateTimings = {\n      duration: duration != null ? duration : instruction.duration,\n      delay: this.currentTimeline.currentTime + (delay != null ? delay : 0) + instruction.delay,\n      easing: ''\n    };\n    const builder = new SubTimelineBuilder(\n        this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps,\n        instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);\n    this.timelines.push(builder);\n    return updatedTimings;\n  }\n\n  incrementTime(time: number) {\n    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);\n  }\n\n  delayNextStep(delay: number) {\n    // negative delays are not yet supported\n    if (delay > 0) {\n      this.currentTimeline.delayNextStep(delay);\n    }\n  }\n\n  invokeQuery(\n      selector: string, originalSelector: string, limit: number, includeSelf: boolean,\n      optional: boolean, errors: any[]): any[] {\n    let results: any[] = [];\n    if (includeSelf) {\n      results.push(this.element);\n    }\n    if (selector.length > 0) {  // if :self is only used then the selector is empty\n      selector = selector.replace(ENTER_TOKEN_REGEX, '.' + this._enterClassName);\n      selector = selector.replace(LEAVE_TOKEN_REGEX, '.' + this._leaveClassName);\n      const multi = limit != 1;\n      let elements = this._driver.query(this.element, selector, multi);\n      if (limit !== 0) {\n        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) :\n                               elements.slice(0, limit);\n      }\n      results.push(...elements);\n    }\n\n    if (!optional && results.length == 0) {\n      errors.push(\n          `\\`query(\"${originalSelector}\")\\` returned zero elements. (Use \\`query(\"${originalSelector}\", { optional: true })\\` if you wish to allow this.)`);\n    }\n    return results;\n  }\n}\n\n\nexport class TimelineBuilder {\n  public duration: number = 0;\n  // TODO(issue/24571): remove '!'.\n  public easing !: string | null;\n  private _previousKeyframe: ɵStyleData = {};\n  private _currentKeyframe: ɵStyleData = {};\n  private _keyframes = new Map<number, ɵStyleData>();\n  private _styleSummary: {[prop: string]: StyleAtTime} = {};\n  private _localTimelineStyles: ɵStyleData;\n  private _globalTimelineStyles: ɵStyleData;\n  private _pendingStyles: ɵStyleData = {};\n  private _backFill: ɵStyleData = {};\n  private _currentEmptyStepKeyframe: ɵStyleData|null = null;\n\n  constructor(\n      private _driver: AnimationDriver, public element: any, public startTime: number,\n      private _elementTimelineStylesLookup?: Map<any, ɵStyleData>) {\n    if (!this._elementTimelineStylesLookup) {\n      this._elementTimelineStylesLookup = new Map<any, ɵStyleData>();\n    }\n\n    this._localTimelineStyles = Object.create(this._backFill, {});\n    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element) !;\n    if (!this._globalTimelineStyles) {\n      this._globalTimelineStyles = this._localTimelineStyles;\n      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);\n    }\n    this._loadKeyframe();\n  }\n\n  containsAnimation(): boolean {\n    switch (this._keyframes.size) {\n      case 0:\n        return false;\n      case 1:\n        return this.getCurrentStyleProperties().length > 0;\n      default:\n        return true;\n    }\n  }\n\n  getCurrentStyleProperties(): string[] { return Object.keys(this._currentKeyframe); }\n\n  get currentTime() { return this.startTime + this.duration; }\n\n  delayNextStep(delay: number) {\n    // in the event that a style() step is placed right before a stagger()\n    // and that style() step is the very first style() value in the animation\n    // then we need to make a copy of the keyframe [0, copy, 1] so that the delay\n    // properly applies the style() values to work with the stagger...\n    const hasPreStyleStep = this._keyframes.size == 1 && Object.keys(this._pendingStyles).length;\n\n    if (this.duration || hasPreStyleStep) {\n      this.forwardTime(this.currentTime + delay);\n      if (hasPreStyleStep) {\n        this.snapshotCurrentStyles();\n      }\n    } else {\n      this.startTime += delay;\n    }\n  }\n\n  fork(element: any, currentTime?: number): TimelineBuilder {\n    this.applyStylesToKeyframe();\n    return new TimelineBuilder(\n        this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);\n  }\n\n  private _loadKeyframe() {\n    if (this._currentKeyframe) {\n      this._previousKeyframe = this._currentKeyframe;\n    }\n    this._currentKeyframe = this._keyframes.get(this.duration) !;\n    if (!this._currentKeyframe) {\n      this._currentKeyframe = Object.create(this._backFill, {});\n      this._keyframes.set(this.duration, this._currentKeyframe);\n    }\n  }\n\n  forwardFrame() {\n    this.duration += ONE_FRAME_IN_MILLISECONDS;\n    this._loadKeyframe();\n  }\n\n  forwardTime(time: number) {\n    this.applyStylesToKeyframe();\n    this.duration = time;\n    this._loadKeyframe();\n  }\n\n  private _updateStyle(prop: string, value: string|number) {\n    this._localTimelineStyles[prop] = value;\n    this._globalTimelineStyles[prop] = value;\n    this._styleSummary[prop] = {time: this.currentTime, value};\n  }\n\n  allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe; }\n\n  applyEmptyStep(easing: string|null) {\n    if (easing) {\n      this._previousKeyframe['easing'] = easing;\n    }\n\n    // special case for animate(duration):\n    // all missing styles are filled with a `*` value then\n    // if any destination styles are filled in later on the same\n    // keyframe then they will override the overridden styles\n    // We use `_globalTimelineStyles` here because there may be\n    // styles in previous keyframes that are not present in this timeline\n    Object.keys(this._globalTimelineStyles).forEach(prop => {\n      this._backFill[prop] = this._globalTimelineStyles[prop] || AUTO_STYLE;\n      this._currentKeyframe[prop] = AUTO_STYLE;\n    });\n    this._currentEmptyStepKeyframe = this._currentKeyframe;\n  }\n\n  setStyles(\n      input: (ɵStyleData|string)[], easing: string|null, errors: any[],\n      options?: AnimationOptions) {\n    if (easing) {\n      this._previousKeyframe['easing'] = easing;\n    }\n\n    const params = (options && options.params) || {};\n    const styles = flattenStyles(input, this._globalTimelineStyles);\n    Object.keys(styles).forEach(prop => {\n      const val = interpolateParams(styles[prop], params, errors);\n      this._pendingStyles[prop] = val;\n      if (!this._localTimelineStyles.hasOwnProperty(prop)) {\n        this._backFill[prop] = this._globalTimelineStyles.hasOwnProperty(prop) ?\n            this._globalTimelineStyles[prop] :\n            AUTO_STYLE;\n      }\n      this._updateStyle(prop, val);\n    });\n  }\n\n  applyStylesToKeyframe() {\n    const styles = this._pendingStyles;\n    const props = Object.keys(styles);\n    if (props.length == 0) return;\n\n    this._pendingStyles = {};\n\n    props.forEach(prop => {\n      const val = styles[prop];\n      this._currentKeyframe[prop] = val;\n    });\n\n    Object.keys(this._localTimelineStyles).forEach(prop => {\n      if (!this._currentKeyframe.hasOwnProperty(prop)) {\n        this._currentKeyframe[prop] = this._localTimelineStyles[prop];\n      }\n    });\n  }\n\n  snapshotCurrentStyles() {\n    Object.keys(this._localTimelineStyles).forEach(prop => {\n      const val = this._localTimelineStyles[prop];\n      this._pendingStyles[prop] = val;\n      this._updateStyle(prop, val);\n    });\n  }\n\n  getFinalKeyframe() { return this._keyframes.get(this.duration); }\n\n  get properties() {\n    const properties: string[] = [];\n    for (let prop in this._currentKeyframe) {\n      properties.push(prop);\n    }\n    return properties;\n  }\n\n  mergeTimelineCollectedStyles(timeline: TimelineBuilder) {\n    Object.keys(timeline._styleSummary).forEach(prop => {\n      const details0 = this._styleSummary[prop];\n      const details1 = timeline._styleSummary[prop];\n      if (!details0 || details1.time > details0.time) {\n        this._updateStyle(prop, details1.value);\n      }\n    });\n  }\n\n  buildKeyframes(): AnimationTimelineInstruction {\n    this.applyStylesToKeyframe();\n    const preStyleProps = new Set<string>();\n    const postStyleProps = new Set<string>();\n    const isEmpty = this._keyframes.size === 1 && this.duration === 0;\n\n    let finalKeyframes: ɵStyleData[] = [];\n    this._keyframes.forEach((keyframe, time) => {\n      const finalKeyframe = copyStyles(keyframe, true);\n      Object.keys(finalKeyframe).forEach(prop => {\n        const value = finalKeyframe[prop];\n        if (value == PRE_STYLE) {\n          preStyleProps.add(prop);\n        } else if (value == AUTO_STYLE) {\n          postStyleProps.add(prop);\n        }\n      });\n      if (!isEmpty) {\n        finalKeyframe['offset'] = time / this.duration;\n      }\n      finalKeyframes.push(finalKeyframe);\n    });\n\n    const preProps: string[] = preStyleProps.size ? iteratorToArray(preStyleProps.values()) : [];\n    const postProps: string[] = postStyleProps.size ? iteratorToArray(postStyleProps.values()) : [];\n\n    // special case for a 0-second animation (which is designed just to place styles onscreen)\n    if (isEmpty) {\n      const kf0 = finalKeyframes[0];\n      const kf1 = copyObj(kf0);\n      kf0['offset'] = 0;\n      kf1['offset'] = 1;\n      finalKeyframes = [kf0, kf1];\n    }\n\n    return createTimelineInstruction(\n        this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime,\n        this.easing, false);\n  }\n}\n\nclass SubTimelineBuilder extends TimelineBuilder {\n  public timings: AnimateTimings;\n\n  constructor(\n      driver: AnimationDriver, public element: any, public keyframes: ɵStyleData[],\n      public preStyleProps: string[], public postStyleProps: string[], timings: AnimateTimings,\n      private _stretchStartingKeyframe: boolean = false) {\n    super(driver, element, timings.delay);\n    this.timings = {duration: timings.duration, delay: timings.delay, easing: timings.easing};\n  }\n\n  containsAnimation(): boolean { return this.keyframes.length > 1; }\n\n  buildKeyframes(): AnimationTimelineInstruction {\n    let keyframes = this.keyframes;\n    let {delay, duration, easing} = this.timings;\n    if (this._stretchStartingKeyframe && delay) {\n      const newKeyframes: ɵStyleData[] = [];\n      const totalTime = duration + delay;\n      const startingGap = delay / totalTime;\n\n      // the original starting keyframe now starts once the delay is done\n      const newFirstKeyframe = copyStyles(keyframes[0], false);\n      newFirstKeyframe['offset'] = 0;\n      newKeyframes.push(newFirstKeyframe);\n\n      const oldFirstKeyframe = copyStyles(keyframes[0], false);\n      oldFirstKeyframe['offset'] = roundOffset(startingGap);\n      newKeyframes.push(oldFirstKeyframe);\n\n      /*\n        When the keyframe is stretched then it means that the delay before the animation\n        starts is gone. Instead the first keyframe is placed at the start of the animation\n        and it is then copied to where it starts when the original delay is over. This basically\n        means nothing animates during that delay, but the styles are still renderered. For this\n        to work the original offset values that exist in the original keyframes must be \"warped\"\n        so that they can take the new keyframe + delay into account.\n\n        delay=1000, duration=1000, keyframes = 0 .5 1\n\n        turns into\n\n        delay=0, duration=2000, keyframes = 0 .33 .66 1\n       */\n\n      // offsets between 1 ... n -1 are all warped by the keyframe stretch\n      const limit = keyframes.length - 1;\n      for (let i = 1; i <= limit; i++) {\n        let kf = copyStyles(keyframes[i], false);\n        const oldOffset = kf['offset'] as number;\n        const timeAtKeyframe = delay + oldOffset * duration;\n        kf['offset'] = roundOffset(timeAtKeyframe / totalTime);\n        newKeyframes.push(kf);\n      }\n\n      // the new starting keyframe should be added at the start\n      duration = totalTime;\n      delay = 0;\n      easing = '';\n\n      keyframes = newKeyframes;\n    }\n\n    return createTimelineInstruction(\n        this.element, keyframes, this.preStyleProps, this.postStyleProps, duration, delay, easing,\n        true);\n  }\n}\n\nfunction roundOffset(offset: number, decimalPoints = 3): number {\n  const mult = Math.pow(10, decimalPoints - 1);\n  return Math.round(offset * mult) / mult;\n}\n\nfunction flattenStyles(input: (ɵStyleData | string)[], allStyles: ɵStyleData) {\n  const styles: ɵStyleData = {};\n  let allProperties: string[];\n  input.forEach(token => {\n    if (token === '*') {\n      allProperties = allProperties || Object.keys(allStyles);\n      allProperties.forEach(prop => { styles[prop] = AUTO_STYLE; });\n    } else {\n      copyStyles(token as ɵStyleData, false, styles);\n    }\n  });\n  return styles;\n}\n"],"sourceRoot":""}