{"version":3,"sources":["../../../../../../../../packages/animations/browser/src/render/transition_animation_engine.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationOptions, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer as AnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationTimelineInstruction} from '../dsl/animation_timeline_instruction';\nimport {AnimationTransitionFactory} from '../dsl/animation_transition_factory';\nimport {AnimationTransitionInstruction} from '../dsl/animation_transition_instruction';\nimport {AnimationTrigger} from '../dsl/animation_trigger';\nimport {ElementInstructionMap} from '../dsl/element_instruction_map';\nimport {AnimationStyleNormalizer} from '../dsl/style_normalization/animation_style_normalizer';\nimport {ENTER_CLASSNAME, LEAVE_CLASSNAME, NG_ANIMATING_CLASSNAME, NG_ANIMATING_SELECTOR, NG_TRIGGER_CLASSNAME, NG_TRIGGER_SELECTOR, copyObj, eraseStyles, iteratorToArray, setStyles} from '../util';\n\nimport {AnimationDriver} from './animation_driver';\nimport {getOrSetAsInMap, listenOnPlayer, makeAnimationEvent, normalizeKeyframes, optimizeGroupPlayer} from './shared';\n\nconst QUEUED_CLASSNAME = 'ng-animate-queued';\nconst QUEUED_SELECTOR = '.ng-animate-queued';\nconst DISABLED_CLASSNAME = 'ng-animate-disabled';\nconst DISABLED_SELECTOR = '.ng-animate-disabled';\nconst STAR_CLASSNAME = 'ng-star-inserted';\nconst STAR_SELECTOR = '.ng-star-inserted';\n\nconst EMPTY_PLAYER_ARRAY: TransitionAnimationPlayer[] = [];\nconst NULL_REMOVAL_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForRemoval: false,\n  setForMove: false,\n  hasAnimation: false,\n  removedBeforeQueried: false\n};\nconst NULL_REMOVED_QUERIED_STATE: ElementAnimationState = {\n  namespaceId: '',\n  setForMove: false,\n  setForRemoval: false,\n  hasAnimation: false,\n  removedBeforeQueried: true\n};\n\ninterface TriggerListener {\n  name: string;\n  phase: string;\n  callback: (event: any) => any;\n}\n\nexport interface QueueInstruction {\n  element: any;\n  triggerName: string;\n  fromState: StateValue;\n  toState: StateValue;\n  transition: AnimationTransitionFactory;\n  player: TransitionAnimationPlayer;\n  isFallbackTransition: boolean;\n}\n\nexport const REMOVAL_FLAG = '__ng_removed';\n\nexport interface ElementAnimationState {\n  setForRemoval: boolean;\n  setForMove: boolean;\n  hasAnimation: boolean;\n  namespaceId: string;\n  removedBeforeQueried: boolean;\n}\n\nexport class StateValue {\n  public value: string;\n  public options: AnimationOptions;\n\n  get params(): {[key: string]: any} { return this.options.params as{[key: string]: any}; }\n\n  constructor(input: any, public namespaceId: string = '') {\n    const isObj = input && input.hasOwnProperty('value');\n    const value = isObj ? input['value'] : input;\n    this.value = normalizeTriggerValue(value);\n    if (isObj) {\n      const options = copyObj(input as any);\n      delete options['value'];\n      this.options = options as AnimationOptions;\n    } else {\n      this.options = {};\n    }\n    if (!this.options.params) {\n      this.options.params = {};\n    }\n  }\n\n  absorbOptions(options: AnimationOptions) {\n    const newParams = options.params;\n    if (newParams) {\n      const oldParams = this.options.params !;\n      Object.keys(newParams).forEach(prop => {\n        if (oldParams[prop] == null) {\n          oldParams[prop] = newParams[prop];\n        }\n      });\n    }\n  }\n}\n\nexport const VOID_VALUE = 'void';\nexport const DEFAULT_STATE_VALUE = new StateValue(VOID_VALUE);\n\nexport class AnimationTransitionNamespace {\n  public players: TransitionAnimationPlayer[] = [];\n\n  private _triggers: {[triggerName: string]: AnimationTrigger} = {};\n  private _queue: QueueInstruction[] = [];\n\n  private _elementListeners = new Map<any, TriggerListener[]>();\n\n  private _hostClassName: string;\n\n  constructor(\n      public id: string, public hostElement: any, private _engine: TransitionAnimationEngine) {\n    this._hostClassName = 'ng-tns-' + id;\n    addClass(hostElement, this._hostClassName);\n  }\n\n  listen(element: any, name: string, phase: string, callback: (event: any) => boolean): () => any {\n    if (!this._triggers.hasOwnProperty(name)) {\n      throw new Error(`Unable to listen on the animation trigger event \"${\n          phase}\" because the animation trigger \"${name}\" doesn\\'t exist!`);\n    }\n\n    if (phase == null || phase.length == 0) {\n      throw new Error(`Unable to listen on the animation trigger \"${\n          name}\" because the provided event is undefined!`);\n    }\n\n    if (!isTriggerEventValid(phase)) {\n      throw new Error(`The provided animation trigger event \"${phase}\" for the animation trigger \"${\n          name}\" is not supported!`);\n    }\n\n    const listeners = getOrSetAsInMap(this._elementListeners, element, []);\n    const data = {name, phase, callback};\n    listeners.push(data);\n\n    const triggersWithStates = getOrSetAsInMap(this._engine.statesByElement, element, {});\n    if (!triggersWithStates.hasOwnProperty(name)) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + name);\n      triggersWithStates[name] = DEFAULT_STATE_VALUE;\n    }\n\n    return () => {\n      // the event listener is removed AFTER the flush has occurred such\n      // that leave animations callbacks can fire (otherwise if the node\n      // is removed in between then the listeners would be deregistered)\n      this._engine.afterFlush(() => {\n        const index = listeners.indexOf(data);\n        if (index >= 0) {\n          listeners.splice(index, 1);\n        }\n\n        if (!this._triggers[name]) {\n          delete triggersWithStates[name];\n        }\n      });\n    };\n  }\n\n  register(name: string, ast: AnimationTrigger): boolean {\n    if (this._triggers[name]) {\n      // throw\n      return false;\n    } else {\n      this._triggers[name] = ast;\n      return true;\n    }\n  }\n\n  private _getTrigger(name: string) {\n    const trigger = this._triggers[name];\n    if (!trigger) {\n      throw new Error(`The provided animation trigger \"${name}\" has not been registered!`);\n    }\n    return trigger;\n  }\n\n  trigger(element: any, triggerName: string, value: any, defaultToFallback: boolean = true):\n      TransitionAnimationPlayer|undefined {\n    const trigger = this._getTrigger(triggerName);\n    const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n    let triggersWithStates = this._engine.statesByElement.get(element);\n    if (!triggersWithStates) {\n      addClass(element, NG_TRIGGER_CLASSNAME);\n      addClass(element, NG_TRIGGER_CLASSNAME + '-' + triggerName);\n      this._engine.statesByElement.set(element, triggersWithStates = {});\n    }\n\n    let fromState = triggersWithStates[triggerName];\n    const toState = new StateValue(value, this.id);\n\n    const isObj = value && value.hasOwnProperty('value');\n    if (!isObj && fromState) {\n      toState.absorbOptions(fromState.options);\n    }\n\n    triggersWithStates[triggerName] = toState;\n\n    if (!fromState) {\n      fromState = DEFAULT_STATE_VALUE;\n    }\n\n    const isRemoval = toState.value === VOID_VALUE;\n\n    // normally this isn't reached by here, however, if an object expression\n    // is passed in then it may be a new object each time. Comparing the value\n    // is important since that will stay the same despite there being a new object.\n    // The removal arc here is special cased because the same element is triggered\n    // twice in the event that it contains animations on the outer/inner portions\n    // of the host container\n    if (!isRemoval && fromState.value === toState.value) {\n      // this means that despite the value not changing, some inner params\n      // have changed which means that the animation final styles need to be applied\n      if (!objEquals(fromState.params, toState.params)) {\n        const errors: any[] = [];\n        const fromStyles = trigger.matchStyles(fromState.value, fromState.params, errors);\n        const toStyles = trigger.matchStyles(toState.value, toState.params, errors);\n        if (errors.length) {\n          this._engine.reportError(errors);\n        } else {\n          this._engine.afterFlush(() => {\n            eraseStyles(element, fromStyles);\n            setStyles(element, toStyles);\n          });\n        }\n      }\n      return;\n    }\n\n    const playersOnElement: TransitionAnimationPlayer[] =\n        getOrSetAsInMap(this._engine.playersByElement, element, []);\n    playersOnElement.forEach(player => {\n      // only remove the player if it is queued on the EXACT same trigger/namespace\n      // we only also deal with queued players here because if the animation has\n      // started then we want to keep the player alive until the flush happens\n      // (which is where the previousPlayers are passed into the new palyer)\n      if (player.namespaceId == this.id && player.triggerName == triggerName && player.queued) {\n        player.destroy();\n      }\n    });\n\n    let transition =\n        trigger.matchTransition(fromState.value, toState.value, element, toState.params);\n    let isFallbackTransition = false;\n    if (!transition) {\n      if (!defaultToFallback) return;\n      transition = trigger.fallbackTransition;\n      isFallbackTransition = true;\n    }\n\n    this._engine.totalQueuedPlayers++;\n    this._queue.push(\n        {element, triggerName, transition, fromState, toState, player, isFallbackTransition});\n\n    if (!isFallbackTransition) {\n      addClass(element, QUEUED_CLASSNAME);\n      player.onStart(() => { removeClass(element, QUEUED_CLASSNAME); });\n    }\n\n    player.onDone(() => {\n      let index = this.players.indexOf(player);\n      if (index >= 0) {\n        this.players.splice(index, 1);\n      }\n\n      const players = this._engine.playersByElement.get(element);\n      if (players) {\n        let index = players.indexOf(player);\n        if (index >= 0) {\n          players.splice(index, 1);\n        }\n      }\n    });\n\n    this.players.push(player);\n    playersOnElement.push(player);\n\n    return player;\n  }\n\n  deregister(name: string) {\n    delete this._triggers[name];\n\n    this._engine.statesByElement.forEach((stateMap, element) => { delete stateMap[name]; });\n\n    this._elementListeners.forEach((listeners, element) => {\n      this._elementListeners.set(\n          element, listeners.filter(entry => { return entry.name != name; }));\n    });\n  }\n\n  clearElementCache(element: any) {\n    this._engine.statesByElement.delete(element);\n    this._elementListeners.delete(element);\n    const elementPlayers = this._engine.playersByElement.get(element);\n    if (elementPlayers) {\n      elementPlayers.forEach(player => player.destroy());\n      this._engine.playersByElement.delete(element);\n    }\n  }\n\n  private _signalRemovalForInnerTriggers(rootElement: any, context: any, animate: boolean = false) {\n    // emulate a leave animation for all inner nodes within this node.\n    // If there are no animations found for any of the nodes then clear the cache\n    // for the element.\n    this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true).forEach(elm => {\n      // this means that an inner remove() operation has already kicked off\n      // the animation on this element...\n      if (elm[REMOVAL_FLAG]) return;\n\n      const namespaces = this._engine.fetchNamespacesByElement(elm);\n      if (namespaces.size) {\n        namespaces.forEach(ns => ns.triggerLeaveAnimation(elm, context, false, true));\n      } else {\n        this.clearElementCache(elm);\n      }\n    });\n  }\n\n  triggerLeaveAnimation(\n      element: any, context: any, destroyAfterComplete?: boolean,\n      defaultToFallback?: boolean): boolean {\n    const triggerStates = this._engine.statesByElement.get(element);\n    if (triggerStates) {\n      const players: TransitionAnimationPlayer[] = [];\n      Object.keys(triggerStates).forEach(triggerName => {\n        // this check is here in the event that an element is removed\n        // twice (both on the host level and the component level)\n        if (this._triggers[triggerName]) {\n          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);\n          if (player) {\n            players.push(player);\n          }\n        }\n      });\n\n      if (players.length) {\n        this._engine.markElementAsRemoved(this.id, element, true, context);\n        if (destroyAfterComplete) {\n          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n\n  prepareLeaveAnimationListeners(element: any) {\n    const listeners = this._elementListeners.get(element);\n    if (listeners) {\n      const visitedTriggers = new Set<string>();\n      listeners.forEach(listener => {\n        const triggerName = listener.name;\n        if (visitedTriggers.has(triggerName)) return;\n        visitedTriggers.add(triggerName);\n\n        const trigger = this._triggers[triggerName];\n        const transition = trigger.fallbackTransition;\n        const elementStates = this._engine.statesByElement.get(element) !;\n        const fromState = elementStates[triggerName] || DEFAULT_STATE_VALUE;\n        const toState = new StateValue(VOID_VALUE);\n        const player = new TransitionAnimationPlayer(this.id, triggerName, element);\n\n        this._engine.totalQueuedPlayers++;\n        this._queue.push({\n          element,\n          triggerName,\n          transition,\n          fromState,\n          toState,\n          player,\n          isFallbackTransition: true\n        });\n      });\n    }\n  }\n\n  removeNode(element: any, context: any): void {\n    const engine = this._engine;\n\n    if (element.childElementCount) {\n      this._signalRemovalForInnerTriggers(element, context, true);\n    }\n\n    // this means that a * => VOID animation was detected and kicked off\n    if (this.triggerLeaveAnimation(element, context, true)) return;\n\n    // find the player that is animating and make sure that the\n    // removal is delayed until that player has completed\n    let containsPotentialParentTransition = false;\n    if (engine.totalAnimations) {\n      const currentPlayers =\n          engine.players.length ? engine.playersByQueriedElement.get(element) : [];\n\n      // when this `if statement` does not continue forward it means that\n      // a previous animation query has selected the current element and\n      // is animating it. In this situation want to continue forwards and\n      // allow the element to be queued up for animation later.\n      if (currentPlayers && currentPlayers.length) {\n        containsPotentialParentTransition = true;\n      } else {\n        let parent = element;\n        while (parent = parent.parentNode) {\n          const triggers = engine.statesByElement.get(parent);\n          if (triggers) {\n            containsPotentialParentTransition = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // at this stage we know that the element will either get removed\n    // during flush or will be picked up by a parent query. Either way\n    // we need to fire the listeners for this element when it DOES get\n    // removed (once the query parent animation is done or after flush)\n    this.prepareLeaveAnimationListeners(element);\n\n    // whether or not a parent has an animation we need to delay the deferral of the leave\n    // operation until we have more information (which we do after flush() has been called)\n    if (containsPotentialParentTransition) {\n      engine.markElementAsRemoved(this.id, element, false, context);\n    } else {\n      // we do this after the flush has occurred such\n      // that the callbacks can be fired\n      engine.afterFlush(() => this.clearElementCache(element));\n      engine.destroyInnerAnimations(element);\n      engine._onRemovalComplete(element, context);\n    }\n  }\n\n  insertNode(element: any, parent: any): void { addClass(element, this._hostClassName); }\n\n  drainQueuedTransitions(microtaskId: number): QueueInstruction[] {\n    const instructions: QueueInstruction[] = [];\n    this._queue.forEach(entry => {\n      const player = entry.player;\n      if (player.destroyed) return;\n\n      const element = entry.element;\n      const listeners = this._elementListeners.get(element);\n      if (listeners) {\n        listeners.forEach((listener: TriggerListener) => {\n          if (listener.name == entry.triggerName) {\n            const baseEvent = makeAnimationEvent(\n                element, entry.triggerName, entry.fromState.value, entry.toState.value);\n            (baseEvent as any)['_data'] = microtaskId;\n            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);\n          }\n        });\n      }\n\n      if (player.markedForDestroy) {\n        this._engine.afterFlush(() => {\n          // now we can destroy the element properly since the event listeners have\n          // been bound to the player\n          player.destroy();\n        });\n      } else {\n        instructions.push(entry);\n      }\n    });\n\n    this._queue = [];\n\n    return instructions.sort((a, b) => {\n      // if depCount == 0 them move to front\n      // otherwise if a contains b then move back\n      const d0 = a.transition.ast.depCount;\n      const d1 = b.transition.ast.depCount;\n      if (d0 == 0 || d1 == 0) {\n        return d0 - d1;\n      }\n      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;\n    });\n  }\n\n  destroy(context: any) {\n    this.players.forEach(p => p.destroy());\n    this._signalRemovalForInnerTriggers(this.hostElement, context);\n  }\n\n  elementContainsData(element: any): boolean {\n    let containsData = false;\n    if (this._elementListeners.has(element)) containsData = true;\n    containsData =\n        (this._queue.find(entry => entry.element === element) ? true : false) || containsData;\n    return containsData;\n  }\n}\n\nexport interface QueuedTransition {\n  element: any;\n  instruction: AnimationTransitionInstruction;\n  player: TransitionAnimationPlayer;\n}\n\nexport class TransitionAnimationEngine {\n  public players: TransitionAnimationPlayer[] = [];\n  public newHostElements = new Map<any, AnimationTransitionNamespace>();\n  public playersByElement = new Map<any, TransitionAnimationPlayer[]>();\n  public playersByQueriedElement = new Map<any, TransitionAnimationPlayer[]>();\n  public statesByElement = new Map<any, {[triggerName: string]: StateValue}>();\n  public disabledNodes = new Set<any>();\n\n  public totalAnimations = 0;\n  public totalQueuedPlayers = 0;\n\n  private _namespaceLookup: {[id: string]: AnimationTransitionNamespace} = {};\n  private _namespaceList: AnimationTransitionNamespace[] = [];\n  private _flushFns: (() => any)[] = [];\n  private _whenQuietFns: (() => any)[] = [];\n\n  public namespacesByHostElement = new Map<any, AnimationTransitionNamespace>();\n  public collectedEnterElements: any[] = [];\n  public collectedLeaveElements: any[] = [];\n\n  // this method is designed to be overridden by the code that uses this engine\n  public onRemovalComplete = (element: any, context: any) => {};\n\n  /** @internal */\n  _onRemovalComplete(element: any, context: any) { this.onRemovalComplete(element, context); }\n\n  constructor(\n      public bodyNode: any, public driver: AnimationDriver,\n      private _normalizer: AnimationStyleNormalizer) {}\n\n  get queuedPlayers(): TransitionAnimationPlayer[] {\n    const players: TransitionAnimationPlayer[] = [];\n    this._namespaceList.forEach(ns => {\n      ns.players.forEach(player => {\n        if (player.queued) {\n          players.push(player);\n        }\n      });\n    });\n    return players;\n  }\n\n  createNamespace(namespaceId: string, hostElement: any) {\n    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);\n    if (hostElement.parentNode) {\n      this._balanceNamespaceList(ns, hostElement);\n    } else {\n      // defer this later until flush during when the host element has\n      // been inserted so that we know exactly where to place it in\n      // the namespace list\n      this.newHostElements.set(hostElement, ns);\n\n      // given that this host element is apart of the animation code, it\n      // may or may not be inserted by a parent node that is an of an\n      // animation renderer type. If this happens then we can still have\n      // access to this item when we query for :enter nodes. If the parent\n      // is a renderer then the set data-structure will normalize the entry\n      this.collectEnterElement(hostElement);\n    }\n    return this._namespaceLookup[namespaceId] = ns;\n  }\n\n  private _balanceNamespaceList(ns: AnimationTransitionNamespace, hostElement: any) {\n    const limit = this._namespaceList.length - 1;\n    if (limit >= 0) {\n      let found = false;\n      for (let i = limit; i >= 0; i--) {\n        const nextNamespace = this._namespaceList[i];\n        if (this.driver.containsElement(nextNamespace.hostElement, hostElement)) {\n          this._namespaceList.splice(i + 1, 0, ns);\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        this._namespaceList.splice(0, 0, ns);\n      }\n    } else {\n      this._namespaceList.push(ns);\n    }\n\n    this.namespacesByHostElement.set(hostElement, ns);\n    return ns;\n  }\n\n  register(namespaceId: string, hostElement: any) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (!ns) {\n      ns = this.createNamespace(namespaceId, hostElement);\n    }\n    return ns;\n  }\n\n  registerTrigger(namespaceId: string, name: string, trigger: AnimationTrigger) {\n    let ns = this._namespaceLookup[namespaceId];\n    if (ns && ns.register(name, trigger)) {\n      this.totalAnimations++;\n    }\n  }\n\n  destroy(namespaceId: string, context: any) {\n    if (!namespaceId) return;\n\n    const ns = this._fetchNamespace(namespaceId);\n\n    this.afterFlush(() => {\n      this.namespacesByHostElement.delete(ns.hostElement);\n      delete this._namespaceLookup[namespaceId];\n      const index = this._namespaceList.indexOf(ns);\n      if (index >= 0) {\n        this._namespaceList.splice(index, 1);\n      }\n    });\n\n    this.afterFlushAnimationsDone(() => ns.destroy(context));\n  }\n\n  private _fetchNamespace(id: string) { return this._namespaceLookup[id]; }\n\n  fetchNamespacesByElement(element: any): Set<AnimationTransitionNamespace> {\n    // normally there should only be one namespace per element, however\n    // if @triggers are placed on both the component element and then\n    // its host element (within the component code) then there will be\n    // two namespaces returned. We use a set here to simply the dedupe\n    // of namespaces incase there are multiple triggers both the elm and host\n    const namespaces = new Set<AnimationTransitionNamespace>();\n    const elementStates = this.statesByElement.get(element);\n    if (elementStates) {\n      const keys = Object.keys(elementStates);\n      for (let i = 0; i < keys.length; i++) {\n        const nsId = elementStates[keys[i]].namespaceId;\n        if (nsId) {\n          const ns = this._fetchNamespace(nsId);\n          if (ns) {\n            namespaces.add(ns);\n          }\n        }\n      }\n    }\n    return namespaces;\n  }\n\n  trigger(namespaceId: string, element: any, name: string, value: any): boolean {\n    if (isElementNode(element)) {\n      const ns = this._fetchNamespace(namespaceId);\n      if (ns) {\n        ns.trigger(element, name, value);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  insertNode(namespaceId: string, element: any, parent: any, insertBefore: boolean): void {\n    if (!isElementNode(element)) return;\n\n    // special case for when an element is removed and reinserted (move operation)\n    // when this occurs we do not want to use the element for deletion later\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      details.setForRemoval = false;\n      details.setForMove = true;\n      const index = this.collectedLeaveElements.indexOf(element);\n      if (index >= 0) {\n        this.collectedLeaveElements.splice(index, 1);\n      }\n    }\n\n    // in the event that the namespaceId is blank then the caller\n    // code does not contain any animation code in it, but it is\n    // just being called so that the node is marked as being inserted\n    if (namespaceId) {\n      const ns = this._fetchNamespace(namespaceId);\n      // This if-statement is a workaround for router issue #21947.\n      // The router sometimes hits a race condition where while a route\n      // is being instantiated a new navigation arrives, triggering leave\n      // animation of DOM that has not been fully initialized, until this\n      // is resolved, we need to handle the scenario when DOM is not in a\n      // consistent state during the animation.\n      if (ns) {\n        ns.insertNode(element, parent);\n      }\n    }\n\n    // only *directives and host elements are inserted before\n    if (insertBefore) {\n      this.collectEnterElement(element);\n    }\n  }\n\n  collectEnterElement(element: any) { this.collectedEnterElements.push(element); }\n\n  markElementAsDisabled(element: any, value: boolean) {\n    if (value) {\n      if (!this.disabledNodes.has(element)) {\n        this.disabledNodes.add(element);\n        addClass(element, DISABLED_CLASSNAME);\n      }\n    } else if (this.disabledNodes.has(element)) {\n      this.disabledNodes.delete(element);\n      removeClass(element, DISABLED_CLASSNAME);\n    }\n  }\n\n  removeNode(namespaceId: string, element: any, context: any): void {\n    if (!isElementNode(element)) {\n      this._onRemovalComplete(element, context);\n      return;\n    }\n\n    const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;\n    if (ns) {\n      ns.removeNode(element, context);\n    } else {\n      this.markElementAsRemoved(namespaceId, element, false, context);\n    }\n  }\n\n  markElementAsRemoved(namespaceId: string, element: any, hasAnimation?: boolean, context?: any) {\n    this.collectedLeaveElements.push(element);\n    element[REMOVAL_FLAG] = {\n      namespaceId,\n      setForRemoval: context, hasAnimation,\n      removedBeforeQueried: false\n    };\n  }\n\n  listen(\n      namespaceId: string, element: any, name: string, phase: string,\n      callback: (event: any) => boolean): () => any {\n    if (isElementNode(element)) {\n      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);\n    }\n    return () => {};\n  }\n\n  private _buildInstruction(\n      entry: QueueInstruction, subTimelines: ElementInstructionMap, enterClassName: string,\n      leaveClassName: string, skipBuildAst?: boolean) {\n    return entry.transition.build(\n        this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName,\n        leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);\n  }\n\n  destroyInnerAnimations(containerElement: any) {\n    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);\n    elements.forEach(element => this.destroyActiveAnimationsForElement(element));\n\n    if (this.playersByQueriedElement.size == 0) return;\n\n    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);\n    elements.forEach(element => this.finishActiveQueriedAnimationOnElement(element));\n  }\n\n  destroyActiveAnimationsForElement(element: any) {\n    const players = this.playersByElement.get(element);\n    if (players) {\n      players.forEach(player => {\n        // special case for when an element is set for destruction, but hasn't started.\n        // in this situation we want to delay the destruction until the flush occurs\n        // so that any event listeners attached to the player are triggered.\n        if (player.queued) {\n          player.markedForDestroy = true;\n        } else {\n          player.destroy();\n        }\n      });\n    }\n  }\n\n  finishActiveQueriedAnimationOnElement(element: any) {\n    const players = this.playersByQueriedElement.get(element);\n    if (players) {\n      players.forEach(player => player.finish());\n    }\n  }\n\n  whenRenderingDone(): Promise<any> {\n    return new Promise(resolve => {\n      if (this.players.length) {\n        return optimizeGroupPlayer(this.players).onDone(() => resolve());\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  processLeaveNode(element: any) {\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) {\n      // this will prevent it from removing it twice\n      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;\n      if (details.namespaceId) {\n        this.destroyInnerAnimations(element);\n        const ns = this._fetchNamespace(details.namespaceId);\n        if (ns) {\n          ns.clearElementCache(element);\n        }\n      }\n      this._onRemovalComplete(element, details.setForRemoval);\n    }\n\n    if (this.driver.matchesElement(element, DISABLED_SELECTOR)) {\n      this.markElementAsDisabled(element, false);\n    }\n\n    this.driver.query(element, DISABLED_SELECTOR, true).forEach(node => {\n      this.markElementAsDisabled(element, false);\n    });\n  }\n\n  flush(microtaskId: number = -1) {\n    let players: AnimationPlayer[] = [];\n    if (this.newHostElements.size) {\n      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));\n      this.newHostElements.clear();\n    }\n\n    if (this.totalAnimations && this.collectedEnterElements.length) {\n      for (let i = 0; i < this.collectedEnterElements.length; i++) {\n        const elm = this.collectedEnterElements[i];\n        addClass(elm, STAR_CLASSNAME);\n      }\n    }\n\n    if (this._namespaceList.length &&\n        (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {\n      const cleanupFns: Function[] = [];\n      try {\n        players = this._flushAnimations(cleanupFns, microtaskId);\n      } finally {\n        for (let i = 0; i < cleanupFns.length; i++) {\n          cleanupFns[i]();\n        }\n      }\n    } else {\n      for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n        const element = this.collectedLeaveElements[i];\n        this.processLeaveNode(element);\n      }\n    }\n\n    this.totalQueuedPlayers = 0;\n    this.collectedEnterElements.length = 0;\n    this.collectedLeaveElements.length = 0;\n    this._flushFns.forEach(fn => fn());\n    this._flushFns = [];\n\n    if (this._whenQuietFns.length) {\n      // we move these over to a variable so that\n      // if any new callbacks are registered in another\n      // flush they do not populate the existing set\n      const quietFns = this._whenQuietFns;\n      this._whenQuietFns = [];\n\n      if (players.length) {\n        optimizeGroupPlayer(players).onDone(() => { quietFns.forEach(fn => fn()); });\n      } else {\n        quietFns.forEach(fn => fn());\n      }\n    }\n  }\n\n  reportError(errors: string[]) {\n    throw new Error(\n        `Unable to process animations due to the following failed trigger transitions\\n ${\n            errors.join('\\n')}`);\n  }\n\n  private _flushAnimations(cleanupFns: Function[], microtaskId: number):\n      TransitionAnimationPlayer[] {\n    const subTimelines = new ElementInstructionMap();\n    const skippedPlayers: TransitionAnimationPlayer[] = [];\n    const skippedPlayersMap = new Map<any, AnimationPlayer[]>();\n    const queuedInstructions: QueuedTransition[] = [];\n    const queriedElements = new Map<any, TransitionAnimationPlayer[]>();\n    const allPreStyleElements = new Map<any, Set<string>>();\n    const allPostStyleElements = new Map<any, Set<string>>();\n\n    const disabledElementsSet = new Set<any>();\n    this.disabledNodes.forEach(node => {\n      disabledElementsSet.add(node);\n      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);\n      for (let i = 0; i < nodesThatAreDisabled.length; i++) {\n        disabledElementsSet.add(nodesThatAreDisabled[i]);\n      }\n    });\n\n    const bodyNode = this.bodyNode;\n    const allTriggerElements = Array.from(this.statesByElement.keys());\n    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);\n\n    // this must occur before the instructions are built below such that\n    // the :enter queries match the elements (since the timeline queries\n    // are fired during instruction building).\n    const enterNodeMapIds = new Map<any, string>();\n    let i = 0;\n    enterNodeMap.forEach((nodes, root) => {\n      const className = ENTER_CLASSNAME + i++;\n      enterNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    const allLeaveNodes: any[] = [];\n    const mergedLeaveNodes = new Set<any>();\n    const leaveNodesWithoutAnimations = new Set<any>();\n    for (let i = 0; i < this.collectedLeaveElements.length; i++) {\n      const element = this.collectedLeaveElements[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      if (details && details.setForRemoval) {\n        allLeaveNodes.push(element);\n        mergedLeaveNodes.add(element);\n        if (details.hasAnimation) {\n          this.driver.query(element, STAR_SELECTOR, true).forEach(elm => mergedLeaveNodes.add(elm));\n        } else {\n          leaveNodesWithoutAnimations.add(element);\n        }\n      }\n    }\n\n    const leaveNodeMapIds = new Map<any, string>();\n    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));\n    leaveNodeMap.forEach((nodes, root) => {\n      const className = LEAVE_CLASSNAME + i++;\n      leaveNodeMapIds.set(root, className);\n      nodes.forEach(node => addClass(node, className));\n    });\n\n    cleanupFns.push(() => {\n      enterNodeMap.forEach((nodes, root) => {\n        const className = enterNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      leaveNodeMap.forEach((nodes, root) => {\n        const className = leaveNodeMapIds.get(root) !;\n        nodes.forEach(node => removeClass(node, className));\n      });\n\n      allLeaveNodes.forEach(element => { this.processLeaveNode(element); });\n    });\n\n    const allPlayers: TransitionAnimationPlayer[] = [];\n    const erroneousTransitions: AnimationTransitionInstruction[] = [];\n    for (let i = this._namespaceList.length - 1; i >= 0; i--) {\n      const ns = this._namespaceList[i];\n      ns.drainQueuedTransitions(microtaskId).forEach(entry => {\n        const player = entry.player;\n        const element = entry.element;\n        allPlayers.push(player);\n\n        if (this.collectedEnterElements.length) {\n          const details = element[REMOVAL_FLAG] as ElementAnimationState;\n          // move animations are currently not supported...\n          if (details && details.setForMove) {\n            player.destroy();\n            return;\n          }\n        }\n\n        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);\n        const leaveClassName = leaveNodeMapIds.get(element) !;\n        const enterClassName = enterNodeMapIds.get(element) !;\n        const instruction = this._buildInstruction(\n            entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned) !;\n        if (instruction.errors && instruction.errors.length) {\n          erroneousTransitions.push(instruction);\n          return;\n        }\n\n        // even though the element may not be apart of the DOM, it may\n        // still be added at a later point (due to the mechanics of content\n        // projection and/or dynamic component insertion) therefore it's\n        // important we still style the element.\n        if (nodeIsOrphaned) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // if a unmatched transition is queued to go then it SHOULD NOT render\n        // an animation and cancel the previously running animations.\n        if (entry.isFallbackTransition) {\n          player.onStart(() => eraseStyles(element, instruction.fromStyles));\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this means that if a parent animation uses this animation as a sub trigger\n        // then it will instruct the timeline builder to not add a player delay, but\n        // instead stretch the first keyframe gap up until the animation starts. The\n        // reason this is important is to prevent extra initialization styles from being\n        // required by the user in the animation.\n        instruction.timelines.forEach(tl => tl.stretchStartingKeyframe = true);\n\n        subTimelines.append(element, instruction.timelines);\n\n        const tuple = {instruction, player, element};\n\n        queuedInstructions.push(tuple);\n\n        instruction.queriedElements.forEach(\n            element => getOrSetAsInMap(queriedElements, element, []).push(player));\n\n        instruction.preStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          if (props.length) {\n            let setVal: Set<string> = allPreStyleElements.get(element) !;\n            if (!setVal) {\n              allPreStyleElements.set(element, setVal = new Set<string>());\n            }\n            props.forEach(prop => setVal.add(prop));\n          }\n        });\n\n        instruction.postStyleProps.forEach((stringMap, element) => {\n          const props = Object.keys(stringMap);\n          let setVal: Set<string> = allPostStyleElements.get(element) !;\n          if (!setVal) {\n            allPostStyleElements.set(element, setVal = new Set<string>());\n          }\n          props.forEach(prop => setVal.add(prop));\n        });\n      });\n    }\n\n    if (erroneousTransitions.length) {\n      const errors: string[] = [];\n      erroneousTransitions.forEach(instruction => {\n        errors.push(`@${instruction.triggerName} has failed due to:\\n`);\n        instruction.errors !.forEach(error => errors.push(`- ${error}\\n`));\n      });\n\n      allPlayers.forEach(player => player.destroy());\n      this.reportError(errors);\n    }\n\n    const allPreviousPlayersMap = new Map<any, TransitionAnimationPlayer[]>();\n    // this map works to tell which element in the DOM tree is contained by\n    // which animation. Further down below this map will get populated once\n    // the players are built and in doing so it can efficiently figure out\n    // if a sub player is skipped due to a parent player having priority.\n    const animationElementMap = new Map<any, any>();\n    queuedInstructions.forEach(entry => {\n      const element = entry.element;\n      if (subTimelines.has(element)) {\n        animationElementMap.set(element, element);\n        this._beforeAnimationBuild(\n            entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);\n      }\n    });\n\n    skippedPlayers.forEach(player => {\n      const element = player.element;\n      const previousPlayers =\n          this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);\n      previousPlayers.forEach(prevPlayer => {\n        getOrSetAsInMap(allPreviousPlayersMap, element, []).push(prevPlayer);\n        prevPlayer.destroy();\n      });\n    });\n\n    // this is a special case for nodes that will be removed (either by)\n    // having their own leave animations or by being queried in a container\n    // that will be removed once a parent animation is complete. The idea\n    // here is that * styles must be identical to ! styles because of\n    // backwards compatibility (* is also filled in by default in many places).\n    // Otherwise * styles will return an empty value or auto since the element\n    // that is being getComputedStyle'd will not be visible (since * = destination)\n    const replaceNodes = allLeaveNodes.filter(node => {\n      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);\n    });\n\n    // POST STAGE: fill the * styles\n    const postStylesMap = new Map<any, ɵStyleData>();\n    const allLeaveQueriedNodes = cloakAndComputeStyles(\n        postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);\n\n    allLeaveQueriedNodes.forEach(node => {\n      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {\n        replaceNodes.push(node);\n      }\n    });\n\n    // PRE STAGE: fill the ! styles\n    const preStylesMap = new Map<any, ɵStyleData>();\n    enterNodeMap.forEach((nodes, root) => {\n      cloakAndComputeStyles(\n          preStylesMap, this.driver, new Set(nodes), allPreStyleElements, PRE_STYLE);\n    });\n\n    replaceNodes.forEach(node => {\n      const post = postStylesMap.get(node);\n      const pre = preStylesMap.get(node);\n      postStylesMap.set(node, { ...post, ...pre } as any);\n    });\n\n    const rootPlayers: TransitionAnimationPlayer[] = [];\n    const subPlayers: TransitionAnimationPlayer[] = [];\n    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};\n    queuedInstructions.forEach(entry => {\n      const {element, player, instruction} = entry;\n      // this means that it was never consumed by a parent animation which\n      // means that it is independent and therefore should be set for animation\n      if (subTimelines.has(element)) {\n        if (disabledElementsSet.has(element)) {\n          player.onDestroy(() => setStyles(element, instruction.toStyles));\n          player.disabled = true;\n          player.overrideTotalTime(instruction.totalTime);\n          skippedPlayers.push(player);\n          return;\n        }\n\n        // this will flow up the DOM and query the map to figure out\n        // if a parent animation has priority over it. In the situation\n        // that a parent is detected then it will cancel the loop. If\n        // nothing is detected, or it takes a few hops to find a parent,\n        // then it will fill in the missing nodes and signal them as having\n        // a detected parent (or a NO_PARENT value via a special constant).\n        let parentWithAnimation: any = NO_PARENT_ANIMATION_ELEMENT_DETECTED;\n        if (animationElementMap.size > 1) {\n          let elm = element;\n          const parentsToAdd: any[] = [];\n          while (elm = elm.parentNode) {\n            const detectedParent = animationElementMap.get(elm);\n            if (detectedParent) {\n              parentWithAnimation = detectedParent;\n              break;\n            }\n            parentsToAdd.push(elm);\n          }\n          parentsToAdd.forEach(parent => animationElementMap.set(parent, parentWithAnimation));\n        }\n\n        const innerPlayer = this._buildAnimation(\n            player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap,\n            postStylesMap);\n\n        player.setRealPlayer(innerPlayer);\n\n        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {\n          rootPlayers.push(player);\n        } else {\n          const parentPlayers = this.playersByElement.get(parentWithAnimation);\n          if (parentPlayers && parentPlayers.length) {\n            player.parentPlayer = optimizeGroupPlayer(parentPlayers);\n          }\n          skippedPlayers.push(player);\n        }\n      } else {\n        eraseStyles(element, instruction.fromStyles);\n        player.onDestroy(() => setStyles(element, instruction.toStyles));\n        // there still might be a ancestor player animating this\n        // element therefore we will still add it as a sub player\n        // even if its animation may be disabled\n        subPlayers.push(player);\n        if (disabledElementsSet.has(element)) {\n          skippedPlayers.push(player);\n        }\n      }\n    });\n\n    // find all of the sub players' corresponding inner animation player\n    subPlayers.forEach(player => {\n      // even if any players are not found for a sub animation then it\n      // will still complete itself after the next tick since it's Noop\n      const playersForElement = skippedPlayersMap.get(player.element);\n      if (playersForElement && playersForElement.length) {\n        const innerPlayer = optimizeGroupPlayer(playersForElement);\n        player.setRealPlayer(innerPlayer);\n      }\n    });\n\n    // the reason why we don't actually play the animation is\n    // because all that a skipped player is designed to do is to\n    // fire the start/done transition callback events\n    skippedPlayers.forEach(player => {\n      if (player.parentPlayer) {\n        player.syncPlayerEvents(player.parentPlayer);\n      } else {\n        player.destroy();\n      }\n    });\n\n    // run through all of the queued removals and see if they\n    // were picked up by a query. If not then perform the removal\n    // operation right away unless a parent animation is ongoing.\n    for (let i = 0; i < allLeaveNodes.length; i++) {\n      const element = allLeaveNodes[i];\n      const details = element[REMOVAL_FLAG] as ElementAnimationState;\n      removeClass(element, LEAVE_CLASSNAME);\n\n      // this means the element has a removal animation that is being\n      // taken care of and therefore the inner elements will hang around\n      // until that animation is over (or the parent queried animation)\n      if (details && details.hasAnimation) continue;\n\n      let players: TransitionAnimationPlayer[] = [];\n\n      // if this element is queried or if it contains queried children\n      // then we want for the element not to be removed from the page\n      // until the queried animations have finished\n      if (queriedElements.size) {\n        let queriedPlayerResults = queriedElements.get(element);\n        if (queriedPlayerResults && queriedPlayerResults.length) {\n          players.push(...queriedPlayerResults);\n        }\n\n        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);\n        for (let j = 0; j < queriedInnerElements.length; j++) {\n          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);\n          if (queriedPlayers && queriedPlayers.length) {\n            players.push(...queriedPlayers);\n          }\n        }\n      }\n\n      const activePlayers = players.filter(p => !p.destroyed);\n      if (activePlayers.length) {\n        removeNodesAfterAnimationDone(this, element, activePlayers);\n      } else {\n        this.processLeaveNode(element);\n      }\n    }\n\n    // this is required so the cleanup method doesn't remove them\n    allLeaveNodes.length = 0;\n\n    rootPlayers.forEach(player => {\n      this.players.push(player);\n      player.onDone(() => {\n        player.destroy();\n\n        const index = this.players.indexOf(player);\n        this.players.splice(index, 1);\n      });\n      player.play();\n    });\n\n    return rootPlayers;\n  }\n\n  elementContainsData(namespaceId: string, element: any) {\n    let containsData = false;\n    const details = element[REMOVAL_FLAG] as ElementAnimationState;\n    if (details && details.setForRemoval) containsData = true;\n    if (this.playersByElement.has(element)) containsData = true;\n    if (this.playersByQueriedElement.has(element)) containsData = true;\n    if (this.statesByElement.has(element)) containsData = true;\n    return this._fetchNamespace(namespaceId).elementContainsData(element) || containsData;\n  }\n\n  afterFlush(callback: () => any) { this._flushFns.push(callback); }\n\n  afterFlushAnimationsDone(callback: () => any) { this._whenQuietFns.push(callback); }\n\n  private _getPreviousPlayers(\n      element: string, isQueriedElement: boolean, namespaceId?: string, triggerName?: string,\n      toStateValue?: any): TransitionAnimationPlayer[] {\n    let players: TransitionAnimationPlayer[] = [];\n    if (isQueriedElement) {\n      const queriedElementPlayers = this.playersByQueriedElement.get(element);\n      if (queriedElementPlayers) {\n        players = queriedElementPlayers;\n      }\n    } else {\n      const elementPlayers = this.playersByElement.get(element);\n      if (elementPlayers) {\n        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;\n        elementPlayers.forEach(player => {\n          if (player.queued) return;\n          if (!isRemovalAnimation && player.triggerName != triggerName) return;\n          players.push(player);\n        });\n      }\n    }\n    if (namespaceId || triggerName) {\n      players = players.filter(player => {\n        if (namespaceId && namespaceId != player.namespaceId) return false;\n        if (triggerName && triggerName != player.triggerName) return false;\n        return true;\n      });\n    }\n    return players;\n  }\n\n  private _beforeAnimationBuild(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>) {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // when a removal animation occurs, ALL previous players are collected\n    // and destroyed (even if they are outside of the current namespace)\n    const targetNameSpaceId: string|undefined =\n        instruction.isRemovalTransition ? undefined : namespaceId;\n    const targetTriggerName: string|undefined =\n        instruction.isRemovalTransition ? undefined : triggerName;\n\n    for (const timelineInstruction of instruction.timelines) {\n      const element = timelineInstruction.element;\n      const isQueriedElement = element !== rootElement;\n      const players = getOrSetAsInMap(allPreviousPlayersMap, element, []);\n      const previousPlayers = this._getPreviousPlayers(\n          element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);\n      previousPlayers.forEach(player => {\n        const realPlayer = player.getRealPlayer() as any;\n        if (realPlayer.beforeDestroy) {\n          realPlayer.beforeDestroy();\n        }\n        player.destroy();\n        players.push(player);\n      });\n    }\n\n    // this needs to be done so that the PRE/POST styles can be\n    // computed properly without interfering with the previous animation\n    eraseStyles(rootElement, instruction.fromStyles);\n  }\n\n  private _buildAnimation(\n      namespaceId: string, instruction: AnimationTransitionInstruction,\n      allPreviousPlayersMap: Map<any, TransitionAnimationPlayer[]>,\n      skippedPlayersMap: Map<any, AnimationPlayer[]>, preStylesMap: Map<any, ɵStyleData>,\n      postStylesMap: Map<any, ɵStyleData>): AnimationPlayer {\n    const triggerName = instruction.triggerName;\n    const rootElement = instruction.element;\n\n    // we first run this so that the previous animation player\n    // data can be passed into the successive animation players\n    const allQueriedPlayers: TransitionAnimationPlayer[] = [];\n    const allConsumedElements = new Set<any>();\n    const allSubElements = new Set<any>();\n    const allNewPlayers = instruction.timelines.map(timelineInstruction => {\n      const element = timelineInstruction.element;\n      allConsumedElements.add(element);\n\n      // FIXME (matsko): make sure to-be-removed animations are removed properly\n      const details = element[REMOVAL_FLAG];\n      if (details && details.removedBeforeQueried)\n        return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);\n\n      const isQueriedElement = element !== rootElement;\n      const previousPlayers =\n          flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY)\n                                  .map(p => p.getRealPlayer()))\n              .filter(p => {\n                // the `element` is not apart of the AnimationPlayer definition, but\n                // Mock/WebAnimations\n                // use the element within their implementation. This will be added in Angular5 to\n                // AnimationPlayer\n                const pp = p as any;\n                return pp.element ? pp.element === element : false;\n              });\n\n      const preStyles = preStylesMap.get(element);\n      const postStyles = postStylesMap.get(element);\n      const keyframes = normalizeKeyframes(\n          this.driver, this._normalizer, element, timelineInstruction.keyframes, preStyles,\n          postStyles);\n      const player = this._buildPlayer(timelineInstruction, keyframes, previousPlayers);\n\n      // this means that this particular player belongs to a sub trigger. It is\n      // important that we match this player up with the corresponding (@trigger.listener)\n      if (timelineInstruction.subTimeline && skippedPlayersMap) {\n        allSubElements.add(element);\n      }\n\n      if (isQueriedElement) {\n        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);\n        wrappedPlayer.setRealPlayer(player);\n        allQueriedPlayers.push(wrappedPlayer);\n      }\n\n      return player;\n    });\n\n    allQueriedPlayers.forEach(player => {\n      getOrSetAsInMap(this.playersByQueriedElement, player.element, []).push(player);\n      player.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player.element, player));\n    });\n\n    allConsumedElements.forEach(element => addClass(element, NG_ANIMATING_CLASSNAME));\n    const player = optimizeGroupPlayer(allNewPlayers);\n    player.onDestroy(() => {\n      allConsumedElements.forEach(element => removeClass(element, NG_ANIMATING_CLASSNAME));\n      setStyles(rootElement, instruction.toStyles);\n    });\n\n    // this basically makes all of the callbacks for sub element animations\n    // be dependent on the upper players for when they finish\n    allSubElements.forEach(\n        element => { getOrSetAsInMap(skippedPlayersMap, element, []).push(player); });\n\n    return player;\n  }\n\n  private _buildPlayer(\n      instruction: AnimationTimelineInstruction, keyframes: ɵStyleData[],\n      previousPlayers: AnimationPlayer[]): AnimationPlayer {\n    if (keyframes.length > 0) {\n      return this.driver.animate(\n          instruction.element, keyframes, instruction.duration, instruction.delay,\n          instruction.easing, previousPlayers);\n    }\n\n    // special case for when an empty transition|definition is provided\n    // ... there is no point in rendering an empty animation\n    return new NoopAnimationPlayer(instruction.duration, instruction.delay);\n  }\n}\n\nexport class TransitionAnimationPlayer implements AnimationPlayer {\n  private _player: AnimationPlayer = new NoopAnimationPlayer();\n  private _containsRealPlayer = false;\n\n  private _queuedCallbacks: {[name: string]: (() => any)[]} = {};\n  public readonly destroyed = false;\n  // TODO(issue/24571): remove '!'.\n  public parentPlayer !: AnimationPlayer;\n\n  public markedForDestroy: boolean = false;\n  public disabled = false;\n\n  readonly queued: boolean = true;\n  public readonly totalTime: number = 0;\n\n  constructor(public namespaceId: string, public triggerName: string, public element: any) {}\n\n  setRealPlayer(player: AnimationPlayer) {\n    if (this._containsRealPlayer) return;\n\n    this._player = player;\n    Object.keys(this._queuedCallbacks).forEach(phase => {\n      this._queuedCallbacks[phase].forEach(\n          callback => listenOnPlayer(player, phase, undefined, callback));\n    });\n    this._queuedCallbacks = {};\n    this._containsRealPlayer = true;\n    this.overrideTotalTime(player.totalTime);\n    (this as{queued: boolean}).queued = false;\n  }\n\n  getRealPlayer() { return this._player; }\n\n  overrideTotalTime(totalTime: number) { (this as any).totalTime = totalTime; }\n\n  syncPlayerEvents(player: AnimationPlayer) {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      player.onStart(() => p.triggerCallback !('start'));\n    }\n    player.onDone(() => this.finish());\n    player.onDestroy(() => this.destroy());\n  }\n\n  private _queueEvent(name: string, callback: (event: any) => any): void {\n    getOrSetAsInMap(this._queuedCallbacks, name, []).push(callback);\n  }\n\n  onDone(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('done', fn);\n    }\n    this._player.onDone(fn);\n  }\n\n  onStart(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('start', fn);\n    }\n    this._player.onStart(fn);\n  }\n\n  onDestroy(fn: () => void): void {\n    if (this.queued) {\n      this._queueEvent('destroy', fn);\n    }\n    this._player.onDestroy(fn);\n  }\n\n  init(): void { this._player.init(); }\n\n  hasStarted(): boolean { return this.queued ? false : this._player.hasStarted(); }\n\n  play(): void { !this.queued && this._player.play(); }\n\n  pause(): void { !this.queued && this._player.pause(); }\n\n  restart(): void { !this.queued && this._player.restart(); }\n\n  finish(): void { this._player.finish(); }\n\n  destroy(): void {\n    (this as{destroyed: boolean}).destroyed = true;\n    this._player.destroy();\n  }\n\n  reset(): void { !this.queued && this._player.reset(); }\n\n  setPosition(p: any): void {\n    if (!this.queued) {\n      this._player.setPosition(p);\n    }\n  }\n\n  getPosition(): number { return this.queued ? 0 : this._player.getPosition(); }\n\n  /** @internal */\n  triggerCallback(phaseName: string): void {\n    const p = this._player as any;\n    if (p.triggerCallback) {\n      p.triggerCallback(phaseName);\n    }\n  }\n}\n\nfunction deleteOrUnsetInMap(map: Map<any, any[]>| {[key: string]: any}, key: any, value: any) {\n  let currentValues: any[]|null|undefined;\n  if (map instanceof Map) {\n    currentValues = map.get(key);\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        map.delete(key);\n      }\n    }\n  } else {\n    currentValues = map[key];\n    if (currentValues) {\n      if (currentValues.length) {\n        const index = currentValues.indexOf(value);\n        currentValues.splice(index, 1);\n      }\n      if (currentValues.length == 0) {\n        delete map[key];\n      }\n    }\n  }\n  return currentValues;\n}\n\nfunction normalizeTriggerValue(value: any): any {\n  // we use `!= null` here because it's the most simple\n  // way to test against a \"falsy\" value without mixing\n  // in empty strings or a zero value. DO NOT OPTIMIZE.\n  return value != null ? value : null;\n}\n\nfunction isElementNode(node: any) {\n  return node && node['nodeType'] === 1;\n}\n\nfunction isTriggerEventValid(eventName: string): boolean {\n  return eventName == 'start' || eventName == 'done';\n}\n\nfunction cloakElement(element: any, value?: string) {\n  const oldValue = element.style.display;\n  element.style.display = value != null ? value : 'none';\n  return oldValue;\n}\n\nfunction cloakAndComputeStyles(\n    valuesMap: Map<any, ɵStyleData>, driver: AnimationDriver, elements: Set<any>,\n    elementPropsMap: Map<any, Set<string>>, defaultStyle: string): any[] {\n  const cloakVals: string[] = [];\n  elements.forEach(element => cloakVals.push(cloakElement(element)));\n\n  const failedElements: any[] = [];\n\n  elementPropsMap.forEach((props: Set<string>, element: any) => {\n    const styles: ɵStyleData = {};\n    props.forEach(prop => {\n      const value = styles[prop] = driver.computeStyle(element, prop, defaultStyle);\n\n      // there is no easy way to detect this because a sub element could be removed\n      // by a parent animation element being detached.\n      if (!value || value.length == 0) {\n        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;\n        failedElements.push(element);\n      }\n    });\n    valuesMap.set(element, styles);\n  });\n\n  // we use a index variable here since Set.forEach(a, i) does not return\n  // an index value for the closure (but instead just the value)\n  let i = 0;\n  elements.forEach(element => cloakElement(element, cloakVals[i++]));\n\n  return failedElements;\n}\n\n/*\nSince the Angular renderer code will return a collection of inserted\nnodes in all areas of a DOM tree, it's up to this algorithm to figure\nout which nodes are roots for each animation @trigger.\n\nBy placing each inserted node into a Set and traversing upwards, it\nis possible to find the @trigger elements and well any direct *star\ninsertion nodes, if a @trigger root is found then the enter element\nis placed into the Map[@trigger] spot.\n */\nfunction buildRootMap(roots: any[], nodes: any[]): Map<any, any[]> {\n  const rootMap = new Map<any, any[]>();\n  roots.forEach(root => rootMap.set(root, []));\n\n  if (nodes.length == 0) return rootMap;\n\n  const NULL_NODE = 1;\n  const nodeSet = new Set(nodes);\n  const localRootMap = new Map<any, any>();\n\n  function getRoot(node: any): any {\n    if (!node) return NULL_NODE;\n\n    let root = localRootMap.get(node);\n    if (root) return root;\n\n    const parent = node.parentNode;\n    if (rootMap.has(parent)) {  // ngIf inside @trigger\n      root = parent;\n    } else if (nodeSet.has(parent)) {  // ngIf inside ngIf\n      root = NULL_NODE;\n    } else {  // recurse upwards\n      root = getRoot(parent);\n    }\n\n    localRootMap.set(node, root);\n    return root;\n  }\n\n  nodes.forEach(node => {\n    const root = getRoot(node);\n    if (root !== NULL_NODE) {\n      rootMap.get(root) !.push(node);\n    }\n  });\n\n  return rootMap;\n}\n\nconst CLASSES_CACHE_KEY = '$$classes';\nfunction containsClass(element: any, className: string): boolean {\n  if (element.classList) {\n    return element.classList.contains(className);\n  } else {\n    const classes = element[CLASSES_CACHE_KEY];\n    return classes && classes[className];\n  }\n}\n\nfunction addClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (!classes) {\n      classes = element[CLASSES_CACHE_KEY] = {};\n    }\n    classes[className] = true;\n  }\n}\n\nfunction removeClass(element: any, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    let classes: {[className: string]: boolean} = element[CLASSES_CACHE_KEY];\n    if (classes) {\n      delete classes[className];\n    }\n  }\n}\n\nfunction removeNodesAfterAnimationDone(\n    engine: TransitionAnimationEngine, element: any, players: AnimationPlayer[]) {\n  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));\n}\n\nfunction flattenGroupPlayers(players: AnimationPlayer[]): AnimationPlayer[] {\n  const finalPlayers: AnimationPlayer[] = [];\n  _flattenGroupPlayersRecur(players, finalPlayers);\n  return finalPlayers;\n}\n\nfunction _flattenGroupPlayersRecur(players: AnimationPlayer[], finalPlayers: AnimationPlayer[]) {\n  for (let i = 0; i < players.length; i++) {\n    const player = players[i];\n    if (player instanceof AnimationGroupPlayer) {\n      _flattenGroupPlayersRecur(player.players, finalPlayers);\n    } else {\n      finalPlayers.push(player as AnimationPlayer);\n    }\n  }\n}\n\nfunction objEquals(a: {[key: string]: any}, b: {[key: string]: any}): boolean {\n  const k1 = Object.keys(a);\n  const k2 = Object.keys(b);\n  if (k1.length != k2.length) return false;\n  for (let i = 0; i < k1.length; i++) {\n    const prop = k1[i];\n    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;\n  }\n  return true;\n}\n\nfunction replacePostStylesAsPre(\n    element: any, allPreStyleElements: Map<any, Set<string>>,\n    allPostStyleElements: Map<any, Set<string>>): boolean {\n  const postEntry = allPostStyleElements.get(element);\n  if (!postEntry) return false;\n\n  let preEntry = allPreStyleElements.get(element);\n  if (preEntry) {\n    postEntry.forEach(data => preEntry !.add(data));\n  } else {\n    allPreStyleElements.set(element, postEntry);\n  }\n\n  allPostStyleElements.delete(element);\n  return true;\n}\n"],"sourceRoot":""}