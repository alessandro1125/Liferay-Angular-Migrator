{"version":3,"sources":["../../../../../../../packages/animations/src/players/animation_player.ts"],"names":[],"mappings":";;;;;;AAOA,WAAQ,iBAAR,QAAgC,SAAhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4GA,SAAM,MAAA,mBAAA,CAAA;;;;;AASJ,gBAAY,WAAmB,CAA/B,EAAkC,QAAgB,CAAlD,EAAmD;wBARlB,E;yBACC,E;2BACE,E;sBACjB,K;wBACE,K;uBACD,K;0BACwB,I;AAEW,WAAK,SAAL,GAAiB,WAAW,KAA5B;AAAoC;;;;AACnF,gBAAS;AACf,UAAI,CAAC,KAAK,SAAV,EAAqB;AACnB,aAAK,SAAL,GAAiB,IAAjB;AACA,aAAK,UAAL,CAAgB,OAAhB,CAAwB,MAAM,IAA9B;AACA,aAAK,UAAL,GAAkB,EAAlB;AACD;;;;;;AAEH,YAAQ,EAAR,EAAsB;AAAU,WAAK,WAAL,CAAiB,IAAjB,CAAsB,EAAtB;AAA4B;;;;;AAC5D,WAAO,EAAP,EAAqB;AAAU,WAAK,UAAL,CAAgB,IAAhB,CAAqB,EAArB;AAA2B;;;;;AAC1D,cAAU,EAAV,EAAwB;AAAU,WAAK,aAAL,CAAmB,IAAnB,CAAwB,EAAxB;AAA8B;;;;AAChE,iBAAU;AAAc,aAAO,KAAK,QAAZ;AAAuB;;;;AAC/C,WAAI,CAAW;;;;AACf,WAAI;AACF,UAAI,CAAC,KAAK,UAAL,EAAL,EAAwB;AACtB,aAAK,QAAL;AACA,aAAK,gBAAL;AACD;AACD,WAAK,QAAL,GAAgB,IAAhB;AACD;;;;;AAGD,uBAAgB;AAAK,wBAAkB,MAAM,KAAK,SAAL,EAAxB;AAA4C;;;;AAEzD,eAAQ;AACd,WAAK,WAAL,CAAiB,OAAjB,CAAyB,MAAM,IAA/B;AACA,WAAK,WAAL,GAAmB,EAAnB;;;;;AAGF,YAAK,CAAW;;;;AAChB,cAAO,CAAW;;;;AAClB,aAAM;AAAW,WAAK,SAAL;AAAmB;;;;AACpC,cAAO;AACL,UAAI,CAAC,KAAK,UAAV,EAAsB;AACpB,aAAK,UAAL,GAAkB,IAAlB;AACA,YAAI,CAAC,KAAK,UAAL,EAAL,EAAwB;AACtB,eAAK,QAAL;AACD;AACD,aAAK,MAAL;AACA,aAAK,aAAL,CAAmB,OAAnB,CAA2B,MAAM,IAAjC;AACA,aAAK,aAAL,GAAqB,EAArB;AACD;AACF;;;;AACD,YAAK,CAAW;;;;;AAChB,gBAAY,QAAZ,EAA4B,CAAU;;;;AACtC,kBAAW;AAAa,aAAO,CAAP;AAAW;;;;;;AAGnC,oBAAgB,SAAhB,EAAiC;;AAC/B,YAAM,UAAU,aAAa,OAAb,GAAuB,KAAK,WAA5B,GAA0C,KAAK,UAA/D;AACA,cAAQ,OAAR,CAAgB,MAAM,IAAtB;AACA,cAAQ,MAAR,GAAiB,CAAjB;AACD;AA7DG","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {scheduleMicroTask} from '../util';\n\n/**\n * Provides programmatic control of a reusable animation sequence,\n * built using the `build()` method of `AnimationBuilder`. The `build()` method\n * returns a factory, whose `create()` method instantiates and initializes this interface.\n *\n * @see `AnimationBuilder`\n * @see `AnimationFactory`\n * @see `animate()` \n *\n */\nexport interface AnimationPlayer {\n  /**\n   * Provides a callback to invoke when the animation finishes.\n   * @param fn The callback function.\n   * @see `finish()`\n   */\n  onDone(fn: () => void): void;\n  /**\n   * Provides a callback to invoke when the animation starts.\n   * @param fn The callback function.\n   * @see `run()`\n   */\n  onStart(fn: () => void): void;\n  /**\n   * Provides a callback to invoke after the animation is destroyed.\n   * @param fn The callback function.\n   * @see `destroy()`\n   * @see `beforeDestroy()`\n   */\n  onDestroy(fn: () => void): void;\n  /**\n   * Initializes the animation.\n   */\n  init(): void;\n  /**\n   * Reports whether the animation has started.\n   * @returns True if the animation has started, false otherwise.\n   */\n  hasStarted(): boolean;\n  /**\n   * Runs the animation, invoking the `onStart()` callback.\n   */\n  play(): void;\n  /**\n   * Pauses the animation.\n   */\n  pause(): void;\n  /**\n   * Restarts the paused animation.\n   */\n  restart(): void;\n  /**\n   * Ends the animation, invoking the `onDone()` callback.\n   */\n  finish(): void;\n  /**\n   * Destroys the animation, after invoking the `beforeDestroy()` callback.\n   * Calls the `onDestroy()` callback when destruction is completed.\n   */\n  destroy(): void;\n  /**\n   * Resets the animation to its initial state.\n   */\n  reset(): void;\n  /**\n   * Sets the position of the animation.\n   * @param position A 0-based offset into the duration, in milliseconds.\n   */\n  setPosition(position: any /** TODO #9100 */): void;\n  /**\n   * Reports the current position of the animation.\n   * @returns A 0-based offset into the duration, in milliseconds.\n   */\n  getPosition(): number;\n  /**\n   * The parent of this player, if any.\n   */\n  parentPlayer: AnimationPlayer|null;\n  /**\n   * The total run time of the animation, in milliseconds.\n   */\n  readonly totalTime: number;\n  /**\n   * Provides a callback to invoke before the animation is destroyed.\n   */\n  beforeDestroy?: () => any;\n  /** @internal\n   * Internal\n   */\n  triggerCallback?: (phaseName: string) => void;\n  /** @internal\n   * Internal\n   */\n  disabled?: boolean;\n}\n\n/**\n * An empty programmatic controller for reusable animations.\n * Used internally when animations are disabled, to avoid\n * checking for the null case when an animation player is expected.\n *\n * @see `animate()`\n * @see `AnimationPlayer`\n * @see `GroupPlayer`\n *\n */\nexport class NoopAnimationPlayer implements AnimationPlayer {\n  private _onDoneFns: Function[] = [];\n  private _onStartFns: Function[] = [];\n  private _onDestroyFns: Function[] = [];\n  private _started = false;\n  private _destroyed = false;\n  private _finished = false;\n  public parentPlayer: AnimationPlayer|null = null;\n  public readonly totalTime: number;\n  constructor(duration: number = 0, delay: number = 0) { this.totalTime = duration + delay; }\n  private _onFinish() {\n    if (!this._finished) {\n      this._finished = true;\n      this._onDoneFns.forEach(fn => fn());\n      this._onDoneFns = [];\n    }\n  }\n  onStart(fn: () => void): void { this._onStartFns.push(fn); }\n  onDone(fn: () => void): void { this._onDoneFns.push(fn); }\n  onDestroy(fn: () => void): void { this._onDestroyFns.push(fn); }\n  hasStarted(): boolean { return this._started; }\n  init(): void {}\n  play(): void {\n    if (!this.hasStarted()) {\n      this._onStart();\n      this.triggerMicrotask();\n    }\n    this._started = true;\n  }\n\n  /** @internal */\n  triggerMicrotask() { scheduleMicroTask(() => this._onFinish()); }\n\n  private _onStart() {\n    this._onStartFns.forEach(fn => fn());\n    this._onStartFns = [];\n  }\n\n  pause(): void {}\n  restart(): void {}\n  finish(): void { this._onFinish(); }\n  destroy(): void {\n    if (!this._destroyed) {\n      this._destroyed = true;\n      if (!this.hasStarted()) {\n        this._onStart();\n      }\n      this.finish();\n      this._onDestroyFns.forEach(fn => fn());\n      this._onDestroyFns = [];\n    }\n  }\n  reset(): void {}\n  setPosition(position: number): void {}\n  getPosition(): number { return 0; }\n\n  /** @internal */\n  triggerCallback(phaseName: string): void {\n    const methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;\n    methods.forEach(fn => fn());\n    methods.length = 0;\n  }\n}\n"],"sourceRoot":""}